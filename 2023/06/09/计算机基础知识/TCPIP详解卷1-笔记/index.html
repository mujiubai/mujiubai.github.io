<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="TCP/IP详解，卷1：协议阅读笔记, w">
    <meta name="description" content="TCP&amp;#x2F;IP详解，卷1：协议 阅读笔记
第1章 概 述基础知识：

传输层协议TCP和UDP采用16 bit的端口号来识别应用程序，而知名的程序端口已被固定分配。
底层向上传送数据时，每层协议都要去检查报文首部中的协议标识，以确定">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>TCP/IP详解，卷1：协议阅读笔记 | w</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">w</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">

      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/C/">
          
          <span>C++</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/JAVA/">
          
          <span>Java</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/LeetCode/">
          
          <span>LeetCode</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
          
          <span>计算机基础知识</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/%E9%A1%B9%E7%9B%AE/">
          
          <span>项目</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">w</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-bookmark"></i>
			
			分类
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/categories/C/ " style="margin-left:75px">
				  
		          <span>C++</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/JAVA/ " style="margin-left:75px">
				  
		          <span>Java</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/LeetCode/ " style="margin-left:75px">
				  
		          <span>LeetCode</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ " style="margin-left:75px">
				  
		          <span>计算机基础知识</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/%E9%A1%B9%E7%9B%AE/ " style="margin-left:75px">
				  
		          <span>项目</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/1.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">TCP/IP详解，卷1：协议阅读笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Linux/">
                                <span class="chip bg-color">Linux</span>
                            </a>
                        
                            <a href="/tags/%E7%BD%91%E7%BB%9C/">
                                <span class="chip bg-color">网络</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-category">
                                计算机基础知识
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-06-09
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-06-20
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    13.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    48 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><a target="_blank" rel="noopener" href="http://www.52im.net/topic-tcpipvol1.html"><em>TCP&#x2F;IP详解，卷1：协议</em> </a>阅读笔记</p>
<h1 id="第1章-概-述"><a href="#第1章-概-述" class="headerlink" title="第1章 概 述"></a>第1章 概 述</h1><p><strong>基础知识</strong>：</p>
<ul>
<li>传输层协议TCP和UDP采用16 bit的端口号来识别应用程序，而知名的程序端口已被固定分配。</li>
<li>底层向上传送数据时，每层协议都要去检查报文首部中的协议标识，以确定接收数据的上层协议，这个过程称作分用<ul>
<li>例如IP协议中首部有个8bit的数字，表示上层协议名字，6表示TCP协议</li>
</ul>
</li>
<li>RFC(Request For Comment) 中TCP&#x2F;IP协议族每一层的稳健性原则：<strong>自由地接收，保守地发送</strong></li>
<li>网络层和运输层之间的区别：网络层（IP）提供点到点的服务，而运输层（TCP和UDP）提供端到端的服务。这也是为什么将网络层和运输层划分开的原因。</li>
</ul>
<p><strong>FTP发送消息示例</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230609202737930.png"></p>
<p>本书要讨论的协议</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230609113755572.png"></p>
<p><strong>几类IP地址</strong>（注意比较，网络号的规则是逐渐加一个字节）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230609202849943.png"></p>
<h1 id="第2章-链路层"><a href="#第2章-链路层" class="headerlink" title="第2章 链路层"></a>第2章 链路层</h1><p>链路层主要有三个目的：、</p>
<ul>
<li>（1）为IP模块发送和接收IP数据报；</li>
<li>（2）为ARP模块发送ARP请求和接收ARP应答；</li>
<li>（3）为RARP发送RARP请求和接收RARP应答</li>
</ul>
<h2 id="2-1-以太网和IEEE-802封装"><a href="#2-1-以太网和IEEE-802封装" class="headerlink" title="2.1 以太网和IEEE 802封装"></a>2.1 以太网和IEEE 802封装</h2><p>以太网和IEEE802帧格式稍有不同：</p>
<ul>
<li>在802中，长度字段是指它后续数据的字节长度，但不包括CRC检验码，类型字段则由后续的子网接入协议的首部给出。以太网的类型字段定义了后续数据的类型。</li>
<li>802.3规定数据部分必须至少为38字节，而对于以太网，则要求最少要有46字节。为了保证这一点，必须在不足的空间插入填充（pad）字节。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620103016456.png"></p>
<h2 id="2-2-SLIP：串行线路IP"><a href="#2-2-SLIP：串行线路IP" class="headerlink" title="2.2 SLIP：串行线路IP"></a>2.2 SLIP：串行线路IP</h2><p><strong>SLIP协议帧格式</strong>：</p>
<ul>
<li>IP数据报以一个称作END（0xc0）的特殊字符结束。同时，为了防止数据报到来之前的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个END字符（如果有线路噪声，那么END字符将结束这份错误的报文。这样当前的报文得以正确地传输，而前一个错误报文交给上层后，会发现其内容毫无意义而被丢弃）。</li>
<li>如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它。0xdb这个特殊字符被称作SLIP的ESC字符，但是它的值与ASCII码的ESC字符（0x1b）不同。</li>
<li>如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。</li>
<li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620104831921.png"></li>
</ul>
<p><strong>SLIP缺陷</strong>：</p>
<ul>
<li>每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。</li>
<li>数据帧中没有类型字段（类似于以太网中的类型字段）。如果一条串行线路用于SLIP，那么它不能同时使用其他协议。</li>
<li>SLIP没有在数据帧中加上检验和，只能通过上层协议来发现错误。因此IP首部和TCP首部及其数据始终都有检验和，UDP首部及其数据的检验和却是可选的。</li>
</ul>
<p><strong>压缩SLIP（SCLIP）</strong></p>
<ul>
<li>SLIP线路上有许多小的TCP分组进行交换，为了传送1个字节的数据需要20个字节的IP首部和20个字节的TCP首部，总数超过40个字节，整体效率很低</li>
<li>CSLIP一般能把上面的40个字节压缩到3或5个字节。它能在CSLIP的每一端维持多达16个TCP连接，并且知道其中每个连接的首部中的某些字段一般不会发生变化。</li>
</ul>
<h2 id="2-3-PPP：点对点协议"><a href="#2-3-PPP：点对点协议" class="headerlink" title="2.3 PPP：点对点协议"></a>2.3 PPP：点对点协议</h2><p>PPP，点对点协议修改了SLIP协议中的所有缺陷。PPP包括以下三个部分：</p>
<ol>
<li>在串行链路上封装IP数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式，还支持面向比特的同步链接。</li>
<li>建立、配置及测试数据链路的链路控制协议（LCP：Link Control Protocol）。它允许通信双方进行协商，以确定不同的选项。</li>
<li>针对不同网络层协议的网络控制协议（NCP：Network Control Protocol）体系。IP NCP允许双方商定是否对报文首部进行压缩，类似于CSLIP。</li>
</ol>
<p><strong>PPP帧格式</strong></p>
<ul>
<li><p>每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。</p>
</li>
<li><p>当遇到字符0x7e时，需连续传送两个字符：0x7d和0x5e，以实现标志字符的转义。当遇到转义字符0x7d时，需连续传送两个字符：0x7d和0x5d，以实现转义字符的转义。</p>
</li>
<li><p>利用链路控制协议，大多数的产品通过协商可以省略标志符和地址字段，并且把协议字段由2个字节减少到1个字节。PPP只增加了3个额外的字节：1个字节留给协议字段，另2个给CRC字段使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620113229094.png"></p>
</li>
</ul>
<p><strong>PPP优点</strong></p>
<ul>
<li>(1)PPP支持在单根串行线路上运行多种协议，不只是IP协议；</li>
<li>(2)每一帧都有循环冗余检验；</li>
<li>(3)通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；</li>
<li>(4)与CSLIP类似，对TCP和IP报文首部进行压缩；</li>
<li>(5)链路控制协议可以对多个数据链路选项进行设置。</li>
</ul>
<h2 id="2-4-环回接口"><a href="#2-4-环回接口" class="headerlink" title="2.4 环回接口"></a>2.4 环回接口</h2><p>大多数的产品都支持环回接口（Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过TCP&#x2F;IP进行通信。A类网络号127就是为环回接口预留的。根据惯例，大多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。</p>
<p>大多实现照样完成传输层和网络层的所有过程，只是当IP数据报离开网络层时把它返回给自己。</p>
<ul>
<li>传给环回地址（一般是127.0.0.1）的任何数据均作为IP输入。</li>
<li>传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是因为广播传送和多播传送的定义包含主机本身。</li>
<li>任何传给该主机IP地址的数据均送到环回接口。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620113700866.png"></p>
<h2 id="2-5-最大传输单元MTU"><a href="#2-5-最大传输单元MTU" class="headerlink" title="2.5 最大传输单元MTU"></a>2.5 最大传输单元MTU</h2><p>以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特性称作MTU ,最大传输单元。</p>
<p>如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大,那么IP层就需要进行分片（fragmentation），把数据报分成若干片，这样每一片都小于MTU。</p>
<p>点到点的链路层（如SLIP和PPP）的<strong>MTU并非指的是网络媒体的物理特性，而是一个逻辑限制</strong>，目的是为交互使用提供足够快的响应时间。</p>
<p><strong>路径MTU</strong>：两台通信主机路径中的最小MTU</p>
<h1 id="第3章-IP-网际协议"><a href="#第3章-IP-网际协议" class="headerlink" title="第3章 IP:网际协议"></a>第3章 IP:网际协议</h1><h2 id="3-1-IP首部"><a href="#3-1-IP首部" class="headerlink" title="3.1 IP首部"></a>3.1 <strong>IP首部</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230611190424255.png"></p>
<p>网络数据传输采用<strong>大端字节序</strong>，也称网络字节序（即先传输左边的高位）。IP首部各字段作用：</p>
<ul>
<li>首部长度：指首部占32 bit字（4字节）的数目。其是一个4比特字段，因此首部最长为60个字节。</li>
<li>服务类型（TOS）字段：包括一个3bit的优先权子字段（现已被忽略），4bit的TOS子字段和1bit未用位但必须置0。<ul>
<li>4bit的TO S分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4bit中只能置其中1bit。均为0则为一般服务。</li>
</ul>
</li>
<li>总长度字段：指整个IP数据报的长度，以字节为单位。利用首部长度字段，可以知道IP数据报中数据内容的起始位置和长度。<ul>
<li>以太网有最小帧长限制，需要对数据进行填充，因此必须有总长度字段才能知道IP数据包的内容。</li>
</ul>
</li>
<li>标识字段：唯一地标识主机发送的每一份数据报，每发送一份报文它的值就会加1。</li>
<li>片偏移：用于分片和重组</li>
<li>TTL：数据报可以经过的最多路由器数，每经过一个路由器此值减1</li>
<li>首部检验和：根据IP首部计算的检验和码（不包括数据，因为ICMP、TCP等均含有同时覆盖首部和数据的检验和码）<ul>
<li>检验和生成：把检验和字段置为0，对首部中每个16 bit进行二进制反码求和</li>
<li>检验和校验：校验也是对首部中每个16 bit进行二进制反码求和（包括检验字段），因此结果应该全为1.</li>
</ul>
</li>
<li>选项字段：可选时间戳等，是一个变长字段。一直都是以32 bit作为界限，在必要的时候插入值为0的填充字节</li>
</ul>
<h2 id="3-2-IP路由选择"><a href="#3-2-IP路由选择" class="headerlink" title="3.2 IP路由选择"></a>3.2 IP路由选择</h2><p>当IP层从TCP等或一个网络接口收到数据报并进行发送时，会先搜索路由表（每一份数据报都搜索）。</p>
<p>如果从网口收到数据，则检查目的IP地址是否为本机的IP地址之一或者IP广播地址，是则送到指定协议模块处理，不是则根据主机设定进行转发或丢弃（主机可以设定是否进行路由功能）</p>
<p>路由表中的每一项都包含以下信息：</p>
<ul>
<li>目的IP地址：一个主机地址或网络地址，由一个标志字段决定</li>
<li>下一站（或下一跳）路由器的IP地址，或者有直接连接的网络IP地址</li>
<li>标志：一个指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口</li>
<li>数据报的传输指定一个网络接口</li>
</ul>
<p>P路由选择是逐跳地进行的，IP并不知道到达任何目的的完整路径。IP路由选择规则：</p>
<ul>
<li>先寻找能与目的IP地址完全匹配的表目，若没找到则寻找能与目的网络号相匹配的表目，还是没找到则寻找标为“默认（default）”的表目。</li>
</ul>
<h2 id="3-3-子网掩码"><a href="#3-3-子网掩码" class="headerlink" title="3.3 子网掩码"></a>3.3 子网掩码</h2><p><strong>子网好处</strong>：可以将主机数巨大的地址空间划分为多个子网；由于划分子网对外界是透明的，因此相比将其分为C类地址，可以显著减少路由条目</p>
<p>子网掩码是一个32 bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230612155526100.png"></p>
<blockquote>
<p>0表示所有的比特位全为0；-1表示所有的比特位全为1；netid、subnetid和hostid分别表示不为全0或全1的对应字段。子网号栏为空表示该地址没有进行子网划分。</p>
</blockquote>
<h1 id="第4章-ARP-地址解析协议"><a href="#第4章-ARP-地址解析协议" class="headerlink" title="第4章 ARP:地址解析协议"></a>第4章 ARP:地址解析协议</h1><p>在链路层进行数据传输需要有硬件地址（一个48 bit的值），ARP为IP地址到对应的硬件地址之间提供动态映射。</p>
<p><strong>ARP高速缓存</strong>：每个主机上都有一个ARP高速缓存，存放了最近IP地址到硬件地址之间的映射记录，每一项的生存时间一般为20分钟。</p>
<p><strong>ARP请求或应答格式</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230612161939294.png"></p>
<p>字段说明：</p>
<ul>
<li>以太网的源地址和目的地址：目的地址为全1，表示广播帧</li>
<li>帧类型：表示后面数据的类型，ARP该值为0x0806</li>
<li>硬件类型：表示硬件地址的类型，值为1即表示以太网地址</li>
<li>协议类型：表示要映射的协议地址类型，值为0x0800即表示IP地址</li>
<li>硬件地址长度和协议地址长度：分别指出硬件地址和协议地址的长度，以字节为单位。当为ARP时，值分别为6和4。</li>
<li>操作：四种操作类型，ARP请求（1）、ARP应答（2）、RARP请求（3）和RARP应答（4）</li>
<li>最后四个字段分别为发送接收端IP地址和以太网地址，注意这里硬件地址有所重复。</li>
</ul>
<p>ARP请求：除目的端硬件地址外的所有其他的字段都有填充值。</p>
<p>ARP接受：当系统收到一份目的端为本机的ARP请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为2，最后把它发送回去。（注意是处理请求部分，这里逻辑感觉有点不清楚，难道目的两个地址不进行更改？）</p>
<blockquote>
<p>如果查询的主机已关机或不存在，那么ARP会不断重传报文，如果超过时间限制则结束，而此时上层协议也会因超时等原因传输失败</p>
</blockquote>
<p><strong>ARP代理</strong>：如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求</p>
<ul>
<li>这样可以欺骗发起ARP请求的发送端，使它误以为路由器就是目的主机，而事实上目的主机是在路由器的“另一边”。路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。</li>
</ul>
<p><strong>免费ARP</strong>：指主机发送ARP查找自己的IP地址。通常发生在系统引导期间进行接口配置的时候。其作用如下：</p>
<ul>
<li>可以通过其来确定另一个主机是否设置了相同的IP地址。</li>
<li>如果发送免费ARP的主机正好改变了硬件地址，那么就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。</li>
</ul>
<h1 id="第5章-RARP-逆地址解析协议"><a href="#第5章-RARP-逆地址解析协议" class="headerlink" title="第5章 RARP:逆地址解析协议"></a>第5章 RARP:逆地址解析协议</h1><blockquote>
<p>具有本地磁盘的系统引导时，一般是从磁盘上的配置文件中读取IP地址。但是无盘机，如X终端或无盘工作站，则需要采用其他方法来获得IP地址。（为啥不用DHCP获取？引导镜像需要发送TFTP请求进行读取，可能DHCP较复杂）</p>
</blockquote>
<p><strong>RARP的分组格式</strong>：与ARP分组基本一致。主要差别是RARP请求或应答的帧类型代码为0x8035，且RARP请求的操作代码为3，应答操作代码为4。</p>
<ul>
<li>RARP请求以广播方式传送，而RARP应答一般是单播传送的（RAP应答也是单播）。</li>
<li>同样，RARP也会超时重发</li>
</ul>
<p>RARP服务器的复杂性在于</p>
<ul>
<li>由于需要提供硬件地址到IP地址的映射，而此映射一般在磁盘文件中。由于内核一般不读取和分析磁盘文件，因此RARP服务器的功能就由用户进程来提供</li>
<li>由于发送和接收这些数据帧与系统有关，因此RARP服务器的实现是与系统捆绑在一起的。</li>
</ul>
<h1 id="第11章-UDP-用户数据报协议"><a href="#第11章-UDP-用户数据报协议" class="headerlink" title="第11章 UDP:用户数据报协议"></a>第11章 UDP:用户数据报协议</h1><h2 id="11-1-UDP首部"><a href="#11-1-UDP首部" class="headerlink" title="11.1 UDP首部"></a>11.1 UDP首部</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230613151945659.png"></p>
<ul>
<li><p>端口号：表示发送和接收进程</p>
</li>
<li><p>UDP长度：指的是UDP首部和UDP数据的字节长度，最小值为8字节，因此可以发送一个0字节报文。且此字段是冗余的，可以通过IP长度字段求得此字段</p>
</li>
<li><p>UDP校验和：覆盖UDP首部和UDP数据。计算方法和IP首部校验相同，只是由于该算法是将16bit相加，不足处补0。</p>
<ul>
<li>且计算时还存在一个12字节长的伪首部，用于检查数据是否已经到达了正确的目的地<ul>
<li>比如IP头部的目的ip地址在传输过程中被错误的改变了，这个分组就会到达错误ip地址的主机。</li>
<li>比如IP头部的协议号被错误的改变了（本来是TCP，现在却错改成UDP），这个分组就会到达UDP协议栈，但实际上这个分组不应该被UDP处理。</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230613152618515.png" style="zoom:50%;" /></li>
</ul>
<h2 id="11-2-IP分片"><a href="#11-2-IP分片" class="headerlink" title="11.2 IP分片"></a>11.2 IP分片</h2><p>物理网络层一般要限制每次发送数据帧的最大长度，当IP数据报长度超过其MTU时，就会进行分片（发生在原始发送端或中间路由器）</p>
<p>当分片到达目的地才进行重新组装（是<strong>在下一站就进行重装</strong>，而不是最终目的地），重新组装由目的端的IP层来完成。</p>
<p>分片过程：</p>
<ul>
<li>每份IP数据报都有唯一标识，分片时会复制到分片中。</li>
<li>标志字段用其中一个比特来表示“更多的片”，除最后一片外该值都要置1</li>
<li>片偏移字段指的是该片偏移原始数据报开始处的位置（以8字节为单位）。当数据报被分片后，每个片的总长度值要改为该片的长度值。</li>
<li>标志字段中有一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片</li>
<li>注意，除最后一片外,其他片中的数据长度均要求为8字节的整数倍</li>
</ul>
<blockquote>
<p><strong>判断到达目的端的路途中最小MTU方法：</strong></p>
<ul>
<li>不断增大数据报长度，且在IP首部设置不分片（DF）的标志比特，那么当路由器遇见此种情况就会发送一个ICMP差错报文。</li>
</ul>
</blockquote>
<h2 id="11-3-UDP和ARP之间的交互作用"><a href="#11-3-UDP和ARP之间的交互作用" class="headerlink" title="11.3 UDP和ARP之间的交互作用"></a>11.3 UDP和ARP之间的交互作用</h2><p>当使用UDP发送一个8192字节的数据报（会产生6个分片），并将ARP缓存清空。此时会发生以下情况：</p>
<ul>
<li>由于产生分片速度更快，在第一个ARP请求未响应前，每个分片都会产生一个ARP请求，共产生6个请求。</li>
<li>在接收到第一个ARP应答时，只发送最后一个数据报片，看来似乎将前5个数据报片全都丢弃了<ul>
<li>这是ARP的正常操作。在大多数的实现中，在等待一个ARP应答时，只将最后一个报文发送给特定目的主机。</li>
</ul>
</li>
<li>还有一个无法解释的现象是会收到7个ARP解答，而不是6个</li>
</ul>
<h2 id="11-4-最大UDP数据报长度"><a href="#11-4-最大UDP数据报长度" class="headerlink" title="11.4 最大UDP数据报长度"></a>11.4 最大UDP数据报长度</h2><p>IP数据报的最大长度是65535字节，这是由IP首部16比特总长度字段所限制的。去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节。但真实UDP最大长度有以下限制：</p>
<ul>
<li>可能会受到其程序接口的限制，如设置接收和发送缓存的长度会影响最大UDP长度</li>
<li>另外的限制来自于TCP&#x2F;IP的内核实现。可能存在一些实现特性（或差错），使IP数据报长度小于65535字节。</li>
</ul>
<blockquote>
<p>UDP编程接口允许应用程序指定每次返回的最大字节数。如果接收到的数据报长度大于应用程序所能处理的长度，那么会发生什么情况呢？</p>
<ul>
<li>取决于编程接口和实现，有的会丢弃多余数据，有的超出部分数据在后面的读取中返回</li>
</ul>
</blockquote>
<h2 id="11-5-习题"><a href="#11-5-习题" class="headerlink" title="11.5 习题"></a>11.5 习题</h2><ol>
<li>为什么除最后一片外,其他片中的数据长度均要求为8字节的整数倍?<ul>
<li>因为片偏移量是以8字节为单位</li>
</ul>
</li>
<li>分片后再分片？<ul>
<li>可以进行，仍然以片偏移字段进行恢复，其值是指当前分片在最初IP数据报中的位置</li>
</ul>
</li>
<li>UDP数据报因分片直接收到1、2、3，而未接受到4。那么当重传时，原来的123片能否使用重传的4重组？<ul>
<li>不能，每个分片都有唯一标识</li>
</ul>
</li>
<li>TCP检验和差错被丢弃20个，但UDP检验和差错而被丢弃的数据报一份也没有。请说明两个方面的原因<ul>
<li>如果输出UDP的检验和没有被使用，就不会验证一个进入UDP的检验和</li>
<li>大多数的UDP通信量都是本地的，而不是WAN的，因此没有服从所有的WAN特征。</li>
</ul>
</li>
<li>分片时IP首部中的选项是否也要被复制到每个数据报片中，或者只留在第一个数据报片中？<ul>
<li>不严格的和严格的源站选路选项被复制到每一个数据报片中。</li>
<li>时间戳选项和记录路由选项没有被复制到每一个数据报片中—它们只出现在第1个数据报片中。</li>
</ul>
</li>
</ol>
<h1 id="第17章-TCP：传输控制协议"><a href="#第17章-TCP：传输控制协议" class="headerlink" title="第17章 TCP：传输控制协议"></a>第17章 TCP：传输控制协议</h1><p><strong>TCP提供一种面向连接的、可靠的字节流服务</strong></p>
<p>TCP通过下列方式来提供可靠性：</p>
<ul>
<li>应用数据被分割成TCP认为最适合发送的数据块。而UDP则保持应用产生的数据报长度不变。</li>
<li>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
<li>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒</li>
<li>TCP将检测它首部和数据的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段</li>
<li>TCP将对收到的数据进行重新排序，以正确的顺序交给应用层</li>
<li>IP数据报会发生重复，TCP的接收端必须丢弃重复的数据</li>
<li>TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</li>
</ul>
<h2 id="17-1-TCP的首部"><a href="#17-1-TCP的首部" class="headerlink" title="17.1 TCP的首部"></a>17.1 <strong>TCP的首部</strong></h2><p>如果不计任选字段，首部通常是20个字节</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230613200442824.png"></p>
<ul>
<li>端口号：用于寻找发端和收端应用进程<ul>
<li>一个IP地址和一个端口号也称为一个插口（socket）。插口对（socketpair）(包含客户IP地址、客户端口号、服务器IP地址和服务器端口号的四元组)可唯一确定互联网络中每个TCP连接的双方。</li>
</ul>
</li>
<li>序号：标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节<ul>
<li>序号超过最大值后会从0开始</li>
</ul>
</li>
<li>确认序号：发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加1。只有ACK标志为1时确认序号字段才有效。</li>
<li>首部长度：首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的，最多有60字节的首部（(2^4-1)*4)。</li>
<li>6个标志比特:<ul>
<li>URG：紧急指针有效</li>
<li>ACK：确认序号有效</li>
<li>PSH：接收方尽快将这个保温段交给应用层</li>
<li>RST：重建连接</li>
<li>SYN：同步序号用来发起一个链接</li>
<li>FIN：发端完成发送任务</li>
</ul>
</li>
<li>窗口大小：用于流量控制</li>
<li>检验和：覆盖了整个TCP报文段，是强制性的，由发端计算和存储，并由收端进行验证。TCP检验和的计算和UDP检验和的计算相似。</li>
<li>紧急指针：是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。只有当URG标志置1时紧急指针才有效。</li>
<li>可选字段：最常见的是最长报文大小，通常在连接建立时发送</li>
</ul>
<h2 id="17-2-习题"><a href="#17-2-习题" class="headerlink" title="17.2 习题"></a>17.2 <strong>习题</strong></h2><ol>
<li>各种协议检验和包括IP数据报中的哪些部分，以及该检验和是强制的还是可选的？<ul>
<li>除了UDP的检验和，其他都是必需的。IP检验和只覆盖了IP首部，而其他字段都包含首部和数据。</li>
</ul>
</li>
<li>为什么我们已经讨论的所有Internet协议（IP,ICMP,IGMP,UDP,TCP）收到有检验和错的分组都仅作丢弃处理？<ul>
<li>源IP地址、源端口号或者协议字段可能被破坏了</li>
</ul>
</li>
<li>TCP提供了一种字节流服务，而收发双方都不保持记录的边界。应用程序如何提供它们自己的记录标识？<ul>
<li>使用特定字符或数据长度</li>
</ul>
</li>
<li>为什么在TCP首部的开始便是源和目的的端口号？<ul>
<li>一个ICMP差错报文必须至少返回引起差错的IP数据报中除了IP首部的前8个字节。当TCP收到一个ICMP差错报文时，它需要检查两个端口号以决定差错对应于哪个连接。因此，端口号必须包含在TCP首部的前8个字节里。</li>
</ul>
</li>
<li>为什么TCP首部有一个首部长度字段而UDP首部中却没有？<ul>
<li>TCP首部的最后有一些选项，但UDP首部中没有选项。（但其实也能通过IP报文长度字段推导出来）</li>
</ul>
</li>
</ol>
<h1 id="第18章-TCP连接的建立与终止"><a href="#第18章-TCP连接的建立与终止" class="headerlink" title="第18章 TCP连接的建立与终止"></a>第18章 TCP连接的建立与终止</h1><p> TCP的状态变迁图</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614161733356.png"></p>
<h2 id="18-1-连接建立"><a href="#18-1-连接建立" class="headerlink" title="18.1 连接建立"></a>18.1 连接建立</h2><p>建立一条TCP连接，即<strong>三次握手</strong>：</p>
<ol>
<li>请求端发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN）。这个SYN段为报文段1。<ul>
<li>ISN随时间而变化，可看作是一个32比特的计数器，每4ms加1（有的地方又写每0.5秒增加64000）</li>
</ul>
</li>
<li>服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个序号。</li>
<li>客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认（报文段3）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614160138378.png"></p>
<p><strong>连接建立超时</strong>：当发送请求长时间未收到应答则会重传，当重传一定次数或时间则结束此次请求</p>
<p><strong>最大报文段长度</strong>：在建立连接时，连接的双方都要通告各自的MSS（TCP的可选字段），如未收到则默认536字节。在没有分段发生情况下，通常越大越好。</p>
<h2 id="18-2-连接终止"><a href="#18-2-连接终止" class="headerlink" title="18.2 连接终止"></a>18.2 连接终止</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614170223488.png"></p>
<p><strong>半关闭</strong>：连接的一端在结束它的发送后还能接收来自另一端数据</p>
<ul>
<li>如果应用程序不调用close而调用shutdown，且第2个参数值为1，则插口的API支持半关闭</li>
<li>为什么要有半关闭？如RSH命令需要向远程传输数据并接受返回结果，如果没有半关闭功能，则还需要采取其他方式通知数据已经传输完毕。</li>
</ul>
<blockquote>
<p>当四次挥手时，如果收到一个SYN会如何处理？</p>
<ul>
<li>发送一个带ACK的SYN（进入SYN_RCVD）。然后如果收到一个RST，而不是一个ACK，便又回到LISTEN状态并等待另一个连接请求的到来</li>
</ul>
</blockquote>
<p><strong>2MSL等待状态</strong>：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）</p>
<ul>
<li>2MSL会使得该端口不可用，但可以使用SO_REUSEADDR来重用（注意，这是实现所支持的，但TCP不能允许一个新的连接建立在相同的插口对，即四元组）</li>
</ul>
<p><strong>平静时间</strong>：TCP在重启动后的MSL秒内不能建立任何连接，即为平静时间</p>
<p> <strong>FIN_WAIT_2状态</strong>：只有收到另一端的FIN，才会从FIN_WAIT_2状态进入TIME_WAIT状态，也就意味着可能永远保持这个状态。另一端也将处于CLOSE_WAIT状态，并一直保持这个状态直到应用层决定进行关闭。</p>
<ul>
<li>在实现中，如果进行全关闭，则设置一个定时器，如果这个连接空闲10分钟75秒，TCP将进入CLOSED状态。</li>
</ul>
<p><strong>复位报文段</strong>：无论何时一个报文段发往四元组连接出现错误，TCP都会发出一个复位报文段，注意收到RST不会产生任何响应。有如下情况：</p>
<ul>
<li>到不存在的端口的连接请求。例如UDP发送到一个未使用的端口，则产生ICMP信息；而TCP则使用复位。</li>
<li>异常终止一个连接。通常有以下优点：<ul>
<li>丢弃任何待发数据并立即发送复位报文段；</li>
<li>RST的接收方能区分另一端执行的是异常关闭还是正常关闭。</li>
</ul>
</li>
<li>检测半打开连接。<ul>
<li>如果一方已经关闭或异常终止连接而另一方却还不知道，这样的TCP连接称为半打开</li>
<li>例如因掉电而重启，服务端已经丢失原来连接信息，此时客户端发送一个消息，服务端则以复位作为应答。</li>
</ul>
</li>
</ul>
<p><strong>两方同时发送建立连接</strong>：这种情况只会建立一条连接（注意两方必须属于同一四元组）</p>
<ul>
<li>两端几乎在同时发送SYN，并进入SYN_SENT状态。</li>
<li>当每一端收到SYN时，状态变为SYN_RCVD，同时它们都再发SYN并对收到的SYN进行确认。</li>
<li>当双方都收到SYN及相应的ACK时，状态都变迁为ESTABLISHED。</li>
<li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614192431876.png"></li>
</ul>
<p><strong>两方同时关闭连接</strong>：</p>
<ul>
<li><p>当应用层发出关闭命令时，两端均从ESTABLISHED变为FIN_WAIT_1</p>
</li>
<li><p>双方各发送一个FIN，双方收到FIN后，状态由FIN_WAIT_1变迁到CLOSING，并发送最后的ACK</p>
</li>
<li><p>当收到最后的ACK时，状态变化为TIME_WAIT（有点不太理解为啥不直接closed，此时已经接收到ack了，如果是为了保证对方能正确接收到ack，难道对方超时后会重新发送FIN吗）</p>
<blockquote>
<p>如果最后ack丢失怎么办？重新发送FIN？</p>
</blockquote>
</li>
</ul>
<p><strong>TCP选项</strong>：</p>
<ul>
<li>每个选项的开始是1字节kind字段，说明选项的类型。kind字段为0和1的选项仅占1个字节。其他的选项在kind字节后还有len字节。它说明的长度是指总长度，包括kind字节和len字节。</li>
<li>设置无操作选项的原因在于允许发方填充字段为4字节的倍数。</li>
<li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614195305445.png"></li>
</ul>
<blockquote>
<p><strong>习题</strong></p>
<ol>
<li>半打开连接和半关闭连接的区别是什么？<ul>
<li>在一个半关闭的连接上，一个端点已经发送了一个FIN，正等待另一端的数据或者一个FIN。一个半打开的连接是当一个端点崩溃了，而另一端还不知道的情况。</li>
</ul>
</li>
<li>如果启动sock程序作为一个服务器程序，然后终止它（还没有客户进程与它相连接），我们能立即重新启动这个服务器程序。这意味着它没有经历2MSL等待状态。<ul>
<li>一个连接只有经过了已建立状态才能进入2MSL等待状态。</li>
</ul>
</li>
<li>主动关闭方因超时而从FIN_WAIT_2变为CLOSED，如果此时被关闭方发送一个FIN，该如何处理？<ul>
<li>在一个已经关闭的连接上到达了一个FIN，会发送了一个复位报文（但如果还是TIME_WAIT状态则会重新开始2msl定时）。</li>
</ul>
</li>
<li>为什么服务器不将对客户FIN的ACK与自己的FIN合并，从而将报文段数减少为3个？<ul>
<li>服务器对客户的FIN的确认一般不会被延迟，而是在FIN到达后立即发送。</li>
<li>服务器收到客户的FIN后，并不一定要关闭它这一端的连接。</li>
</ul>
</li>
<li>假定MSL为120秒，试问系统能够初始化一个新连接然后进行主动关闭的最大速率是多少？<ul>
<li>最大数目的TCP端口号（65536-1024&#x3D;64512，忽略知名端口）除以TIME_WAIT状态的2MSL。</li>
</ul>
</li>
<li>分析处于TIME_WAIT状态的主机收到使其进入此状态的重复的FIN时所发生的情况<ul>
<li>重复的FIN会得到确认，2MSL定时器重新开始。</li>
</ul>
</li>
<li>分析处于TIME_WAIT状态的主机收到一个RST时所发生的情况。<ul>
<li>在TIME_WAIT状态中收到一个RST引起状态过早地终止，这就叫作TIME_WAIT断开。有RFC提出的简单的修改就是在TIME_WAIT状态时忽略RST段。</li>
</ul>
</li>
<li>在图1-8中，我们曾提到到来的TCP报文段可根据其目的端口号进行分用，请问这种说法是否正确？<ul>
<li>错误，只能根据四元组进行分用</li>
</ul>
</li>
</ol>
</blockquote>
<h1 id="第19章-TCP的交互数据流"><a href="#第19章-TCP的交互数据流" class="headerlink" title="第19章 TCP的交互数据流"></a>第19章 TCP的交互数据流</h1><p>通常TCP在接收到数据时并不立即发送ACK而是推迟发送，以便将ACK与需要沿该方向发送的数据一起发送。绝大多数实现TCP将以最大200 ms的时延等待是否有数据一起发送。在等待时，如果有数据则立即发送。</p>
<p><strong>Nagle算法</strong>：该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组（微小TCP报文），在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去<em>（TCP本来就是流，相当于积存较多的数据一起发送）</em>。</p>
<ul>
<li>有时也需要关闭Nagle算法。如小消息（鼠标移动）必须无时延地发送，</li>
</ul>
<p><strong>窗口大小通告</strong>：发送报文时会填写通告窗口大小，其值为当前缓冲区可用大小</p>
<h1 id="第20章-TCP的成块数据流"><a href="#第20章-TCP的成块数据流" class="headerlink" title="第20章 TCP的成块数据流"></a>第20章 TCP的成块数据流</h1><p><strong>滑动窗口</strong>：滑动窗口大小由对方指定的窗口值（和拥塞窗口中最小值）确定，因此可能会变大或变小</p>
<ul>
<li>称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。</li>
<li>当窗口右边沿向右移动时将允许发送更多的数据，称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时（此时报文中的窗口值变大）。</li>
<li>如果接收到一个指示窗口左边沿向左移动的ACK，则它被认为是一个重复ACK</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230615194408439.png"></p>
<p><strong>PUSH标志</strong>：使用该标志通知接收方将所收到的数据全部提交给接收进程。这里的数据包括与PUSH一起传送的数据以及接收方TCP已经为接收进程收到的其他数据。</p>
<ul>
<li>如果待发送数据将清空发送缓存，则大多数的源于伯克利的实现能够自动设置PUSH标志。而源于伯克利的实现一般从不将接收到的数据推迟交付给应用程序</li>
</ul>
<p><strong>慢启动</strong>：慢启动为发送方的TCP增加了拥塞窗口，记为cwnd。拥塞窗口被初始化为1个报文段（连接建立时发送的MSS值），每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加），因此经过一次RTT，cwnd会倍增。<strong>发送方取拥塞窗口与通告窗口中的最小值作为发送上限。</strong></p>
<ul>
<li>拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。</li>
</ul>
<p><strong>带宽时延乘积</strong>：一般窗口等于带宽时延积较好，如果小于则不能充分利用带宽，大于则好像浪费？</p>
<ul>
<li>时延是指往返时间。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230615204904420.png"></p>
<p><strong>紧急方式</strong>：它使一端可以告诉另一端有些具有某种方式的“紧急数据”已经放置在普通的数据流中。可以通过设置TCP首部URG比特为1，并且一个16bit的紧急指针被置为一个正的偏移量（该偏移量必须与TCP首部中的序号字段相加，以便得出紧急数据的<em>最后一个字节</em>的序号）</p>
<ul>
<li>作用：可以在滑动窗口为0时，通过发送紧急指针和URG标志来将紧急信息发给对方，使得对方能优先接收处理。</li>
<li>例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行。因此用户从键盘发出中断命令（Ctrl+C）。如果不使用紧急指针数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用程序。</li>
</ul>
<blockquote>
<p><strong>习题</strong></p>
<ol>
<li>如果API提供一种方法，使得发送方可以告诉其TCP打开PUSH标志，而接收方可以查询一个接收的报文段是否被设置了PUSH标志，试问该标志能否被用作一个记录标记？<ul>
<li>不，因为TCP超时之后可能重新对数据进行分组</li>
</ul>
</li>
<li>在一个Usenet记录中，有人抱怨说美国和日本之间的一个128 ms时延、速率为256 000 b&#x2F;s的链路吞吐量为120 000 b&#x2F;s（利用率为47%），而当链路通过卫星时其吞吐量则为33 000 b&#x2F;s（利用率为13％）。试问在这两种情况下窗口大小各为多少（假定卫星链路的时延为500 ms）？卫星链路的窗口大小应该如何调整？<ul>
<li>第一种情况是1920字节，卫星的情况是2062字节。直接将吞吐量和时延相乘即可。</li>
</ul>
</li>
</ol>
</blockquote>
<h1 id="第21章-TCP的超时与重传"><a href="#第21章-TCP的超时与重传" class="headerlink" title="第21章 TCP的超时与重传"></a>第21章 TCP的超时与重传</h1><p>TCP通过在发送时设置一个定时器来解决这种问题，当定时器溢出时还没有收到确认，它就重传该数据。通常重传时间每失败一次都会倍增，如2、4、8。</p>
<ul>
<li><p>当超时发生，先使用以下公式计算一个避退指数，一般A为0，D为当前RTT的一半。因此下一次超时时间为2*RTO，再下一次是4 *RTO</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230619172145792.png"></p>
</li>
<li><p>但是在习题21.1中给的答案又非如此，如第一次6，第二次2*6&#x3D;12，第三次4 *12&#x3D;48（可见答案，可能答案错误）。</p>
</li>
</ul>
<p>对每个连接，TCP管理4个不同的定时器：</p>
<ul>
<li>重传定时器使用于当希望收到另一端的确认。</li>
<li>坚持(persist)定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。第22章讨论。</li>
<li>保活(keepalive)定时器可检测到一个空闲连接的另一端何时崩溃或重启。</li>
<li>2MSL定时器测量一个连接处于TIME_WA IT状态的时间。</li>
</ul>
<h2 id="21-1-往返时间测量"><a href="#21-1-往返时间测量" class="headerlink" title="21.1 往返时间测量"></a>21.1 <strong>往返时间测量</strong></h2><ul>
<li><p>M为RTT，<em>A</em>是被平滑的RTT，D则是被平滑的均值偏差，<em>Err</em>是刚得到的测量结果与当前的RTT估计器之差。<em>A</em>和<em>D</em>均被用于计算下一个重传时间（RTO）。增量g起平均作用，取为1&#x2F;8（0.125）。偏差的增益是<em>h</em>，取值为0.25。当RTT变化时，较大的偏差增益将使<em>RTO</em>快速上升。</p>
</li>
<li><p>变量<em>A</em>和<em>D</em>分别被初始化为0和3秒</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230616114652804.png"></p>
</li>
<li><p>注意，每个时间只有一个定时器进行测量，例如报文3启动一个定时器，而在报文3的确认为返回前，其他报文都不会启动定时器（也就不测量往返时间）。有的实现中，测量时间值并非真实往返值，而是时钟滴答次数（见21.4.1）</p>
</li>
</ul>
<blockquote>
<p>分组重传，然后收到一个确认。那么这个ACK是针对第一个分组的还是针对第二个分组呢？</p>
<p><strong>Karn算法</strong>：</p>
<ul>
<li>对于超时重传的数据报的确认，不更新RTT。</li>
<li>重传的情况下，採用“指数退避”的方式。当第一次超时时，使用上面的公式计算一个初始避退指数，然后每超时一次则避退倍乘，下一次传送就使用这个避退指数。</li>
<li>重传数据确认之后。再次发送的数据假设正常被确定，则使用重传之前的RTO进行更新。</li>
</ul>
</blockquote>
<h2 id="21-2-拥塞避免算法"><a href="#21-2-拥塞避免算法" class="headerlink" title="21.2 拥塞避免算法"></a>21.2 <strong>拥塞避免算法</strong></h2><ul>
<li><p>拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点。</p>
</li>
<li><p>拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口<em>cwnd</em>和一个慢启动门限<em>ssthresh</em>。这样得到的算法的工作过程如下：</p>
<ul>
<li>对一个给定的连接，初始化<em>cwnd</em>为1个报文段（连接建立时发送的MSS值），<em>ssthresh</em>为65535个字节。</li>
<li>TCP的输出不能超过<em>cwnd</em>和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。</li>
<li>当拥塞发生时（超时或收到重复确认），<em>ssthresh</em>被设置为当前窗口大小的一半（<em>cwnd</em>和接收方通告窗口大小的最小值，但<em>最少为2个报文段</em>）。此外，如果是超时引起了拥塞，则<em>cwnd</em>被设置为1个报文段（这就是慢启动）。</li>
<li>当新的数据被对方确认时，就增加<em>cwnd</em>。如果<em>cwnd</em>小于或等于<em>ssthresh</em>，则正在进行慢启动，否则正在进行拥塞避免。慢启动一直持续到回到当拥塞发生时所处位置的半时候才停止，然后转为执行拥塞避免。</li>
<li>拥塞避免算法每收到一个ACK确认时将<em>cwnd</em>增加1&#x2F;<em>cwnd</em>（cwnd指的是报文段个数），而慢启动则是大致增加一个报文段MSS；</li>
</ul>
<blockquote>
<p>查看21.8拥塞实例解开了许多疑惑</p>
<ul>
<li>cwnd指的是报文段MSS个数，但实现中使用的是字节，因此算法中都是指MSS个数</li>
<li>慢启动时，每收到一个ACK，cwnd则+1，一次RTT会发送cwnd个报文段，因此cwnd会倍增</li>
<li>拥塞避免时，没收到一个ACK，cwnd增加1&#x2F;cwnd，同理一次RTT后，cwnd加1，也就增加一个报文段。<ul>
<li>计算公式如下，这公式中的cwnd指的字节，而非报文段个数。但没弄明白为啥会有segsize&#x2F;8，网上解释是这只是一个补充量，不在算法描述横纵。</li>
<li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230619163800347.png"></li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="21-3-快速重传与快速恢复算法"><a href="#21-3-快速重传与快速恢复算法" class="headerlink" title="21.3 快速重传与快速恢复算法"></a>21.3 <strong>快速重传与快速恢复算法</strong></h2><ul>
<li>如果一连串收到3个或3个以上的重复ACK，就非常可能是一个报文段丢失了。于是就重传丢失的数据报文段，这就是快速重传算法。接下来执行的不是慢启动算法而是拥塞避免算法，这就是快速恢复算法。</li>
<li>具体算法流程如下：<ul>
<li>当收到第3个重复的ACK时，将<em>ssthresh</em>设置为当前拥塞窗口<em>cwnd</em>的一半。设置<em>cwnd</em>为<em>ssthresh</em>加上3倍的报文段大小（MSS）。</li>
<li>每次收到另一个重复的ACK时，<em>cwnd</em>增加1个报文段大小并发送1个分组（如果新的<em>cwnd</em>允许发送）。</li>
<li>当下一个确认新数据的ACK到达时，设置<em>cwnd</em>为<em>ssthresh</em>（在第1步中设置的值）。这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。</li>
</ul>
</li>
</ul>
<blockquote>
<p>当一个TCP连接关闭时，如果已经发送了16个窗口的数据，即得到16个RTT采样，那么被平滑的RTT、被平滑的均值偏差以及慢启动门限保存在路由表项中以备下次使用，下次就使用这些值进行初始化。</p>
</blockquote>
<h2 id="21-4-ICMP的差错处理"><a href="#21-4-ICMP的差错处理" class="headerlink" title="21.4 ICMP的差错处理"></a>21.4 <strong>ICMP的差错处理</strong></h2><ul>
<li>一个接收到的源站抑制引起拥塞窗口<em>cwnd</em>被置为1个报文段大小来发起慢启动，但是慢启动门限<em>ssthresh</em>没有变化，所以窗口将打开直至它或者开放了所有的通路（受窗口大小和往返时间的限制）或者发生了拥塞。</li>
<li>一个接收到的主机不可达或网络不可达实际上都被忽略，因为这两个差错都被认为是短暂现象。（这有可能是由于中间路由器被关闭而导致选路协议要花费数分钟才能稳定到另一个替换路由）</li>
</ul>
<p><strong>重新分组</strong></p>
<ul>
<li>当TCP超时并重传时，不一定要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能（不能够超过接收方声明的MSS）。</li>
</ul>
<p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_52244492/article/details/124274114">1</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230619164538648.png"></p>
<h1 id="第22章-TCP的坚持定时器"><a href="#第22章-TCP的坚持定时器" class="headerlink" title="第22章 TCP的坚持定时器"></a>第22章 TCP的坚持定时器</h1><p>当发送方窗口为0时，如果接收方更新窗口大小的ACK报文丢失（TCP不对ACK报文段进行确认），则双方就有可能因为等待对方而使连接终止：</p>
<ul>
<li>接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新。</li>
</ul>
<p>为防止这种死锁情况的发生，发送方使用一个坚持定时器来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为<strong>窗口探查</strong>。</p>
<ul>
<li>探查每隔60秒发送一次，这个过程将持续到或者窗口被打开，或者应用进程使用的连接被终止。</li>
</ul>
<p><strong>糊涂窗口综合症</strong>：其现象是交换的数据段大小不是全长而是一些较小的数据。由于每个数据段的有用数据（数据部分）较少，因而消耗的资源也更多，相应的传输效率也更低。</p>
<ul>
<li>产生原因：接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告），而发送方也可以发送少量的数据（而不是等待其他的数据以便发送一个大的报文段）。</li>
<li>解决办法：<ul>
<li>接收端：接收方不通告小窗口。通常的算法是接收方不通告一个比当前窗口大的窗口（可以为0），除非窗口可以增加一个报文段大小（也就是将要接收的MSS）或者可以增加接收方缓存空间的一半，不论实际有多少。</li>
<li>发送端：只有以下条件之一满足时才发送数据：(a)可以发送一个满长度的报文段；(b)可以发送至少是接收方通告窗口大小一半的报文段；(c)可以发送任何数据并且不希望接收ACK（也就是说，没有还未被确认的数据）或者该连接上不能使用Nagle算法</li>
</ul>
</li>
</ul>
<h1 id="第23章-TCP的保活定时器"><a href="#第23章-TCP的保活定时器" class="headerlink" title="第23章 TCP的保活定时器"></a>第23章 TCP的保活定时器</h1><p>保活并不是TCP规范中的一部分，但许多实现提供了保活计时器。</p>
<p>服务器向客户发送一个探查报文段，客户主机必须处于以下4个状态之一：</p>
<ul>
<li>客户主机依然正常运行，并从服务器可达。服务器在两小时以后将保活定时器复位。如果交换了数据，则定时器在交换数据后的未来2小时再复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。服务器将不能够收到对探查的响应，并在75秒后超时。服务器总共发送10个这样的探查，每个间隔75秒。认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。</li>
<li>客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。</li>
</ul>
<p>保活功能：</p>
<ul>
<li>优点：激活keepalive选项比显式地编写应用程序探测报文更容易；keepalive探测报文比应用程序探测报文占用更少的网络带宽（因为keepalive探测报文和应答不包含任何数据)；如果连接不是空闲的，就不会发送探测报文。</li>
<li>缺点：keepalive选项可能会由于一个临时性的网络中断而引起一个非常好的连接断开；发送探测报文的间隔（2小时）一般不可以根据应用程序进行配置；会耗费带宽</li>
</ul>
<h1 id="第24章-TCP的未来和性能"><a href="#第24章-TCP的未来和性能" class="headerlink" title="第24章 TCP的未来和性能"></a>第24章 TCP的未来和性能</h1><h2 id="24-1-路径MTU发现"><a href="#24-1-路径MTU发现" class="headerlink" title="24.1 路径MTU发现"></a>24.1 路径MTU发现</h2><p><strong>TCP的路径MTU发现过程：</strong></p>
<ul>
<li>在连接建立时，TCP使用输出接口或对端声明的MSS中的最小MTU作为起始的报文段大小。路径MTU发现不允许TCP超过对端声明的MSS。如果对端没有指定一个MSS，则默认为536。</li>
<li>在该连接上的所有被TCP发送的IP数据报都将被设置DF比特。如果某个中间路由器需要对一个设置了DF标志的数据报进行分片，它就丢弃这个数据报，并产生一个ICMP的“不能分片”差错。</li>
<li>如果收到这个ICMP差错，TCP就减少段大小并进行重传。如果路由器产生的是一个较新的该类ICMP差错，则报文段大小被设置为下一跳的MTU减去IP和TCP的首部长度。如果是一个较旧的该类ICMP差错，则必须尝试下一个可能的最小MTU。<strong>当由这个ICMP差错引起的重传发生时，拥塞窗口不需要变化，但要启动慢启动。</strong></li>
</ul>
<p><strong>分组大小选择</strong>：并非越大越好，因为路由器需要接收整个分组才会进行发送，如果过大则导致接受分组耗时过多。当分组足够大也就和报文交换类似，这也是报文交换的缺点。</p>
<h2 id="24-2-长肥管道"><a href="#24-2-长肥管道" class="headerlink" title="24.2 长肥管道"></a>24.2 长肥管道</h2><p>具有大的带宽时延乘积的网络被称为长肥网络（Long Fat Network），其会出现以下问题：</p>
<ol>
<li>TCP首部中窗口大小为16 bit，从而将窗口限制在65535个字节内。窗口扩大选项可以解决这个问题。</li>
<li>在一个长肥网络LFN内的分组丢失会使吞吐量急剧减少。如果只有一个报文段丢失，利用快速重传和快速恢复算法来使管道避免急剧减少。但是即使使用这些算法，在一个窗口内发生的多个分组丢失也会典型地使管道急剧减少</li>
<li>TCP实现对每个窗口的RTT仅进行一次测量。它们并不对每个报文段进行RTT测量。在一个长肥网络LFN上需要更好的RTT测量机制</li>
<li>TCP对每个字节数据使用一个32 bit无符号的序号来进行标识，长肥管道足够快以至于在不到一个MSL的时候序号就发生了回绕。使用TCP的时间戳选项的PAWS(Protection Against Wrapped Sequence numbers)算法解决。</li>
</ol>
<h2 id="24-3-窗口扩大选项"><a href="#24-3-窗口扩大选项" class="headerlink" title="24.3 窗口扩大选项"></a>24.3 窗口扩大选项</h2><p>窗口扩大选项使TCP的窗口定义从16 bit增加为32 bit。通过定义一个一字节的移位记数器实现对16 bit的扩大操作来完成的。于是TCP在内部将实际的窗口大小维持为32 bit的值（最大的窗口是65535×2^14，而不是2 ^16×2 ^14，）。</p>
<p>算法过程：</p>
<ul>
<li>这个选项只能够出现在一个SYN报文段中，因此当连接建立起来后，在每个方向的扩大因子是固定的。</li>
<li>为了使用窗口扩大，两端必须在它们的SYN报文段中发送这个选项。主动建立连接的一方在其SYN中发送这个选项，但是被动建立连接的一方只能够在收到带有这个选项的SYN之后才可以发送这个选项。每个方向上的扩大因子可以不同。</li>
<li>如果主动连接的一方发送一个非零的扩大因子，但是没有从另一端收到一个窗口扩大选项，它就将发送和接收的移位记数器置为0。这就实现了新旧系统的兼容。</li>
<li>假定发送移位记数为S，而接收移位记数则为R。从另一端收到的每一个16 bit的通告窗口将被左移R位以获得实际的通告窗口大小。每次当我们向对方发送一个窗口通告的时候，我们将实际的32 bit窗口大小右移S比特，然后用它来替换TCP首部中的16 bit的值。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230619203724446.png"></p>
<h2 id="24-4-时间戳选项"><a href="#24-4-时间戳选项" class="headerlink" title="24.4 时间戳选项"></a>24.4 时间戳选项</h2><p>时间戳选项使发送方在每个报文段中放置一个32 bit的时间戳值。接收方在确认中返回这个数值，从而允许发送方为每一个收到的ACK计算RTT。</p>
<p>在连接建立阶段，主动发起连接的一方在它的SYN中指定选项。只有在它从另一方的SYN中收到了这个选项之后，该选项才会在以后的报文段中进行设置。</p>
<blockquote>
<p><strong>如果接收方发送一个确认了两个报文段的ACK，那么哪一个收到的时间戳应当放入回显应答字段中来发回去呢？</strong></p>
</blockquote>
<p>解决方法：对于每个连接只保持一个时间戳的数值。选择何时更新这个数值的算法非常简单：</p>
<ol>
<li>TCP跟踪下一个ACK中将要发送的时间戳的值（一个名为<em>tsrecent</em>的变量）以及最后发送的ACK中的确认序号（一个名为<em>lastack</em>的变量）。这个序号就是接收方期望的序号。</li>
<li>当一个包含有字节号<em>lastack</em>的报文段到达时，则该报文段中的时间戳被保存在<em>tsrecent</em>中。</li>
<li>无论何时发送一个时间戳选项，<em>tsrecent</em>就作为时间戳回显应答字段被发送，而序号字段被保存在<em>lastack</em>中。</li>
<li>简单来说：接收方采用包含最后确认的报文段的时间戳发送</li>
</ol>
<h2 id="24-5-PAWS：防止回绕的序号"><a href="#24-5-PAWS：防止回绕的序号" class="headerlink" title="24.5 PAWS：防止回绕的序号"></a>24.5 PAWS：防止回绕的序号</h2><p>假定使用了时间戳选项，发送方指定的时间戳对每个将要发送的窗口加1</p>
<p>PAWS算法不需要在发送方和接收方之间进行任何形式的时间同步。接收方所需要的就是时间戳的值应该单调递增，并且每个窗口至少增加1。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">mujiubai</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://mujiubai.github.io/2023/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71-%E7%AC%94%E8%AE%B0/">https://mujiubai.github.io/2023/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71-%E7%AC%94%E8%AE%B0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">mujiubai</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Linux/">
                                    <span class="chip bg-color">Linux</span>
                                </a>
                            
                                <a href="/tags/%E7%BD%91%E7%BB%9C/">
                                    <span class="chip bg-color">网络</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/06/12/leetcode/%E6%95%B0%E7%BB%84/leetcode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-diffcult/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="4. 寻找两个正序数组的中位数">
                        
                        <span class="card-title">4. 寻找两个正序数组的中位数</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-06-12
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/LeetCode/" class="post-category">
                                    LeetCode
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Alg-%E6%95%B0%E7%BB%84/">
                        <span class="chip bg-color">Alg-数组</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/06/01/leetcode/other/leetcode-470-%E7%94%A8Rand7()%20%E5%AE%9E%E7%8E%B0%20Rand10()-middle/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="470. 用 Rand7() 实现 Rand10()">
                        
                        <span class="card-title">470. 用 Rand7() 实现 Rand10()</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-06-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/LeetCode/" class="post-category">
                                    LeetCode
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Alg-%E9%9A%8F%E6%9C%BA%E6%95%B0/">
                        <span class="chip bg-color">Alg-随机数</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <a href="/about" target="_blank">mujiubai</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">444.2k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/mujiubai" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1057378931@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1057378931" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1057378931" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/star.js"><\/script>');
            }
        </script>
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
