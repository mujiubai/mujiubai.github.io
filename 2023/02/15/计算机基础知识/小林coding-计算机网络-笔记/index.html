<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="小林coding-计算机网络-笔记, w">
    <meta name="description" content="总结知识点，以便以后快速复习。
参考小林coding网络图解, 地址
一、基础篇1.1 TCP&amp;#x2F;IP 网络模型有哪几层？应用层

应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的
应用层是工作在操作系统中的用户态，">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>小林coding-计算机网络-笔记 | w</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">w</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">

      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/C/">
          
          <span>C++</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/LeetCode/">
          
          <span>LeetCode</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
          
          <span>计算机基础知识</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/%E9%A1%B9%E7%9B%AE/">
          
          <span>项目</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">w</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-bookmark"></i>
			
			分类
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/categories/C/ " style="margin-left:75px">
				  
		          <span>C++</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/LeetCode/ " style="margin-left:75px">
				  
		          <span>LeetCode</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ " style="margin-left:75px">
				  
		          <span>计算机基础知识</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/%E9%A1%B9%E7%9B%AE/ " style="margin-left:75px">
				  
		          <span>项目</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/19.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">小林coding-计算机网络-笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                <span class="chip bg-color">计算机网络</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-category">
                                计算机基础知识
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-02-15
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-06-20
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    33.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    118 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>总结知识点，以便以后快速复习。</p>
<p><em>参考小林coding网络图解</em>, <a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/network">地址</a></p>
<h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="1-1-TCP-x2F-IP-网络模型有哪几层？"><a href="#1-1-TCP-x2F-IP-网络模型有哪几层？" class="headerlink" title="1.1 TCP&#x2F;IP 网络模型有哪几层？"></a>1.1 TCP&#x2F;IP 网络模型有哪几层？</h2><p><strong>应用层</strong></p>
<ul>
<li>应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的</li>
<li>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态</li>
</ul>
<p><strong>传输层</strong>：</p>
<ul>
<li><p>为应用层提供网络支持</p>
</li>
<li><p>TCP 的全称叫传输控制协议，大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p>
<blockquote>
<p><strong>IP层有分块，为什么TCP还要分块？</strong></p>
<p>应用需要传输的数据可能会非常大，当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。</p>
<p>如果TCP不进行分块，则在IP层可能会分块，当一个分块丢失，则需要重传整个数据，造成效率很低。</p>
</blockquote>
</li>
<li><p>UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。</p>
</li>
<li><p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。</p>
</li>
</ul>
<p><strong>网络层</strong></p>
<ul>
<li><p>实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，这就是网络层要干的事。</p>
</li>
<li><p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p>
</li>
<li><p>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</p>
</li>
</ul>
<p><strong>网络接口层</strong></p>
<ul>
<li>网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备</li>
<li>网络接口层通常负责直接相连的节点之间的传输</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316210322498.png"></p>
<p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>
<h2 id="1-2-键入网址到网页显示，期间发生了什么？"><a href="#1-2-键入网址到网页显示，期间发生了什么？" class="headerlink" title="1.2 键入网址到网页显示，期间发生了什么？"></a>1.2 键入网址到网页显示，期间发生了什么？</h2><ol>
<li><p>解析 URL：使用DNS解析域名</p>
<ul>
<li>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/6.jpg"></li>
</ul>
</li>
<li><p>使用操作系统中的协议栈来发送HTTP数据</p>
<ul>
<li><p>先三次握手建立连接</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316211136080.png"></p>
</li>
</ul>
</li>
</ol>
<h2 id="1-3-Linux-系统是如何收发网络包的？"><a href="#1-3-Linux-系统是如何收发网络包的？" class="headerlink" title="1.3 Linux 系统是如何收发网络包的？"></a>1.3 Linux 系统是如何收发网络包的？</h2><p><strong>Linux 网络协议栈</strong></p>
<ul>
<li>应用程序需要通过系统调用，来跟 Socket 层进行数据交互；</li>
<li>Socket 层的下面就是传输层、网络层和网络接口层；</li>
<li>最下面的一层，则是网卡驱动程序和硬件网卡设备；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316211406095.png"></p>
<p><strong>Linux 接收网络包的流程</strong></p>
<ul>
<li>当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区</li>
<li>触发一个中断告诉操作系统有数据到达，后面操作系统会发起一个软中断用于处理数据。内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。<ul>
<li>为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 NAPI 机制（<em>NAPI 机制</em>：不采用中断的方式读取数据，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据）</li>
</ul>
</li>
<li>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</li>
<li>在网络接口层，检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，接着再去掉帧头和帧尾，然后交给网络层</li>
<li>到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。</li>
<li>传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」(TCP) 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。</li>
<li>应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316211518689.png"></p>
<p><strong>Linux 发送网络包的流程</strong></p>
<ol>
<li>应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 sk_buff 内存，<strong>将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区</strong>。</li>
<li>网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理</li>
<li>如果使用的是 TCP 传输协议发送数据，那么<strong>先拷贝一个新的 sk_buff 副本</strong>，然后对 sk_buff 填充 TCP 头。<ul>
<li>拷贝副本原因：因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉，而 TCP 协议是支持丢失重传的。</li>
</ul>
</li>
<li>在网络层里会选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。然后交给网络接口层处理。</li>
<li>网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中。</li>
<li>这些工作准备好后，会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</li>
<li>当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放 sk_buff 内存和清理 RingBuffer 内存。</li>
<li>最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 sk_buff 。</li>
</ol>
<blockquote>
<p>为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，通过调整 sk_buff 中 <code>data</code> 的指针：</p>
<ul>
<li>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。</li>
<li>当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>发送网络数据的时候，涉及几次内存拷贝操作？</strong></p>
<ul>
<li>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</li>
<li>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</li>
<li>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff</li>
</ul>
</blockquote>
<h1 id="二、HTTP篇"><a href="#二、HTTP篇" class="headerlink" title="二、HTTP篇"></a>二、HTTP篇</h1><h2 id="2-1-HTTP-常见面试题"><a href="#2-1-HTTP-常见面试题" class="headerlink" title="2.1 HTTP 常见面试题"></a>2.1 HTTP 常见面试题</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316213651972.png"></p>
<h3 id="HTTP-是什么？"><a href="#HTTP-是什么？" class="headerlink" title="HTTP 是什么？"></a>HTTP 是什么？</h3><p>HTTP 的名字「超文本协议传输」，它可以拆成三个部分：</p>
<ul>
<li>超文本：超越普通文字，包括文字、图片、视频等</li>
<li>传输：确立在两点之间传输数据的约定和规范</li>
<li>协议：确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式（行为约定和规范）</li>
</ul>
<p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p>
<hr>
<h3 id="HTTP-常见的状态码有哪些？"><a href="#HTTP-常见的状态码有哪些？" class="headerlink" title="HTTP 常见的状态码有哪些？"></a>HTTP 常见的状态码有哪些？</h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329155907563.png"></p>
<hr>
<h3 id="HTTP-常见字段有哪些？"><a href="#HTTP-常见字段有哪些？" class="headerlink" title="HTTP 常见字段有哪些？"></a>HTTP 常见字段有哪些？</h3><ul>
<li><strong><em>Host</em> 字段</strong>：使用此字段可以在相同ip+端口部署不同服务</li>
<li><em><strong>Content-Length 字段</strong></em>：数据长度（为了解决粘包问题）</li>
<li><em><strong>Connection 字段</strong></em>：最常用于客户端要求服务器使用「HTTP 长连接」机制（http1.1默认开启keep alibe，1.0则是关闭）</li>
<li><em><strong>Content-Type 字段</strong></em>：数据格式</li>
<li><em><strong>Content-Encoding 字段</strong></em>：数据压缩方法</li>
</ul>
<hr>
<h3 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h3><ul>
<li>GET 的语义是从服务器获取指定的资源，GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII</li>
<li>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理，POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据</li>
</ul>
<hr>
<h3 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h3><blockquote>
<p>「安全」是指请求方法不会「破坏」服务器上的资源；「幂等」是指多次执行相同的操作，结果都是「相同」的。</p>
</blockquote>
<ul>
<li>GET 方法就是安全且幂等的，因为它是「只读」操作（所以可以对get请求的数据做缓存）</li>
<li>POST方法是不安全且不幂等的，因为它会修改服务器上的资源（所以一般不会缓存post请求）</li>
</ul>
<p>上述是RFC规范，但如果不遵循规范可能会导致get并非安全且幂等</p>
<blockquote>
<p><strong>GET 请求可以带 body 吗？</strong></p>
<p>RFC 规范并没有规定 GET 请求不能带 body，任何请求都可以带 body 的 。</p>
<p>URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的</p>
</blockquote>
<hr>
<h3 id="HTTP-缓存有哪些实现方式？"><a href="#HTTP-缓存有哪些实现方式？" class="headerlink" title="HTTP 缓存有哪些实现方式？"></a>HTTP 缓存有哪些实现方式？</h3><p>两种实现方式：</p>
<ul>
<li><p><strong>强制缓存</strong>：只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>
<ul>
<li>HTTP头部有两个字段用于表示缓存有效时间：<code>Cache-Control</code>，相对时间；<code>Expires</code>，绝对时间；</li>
<li>Cache-Control 的优先级高于 Expires </li>
<li>具体实现流程如下：<ul>
<li>当第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>协商缓存</strong>：与服务端协商之后，通过协商结果来判断是否使用本地缓存。协商缓存可以基于两种头部来实现：</p>
<ul>
<li>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现<ul>
<li><code>Last-Modified</code> ：标示这个响应资源的最后修改时间</li>
<li><code>If-Modified-Since</code>：当资源过期，其具有Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后与被请求资源的最后修改时间进行对比，如果资源被改过，则返回最新资源，HTTP 200 OK；如果资源无新修改，响应 HTTP 304 走缓存。</li>
</ul>
</li>
<li>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段<ul>
<li><code>Etag</code>：唯一标识响应资源；</li>
<li><code>If-None-Match</code>：当资源过期时，其具有有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li>
</ul>
</li>
<li>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</li>
</ul>
<blockquote>
<p>请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，<strong>这时 Etag 的优先级更高</strong>。服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。这样做是因为：</p>
<ul>
<li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致认为这文件被改动了</li>
<li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的</li>
<li>有些服务器不能精确获取文件的最后修改时间</li>
</ul>
</blockquote>
</li>
</ul>
<p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329164950051.png" style="zoom:67%;" />

<hr>
<h3 id="HTTP的优点有哪些？"><a href="#HTTP的优点有哪些？" class="headerlink" title="HTTP的优点有哪些？"></a>HTTP的优点有哪些？</h3><ul>
<li><em>简单</em>：基本的报文格式就是 <code>header + body</code>，头部信息是 <code>key-value</code> 形式，易于理解</li>
<li><em>灵活和易于扩展</em>：HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等都允许开发人员自定义和扩充，且下层可以随意变化。</li>
<li><em>应用广泛和跨平台</em></li>
</ul>
<hr>
<h3 id="HTTP的缺点有哪些？"><a href="#HTTP的缺点有哪些？" class="headerlink" title="HTTP的缺点有哪些？"></a>HTTP的缺点有哪些？</h3><ul>
<li><em>无状态双刃剑</em>：<ul>
<li>好处：不需要额外的资源来记录状态信息，能减轻服务器的负担</li>
<li>坏处：完成有关联性的操作时会非常麻烦</li>
</ul>
</li>
<li><em>明文传输双刃剑</em>：对调试工作十分方便，但信息容易被窃取。</li>
<li><em>不安全</em>：通信使用明文（不加密），内容可能会被窃听；不验证通信方的身份，因此有可能遭遇伪装；无法证明报文的完整性，所以有可能已遭篡改。</li>
</ul>
<hr>
<h3 id="HTTP-x2F-1-1-相比-HTTP-x2F-1-0-提高了什么性能？"><a href="#HTTP-x2F-1-1-相比-HTTP-x2F-1-0-提高了什么性能？" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h3><ul>
<li><em><strong>长连接</strong></em>：http1.1默认使用长连接，减少了 TCP 连接的重复建立和断开所造成的额外开销。</li>
<li><em><strong>管道网络传输</strong></em>：即发送完第一个请求后可以马上发送下一个请求，而无序等待第一个请求完成。<ul>
<li>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。所以只<strong>解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="HTTP-x2F-2-做了什么优化？"><a href="#HTTP-x2F-2-做了什么优化？" class="headerlink" title="HTTP&#x2F;2 做了什么优化？"></a>HTTP&#x2F;2 做了什么优化？</h3><p>HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p>
<ul>
<li><strong>重复头部压缩：</strong>如果多个请求的头部是一样的，那么会消除重复的部分。采用<code>HPACK</code> 算法，在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后只发送索引号，从而减少数据。<code>HPACK</code> 算法由以下三个部分组成：<ul>
<li>静态表编码：HTTP&#x2F;2 为高频出现在头部的字符串和字段建立了一张静态表，它不会变化，共61组（序号所在字节第一位用于表示其是否在静态表存在）</li>
<li>动态表编码：对于不在静态表中的字段就需要构建动态表，每次发送一个字段后，客户端和服务端都会更新动态表，以后按动态表的序号发送即可（服务器一般会限制动态表大小）</li>
<li>哈夫曼编码：HTTP&#x2F;2 根据出现频率将 ASCII 码编码为了 Huffman 编码表，是固定不变的。（在头部字段后面的下一个字节的第一位表示是否使用哈夫曼编码，后7为表示value长度）</li>
</ul>
</li>
<li><strong>二进制格式：</strong>头信息和数据体都采用二进制格式。</li>
<li><strong>并发传输：</strong>初步解决http1.1中的服务端队头阻塞问题，使用了stream，多个 Stream 复用在一条 TCP 连接。<ul>
<li>1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 是一个请求或响应</li>
<li>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应。</li>
<li>不同 Stream 的帧是可以乱序发送的，而同一 Stream 内部的帧必须是严格有序的</li>
</ul>
</li>
<li><strong>服务器主动推送资源：</strong>服务端不再是被动地响应，可以主动向客户端发送消息。<ul>
<li>客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>HTTP2缺陷</strong></p>
<p>HTTP2是基于TCP协议的，而TCP协议必须保证收到的报文是完整且连续的。如果接受窗口的一部分数据没有收到，那么即使其后面数据收到也只有等待前面数据收到后，内核才能拿到数据。因此并未真正解决队头阻塞问题。</p>
</blockquote>
<hr>
<h3 id="HTTP-x2F-3-做了哪些优化？"><a href="#HTTP-x2F-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h3><p> HTTP&#x2F;3 把 下层的 TCP 协议改成了 基于UDP的QUIC协议，其特点如下：</p>
<ul>
<li><p><em><strong>无队头阻塞</strong></em>：QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，且有一套机制保证传输可靠性。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。</p>
</li>
<li><p><em><strong>更快的连接建立</strong></em>：HTTP&#x2F;3 的 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商。</p>
<ul>
<li><p>且在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329203350684.png" style="zoom:50%;" /></li>
</ul>
</li>
<li><p><em><strong>连接迁移</strong></em>：TCP协议是基于四元组确认一条连接，当设备网络发生变化后需要重新建立连接。QUIC协议通过连接ID来标记通信的两个端点，当网络变化后通过连接ID、TLS密钥等就可以复用原连接，从而达到连接迁移功能。</p>
</li>
</ul>
<p>HTTP3相比HTTP2变化：</p>
<ul>
<li>HTTP&#x2F;3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream</li>
<li>HTTP&#x2F;3使用QPACK算法压缩，主要将静态表扩大到91项，且利用了QUIC中的两个单向流来同步双方的动态表。</li>
</ul>
<hr>
<h3 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h3><ul>
<li>HTTP 是明文传输，存在安全风险。HTTPS 在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 在 TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<hr>
<h3 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？"></a>HTTPS 解决了 HTTP 的哪些问题？</h3><p>解决了窃听问题、篡改问题、网站冒充问题，使用下面方法进行解决的：</p>
<ul>
<li><strong>混合加密的方式实现信息的机密性，解决了窃听的风险。</strong><ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。这是因为：<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题，但速度慢。</li>
</ul>
</li>
</ul>
</li>
<li><strong>摘要算法的方式来实现完整性，解决了篡改的风险。</strong><ul>
<li>对内容计算出一个「指纹」，然后同内容一起传输给对方。对方收到后先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</li>
<li>指纹是通过哈希函数计算出的一个哈希值，但并不能保证「内容 + 哈希值」不会被中间人替换。<strong>解决办法</strong>是使用私钥对内容的哈希值进行加密，接收方对其解密并验证哈希是否相同。</li>
</ul>
</li>
<li><strong>将服务器公钥放入到数字证书中，解决了冒充的风险。</strong><ul>
<li>通过数字证书的方式保证服务器公钥的身份</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>非对称加密有两种用途</strong>：</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>
<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>
</ul>
</blockquote>
<hr>
<h3 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h3><ol>
<li><p><em><strong>ClientHello</strong></em>：客户端向服务器发起加密通信请求，主要发送以下信息：支持的 TLS 协议版本、生产的随机数、支持的密码套件列表。</p>
</li>
<li><p><em><strong>SeverHello</strong></em>：服务器收到客户端请求后，向客户端发出响应，回应的内容主要如下：确认 TLS 协议版本；服务器生产的随机数；确认的密码套件列表；服务器的数字证书</p>
</li>
<li><p><em><strong>客户端回应</strong></em>：先根据CA公钥确认服务器的数字证书的真实性。如果没有问题，客户端会从数字证书中取出公钥，使用它加密报文，向服务器发送如下信息：</p>
<ul>
<li>一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</li>
<li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li>
<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li>
</ul>
<blockquote>
<p><strong>服务器和客户端有了这三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p>
</blockquote>
</li>
<li><p><em><strong>服务器的最后回应</strong></em>：服务器收到客户端的第三个随机数之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发送最后的信息：</p>
<ul>
<li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li>
<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</li>
</ul>
</li>
</ol>
<blockquote>
<p>SSL&#x2F;TLS 1.2 需要 4 握手，需要 2 个 RTT 的时延。</p>
<p>而SSL&#x2F;TLS 1.3 优化了过程，只需要 1 个 RTT 往返时延，也就是只需要 3 次握手，细节见后文。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329193344364.png"></p>
<p><strong>数字证书签发和验证流程：</strong></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329194543425.png"></strong></p>
<blockquote>
<p><strong>多层证书验证过程</strong></p>
<ul>
<li>根据收到的证书找到其签发机构，如果签发机构不是根证书，则继续找直到达到根证书。</li>
<li>如果此根证书已经预载于系统重，则使用根证书的公钥去验证下一级的证书，不断进行验证从而完成所有证书信任。</li>
</ul>
<p><strong>为什么要搞这么多层级证书？</strong></p>
<p>为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题</p>
</blockquote>
<hr>
<h3 id="HTTPS-的应用数据是如何保证完整性的？"><a href="#HTTPS-的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS 的应用数据是如何保证完整性的？"></a>HTTPS 的应用数据是如何保证完整性的？</h3><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p>
<ul>
<li>TLS 握手协议就是 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据；</li>
<li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li>
</ul>
<p>记录协议过程如下：</p>
<ol>
<li>消息被分割成多个较短片段，对每个片段分别进行压缩</li>
<li>再压缩片段后面加上消息认证码（MAC值）。为防止重放攻击，计算消息认证码时还加上了片段的编码。</li>
<li>使用对称密码对每个片段进行加密，加上报文头从而组成最终报文数据</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329200337847.png" style="zoom:50%;" />

<hr>
<h3 id="HTTPS-一定安全可靠吗？"><a href="#HTTPS-一定安全可靠吗？" class="headerlink" title="HTTPS 一定安全可靠吗？"></a>HTTPS 一定安全可靠吗？</h3><p>受到中间人攻击（伪基站）时，https安全吗？</p>
<p>安全，即使有伪基站进行中间攻击，但客户端会验证其公钥是否与域名对应（CA机构可验证），如果不对应则拒绝后续执行，而伪基站自己生成的公钥和所要访问的域名肯定是不对应的。</p>
<p>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</p>
<blockquote>
<p><strong>为什么抓包工具能截取 HTTPS 数据？</strong></p>
<p>对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:</p>
<ol>
<li>作为客户端与真实服务端建立连接，这一步不会有问题，因为服务端不会校验客户端的身份；</li>
<li>作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；中间人要拿到私钥只能通过如下方式：<ul>
<li>去网站服务端拿到私钥；</li>
<li>去CA处拿域名签发私钥；</li>
<li>自己签发证书，切要被浏览器信任；</li>
</ul>
</li>
</ol>
<p>因此，使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这也是能被截取数据的关键所在</p>
<p><strong>如何避免被中间人抓取数据？</strong></p>
<ul>
<li>不要点击任何证书非法的网站</li>
<li>通过 HTTPS 双向认证，即服务器也验证客户端身份：将包含客户端公钥的证书发给服务器，服务器进行验证</li>
</ul>
</blockquote>
<h2 id="2-2-HTTP-x2F-1-1-优化"><a href="#2-2-HTTP-x2F-1-1-优化" class="headerlink" title="2.2 HTTP&#x2F;1.1 优化"></a>2.2 HTTP&#x2F;1.1 优化</h2><ul>
<li><strong>避免发送HTTP请求</strong>：使用HTTP的强制缓存和协商缓存技术，即收到请求后将其缓存到本地，下次请求时如果缓存没过期则直接使用缓存数据，如果过期则请求时带上数据的摘要，由服务端判断是否继续使用原缓存。</li>
<li><strong>减少 HTTP 请求次数</strong><ul>
<li><strong><em>减少重定向请求次数</em>：</strong>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数</li>
<li><strong><em>合并请求</em>：</strong>将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输</li>
<li><strong><em>延迟发送请求</em>：</strong>按需访问资源，只访问当前用户看得到&#x2F;用得到的资源，才接下来的资源</li>
</ul>
</li>
<li><strong>减少 HTTP 响应的数据大小</strong>：对数据进行压缩，例如对关键数据进行无损压缩，对图片音频等进行有损压缩</li>
</ul>
<h2 id="2-3-HTTPS-RSA-握手解析"><a href="#2-3-HTTPS-RSA-握手解析" class="headerlink" title="2.3 HTTPS RSA 握手解析"></a>2.3 HTTPS RSA 握手解析</h2><p>TLS 的握手过程，如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329205705346.png" style="zoom:50%;" />

<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329212203781.png"></p>
<ul>
<li><strong>第一次握手</strong>：发一个「Client Hello」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random），这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</li>
<li><strong>第二次握手</strong>：返回「Server Hello」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件<ul>
<li>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成随机数（Server Random）</li>
<li>服务端为了证明自己的身份，会发送「Server Certificate」给客户端，这个消息里含有数字证书</li>
</ul>
</li>
<li><strong>第三次握手</strong>：在收到服务端发送的第二次握手信息后，会先验证证书可靠性，如果不可靠则终止。客户端就会生成一个新的随机数 (pre-master)，用服务器的 RSA 公钥加密该随机数，通过「Client Key Exchange」消息传给服务端。<ul>
<li>生成完「会话密钥」后，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息</li>
<li>再发一个「Encrypted Handshake Message（Finishd）」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」</li>
</ul>
</li>
<li><strong>第四次握手</strong>：发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</li>
</ul>
<blockquote>
<p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。因为随机数使用公钥加密的，如果私钥泄露，以前的报文都会被泄露。</p>
</blockquote>
<h2 id="2-4-HTTPS-ECDHE-握手解析"><a href="#2-4-HTTPS-ECDHE-握手解析" class="headerlink" title="2.4 HTTPS ECDHE 握手解析"></a>2.4 HTTPS ECDHE 握手解析</h2><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329212936210.png" style="zoom:50%;" />

<h2 id="2-5-HTTPS-如何优化？"><a href="#2-5-HTTPS-如何优化？" class="headerlink" title="2.5 HTTPS 如何优化？"></a>2.5 HTTPS 如何优化？</h2><p>产生性能消耗的两个环节：</p>
<ul>
<li>第一个环节， TLS 协议握手过程；</li>
<li>第二个环节，握手后的对称加密报文传输。</li>
</ul>
<p><strong>硬件优化</strong>：应该选择可以支持 AES-NI 特性的 CPU，因为这种CPU 在指令级别优化了 AES 算法，加速了数据的加解密传输过程</p>
<p><strong>软件优化</strong>：</p>
<ul>
<li><p><strong>协议优化</strong></p>
<ul>
<li>密钥交换算法应该选择 ECDHE 算法，而不用 RSA 算法，因为 ECDHE 算法具备前向安全性，而且客户端可以在第三次握手之后，就发送加密应用数据，节省了 1 RTT。ECDHE算法尽量选择 x25519 曲线。</li>
<li>将 TLS1.2 升级 TLS1.3，因为 TLS1.3 的握手过程只需要 1 RTT，而且安全性更强。</li>
</ul>
</li>
<li><p><strong>证书优化</strong></p>
<ul>
<li>服务器应该选用 ECDSA 证书，而非 RSA 证书，因为在相同安全级别下，ECC 的密钥长度比 RSA 短很多</li>
<li>服务器应该开启 OCSP Stapling 功能，由服务器预先获得 OCSP 的响应，并把响应结果缓存起来，这样 TLS 握手的时候就不用再访问 CA 服务器，减少了网络通信的开销，提高了证书验证的效率；（OCSP：向 CA 发送查询请求，让 CA 返回证书的有效状态）</li>
</ul>
</li>
<li><p><strong>会话复用：</strong>对于重连 HTTPS 时，可以使用Session ID 和 Session Ticket等回话重用技术，从而快速恢复对话。</p>
<ul>
<li>Session ID：<ul>
<li>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识。</li>
<li>当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态。</li>
</ul>
</li>
<li>Session Ticket：<ul>
<li>客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。</li>
<li>客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，就可以恢复会话了，开始加密通信。</li>
</ul>
</li>
<li>Pre-shared Key：和ticket类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>TLS1.3减少1RTT的方法</strong>：</p>
<ul>
<li>客户端在 Client Hello 消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥</li>
<li>服务端收到后选择其中一中曲线计算公钥，返回时带上公钥，从而双方皆有能生成会话密钥。</li>
</ul>
</blockquote>
<h2 id="2-6-既然有-HTTP-协议，为什么还要有-RPC？"><a href="#2-6-既然有-HTTP-协议，为什么还要有-RPC？" class="headerlink" title="2.6 既然有 HTTP 协议，为什么还要有 RPC？"></a>2.6 既然有 HTTP 协议，为什么还要有 RPC？</h2><p>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义消息边界。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</p>
<p>HTTP 和 RPC 区别</p>
<ul>
<li><strong>服务发现</strong><ul>
<li>在 HTTP 中，知道服务的域名，就可以通过 DNS 服务去解析得到 IP 地址，默认 80 端口。</li>
<li>在 RPC 中，一般会有专门的中间服务去保存服务名和IP信息，比如 Consul 或者 Etcd。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。</li>
</ul>
</li>
<li><strong>底层连接形式</strong><ul>
<li>HTTP&#x2F;1.1 默认在建立底层 TCP 连接之后会一直保持这个连接</li>
<li>RPC 协议也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用</li>
</ul>
</li>
<li><strong>传输的内容</strong><ul>
<li>HTTP&#x2F;1.1使用 Json 来序列化结构体数据</li>
<li>RPC一般采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>HTTP&#x2F;2 在1.1的基础上做了很多改进，所以性能可能比很多 RPC 协议还要好，甚至连 gRPC 底层都直接用的 HTTP&#x2F;2。</p>
</blockquote>
<h2 id="2-7-既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#2-7-既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="2.7 既然有 HTTP 协议，为什么还要有 WebSocket？"></a>2.7 既然有 HTTP 协议，为什么还要有 WebSocket？</h2><p><strong>服务器主动发消息给客户端该怎么实现？</strong></p>
<ul>
<li><strong>使用 HTTP 不断轮询</strong>：代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息<ul>
<li>缺点：消耗带宽和服务器性能；由于存在轮询间隔，因此会感到明显的卡顿</li>
</ul>
</li>
<li><strong>长轮询</strong>：HTTP 请求将超时设置的很大，比如 30 秒，在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。<ul>
<li>缺点：适用于简单场景，如果有大量数据需要推送则不适合。</li>
</ul>
</li>
</ul>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>HTTP1.1是一种半双工协议，服务器不能主动向客户端发送消息，因此WebSocket应运而生。</p>
<p>为了兼容HTTP场景和WebSocket场景，浏览器在 TCP 三次握手建立连接之后，都统一使用 HTTP 协议先进行一次通信：</p>
<ul>
<li>如果此时是普通的 HTTP 请求，那后续双方就还是老样子继续用普通 HTTP 协议进行交互，这点没啥疑问。</li>
<li>如果这时候是想建立 WebSocket 连接，就会在 HTTP 请求里带上一些特殊的header 头，表示想升级成 WebSocket 协议</li>
</ul>
<p>WebSocket握手过程：</p>
<ul>
<li><p>第一次握手：在建立http连接后，在http请求里面加上升级协议字段，并生成一个随机的base64码，发送给服务器</p>
<pre class="line-numbers language-none"><code class="language-none">Connection: Upgrade
Upgrade: WebSocket
Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg&#x3D;&#x3D;\r\n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>第二次握手：如果服务器支持升级WebSocket协议，根据客户端生成的 base64 码，用某个公开的算法变成另一段字符串，放在 HTTP 响应的 Sec-WebSocket-Accept 头里，同时带上101状态码，发回给浏览器。</p>
</li>
<li><p>浏览器也用同样的公开算法将base64码转成另一段字符串，如果这段字符串跟服务器传回来的字符串一致，那就可以使用 webscoket 的数据格式进行通信。</p>
</li>
</ul>
<blockquote>
<p>注意！WebSocket是利用HTTP协议来完成的握手过程，握手完成后就不再使用http协议</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230330173008117.png" style="zoom:50%;" />





<h1 id="三、TCP篇"><a href="#三、TCP篇" class="headerlink" title="三、TCP篇"></a>三、TCP篇</h1><h2 id="3-1-TCP-三次握手与四次挥手面试题"><a href="#3-1-TCP-三次握手与四次挥手面试题" class="headerlink" title="3.1 TCP 三次握手与四次挥手面试题"></a>3.1 TCP 三次握手与四次挥手面试题</h2><h3 id="TCP-头格式有哪些？"><a href="#TCP-头格式有哪些？" class="headerlink" title="TCP 头格式有哪些？"></a>TCP 头格式有哪些？</h3><ul>
<li><p><strong>序列号</strong>：在建立连接时生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」（不包含首部大小）的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示不会再有数据发送，希望断开连接。</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230330191311058.png" style="zoom:50%;" />

<hr>
<h3 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a>什么是 TCP ？</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议：</p>
<ul>
<li><p><strong>面向连接</strong>：一定是「一对一」连接，不像 UDP 协议可以一个主机同时向多个主机发送消息，一对多是无法做到的；</p>
</li>
<li><p><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p>
</li>
<li><p><strong>字节流</strong>：通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。</p>
<ul>
<li>TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>什么是TCP连接？</strong></p>
<p>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合（Socket、序列号和窗口大小）称为连接。</p>
<p><strong>为什么 TCP 是面向字节流的协议？</strong></p>
<p>当用户消息通过 TCP 协议传输时，消息可能会被操作系统分组成多个的 TCP 报文，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。至于什么时候真正被发送，取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件。</p>
<p><strong>如何解决粘包</strong></p>
<ul>
<li>固定长度的消息；</li>
<li>特殊字符作为边界；</li>
<li>自定义消息结构。</li>
</ul>
</blockquote>
<hr>
<h3 id="如何唯一确定一个-TCP-连接呢？"><a href="#如何唯一确定一个-TCP-连接呢？" class="headerlink" title="如何唯一确定一个 TCP 连接呢？"></a>如何唯一确定一个 TCP 连接呢？</h3><p>TCP 四元组可以唯一的确定一个连接，四元组包括：源地址、源端口、目的地址、目的端口</p>
<ul>
<li>源地址和目的地址是在 IP 头部中，源端口和目的端口是在 TCP 头部中</li>
</ul>
<blockquote>
<p>有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</p>
<p>由于本地ip和端口固定，理论最大链接数&#x3D;客户端IP数*客户端端口数&#x3D;2^32 x 2^16。但实际会受文件描述符限制、内存限制</p>
</blockquote>
<hr>
<h3 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h3><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。UPD非常简单，头部只有 <code>8</code> 个字节：</p>
<ul>
<li>目标和源端口：告诉 UDP 协议应该把报文发给哪个进程。</li>
<li>包长度： UDP 首部的长度跟数据的长度之和。</li>
<li>校验和：为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230330192533307.png" style="zoom:33%;" />

<p><strong>TCP 和 UDP 区别：</strong></p>
<ul>
<li><p><em>1. 连接</em></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em>2. 服务对象</em></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em>3. 可靠性</em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。但可以基于 UDP 传输协议实现一个可靠的传输协议</li>
</ul>
<p><em>4. 拥塞控制、流量控制</em></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em>5. 首部开销</em></p>
<ul>
<li>TCP 首部长度较长，在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<p><em>6. 传输方式</em></p>
<ul>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<p><em>7. 分片不同</em></p>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
</li>
</ul>
<p><strong>TCP 和 UDP 应用场景：</strong></p>
<ul>
<li>TCP 常用于：FTP文件传输、HTTP等</li>
<li>UDP常用于：包总量较少的通信DNS；视频、音频等多媒体通信；广播通信</li>
</ul>
<blockquote>
<p><strong>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</strong></p>
<ul>
<li>原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的</li>
</ul>
<p><strong>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong></p>
<ul>
<li>TCP计算负载数据长度方法：IP总长度-IP首部长度-TCP首部长度，因此TCP无需包长度字段也能计算出包长度</li>
<li>UDP也可利用上述方法求，有包长度字段的原因可能是以前UDP不一定基于IP</li>
</ul>
</blockquote>
<hr>
<h3 id="半连接队列、全连接队列是什么"><a href="#半连接队列、全连接队列是什么" class="headerlink" title="半连接队列、全连接队列是什么"></a>半连接队列、全连接队列是什么</h3><p>执行<code>listen方法</code>后，内核会为每一个处于<code>LISTEN</code>状态的<code>socket</code> 分配两个队列：</p>
<ul>
<li><p><strong>半连接队列（SYN队列）</strong>，服务端收到<strong>第一次握手</strong>后，会将<code>sock</code>加入到这个队列中，队列内的<code>sock</code>都处于<code>SYN_RECV</code> 状态。</p>
<ul>
<li><p>半连接队列是个哈希表；当收到第三次握手时，如果半连接队列是个链表，就需要依次遍历才能拿到想要的连接，算法复杂度就是O(n)。</p>
</li>
<li><p>通过以下命令可以查看当前半连接数量</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> <span class="token parameter variable">-nt</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> <span class="token string">'127.0.0.1:8080'</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> <span class="token string">'SYN_RECV'</span> <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
</li>
<li><p><strong>全连接队列（ACCEPT队列）</strong>，在服务端收到<strong>第三次握手</strong>后，会将半连接队列的<code>sock</code>取出，放到全连接队列中。队列里的<code>sock</code>都处于 <code>ESTABLISHED</code>状态。这里面的连接，就<strong>等着服务端执行accept()后被取出了。</strong></p>
<ul>
<li>全连接队列是个链表</li>
<li>通过ss -lnt命令，可以看到全连接队列的大小，其中Send-Q是指全连接队列的最大值，Recv-Q是指当前的全连接队列的使用值</li>
</ul>
</li>
</ul>
<hr>
<h3 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h3><p><strong>可以</strong></p>
<p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序（相同协议）。</p>
<p>主机收到数据包后，根据 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p>
<hr>
<h3 id="TCP-三次握手过程是怎样的？"><a href="#TCP-三次握手过程是怎样的？" class="headerlink" title="TCP 三次握手过程是怎样的？"></a>TCP 三次握手过程是怎样的？</h3><ul>
<li>客户端会随机初始化序号，将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，之后客户端处于 <code>SYN-SENT</code> 状态。此阶段不能携带应用数据。</li>
<li>服务端收到 <code>SYN</code> 报文后，也随机初始化自己的序号，将此序号填入 TCP 首部的「序号」字段中，其次把 「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，之后服务端处于 <code>SYN-RCVD</code> 状态。此阶段不能携带应用数据。</li>
<li>客户端收到服务端报文后，向服务端回应最后一个应答报文，首应答报文  <code>ACK</code> 标志位置为 <code>1</code> ，「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，<strong>这次报文可以携带客户到服务端的数据</strong>，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230330202343022.png" style="zoom:50%;" />

<blockquote>
<p>如何在 Linux 系统中查看 TCP 状态？在 Linux 可以通过 <code>netstat -napt</code> 命令查看</p>
</blockquote>
<hr>
<h3 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h3><ul>
<li><p><strong>三次握手才可以阻止重复历史连接的初始化（主要原因）</strong></p>
<ul>
<li><p>当旧SYN报文比新SYN报文先抵达时，服务器能会对其响应，但客户端收到后会发现并非预期报文，会回RST报文，服务器会关闭连接（二次连接也可以回RST报文，但无法避免丢失情况）。</p>
<blockquote>
<p>为什么 TCP 两次握手为什么无法阻止历史连接呢？</p>
<p>像上述情况，在收到旧报文并做出响应后，服务端就会建立连接，导致服务端资源浪费</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>三次握手才可以同步双方的初始序列号</strong></p>
<ul>
<li>三次握手才能确保对方正确收到了自己报文，才能同步序列号</li>
</ul>
</li>
<li><p><strong>三次握手才可以避免资源浪费</strong></p>
<ul>
<li>如果只有「两次握手」，当客户端发生的 SYN 报文在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以服务端每收到一个 SYN 就只能先主动建立一个连接。导致建立多个冗余的无效链接，造成不必要的资源浪费。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如果客户端发送的第三次握手丢失，而又发送了数据，那数据会不会丢失？</strong></p>
<p>不会，即使服务端还是在 syn_received 状态，也是可以收数据的，而数据包中有ack和确认号，这个确认号和第三次握手的确认号一样。</p>
</blockquote>
<p>小结：不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<hr>
<h3 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h3><p>主要原因：</p>
<ul>
<li><p><strong>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</strong></p>
<ul>
<li><p>如果有报文被阻塞了，而服务器此时宕机重启，之前连接就断掉了，而与客户端又建立了一个新连接。如果被阻塞的报文此时到达，其序号很大可能就在服务端接受端口中，会被正常接受，从而导致数据错乱。</p>
</li>
<li><p>初始化序列化不同并不能完全阻止历史报文问题，还需要用时间戳来判断历史报文。如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包。</p>
<blockquote>
<p>解决时间戳回绕：</p>
<ul>
<li>增加时间戳的大小，由32 bit扩大到64bit：但会导致协议兼容问题</li>
<li>将一个与时钟频率无关的值作为时间戳，时钟频率可以增加但时间戳的增速不变</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</strong></p>
</li>
</ul>
<blockquote>
<p><strong>初始序列号 ISN 是如何随机产生的？</strong></p>
<p>ISN &#x3D; M + F</p>
<ul>
<li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li>
<li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。</li>
</ul>
</blockquote>
<hr>
<h3 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h3><p>当超过 <code>MTU</code> 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层</p>
<p>但是<strong>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文，也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发整个 TCP 报文。</p>
<blockquote>
<p>为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，即SYN报文中会有MSS值</p>
</blockquote>
<hr>
<h3 id="三次握手丢失分析"><a href="#三次握手丢失分析" class="headerlink" title="三次握手丢失分析"></a>三次握手丢失分析</h3><ul>
<li><p><strong>第一次握手丢失了，会发生什么？</strong></p>
<ul>
<li>当发送第一个报文后，进入到 <code>SYN_SENT</code> 状态。如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</li>
<li>不同系统重传时间不同，Linux系统重传次数默认为5，且每次超时等待时间翻倍。</li>
</ul>
</li>
<li><p><strong>第二次握手丢失了，会发生什么？</strong></p>
<ul>
<li><p>当服务端收到客户端的第一次握手后，会进入 <code>SYN_RCVD</code> 状态。当第二次握手丢失了，客户端和服务端都会重传：</p>
<ul>
<li><p>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code>内核参数决定；</p>
</li>
<li><p>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>第三次握手丢失了，会发生什么</strong></p>
<ul>
<li>当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="什么是-SYN-攻击？如何避免-SYN-攻击"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击"></a>什么是 SYN 攻击？如何避免 SYN 攻击</h3><blockquote>
<p>内核中建立连接过程：</p>
<ul>
<li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li>
<li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li>
<li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出连接对象。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331112943795.png" style="zoom:50%;" />
</blockquote>
<p><strong>SYN 攻击</strong>：把 TCP 半连接队列打满，这样当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接。</p>
<p>避免 SYN 攻击方式，可以有以下四种方法：</p>
<ul>
<li><p><strong>调大 netdev_max_backlog：</strong>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。调大 netdev_max_backlog值能增加该队列大小。</p>
</li>
<li><p><strong>增大 TCP 半连接队列：</strong>增大 TCP 半连接队列，要同时增大下面这三个参数：</p>
<ul>
<li>增大 net.ipv4.tcp_max_syn_backlog（主要参数，如果超过tcp_max_syn_backlog值则直接丢弃）</li>
<li>增大 listen() 函数中的 backlog（这个是全连接参数，但半连接丢弃逻辑里面会判断全连接是否满，如果满了则丢弃）</li>
<li>增大 net.core.somaxconn（全连接队列大小也受此参数影响）</li>
</ul>
</li>
<li><p><strong>开启 tcp_syncookies：</strong>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</p>
<ul>
<li><p>当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 <code>cookie</code> 值；</p>
</li>
<li><p>将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端（服务器不保存cookie）；</p>
</li>
<li><p>服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的cookie。如果合法，将该连接对象放入到「 Accept 队列」。</p>
</li>
<li><p>最后应用程序通过调用 <code>accpet()</code> 接口，从「 Accept 队列」取出的连接。</p>
<blockquote>
<p>注意！不会有一个cookies队列，它是通过通信双方的IP地址端口、时间戳、MSS等信息进行实时计算的，保存在TCP报头的seq里。当服务端收到客户端发来的第三次握手包时，会通过seq还原出通信双方的IP地址端口、时间戳、MSS，验证通过则建立连接。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>减少 SYN+ACK 重传次数：</strong>减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开</p>
</li>
</ul>
<blockquote>
<p><strong>如何增大 TCP 全连接队列？</strong></p>
<ul>
<li>TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，backlog 在listen时设定</li>
</ul>
<p><strong>cookies方案为什么不直接取代半连接队列？</strong></p>
<ul>
<li>因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。</li>
<li>编码解码cookies，都是比较耗CPU的，可能会出现cookies攻击，使得cpu耗费大量资源</li>
</ul>
</blockquote>
<hr>
<h3 id="TCP-四次挥手过程是怎样的？"><a href="#TCP-四次挥手过程是怎样的？" class="headerlink" title="TCP 四次挥手过程是怎样的？"></a>TCP 四次挥手过程是怎样的？</h3><ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，之后进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。<ul>
<li>在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，这个 EOF 会被<strong>放在已排队等候的其他已接收的数据之后</strong>。当read读取到EOF后，如果有数据待发送则发送完数据才调用关闭连接函数，否则直接调用关闭连接函数。</li>
</ul>
</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<blockquote>
<p><strong>主动关闭连接的，才有 TIME_WAIT 状态</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331113717875.png" style="zoom:50%;" />

<hr>
<h3 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h3><p>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，<strong>但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序</strong>：</p>
<ul>
<li>如果应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；</li>
<li>如果应用程序没有数据要发送的话，可以直接调用关闭连接的函数，</li>
</ul>
<hr>
<h3 id="四次挥手丢失分析"><a href="#四次挥手丢失分析" class="headerlink" title="四次挥手丢失分析"></a>四次挥手丢失分析</h3><ul>
<li><p><strong>第一次挥手丢失了，会发生什么？</strong></p>
<ul>
<li>客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文。当重传次数超过限制，那么等待一段时间后就直接进入close状态</li>
</ul>
</li>
<li><p><strong>第二次挥手丢失了，会发生什么？</strong></p>
<ul>
<li>客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</li>
</ul>
<blockquote>
<p>如果收到第二次挥手，客户端就会处于 <code>FIN_WAIT2</code> 状态，在这个状态需要等服务端发送第三次挥手：</p>
<ul>
<li>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以<code>FIN_WAIT2</code> 状态不可以持续太久，默认 60 秒。</li>
<li>如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭。如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 <code>FIN_WAIT2</code> 状态</li>
</ul>
</blockquote>
</li>
<li><p><strong>第三次挥手丢失了，会发生什么？</strong></p>
<ul>
<li>服务端就会重发 FIN 报文，直到达到最大重传次数</li>
</ul>
</li>
<li><p><strong>第四次挥手丢失了，会发生什么？</strong></p>
<ul>
<li>服务端就会重发 FIN 报文，直到达到最大重传次数</li>
</ul>
</li>
</ul>
<hr>
<h3 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h3><blockquote>
<p><code>MSL</code> 是指报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p><strong>MSL 与 TTL 的区别</strong>： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡</p>
</blockquote>
<p>如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p>
<blockquote>
<p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p>
</blockquote>
<hr>
<h3 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h3><p>主要是两个原因：</p>
<ul>
<li><strong>防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong><ul>
<li>由于序列号是会循环使用的，如果没有timewait状态，那么新建立的连接可能就会接受到历史连接的数据。</li>
<li>而timewait&#x3D;2msl 足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。（也可以利用时间戳过滤历史数据）</li>
</ul>
</li>
<li><strong>保证「被动关闭连接」的一方，能被正确的关闭</strong><ul>
<li>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</li>
<li>假设没有 TIME_WAIT 状态，在发完最后一次 ACK 报文就进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传FIN 报文，而客户端已经进入到关闭状态了，就会回 RST 报文。服务端收到这个 RST 会将其解释为一个错误。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="TIME-WAIT-过多有什么危害"><a href="#TIME-WAIT-过多有什么危害" class="headerlink" title="TIME_WAIT 过多有什么危害"></a>TIME_WAIT 过多有什么危害</h3><ul>
<li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li>
<li>第二是占用端口资源，端口资源也是有限的。</li>
</ul>
<p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong></p>
<ul>
<li>如果占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接，但可以对不同IP或端口发起连接</li>
</ul>
<p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong></p>
<ul>
<li>并不会导致端口资源受限，因为服务端只监听一个端口，而客户端IP和端口是不同的。但会占用系统资源。</li>
</ul>
<hr>
<h3 id="如何优化-TIME-WAIT？"><a href="#如何优化-TIME-WAIT？" class="headerlink" title="如何优化 TIME_WAIT？"></a>如何优化 TIME_WAIT？</h3><ul>
<li><strong>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项</strong><ul>
<li>打开reuse参数后，可以将处于 TIME_WAIT 的 socket 为新的连接所用</li>
<li>tcp_tw_reuse 功能只能用于连接发起方，因为在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</li>
<li>开始reuse参数则必须打开timestamps，主要是根据时间戳来过滤历史数据。</li>
</ul>
</li>
<li><strong>net.ipv4.tcp_max_tw_buckets</strong><ul>
<li>系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</li>
</ul>
</li>
<li><strong>程序中使用 SO_LINGER ，应用强制使用 RST 关闭</strong><ul>
<li>对so_linger的<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p>
</blockquote>
<hr>
<h3 id="服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>服务器出现大量 TIME_WAIT 状态的原因有哪些？</h3><ul>
<li><strong>第一个场景：HTTP 没有使用长连接</strong><ul>
<li>在大多数 Web 服务的实现中，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</li>
</ul>
</li>
<li><strong>第二个场景：HTTP 长连接超时</strong><ul>
<li>一般在Web服务实现中，如果长连接超过60秒为传输数据，就会关闭连接，从而服务器上出现timewait状态</li>
</ul>
</li>
<li><strong>第三个场景：HTTP 长连接的请求数量达到上限</strong><ul>
<li>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h3><p><strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p>
<p>可能原因如下：</p>
<ul>
<li>没有将服务端监听 socket 注册到 epoll，服务端无法获取新链接，也就不能对 socket 调用 close 函数。（第二次挥手的ACK是内核处理发送的）</li>
<li>有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数</li>
<li>通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端无法调用 close 函数</li>
<li>当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为死锁、代码bug等原因。</li>
</ul>
<hr>
<h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP存在一个保活机制，需要创建socket时使用SO_KEEPALIVE参数，原理如下：</p>
<ul>
<li>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会每隔一个时间间隔，发送一个探测报文，如果连续几个探测报文都没有得到响应，则认为TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</li>
</ul>
<p>如果开启了 TCP 保活，会有以下几种情况：</p>
<ol>
<li><strong>对端程序是正常工作的</strong>。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。</li>
<li><strong>对端主机宕机并重启</strong>。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被重置。</li>
<li><strong>对端主机宕机或报文不可达</strong>。当连续几次探测报文没有响应则会报告该连接已死亡</li>
</ol>
<blockquote>
<p><strong>心跳机制</strong></p>
<p>TCP保活的检测时间过长，可以在应用层实现一个心跳机制。</p>
</blockquote>
<hr>
<h3 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h3><p>TCP 的连接信息是由内核维护的，当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与</p>
<hr>
<h3 id="listen-时候参数-backlog-的意义？"><a href="#listen-时候参数-backlog-的意义？" class="headerlink" title="listen 时候参数 backlog 的意义？"></a>listen 时候参数 backlog 的意义？</h3><p>在早期是指半连接队列，在linux2.2后指全连接队列长度。</p>
<p>但是 全连接队列长度 &#x3D; min(backlog, somaxconn)，somaxconn是内核一个参数</p>
<hr>
<h3 id="accept-发生在三次握手的哪一步？"><a href="#accept-发生在三次握手的哪一步？" class="headerlink" title="accept 发生在三次握手的哪一步？"></a>accept 发生在三次握手的哪一步？</h3><p><strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331162105259.png" style="zoom:50%;" />

<hr>
<h3 id="没有-accept，能建立-TCP-连接吗？"><a href="#没有-accept，能建立-TCP-连接吗？" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h3><p><strong>可以</strong></p>
<p>accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。</p>
<hr>
<h3 id="没有-listen，能建立-TCP-连接吗？"><a href="#没有-listen，能建立-TCP-连接吗？" class="headerlink" title="没有 listen，能建立 TCP 连接吗？"></a>没有 listen，能建立 TCP 连接吗？</h3><p><strong>可以</strong></p>
<p>客户端是可以自己连自己的形成连接（<strong>TCP自连接</strong>），也可以两个客户端同时向对方发出请求建立连接（<strong>TCP同时打开</strong>），这两个情况都有个共同点，就是<strong>没有服务端参与，也就是没有 listen，就能 TCP 建立连接。</strong></p>
<h2 id="3-2-TCP-重传、滑动窗口、流量控制、拥塞控制"><a href="#3-2-TCP-重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="3.2 TCP 重传、滑动窗口、流量控制、拥塞控制"></a>3.2 TCP 重传、滑动窗口、流量控制、拥塞控制</h2><h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><ul>
<li><strong>超时重传</strong><ul>
<li>TCP 会在以下两种情况发生超时重传：数据包丢失；确认应答丢失；</li>
<li>超时时间是以RTO表示，其若过大会很久才回重传，若过小则重发次数显增，其应略大于报文往返RTT值。</li>
<li>Linux中，RTO计算方式考虑两个方面：<ol>
<li>TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，这个值是不断变化的</li>
<li>还要采样 RTT 的波动范围，避免如果 RTT 有一个大的波动的话，很难被发现</li>
</ol>
</li>
<li>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。</li>
</ul>
</li>
<li><strong>快速重传</strong><ul>
<li>当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</li>
<li><strong>需要解决重传的时候，是重传一个，还是重传所有的问题，为此设计了SACK。</strong>。例如，当发送了Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，所以发送方并不知道该重传哪些报文。</li>
</ul>
</li>
<li><strong>SACK方法</strong><ul>
<li><code>SACK</code>（ Selective Acknowledgment）， 选择性确认。在 TCP 头部「选项」字段里加一个 SACK ，可以将已收到的数据的信息发送给「发送方」，就可以只重传丢失的数据</li>
</ul>
</li>
<li><strong>Duplicate  SACK</strong><ul>
<li>又称 D-SACK，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。就是当ACK值大于SACK值时，就会认为SACK数据被重复接受。</li>
<li>例如传送了两个数据包，而「接收方」发给「发送方」的两个 ACK 确认应答都丢失，接收方发送了一个SACK告诉发送方第一个数据包被接受了，而此时ACK确认两个包都被接受，所以这个 SACK 就代表着 <code>D-SACK</code>。接受方就知道数据没丢，只是ACK丢了。</li>
<li>好处：<ul>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h3><p>由于等待每个请求返回再发送新请求会导致效率很低，因此引入了滑动窗口概念。只要在滑动窗口中的数据都可以直接发送。窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。</p>
<ul>
<li>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</li>
</ul>
<p><strong>窗口大小由哪一方决定？</strong></p>
<ul>
<li>通常窗口的大小是由接收方的窗口大小来决定的（还由拥塞窗口大小决定，取最小值）。</li>
<li>TCP 头有一个 <code>Window</code>字段，表示窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</li>
</ul>
<p><strong>程序是如何表示发送方的四个部分的呢？</strong></p>
<ul>
<li><code>SND.WND</code>：表示发送窗口的大小</li>
<li><code>SND.UNA</code>（<em>Send Unacknoleged</em>）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li>
<li><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 <code>SND.UNA</code> 指针加上 <code>SND.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331191516242.png" style="zoom:67%;" />

<p><strong>接收方的滑动窗口</strong></p>
<ul>
<li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li>
<li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 <code>RCV.NXT</code> 指针加上 <code>RCV.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331191722409.png" style="zoom:67%;" />

<p><strong>接收窗口和发送窗口的大小是相等的吗？</strong></p>
<ul>
<li>并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。因为告诉发送方窗口大小是需要时延的。</li>
</ul>
<p><strong>窗口关闭问题</strong></p>
<ul>
<li>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</li>
<li><strong>窗口关闭导致的死锁问题</strong>：如果发送方现在是窗口关闭状态，如果接受方发送的一个新的窗口非0的报文丢失，那么发送方会一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，从而造成死锁。<ul>
<li>解决办法：TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</li>
</ul>
</li>
</ul>
<p><strong>糊涂窗口综合症</strong></p>
<ul>
<li>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。</li>
<li>由于头部存在，发送几个字节的数据利用率很低，解决办法：<ul>
<li>让接收方不通告小窗口给发送方：即小于一定空间，通告窗口为0</li>
<li>让发送方避免发送小数据：等到窗口大于一定阈值或收到之前发送数据的 <code>ack</code> 回包（Nagle 算法）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><blockquote>
<p>流量控制是避免「发送方」的数据填满「接收方」的缓存；拥塞控制是避免「发送方」的数据填满整个网络</p>
</blockquote>
<p>拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化。只要发生了超时重传，就会认为网络出现了拥塞。</p>
<ul>
<li><strong>慢启动</strong><ul>
<li>当发送方每收到一个数据的 ACK，拥塞窗口 cwnd 的大小就会加 1（加经过确认的数据大小）。</li>
<li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li>
</ul>
</li>
<li><strong>拥塞避免</strong><ul>
<li>每当收到一个数据的 ACK 时，cwnd 增加 1&#x2F;cwnd（线性增长）。</li>
</ul>
</li>
<li><strong>拥塞发生</strong>：当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：<ul>
<li>超时重传：<code>ssthresh</code> 设为 <code>cwnd/2</code>；cwnd<code>重置为</code>1（初始值）；</li>
<li>快速重传：cwnd &#x3D; cwnd&#x2F;2；<code>ssthresh = cwnd</code>;并进入快速恢复算法。</li>
</ul>
</li>
<li><strong>快速恢复</strong>：快速重传和快速恢复算法一般同时使用，因为还能收到 3 个重复 ACK 说明网络也不那么糟糕。算法如下：<ul>
<li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值（是+3前的那个值），原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331194227959.png" style="zoom:80%;" />



<h2 id="3-3-如何优化-TCP"><a href="#3-3-如何优化-TCP" class="headerlink" title="3.3 如何优化 TCP?"></a>3.3 如何优化 TCP?</h2><h3 id="TCP-三次握手的性能提升"><a href="#TCP-三次握手的性能提升" class="headerlink" title="TCP 三次握手的性能提升"></a><strong>TCP 三次握手的性能提升</strong></h3><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401154456625.png" style="zoom:50%;" />

<ul>
<li><p><strong>客户端优化</strong></p>
<ul>
<li><strong>SYN_SENT 状态的优化</strong>：客户端在发送SYN报文后会等待服务器的报文，如果一直没等到则会重传SYN报文。因此可以根据网络的稳定性和目标服务器的繁忙程度修改 SYN 的重传次数，调整客户端的三次握手时间上限</li>
</ul>
</li>
<li><p><strong>服务端优化</strong></p>
<ul>
<li><strong>SYN_RCV 状态的优化</strong>：服务端在发送第二次握手后，如果一直没有回应则会重传报文。因此也可以根据网络情况设置重传次数和重传时间。</li>
<li><strong>调整SYN半连接队列长度</strong>：通过 <code>tcp_max_syn_backlog、somaxconn、backlog</code> 参数来调整 SYN 半连接队列的大小。</li>
<li><strong>调整accpet全连接队列长度</strong>：通过 listen 函数的 <code>backlog</code> 参数和 <code>somaxconn</code> 系统参数提高队列大小</li>
<li><strong>开启tcp_syncookies</strong>：如果遭受 SYN 攻击，应把 <code>tcp_syncookies</code> 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接成功建立。</li>
</ul>
</li>
<li><p><strong>绕过三次握手</strong></p>
<ul>
<li><strong>TCP Fast Open</strong>：<ul>
<li>第一次三次握手建立连接时，服务器生成cookie交给客户端缓存起来。</li>
<li>当第二次想再次建立连接时，客户端发送的SYN报文中包含请求数据和Cookie，服务器会对cookie进行验证，如果有效则对请求数据进行处理，并返回SYN+ACK报文和请求响应报文。</li>
<li>cookie 的值是存放到 TCP option 字段</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>accept 队列已满，只能丢弃连接吗？</strong></p>
<ul>
<li>丢弃连接只是 Linux 的默认行为，还可以选择向客户端发送 RST 复位报文，告诉客户端连接已经建立失败。需要将 tcp_abort_on_overflow 参数设置为 1。</li>
</ul>
</blockquote>
<hr>
<h3 id="TCP-四次挥手的性能提升"><a href="#TCP-四次挥手的性能提升" class="headerlink" title="TCP 四次挥手的性能提升"></a><strong>TCP 四次挥手的性能提升</strong></h3><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401154407005.png" style="zoom:50%;" />

<ul>
<li><strong>主动关闭方的优化</strong><ul>
<li>FIN_WAIT1 状态的优化：发送第一次挥手后，如果未收到ack报文会重传，因此可以优化重传次数</li>
<li>FIN_WAIT2 状态的优化：根据关闭方式不同，优化方式不同：<ul>
<li>close函数关闭：这是一个孤儿连接，如果tcp_fin_timeout时间内没收到FIN报文，就直接关闭。可使用tcp_max_orphans参数来限制最大孤儿连接数量。</li>
<li>shutdown函数关闭：此函数关闭会一直等待FIN报文，其不受tcp_max_orphans参数限制。</li>
</ul>
</li>
<li>TIME_WAIT 状态的优化：<ul>
<li>Linux 提供了 tcp_max_tw_buckets 参数，当 TIME_WAIT 的连接数量超过该参数时，新关闭的连接就不再经历 TIME_WAIT 而直接关闭；当连接过多时，可以适当调大<code>tcp_max_tw_buckets</code> 参数，减少不同连接间数据错乱的概率。</li>
<li>打开 tcp_tw_reuse 参数复用处于 TIME_WAIT 状态的连接（只能用于连接发起方，因为是在调用 connect() 时起作用的）</li>
<li>设置so_linger，如果其<code>l_onoff</code> 为非 0， 且 <code>l_linger</code> 值为 0，那么调用 close 后，会立该发送一个 RST 标志给对端，也就跳过了 TIME_WAIT 状态，直接关闭（只推荐客户端使用）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>被动关闭方的优化</strong><ul>
<li>被动关闭的连接方应对非常简单，它在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。</li>
<li>当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，会在 <code>tcp_orphan_retries</code> 参数的控制下重发 FIN 报文</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>如果连接双方同时关闭连接，会怎么样？</strong></p>
<ul>
<li>两方发送 FIN 报文时，都认为自己是主动方，所以都进入了 FIN_WAIT1 状态</li>
<li>双方在等待 ACK 报文的过程中，都等来了 FIN 报文。这是一种新情况，所以连接会进入一种叫做 CLOSING 的新状态，它替代了 FIN_WAIT2 状态。</li>
<li>双方内核回复 ACK 确认对方发送通道的关闭后，进入 TIME_WAIT 状态，等待 2MSL 的时间后，连接自动关闭。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401153825397.png" style="zoom:33%;" />
</blockquote>
<hr>
<h3 id="TCP-数据传输的性能提升"><a href="#TCP-数据传输的性能提升" class="headerlink" title="TCP 数据传输的性能提升"></a><strong>TCP 数据传输的性能提升</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401154704168.png"></p>
<ul>
<li><strong>扩大滑动窗口大小</strong>：通过设置 <code>tcp_window_scaling</code> 提升滑动窗口的上限（需要考虑带宽时延积进行设置）</li>
<li><strong>调整发送缓冲区</strong>：通过 tcp_wmem 参数配置缓冲区大小。发送缓冲区是自行调节的，当发送方发送的数据被确认后，并且没有新的数据要发送，就会把发送缓冲区的内存释放掉。</li>
<li><strong>调整接受缓冲区</strong>：通过设置tcp_rmem 参数配置接收缓冲区大小。需要配置 tcp_moderate_rcvbuf 为 1 来开启自动调节功能。</li>
<li><strong>调节 TCP 内存范围</strong>：通过 tcp_mem 配置不自动调节范围、自动调节范围、不分配新内存范围。</li>
<li><strong>根据实际场景</strong><ul>
<li>在高并发服务器中，为了兼顾网速与大量的并发连接，我们应当保证缓冲区的动态调整的最大值达到带宽时延积，而最小值保持默认的 4K 不变即可。而对于内存紧张的服务而言，调低默认值是提高并发的有效手段。</li>
<li>如果是网络 IO 型服务器，调大 tcp_mem 的上限可以让 TCP 连接使用更多的系统内存，这有利于提升并发能力。千万不要在 socket 上直接设置 SO_SNDBUF 或者 SO_RCVBUF，这样会关闭缓冲区的动态调整功能。</li>
</ul>
</li>
</ul>
<h2 id="3-4-SYN-报文什么时候情况下会被丢弃？"><a href="#3-4-SYN-报文什么时候情况下会被丢弃？" class="headerlink" title="3.4 SYN 报文什么时候情况下会被丢弃？"></a>3.4 SYN 报文什么时候情况下会被丢弃？</h2><p>两种场景：</p>
<ul>
<li><strong>开启 tcp_tw_recycle 参数，并且在 NAT 环境下，造成 SYN 报文被丢弃</strong><ul>
<li>Linux提供了两个参数来快速回收处于 TIME_WAIT 状态的连接，一个是net.ipv4.tcp_tw_reuse，一个是net.ipv4.tcp_tw_recycle。都需要打开时间戳才能生效。</li>
<li>如果同时开启了recycle 和 timestamps 选项，则会开启一种称之为「 per-host 的 PAWS 机制」<ul>
<li>PAWS 机制是防止 TCP 包中的序列号发生绕回。PAWS 要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</li>
<li>per-host 是对「对端 IP 做 PAWS 检查」，而非对「IP + 端口」四元组做 PAWS 检查</li>
</ul>
</li>
<li>当客户端是在NAT网关中，其对外IP是相同的。当使用recycle时，如果A客户端已经连接，然后服务器主动关闭并且快速回收 TIME-WAIT 状态的连接后，此时B客户端也建立连接，如果客户端 B 的 timestamp 比 客户端 A 的 timestamp 小，那么由于服务端的 per-host 的 PAWS 机制的作用，服务端就会丢弃客户端主机 B 发来的 SYN 包。</li>
</ul>
</li>
<li><strong>TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃</strong><ul>
<li>当TCP 半连接队列满了，后面来的 syn 包都会被丢弃。但如果开启了syncookies 功能，即使半连接队列满了，也不会丢弃syn 包。</li>
<li>当TCP全连接队列满了，后续的连接就会被丢弃，这样就会出现服务端请求数量上不去的现象（有点不对题，全连接满影响的是第三次ACK报文，于SYN报文丢弃无关）</li>
</ul>
</li>
</ul>
<h2 id="3-5-已建立连接的TCP，收到SYN会发生什么？"><a href="#3-5-已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="3.5 已建立连接的TCP，收到SYN会发生什么？"></a>3.5 已建立连接的TCP，收到SYN会发生什么？</h2><blockquote>
<p>一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，一直处于 Established 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理？</p>
</blockquote>
<p>TCP是由四元组确定，因此需要看客户端的源端口是否发生变化：</p>
<ul>
<li><strong>客户端的 SYN 报文里的端口号与历史连接不相同</strong></li>
<li>此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。</li>
<li>而旧连接中，如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</li>
<li><strong>客户端的 SYN 报文里的端口号与历史连接相同</strong><ul>
<li>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</li>
<li>客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="如何关闭一个-TCP-连接？"><a href="#如何关闭一个-TCP-连接？" class="headerlink" title="如何关闭一个 TCP 连接？"></a>如何关闭一个 TCP 连接？</h3><p>最简单办法是杀掉进程，但如果服务端杀掉进程会导致其他连接都会被关闭，无法继续提供访问服务。</p>
<p><strong>解决办法</strong>：伪造一个四元组相同的 RST 报文，但必须拿到连接的序列号否则RST报文会被拒绝。</p>
<p><strong>如何拿到序列号？</strong></p>
<ul>
<li>处于 Established 状态的服务端，收到四元组相同的 SYN 报文后，会回复一个 Challenge ACK，这个 ACK 报文里的「确认号」，正好是服务端下一次想要接收的序列号。</li>
</ul>
<p><strong>killcx原理</strong>：主动像服务端发送 SYN 包获取 SEQ&#x2F;ACK 号，然后利用 SEQ&#x2F;ACK 号伪造两个 RST 报文分别发给客户端和服务端，这样双方的 TCP 连接都会被释放，这种方式活跃和非活跃的 TCP 连接都可以杀掉。</p>
<p><strong>tcpkill原理</strong>：在双方进行 TCP 通信时，拿到对方下一次期望收到的序列号，然后将序列号填充到伪造的 RST 报文，并将其发送给对方，达到关闭 TCP 连接的效果。这种方式无法关闭非活跃的 TCP 连接；</p>
<blockquote>
<p>如何伪造成四元组相同的连接？报文伪造很简单，但是对方会根据报文的IP来发送回文，不是主机IP也收不到</p>
<p>应该需要拦截发送的报文进行处理</p>
</blockquote>
<h2 id="3-6-四次挥手中收到乱序的-FIN-包会如何处理？"><a href="#3-6-四次挥手中收到乱序的-FIN-包会如何处理？" class="headerlink" title="3.6 四次挥手中收到乱序的 FIN 包会如何处理？"></a>3.6 四次挥手中收到乱序的 FIN 包会如何处理？</h2><blockquote>
<p>如果服务端在二三次回收之间发了数据，但因为网络延迟而导致第三次握手的FIN比数据包先到，会怎么处理？</p>
</blockquote>
<p><strong>答案</strong></p>
<ul>
<li>在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。</li>
<li>等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。</li>
</ul>
<h2 id="3-7-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？"><a href="#3-7-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？" class="headerlink" title="3.7 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？"></a>3.7 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</h2><ul>
<li><strong>收到合法 SYN</strong><ul>
<li>如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程。</li>
</ul>
</li>
<li><strong>收到非法的 SYN</strong><ul>
<li>如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，就会再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端。</li>
</ul>
</li>
</ul>
<p><strong>在 TIME_WAIT 状态，收到 RST 会断开连接吗？</strong></p>
<ul>
<li>如果 <code>net.ipv4.tcp_rfc1337</code> 参数为 0，则提前结束 TIME_WAIT 状态，释放连接。</li>
<li>如果 <code>net.ipv4.tcp_rfc1337</code> 参数为 1，则会丢掉该 RST 报文。</li>
</ul>
<blockquote>
<ul>
<li><strong>合法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。</li>
<li><strong>非法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。</li>
</ul>
</blockquote>
<h2 id="3-8-12-TCP-连接，一端断电和进程崩溃有什么区别？"><a href="#3-8-12-TCP-连接，一端断电和进程崩溃有什么区别？" class="headerlink" title="3.8 12 TCP 连接，一端断电和进程崩溃有什么区别？"></a>3.8 12 TCP 连接，一端断电和进程崩溃有什么区别？</h2><p>当TCP没有开启keepalive，也没有数据交换时：</p>
<ul>
<li><strong>主机崩溃</strong><ul>
<li>客户端主机崩溃了（断电也属于崩溃一种），服务端是无法感知到的，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。</li>
</ul>
</li>
<li><strong>进程崩溃</strong><ul>
<li>TCP 的连接信息是由内核维护的，内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与</li>
</ul>
</li>
</ul>
<p>当TCP没有开启keepalive，却有数据交换时：</p>
<ul>
<li><strong>客户端主机宕机，又迅速重启</strong><ul>
<li>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发超时重传机制。</li>
<li>服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：<ul>
<li>如果客户端主机上没有进程绑定该 TCP 报文的目标端口号，那么客户端内核就会回复 RST 报文，重置该 TCP 连接；</li>
<li>如果客户端主机上有进程绑定该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会回复 RST 报文，重置该 TCP 连接。</li>
<li>因此，只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接</li>
</ul>
</li>
</ul>
</li>
<li><strong>客户端主机宕机，一直没有重启</strong><ul>
<li>服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，于是服务端的 TCP 连接就会断开。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>TCP 的数据报文具体重传几次呢？</strong></p>
<p>Linux中tcp_retries2 默认为15，但还会根据tcp_retries2 算出一个timeout，如果重传间隔超过这个 timeout，则认为超过了阈值，就会停止重传，然后就会断开 TCP 连接。</p>
</blockquote>
<h2 id="3-9-拔掉网线后，-原本的-TCP-连接还存在吗？"><a href="#3-9-拔掉网线后，-原本的-TCP-连接还存在吗？" class="headerlink" title="3.9 拔掉网线后， 原本的 TCP 连接还存在吗？"></a>3.9 拔掉网线后， 原本的 TCP 连接还存在吗？</h2><p>客户端拔掉网线后，并不会直接影响 TCP 连接状态。拔掉网线后，TCP 连接是否还会存在，关键要看有没有进行数据传输：</p>
<ul>
<li><p><strong>有数据传输的情况：</strong></p>
<ul>
<li><p>如果服务端发送了数据报文，在服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在。</p>
</li>
<li><p>如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。</p>
</li>
</ul>
</li>
<li><p><strong>没有数据传输的情况：</strong></p>
<ul>
<li><p>如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。</p>
</li>
<li><p>如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-10-tcp-tw-reuse-为什么默认是关闭的？"><a href="#3-10-tcp-tw-reuse-为什么默认是关闭的？" class="headerlink" title="3.10 tcp_tw_reuse 为什么默认是关闭的？"></a>3.10 tcp_tw_reuse 为什么默认是关闭的？</h2><blockquote>
<p>这题在变相问「<strong>如果 TIME_WAIT 状态持续时间过短或者没有，会有什么问题？</strong>」</p>
</blockquote>
<p>开启 tcp_tw_reuse 会有 2 个问题：</p>
<ol>
<li>虽然 tcp_tw_reuse 的同时，也需要开启 tcp_timestamps，但 <strong>RST 报文的时间戳即使过期了，只要 RST 报文的序列号在对方的接收窗口内，也是能被接受的</strong>。<ul>
<li>这样如果有历史RST报文存在可能会导致新连接被断开，如果设置了timewait状态，历史rst报文就会消失。</li>
</ul>
</li>
<li>如果第四次挥手的 ACK 报文丢失了，服务端会触发超时重传，重传第三次挥手报文，而重用后的连接处于 syn_sent 状态，收到服务端重传第三次挥手报文，则会回 RST 给服务端，导致服务端不能被正常关闭。</li>
</ol>
<blockquote>
<p><strong>如果 TIME_WAIT 状态被快速复用后，刚好第四次挥手的 ACK 报文丢失了，那客户端复用 TIME_WAIT 状态后发送的 SYN 报文被处于 last_ack 状态的服务端收到了会发生什么呢？</strong></p>
<ul>
<li>处于 last_ack 状态的服务端收到了 SYN 报文后，会回复确认号与服务端上一次发送 ACK 报文一样的 ACK 报文，这个 ACK 报文称为 Challenge ACK ，并不是确认收到 SYN 报文。</li>
<li>处于 syn_sent 状态的客户端收到服务端的 Challenge ACK后，发现不是自己期望收到的确认号，于是就会回复 RST 报文，服务端收到后，就会断开连接。</li>
</ul>
</blockquote>
<h2 id="3-11-HTTPS-中-TLS-和-TCP-能同时握手吗？"><a href="#3-11-HTTPS-中-TLS-和-TCP-能同时握手吗？" class="headerlink" title="3.11 HTTPS 中 TLS 和 TCP 能同时握手吗？"></a>3.11 HTTPS 中 TLS 和 TCP 能同时握手吗？</h2><p>一般情况下，不管 TLS 握手次数如何，都得先经过 TCP 三次握手后才能进行。</p>
<p>HTTPS 中的 TLS 握手过程同时进行三次握手需要特定条件：</p>
<ul>
<li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong><ul>
<li>开启了TCP FAST OPEN后，当第二次建立连接时可以绕过三次握手直接发送数据，携带Cookies即可</li>
<li>TLS1.3也存在会话恢复机制，在第一次发送数据时携带上TLS握手数据即可。</li>
</ul>
</li>
<li><strong>客户端和服务端已经完成过一次通信。</strong></li>
</ul>
<blockquote>
<p><strong>TCP 连接的第三次握手是可以携带数据的，如果客户端在第三次握手发送了 TLSv1.3 第一次握手数据，是不是就表示「<em>HTTPS 中的 TLS 握手过程可以同时进行三次握手</em>」？</strong></p>
<ul>
<li>TLS握手是在应用层，服务端只有在收到客户端的 TCP 的第三次握手后，才能和客户端进行后续 TLSv1.3 握手。</li>
</ul>
</blockquote>
<h2 id="3-12-TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？"><a href="#3-12-TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？" class="headerlink" title="3.12 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？"></a>3.12 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</h2><p>这两个完全是两样不同东西，实现的层面也不同：</p>
<ul>
<li><p><strong>HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接；</strong></p>
<ul>
<li><p>HTTP 的 Keep-Alive 实现了使用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销，这个方法称为 HTTP 长连接。</p>
</li>
<li><p>其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态</p>
<blockquote>
<p>如果客户端完成一个 HTTP 请求后，就不再发起新的请求，会导致资源浪费。因此一般会设置一个定时器，在一定时间没有请求则释放连接。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制；</strong></p>
<ul>
<li>TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活</li>
<li>keepalive的默认时间为2小时，由于过于长久，因此可以设定一个心跳机制来判断是否存活</li>
</ul>
</li>
</ul>
<h2 id="3-13-TCP-协议有什么缺陷？"><a href="#3-13-TCP-协议有什么缺陷？" class="headerlink" title="3.13 TCP 协议有什么缺陷？"></a>3.13 TCP 协议有什么缺陷？</h2><p>TCP 协议缺陷：</p>
<ul>
<li><strong>升级 TCP 的工作很困难</strong>：TCP 协议是在内核中实现的，应用程序只能使用不能修改，如果要想升级 TCP 协议，那么只能升级内核，而升级内核工作十分繁琐。</li>
<li><strong>TCP 建立连接的延迟</strong>：TCP Fast Open能解决延迟问题，但需要客户端和服务端都支持，而现在却并未普及。<ul>
<li>对 HTTPS 来说，TLS 是在应用层实现的握手，而 TCP 是在内核实现的握手，这两个握手过程是无法结合在一起的，总是得先完成 TCP 握手，才能进行 TLS 握手。</li>
<li>TCP 是在内核实现的，所以 TLS 是无法对 TCP 头部加密的，这意味着 TCP 的序列号都是明文传输，所以就存安全的问题。</li>
</ul>
</li>
<li><strong>TCP 存在队头阻塞问题</strong>：TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据</li>
<li><strong>网络迁移需要重新建立 TCP 连接</strong>：TCP是通过四元组确定一条连接，当设备从网络切换时需要重新建立TCP连接。</li>
</ul>
<h2 id="3-14-如何基于-UDP-协议实现可靠传输？"><a href="#3-14-如何基于-UDP-协议实现可靠传输？" class="headerlink" title="3.14 如何基于 UDP 协议实现可靠传输？"></a>3.14 如何基于 UDP 协议实现可靠传输？</h2><h3 id="QUIC-是如何实现可靠传输的？"><a href="#QUIC-是如何实现可靠传输的？" class="headerlink" title="QUIC 是如何实现可靠传输的？"></a><strong>QUIC 是如何实现可靠传输的？</strong></h3><p>如HTTP3为例，在 UDP 报文头部与 HTTP 消息之间，共有 3 层头部：<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403155224700.png" style="zoom:67%;" /></p>
<ul>
<li><p><strong>Packet Header</strong></p>
<ul>
<li><p>可分为两种头部：</p>
<ul>
<li>Long Packet Header 用于首次建立连接。包含源连接ID和目标连接ID。</li>
<li>Short Packet Header 用于日常传输数据。包含目标连接ID、编号和数据（没有源连接ID）<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403155523216.png" style="zoom: 33%;" /></li>
</ul>
</li>
<li><p>QUIC 也是需要三次握手来建立连接的，主要目的是为了协商连接 ID。协商出连接 ID 后，后续传输时，双方只需要固定住连接 ID，从而实现连接迁移功能。</p>
</li>
<li><p><code>Packet Number</code> 是每个报文独一无二的编号，它是<strong>严格递增</strong>的，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。原因如下：</p>
<ul>
<li>如果使用原来的编号，发送方无法知道确认号是对第一次的确认还是重传的确认，使得RTT采样不准确</li>
<li>更便于支持乱序确认，不会因重传而阻塞在原地</li>
</ul>
<blockquote>
<p>编号不一样，那报文？岂不是乱序</p>
<p>QUIC分离了编号的确认功能和数据有序功能，在frame层还有一个序号用于数据顺序</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>QUIC Frame Header</strong></p>
<ul>
<li><p>一个 Packet 报文中可以存放多个 QUIC Frame，每一个 Frame 都有明确的类型，针对类型的不同，功能也不同，自然格式也不同。例如stream类型的frame格式如下：</p>
<ul>
<li>Stream ID ：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别，类似于 HTTP2 的 Stream ID；</li>
<li>Offset ：类似于 TCP 协议中的 Seq 序号，<strong>保证数据的顺序性和可靠性</strong>；</li>
<li>Length ：指明了 Frame 数据的长度。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403160152234.png" style="zoom:33%;" />
</li>
<li><p><strong>通过 Stream ID + Offset 字段信息实现数据的有序性</strong>，通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。</p>
</li>
</ul>
<p>QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装</p>
</li>
</ul>
<hr>
<h3 id="QUIC-是如何解决-TCP-队头阻塞问题的？"><a href="#QUIC-是如何解决-TCP-队头阻塞问题的？" class="headerlink" title="QUIC 是如何解决 TCP 队头阻塞问题的？"></a>QUIC 是如何解决 TCP 队头阻塞问题的？</h3><blockquote>
<p>HTTP&#x2F;2 多个 Stream 请求都是在一条 TCP 连接上传输，这意味着多个 Stream 共用同一个 TCP 滑动窗口，那么当发生数据丢失，滑动窗口是无法往前移动的，此时就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。</p>
</blockquote>
<p><strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。</p>
<hr>
<h3 id="QUIC-是如何做流量控制的？"><a href="#QUIC-是如何做流量控制的？" class="headerlink" title="QUIC 是如何做流量控制的？"></a>QUIC 是如何做流量控制的？</h3><p>QUIC 实现流量控制的方式：</p>
<ul>
<li>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。</li>
<li>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。</li>
</ul>
<p>QUIC 实现了两种级别的流量控制：</p>
<ul>
<li><p><strong>Stream 级别的流量控制</strong>：</p>
<ul>
<li><p>Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</p>
</li>
<li><p>整个滑动窗口可以分为最大接受窗口和接收窗口：</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403161209035.png" style="zoom:50%;" />
</li>
<li><p>接收窗口的左边界取决于接收到的最大偏移字节数，此时的接收窗口 &#x3D; 最大窗口数 - 接收到的最大偏移数。</p>
</li>
<li><p>当图中的绿色部分数据超过最大接收窗口的一半后，最大接收窗口向右移动，接收窗口的右边界也向右扩展，同时给对端发送「窗口更新帧」，当发送方收到接收方的窗口更新帧后，发送窗口的右边界也会往右扩展，以此达到窗口滑动的效果。</p>
<blockquote>
<p>QUIC 的流量控制和 TCP 区别：</p>
<ul>
<li>TCP 的接收窗口只有在前面所有的 Segment 都接收的情况下才会移动左边界，当在前面还有字节未接收但收到后面字节的情况下，窗口也不会移动。</li>
<li>QUIC 的接收窗口的左边界滑动条件取决于接收到的最大偏移字节数。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>Connection 流量控制</strong>：</p>
<ul>
<li>限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。</li>
<li>其接收窗口大小就是各个 Stream 接收窗口大小之和。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>QUIC如何做到乱序确认？</strong></p>
<ul>
<li>发送缓冲区根据尚未接收到确认的数据包来移动缓冲区左边界（即当前已提交的偏移量）</li>
<li>当发送方的缓存区收缩到阈值，接收方发送 MAX_STREAM_DATA Frame（协商缓存大小的特定帧）给发送方，请求增长最大绝对字节偏移量。协商完毕后最大绝对字节偏移量右移，发送方的缓存区变大</li>
<li>当发送方发现有数据包超时，则将超时数据包重新编号为 当前最大值继续发送</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403162210765.png" style="zoom:50%;" />
</blockquote>
<hr>
<h3 id="QUIC-对拥塞控制改进"><a href="#QUIC-对拥塞控制改进" class="headerlink" title="QUIC 对拥塞控制改进"></a>QUIC 对拥塞控制改进</h3><ul>
<li>QUIC 协议当前默认使用了 TCP 的 Cubic 拥塞控制算法（慢开始、拥塞避免、快重传、快恢复策略），同时也支持 CubicBytes、Reno、RenoBytes、BBR、PCC 等拥塞控制算法</li>
<li>QUIC 是处于应用层的，应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。因此可以可以针对不同的应用设置不同的拥塞控制算法。</li>
</ul>
<hr>
<h3 id="QUIC-更快的连接建立"><a href="#QUIC-更快的连接建立" class="headerlink" title="QUIC 更快的连接建立"></a>QUIC 更快的连接建立</h3><p>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p>
<ul>
<li>当HTTP&#x2F;3 使用会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT</li>
</ul>
<hr>
<h3 id="QUIC-是如何迁移连接的？"><a href="#QUIC-是如何迁移连接的？" class="headerlink" title="QUIC 是如何迁移连接的？"></a>QUIC 是如何迁移连接的？</h3><p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>
<h2 id="3-15-TCP-和-UDP-可以使用同一个端口吗？"><a href="#3-15-TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="3.15 TCP 和 UDP 可以使用同一个端口吗？"></a>3.15 TCP 和 UDP 可以使用同一个端口吗？</h2><p><strong>TCP 和 UDP 可以同时绑定相同的端口吗？</strong></p>
<ul>
<li>可以</li>
<li>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，然后模块根据报文「端口号」确定送给哪个应用程序处理</li>
</ul>
<p><strong>多个 TCP 服务进程可以绑定同一个端口吗？</strong></p>
<ul>
<li>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。</li>
<li>有些机器有多个IP，此时如果绑定IP不同，而端口相同也是能绑定成功</li>
<li>注意，0.0.0.0 地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0 地址，相当于把主机上的所有 IP 地址都绑定了</li>
</ul>
<blockquote>
<p>如果想多个进程绑定相同的 IP 地址和端口，也是有办法的，就是对 socket 设置 SO_REUSEPORT 属性（内核 3.9 版本提供的新特性）</p>
</blockquote>
<p><strong>客户端的端口可以重复使用吗？</strong></p>
<ul>
<li>客户端在执行 connect 函数的时候，会在内核里随机选择一个端口，然后向服务端发起 SYN 报文，然后与服务端进行三次握手。</li>
<li>如果重复使用端口是连接不同IP+端口，那么可以重复使用。否则不可重复使用（主机只有一个IP情况下）</li>
</ul>
<p><strong>多个客户端可以 bind 同一个端口吗？</strong></p>
<ul>
<li>如果多个客户端绑定的 IP + PORT 相同，那么在执行 bind() 时候就会出错。否则不会出错。</li>
</ul>
<p><strong>客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？</strong></p>
<ul>
<li>如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了</li>
<li>只要客户端连接的服务器不同，端口资源可以重复使用的</li>
</ul>
<p><strong>客户端端口选择的流程</strong></p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401205103176.png" style="zoom: 25%;" />



<h2 id="3-16-服务端没有-listen，客户端发起连接建立，会发生什么？"><a href="#3-16-服务端没有-listen，客户端发起连接建立，会发生什么？" class="headerlink" title="3.16 服务端没有 listen，客户端发起连接建立，会发生什么？"></a>3.16 服务端没有 listen，客户端发起连接建立，会发生什么？</h2><p>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。</p>
<ul>
<li>没有调用 listen 函数，也就找不到监听该端口的 socket</li>
</ul>
<p><strong>不使用 listen ，可以建立 TCP 连接吗？</strong></p>
<ul>
<li>可以的，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接。</li>
</ul>
<p><strong>那没有listen，为什么还能建立连接？</strong></p>
<ul>
<li>因为<strong>半连接队列和全连接队列都是在执行 listen 方法时内核创建的</strong>，所以客户端没有执行listen也就不会创建两种队列。</li>
<li>但内核还有个全局 hash 表，可以用于存放 sock 连接的信息。<ul>
<li>在 TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash 表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash 中取出信息。于是握手包一来一回，最后成功建立连接。</li>
<li>而两个客户端同时打开原理也类似</li>
</ul>
</li>
</ul>
<h2 id="3-17-用了-TCP-协议，数据一定不会丢吗？"><a href="#3-17-用了-TCP-协议，数据一定不会丢吗？" class="headerlink" title="3.17 用了 TCP 协议，数据一定不会丢吗？"></a>3.17 用了 TCP 协议，数据一定不会丢吗？</h2><p>数据包的发送和接收流程：</p>
<ul>
<li>消息会从应用所在的用户空间拷贝到内核空间的发送缓冲区（send buffer），数据包就这样顺着传输层、网络层，进入到数据链路层，在这里数据包会经过流控（qdisc），再通过RingBuffer发到物理层的网卡。数据就这样顺着网卡发到了纷繁复杂的网络世界里。这里头数据会经过n多个路由器和交换机之间的跳转，最后到达目的机器的网卡处。</li>
<li>目的机器的网卡会通知DMA将数据包信息放到RingBuffer中，再触发一个硬中断给CPU，CPU触发软中断让ksoftirqd去RingBuffer收包，于是一个数据包就这样顺着物理层，数据链路层，网络层，传输层，最后从内核空间拷贝到用户空间里的聊天软件里。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401212856546.png" style="zoom:80%;" />

<p>数据传输中可能发生丢包的情况：</p>
<ul>
<li><p><strong>建立连接时丢包</strong></p>
<ul>
<li>半连接、全连接队列都有长度限制，如果它们满了，那新来的包就会被丢弃。</li>
</ul>
</li>
<li><p><strong>流量控制丢包</strong></p>
<ul>
<li>应用层发送的数据在通过传输层、网络层后，进入网卡前会进行排队处理，其队列名叫qdisc。当发送数据过快，流控队列长度txqueuelen又不够大时，就容易出现丢包现象</li>
</ul>
</li>
<li><p><strong>RingBuffer过小导致丢包</strong></p>
<ul>
<li>在接收数据时，会将数据暂存到RingBuffer接收缓冲区中，然后等着内核触发软中断慢慢收走。如果这个缓冲区过小，而这时候发送的数据又过快，就有可能发生溢出，此时也会产生丢包。</li>
</ul>
</li>
<li><p><strong>网卡性能不足</strong></p>
<ul>
<li>网卡传输速度是有上限的。当网络传输速度过大，达到网卡上限时，就会发生丢包</li>
</ul>
</li>
<li><p><strong>接收缓冲区丢包</strong></p>
<ul>
<li>在TCP编程中，会为每一个socket建立一个发送缓冲区和接收缓冲区。当收到数据后，将数据拷贝到接收缓冲区就完事，发送数据也是拷贝到发送缓冲区就完事。发送缓冲区在这种情况下一般不会丢失数据，但接受缓冲区满了之后，虽然会向发送方报告接收窗口为0，但仍然可能有数据被发送过来，从而导致数据丢失。</li>
</ul>
</li>
<li><p><strong>两端之间的网络丢包</strong></p>
<ul>
<li>数据传输链路上可能会发生丢包</li>
</ul>
</li>
</ul>
<p><strong>TCP只保证数据从A机器的传输层可靠地发到B机器的传输层，即保证发到了对方的传输层TCP接收缓冲区</strong>，但应用还需要将数据从TCP的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。发送端以为自己发的消息已经发给对方了，但接收端却并没有收到这条消息。</p>
<ul>
<li>解决方法：在应用层实现可靠性</li>
</ul>
<blockquote>
<p><strong>两端通信的时候也能对账，为什么还要引入第三端服务器？</strong></p>
<ul>
<li>如果引入服务端，你只需要跟服务器建立<code>1个</code>连接，而不需要跟每个人建立连接。</li>
<li>安全问题，如果是两端通信，随便一个人找你对账一下，你就把聊天记录给同步过去了，这并不合适吧。如果对方别有用心，信息就泄露了。引入第三方服务端就可以很方便的做各种鉴权校验。</li>
<li>软件版本问题。两端的软件版本跨度太大，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件。</li>
</ul>
</blockquote>
<h2 id="3-18-TCP-四次挥手，可以变成三次吗？"><a href="#3-18-TCP-四次挥手，可以变成三次吗？" class="headerlink" title="3.18 TCP 四次挥手，可以变成三次吗？"></a>3.18 TCP 四次挥手，可以变成三次吗？</h2><p><strong>为什么 TCP 挥手需要四次呢？</strong></p>
<ul>
<li>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序</li>
<li>因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，所以服务端的 ACK 和 FIN 一般都会分开发送</li>
</ul>
<p><strong>粗暴关闭 vs 优雅关闭</strong></p>
<ul>
<li>close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。由于不再具有发送和接收数据的能力，所以内核会回 RST 报文给服务端，也就不经过四次挥手。</li>
<li>shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。</li>
</ul>
<p><strong>什么情况会出现三次挥手？</strong></p>
<ul>
<li>当被动关闭方在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></li>
<li>TCP 延迟确认机制是默认开启的</li>
</ul>
<blockquote>
<p>什么是 TCP 延迟确认机制？</p>
<ul>
<li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li>
<li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li>
<li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li>
</ul>
</blockquote>
<h2 id="3-19-TCP-序列号和确认号是如何变化的？"><a href="#3-19-TCP-序列号和确认号是如何变化的？" class="headerlink" title="3.19 TCP 序列号和确认号是如何变化的？"></a>3.19 TCP 序列号和确认号是如何变化的？</h2><p><strong>发送的 TCP 报文序列号和确认号变化：</strong></p>
<ul>
<li>公式一：序列号 &#x3D; 上一次发送的序列号 + 上次len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</li>
<li>公式二：确认号 &#x3D; 上一次收到的报文中的序列号 + 上次len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</li>
</ul>
<blockquote>
<p><strong>为什么第二次和第三次握手报文中的确认号是将对方的序列号 + 1 后作为确认号呢？</strong></p>
<p> TCP 将 SYN 报文视为 1 字节的数据，目的如下：</p>
<ul>
<li>告诉对方，我方已经收到 SYN 报文。</li>
<li>告诉对方，我方下一次「期望」收到的报文的序列号为此确认号，比如客户端与服务端完成三次握手之后，服务端接下来期望收到的是序列号为 client_isn + 1 的 TCP 数据报文。</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403105347105.png" style="zoom: 67%;" />





<h1 id="四、IP篇"><a href="#四、IP篇" class="headerlink" title="四、IP篇"></a>四、IP篇</h1><h2 id="4-1-IP-基础知识"><a href="#4-1-IP-基础知识" class="headerlink" title="4.1 IP 基础知识"></a>4.1 IP 基础知识</h2><p>网络层的主要作用是：<strong>实现主机与主机之间的通信，也叫点对点（end to end）通信</strong></p>
<p><strong>网络层与数据链路层区别</strong></p>
<ul>
<li>MAC 的作用则是实现「直连」的两个设备之间通信， IP 则负责在「没有直连」的两个网络之间进行通信传输</li>
<li>传输过程汇中，源IP地址和目标IP地址在传输过程中是不会变化的，源 MAC 地址和目标 MAC 一直在变化</li>
</ul>
<p><strong>IP 地址的分类</strong></p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403164233104.png" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403164323231.png" style="zoom:50%;" />

<blockquote>
<p>在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。</p>
<ul>
<li>主机号全为 1 指定某个网络下的所有主机，用于广播</li>
<li>主机号全为 0 指定某个网络</li>
</ul>
<p>广播地址可以分为本地广播和直接广播两种。</p>
<ul>
<li><strong>在本网络内广播的叫做本地广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的情况下，广播地址是 192.168.0.255 ，不会到达 192.168.0.0&#x2F;24 以外的其他链路上。</li>
<li><strong>在不同网络之间的广播叫做直接广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的主机向 192.168.1.255&#x2F;24 的目标地址发送 IP 包。使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包。</li>
</ul>
<p>D 类常被用于多播，多播地址用于什么？</p>
<ul>
<li>多播用于将包发送给特定组内的所有主机。</li>
</ul>
</blockquote>
<p><strong>无分类地址 CIDR</strong></p>
<ul>
<li>由于IP分类缺少地址的灵活性，因此出现了CIDR。32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号</li>
<li>表示形式 <code>a.b.c.d/x</code>，其中 <code>/x</code> 表示前 x 位属于网络号</li>
</ul>
<p><strong>子网掩码</strong></p>
<ul>
<li>另一种划分网络号与主机号形式。子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址。</li>
<li>将子网掩码和 IP 地址按位计算 AND，就可得到网络号。</li>
</ul>
<p><strong>公有 IP 地址与私有 IP 地址</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403165306620.png"></p>
<blockquote>
<p>公有 IP 地址由谁管理呢？</p>
<ul>
<li>私有 IP 地址通常是内部的 IT 人员管理，公有 IP 地址是由 <code>ICANN</code> 组织管理。IANA 是 ICANN 的其中一个机构，它负责分配互联网 IP 地址，是按州的方式层层分配。</li>
</ul>
</blockquote>
<p><strong>IP地址如何路由？</strong></p>
<ul>
<li>IP地址的网络地址这一部分是用于进行路由控制。</li>
<li>从路由控制表中找到与目标地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是<strong>最长匹配</strong>。</li>
</ul>
<p><strong>环回地址</strong></p>
<ul>
<li>环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。</li>
<li>计算机使用一个特殊的 IP 地址 127.0.0.1 作为环回地址。与该地址具有相同意义的是一个叫做 localhost 的主机名。使用这个 IP 或主机名时，数据包不会流向网络</li>
</ul>
<p><strong>IPv6 基本认识</strong></p>
<ul>
<li>IPv6 可自动配置，即使没有 DHCP 服务器也可以实现自动分配IP地址</li>
<li>IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大提升了安全性</li>
<li>IPv6 相比 IPv4 的首部改进：<ul>
<li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li>
<li><strong>取消了分片&#x2F;重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li>
<li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 <code>40</code> 字节。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a><strong>DNS</strong></h4><p>域名解析的工作流程：</p>
<ul>
<li>浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 <code>hosts</code>，如果还是没有，就会 DNS 服务器进行查询</li>
<li>客户端首先向本地 DNS 服务器发出一个 DNS 请求，本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 请求域名，则直接返回 IP 地址。如果没有，本地 DNS 会去问根域名服务器</li>
<li>根 DNS 收到来自本地 DNS 的请求后，会返回对应的顶级域名服务器，本地DNS再向顶级域名服务器发起请求</li>
<li>顶级域名服务器会返回一个负责该域名的权威DNS服务器，DNS再向其发起请求</li>
<li>权威DNS服务器返回IP地址，本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403171127948.png" style="zoom:80%;" />

<h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>在发送数据时，需要知道下一跳主机的MAC地址，ARP就是用于通过IP地址查询MAC地址，工作流程如下：</p>
<ul>
<li>主机会通过广播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li>
<li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。</li>
</ul>
<p>操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址，但缓存是有一定期限的。</p>
<blockquote>
<p><strong>RARP</strong>：已知 自己MAC 地址求自己的 IP 地址，工作流程如下：</p>
<ul>
<li>该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li>
<li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。</li>
</ul>
<p><strong>RARP和DHCP区别</strong>：</p>
<ul>
<li>DHCP是BOOTP协议的升级，而BOOTP在某种意义上又是RARP协议的升级</li>
<li>RARP是在数据链路层实现的，而DHCP是在应用层实现的</li>
<li>RARP只能实现简单的从MAC地址到IP地址的查询工作，RARP server上的MAC地址和IP地址是必须事先静态配置好的。但DHCP却可以实现除静态分配外的动态IP地址分配以及IP地址租期管理等等相对复杂的功能。</li>
<li>由于RAPR是链路层协议，因此当RARP客户与RARP服务器不在同一网段,中间有路由器等设备连接时无法获取到IP地址</li>
</ul>
</blockquote>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>DHCP全程都是使用 UDP 广播通信，工作流程如下：</p>
<ul>
<li>客户端发起 DHCP 发现报文的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP 广播通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。</li>
<li>DHCP 服务器收到 DHCP 发现报文时，用 DHCP 提供报文向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。</li>
<li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 DHCP 请求报文（DHCP REQUEST进行响应，回显配置的参数。</li>
<li>最后，服务端用 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数。</li>
<li>一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址</li>
</ul>
<blockquote>
<p><strong>如果 DHCP 服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络都要配一个 DHCP 服务器？</strong></p>
<p>为了解决这一问题，就出现了 DHCP 中继代理。其工作流程如下：</p>
<ul>
<li>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以<strong>单播</strong>的形式发给 DHCP 服务器。</li>
<li>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包广播给 DHCP 客户端 。</li>
</ul>
</blockquote>
<h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>通过路由器的端口映射，把私有 IP 地址转换成公有 IP 地址。</p>
<p>缺点：</p>
<ul>
<li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li>
<li>转换表的生成与转换操作都会产生性能开销。</li>
<li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li>
</ul>
<h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p>
<p>ICMP 大致可以分为两大类：</p>
<ul>
<li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li>
<li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403201453060.png"></p>
<h4 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h4><p><strong>IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong></p>
<ul>
<li>IGMP 报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过 IGMP 加入到组播组，主机申请加入到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了。</li>
<li>IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为 1，因为 IGMP 是工作在主机与连接的路由器之间。</li>
</ul>
<p>IGMP常规查询与响应工作机制：</p>
<ol>
<li>路由器会周期性发送目的地址为 <code>224.0.0.1</code>（表示同一网段内所有主机和路由器） <strong>IGMP 常规查询报文</strong>。</li>
<li>主机1 和 主机 3 收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是 0~10 秒，计时器超时后主机就会发送 <strong>IGMP 成员关系报告报文</strong>（源 IP 地址为自己主机的 IP 地址，目的 IP 地址为组播地址）。如果在定时器超时之前，收到同一个组内的其他主机发送的成员关系报告报文，则自己不再发送，这样可以减少网络中多余的 IGMP 报文数量。</li>
<li>路由器收到主机的成员关系报文后，就会在 IGMP 路由表中加入该组播组，后续网络中一旦该组播地址的数据到达路由器，它会把数据包转发出去。</li>
</ol>
<p>IGMP离开组播组工作机制：</p>
<ol>
<li>主机 1 要离开组 224.1.1.1，发送 IGMP 离组报文，报文的目的地址是 224.0.0.2（表示发向网段内的所有路由器）</li>
<li>路由器 收到该报文后，以 1 秒为间隔连续发送 IGMP 特定组查询报文（共计发送 2 个），以便确认该网络是否还有 224.1.1.1 组的其他成员。</li>
<li>主机 3 仍然是组 224.1.1.1 的成员，因此它立即响应这个特定组查询。路由器知道该网络中仍然存在该组播组的成员，于是继续向该网络转发 224.1.1.1 的组播数据包。</li>
<li>当主机3也离开，路由器连续发送查询报文，如果没有响应，将不会再向这个网段转发该组播地址的数据包。</li>
</ol>
<h2 id="4-2-ping-的工作原理"><a href="#4-2-ping-的工作原理" class="headerlink" title="4.2 ping 的工作原理"></a>4.2 ping 的工作原理</h2><p>ping 是基于 <code>ICMP</code> 协议工作的，</p>
<ul>
<li>ping 命令执行的时候，源主机首先会构建一个 <strong>ICMP 回送请求消息</strong>数据包，字段类型为8.</li>
<li>然后，由 ICMP 协议将这个数据包连同目标地址一起交给 IP 层，构建一个 IP 数据包。</li>
<li>目的主机收到消息后，会构建一个 <strong>ICMP 回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为 <code>0</code>，<strong>序号</strong>为接收到的请求数据包中的序号，然后再发送出去</li>
<li>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</li>
<li>此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403203128549.png"></p>
<h4 id="traceroute-——-差错报文类型的使用"><a href="#traceroute-——-差错报文类型的使用" class="headerlink" title="traceroute —— 差错报文类型的使用"></a>traceroute —— 差错报文类型的使用</h4><p>traceroute作用：</p>
<ul>
<li>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。<ul>
<li>利用 IP 包的生存期限 从 1 开始按照顺序递增的同时发送 UDP 包，强制接收 ICMP 超时消息的一种方法。traceroute 就可以拿到了所有的途径路由器 IP。</li>
<li>发送方如何知道发出的 UDP 包是否到达了目的主机呢？<ul>
<li>traceroute 在发送 UDP 包时，会填入一个不可能的端口号值作为 UDP 目标端口号。当目的主机收到 UDP 包后，会返回 ICMP 差错报文消息，其类型是「端口不可达」。</li>
</ul>
</li>
</ul>
</li>
<li>为了得到路径MTU大小，故意设置不分片，从而确定路径的 MTU<ul>
<li>发送端主机发送 IP 数据报时，将 IP 包首部的<strong>分片禁止标志位设置为 1</strong>。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。</li>
<li>随后，通过一个 ICMP 的不可达消息将<strong>数据链路上 MTU 的值</strong>一起给发送主机，不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」。</li>
<li>发送主机端每次收到 ICMP 差错报文时就<strong>减少</strong>包的大小，以此来定位一个合适的 <code>MTU</code> 值，以便能到达目标主机。</li>
</ul>
</li>
</ul>
<h2 id="4-3-断网了，还能-ping-通-127-0-0-1-吗？"><a href="#4-3-断网了，还能-ping-通-127-0-0-1-吗？" class="headerlink" title="4.3 断网了，还能 ping 通 127.0.0.1 吗？"></a>4.3 断网了，还能 ping 通 127.0.0.1 吗？</h2><p>答案：可以ping通。</p>
<p><strong>什么是127.0.0.1？</strong></p>
<ul>
<li>127 开头的都属于回环地址，而127.0.0.1是众多回环地址中的一个</li>
<li>在ipv6下环回地址是 ::1</li>
</ul>
<p><strong>TCP发数据和ping的区别</strong></p>
<ul>
<li>TCP 传输中创建的方式是 <code>socket(AF_INET, SOCK_STREAM, 0);</code>，其中 <code>AF_INET</code> 表示将使用 IPV4 里 host:port 的方式去解析待会你输入的网络地址。<code>SOCK_STREAM</code> 是指使用面向字节流的 TCP 协议，工作在传输层。</li>
<li>ping创建 <code>socket</code> 的时候用的是 <code>socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)</code>，<code>SOCK_RAW</code> 是原始套接字 ，工作在网络层</li>
</ul>
<h4 id="为什么断网了还能-ping-通-127-0-0-1"><a href="#为什么断网了还能-ping-通-127-0-0-1" class="headerlink" title="为什么断网了还能 ping 通 127.0.0.1"></a>为什么断网了还能 ping 通 127.0.0.1</h4><ul>
<li>发送数据时，到了网络层，系统会根据目的IP，在路由表中获取对应的路由信息，而这其中就包含选择哪个网卡把消息发出。</li>
<li>当发现目标IP是外网IP时，会从”真网卡”发出。当发现目标IP是回环地址时，就会选择本地网卡。</li>
<li>本地网卡，其实就是个”假网卡”，它不像”真网卡”那样有个ring buffer什么的，”假网卡”会把数据推到一个叫 input_pkt_queue 的 链表 中。这个链表是所有网卡共享的，上面挂着发给本机的各种消息。消息被发送到这个链表后，会再触发一个软中断。</li>
<li>ksoftirqd在收到软中断后就会立马去链表里把消息取出，然后顺着数据链路层、网络层等层层往上传递最后给到应用程序。</li>
</ul>
<h4 id="ping回环地址和ping本机地址有什么区别"><a href="#ping回环地址和ping本机地址有什么区别" class="headerlink" title="ping回环地址和ping本机地址有什么区别"></a>ping回环地址和ping本机地址有什么区别</h4><p>ping 本机IP 跟 ping 回环地址一样，相关的网络数据都是走的本地回环接口。只要走了本地回环接口，那数据都不会发送到网络中，在本机网络协议栈中兜一圈，就发回来了。因此 <strong>ping回环地址和ping本机地址没有区别</strong>。</p>
<h4 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗"></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h4><ul>
<li>127.0.0.1 是回环地址</li>
<li>localhost是一个域名，默认解析为127.0.0.1</li>
<li>0.0.0.0表示本机上的所有IPV4地址。执行 ping 0.0.0.0会失败的，因为它在IPV4中表示的是无效的目标地址。</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">mujiubai</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://mujiubai.github.io/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%94%E8%AE%B0/">https://mujiubai.github.io/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%94%E8%AE%B0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">mujiubai</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                    <span class="chip bg-color">计算机网络</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%94%E8%AE%B0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="小林coding-操作系统-笔记">
                        
                        <span class="card-title">小林coding-操作系统-笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-02-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-category">
                                    计算机基础知识
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/02/15/leetcode/other/leetcode-1619-simple/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="1619. 删除某些元素后的数组均值">
                        
                        <span class="card-title">1619. 删除某些元素后的数组均值</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-02-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/LeetCode/" class="post-category">
                                    LeetCode
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Alg-%E6%8E%92%E5%BA%8F/">
                        <span class="chip bg-color">Alg-排序</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">mujiubai</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">317.1k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/mujiubai" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1057378931@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1057378931" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1057378931" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/star.js"><\/script>');
            }
        </script>
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
