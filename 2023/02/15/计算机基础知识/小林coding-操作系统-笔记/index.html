<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="小林coding-操作系统-笔记, w">
    <meta name="description" content="总结知识点，以便以后快速复习。
参考小林coding操作系统, 地址
一、硬件结构1.1 CPU 是如何执行程序的？1.2 磁盘比内存慢几万倍？


存储器级别划分
寄存器：寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>小林coding-操作系统-笔记 | w</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">w</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">

      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/C/">
          
          <span>C++</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/LeetCode/">
          
          <span>LeetCode</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
          
          <span>计算机基础知识</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/%E9%A1%B9%E7%9B%AE/">
          
          <span>项目</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">w</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-bookmark"></i>
			
			分类
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/categories/C/ " style="margin-left:75px">
				  
		          <span>C++</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/LeetCode/ " style="margin-left:75px">
				  
		          <span>LeetCode</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ " style="margin-left:75px">
				  
		          <span>计算机基础知识</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/%E9%A1%B9%E7%9B%AE/ " style="margin-left:75px">
				  
		          <span>项目</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">小林coding-操作系统-笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">操作系统</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-category">
                                计算机基础知识
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-02-15
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-06-20
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    28.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    98 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>总结知识点，以便以后快速复习。</p>
<p><em>参考小林coding操作系统</em>, <a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/os/">地址</a></p>
<h1 id="一、硬件结构"><a href="#一、硬件结构" class="headerlink" title="一、硬件结构"></a>一、硬件结构</h1><h2 id="1-1-CPU-是如何执行程序的？"><a href="#1-1-CPU-是如何执行程序的？" class="headerlink" title="1.1 CPU 是如何执行程序的？"></a>1.1 CPU 是如何执行程序的？</h2><h2 id="1-2-磁盘比内存慢几万倍？"><a href="#1-2-磁盘比内存慢几万倍？" class="headerlink" title="1.2 磁盘比内存慢几万倍？"></a>1.2 磁盘比内存慢几万倍？</h2><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317105246779.png" style="zoom:67%;" />

<hr>
<h3 id="存储器级别划分"><a href="#存储器级别划分" class="headerlink" title="存储器级别划分"></a><strong>存储器级别划分</strong></h3><ul>
<li><p>寄存器：寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写。寄存器的数量通常在几十到几百之间，每个寄存器可以用来存储一定的字节（byte）的数据</p>
</li>
<li><p>CPU Cache：用的是一种叫 SRAM（静态随机存储器） 的芯片，存储密度不高。只要有电，数据就可以保持存在。</p>
<ol>
<li>L1-Cache：每个 CPU 核心都有一块属于自己的 L1 高速缓存，访问速度通常只需要 <code>2~4</code> 个时钟周期，而大小在几十 KB 到几百 KB 不等。通常分成<strong>指令缓存</strong>和<strong>数据缓存</strong>（分开存放）。</li>
<li>L2-Cache：每个 CPU 核心都有，通常大小在几百 KB 到几 MB 不等，速度在 <code>10~20</code> 个时钟周期。</li>
<li>L3-Cahce：多个 CPU 核心共用，通常大小在几 MB 到几十 MB 不等，速度在 <code>20~60</code>个时钟周期</li>
</ol>
</li>
<li><p>内存：使用的是DRAM （动态随机存取存储器） 的芯片，内存速度大概在 <code>200~300</code> 个 时钟周期之间</p>
<blockquote>
<p>相比 SRAM，DRAM 的密度更高，功耗更低。</p>
<p>因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因</p>
</blockquote>
</li>
<li><p>SSD&#x2F;HDD 硬盘</p>
<ul>
<li>SSD结构和内存类似，断电后数据还是存在的，内存的读写速度比 SSD 大概快 <code>10~1000</code> 倍</li>
<li>机械硬盘（*, HDD*）是通过物理读写的方式来访问数据的，它的速度比内存慢 <code>10W</code> 倍左右。</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317105537831.png" style="zoom:50%;" />

<blockquote>
<p>注意：</p>
<ul>
<li><p>CPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。</p>
</li>
<li><p>当 CPU 需要访问内存中某个数据的时候，会不断层级访问判断是否有该数据，如果没有则访问下一层级存储器</p>
</li>
<li><p>分级的目的是要构造<strong>缓存</strong>体系</p>
</li>
</ul>
</blockquote>
<h2 id="1-3-如何写出让-CPU-跑得更快的代码？"><a href="#1-3-如何写出让-CPU-跑得更快的代码？" class="headerlink" title="1.3 如何写出让 CPU 跑得更快的代码？"></a>1.3 如何写出让 CPU 跑得更快的代码？</h2><h3 id="CPU-Cache-的数据结构和读取过程"><a href="#CPU-Cache-的数据结构和读取过程" class="headerlink" title="CPU Cache 的数据结构和读取过程"></a><strong>CPU Cache 的数据结构和读取过程</strong></h3><ol>
<li>根据内存地址中索引信息，计算在 CPU Cache 中的索引，也就是找出对应的 CPU Cache Line 的地址；</li>
<li>找到对应 CPU Cache Line 后，判断 CPU Cache Line 中的有效位，确认 CPU Cache Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；</li>
<li>对比内存地址中组标记和 CPU Cache Line 中的组标记，确认 CPU Cache Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；</li>
<li>根据内存地址中偏移量信息，从 CPU Cache Line 的数据块中，读取对应的字。</li>
</ol>
<blockquote>
<p>上述过程是Cache直接映射计算方法，其使用的取模运算计算映射地址。</p>
<p>组标记是为了区分不同地址映射到相同位置，其实就是拿地址的前部分来判断。</p>
</blockquote>
<p><strong>注意，Cache每次读内存都是一块一块的读，也就是读取目标地址附近一个cache line大小的数据，可以利用此特性加快代码运行</strong></p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317114717676.png" style="zoom:80%;" />

<hr>
<h3 id="如何写出让-CPU-跑得更快的代码？"><a href="#如何写出让-CPU-跑得更快的代码？" class="headerlink" title="如何写出让 CPU 跑得更快的代码？"></a><strong>如何写出让 CPU 跑得更快的代码？</strong></h3><ol>
<li><strong>提升数据缓存的命中率</strong><ul>
<li>按照内存布局顺序访问，将可以有效的利用 CPU Cache 带来的好处，这样我们代码的性能就会得到很大的提升</li>
<li>例如遍历二维数组的情况时，先遍历水平比先遍历竖直方向更快</li>
</ul>
</li>
<li><strong>提升指令缓存的命中率</strong><ul>
<li>对于 if 条件语句，会使用 CPU 的分支预测器预测跳转哪部分。如果分支预测可以预测到接下来要执行 的指令，就可以提前把这些指令放在指令缓存中，这样 CPU 可以直接从 Cache 读取到指令，于是执行速度就会很快。</li>
<li>例如先排序再用if判断比直接if判断分支预测更准确</li>
</ul>
</li>
<li><strong>提升多核 CPU 的缓存命中率</strong><ul>
<li>如果一个线程在不同核心来回切换，各个核心的缓存命中率就会受到影响，相反如果线程都在同一个核心上执行，那么其数据的 L1 和 L2 Cache 的缓存命中率可以得到有效提高，可以减少访问 内存的频率。</li>
<li>在 Linux 上提供了 <code>sched_setaffinity</code> 方法，来实现将线程绑定到某个 CPU 核心这一功能</li>
</ul>
</li>
</ol>
<h2 id="1-4-CPU-缓存一致性"><a href="#1-4-CPU-缓存一致性" class="headerlink" title="1.4 CPU 缓存一致性"></a>1.4 CPU 缓存一致性</h2><h3 id="CPU-Cache-的数据写入"><a href="#CPU-Cache-的数据写入" class="headerlink" title="CPU Cache 的数据写入"></a>CPU Cache 的数据写入</h3><p><strong>写直达</strong></p>
<p>保持内存与 Cache 一致性最简单的方式是，<strong>把数据同时写入内存和 Cache 中</strong>，这种方法称为<strong>写直达</strong></p>
<ul>
<li>写入前会先判断数据是否已经在 CPU Cache 里面了：<ul>
<li>如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面；</li>
<li>如果数据没有在 Cache 里面，就直接把数据更新到内存里面。</li>
</ul>
</li>
<li>缺点：每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响</li>
</ul>
<p><strong>写回</strong></p>
<p><strong>当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中</strong>，减少了数据写回内存的频率。</p>
<ul>
<li>如果当发生写操作时，数据已经在 CPU Cache 里的话，则把数据更新到 CPU Cache 里，同时标记 CPU Cache 里的这个 Cache Block 为脏的，代表这这个 Cache Block 的数据和内存是不一致的，这种情况是不用把数据写到内存里的；</li>
<li>如果当发生写操作时，数据所对应的 Cache Block 里存放的是「别的内存地址的数据」的话，就要检查这个 Cache Block 里的数据有没有被标记为脏的：<ul>
<li>如果是脏的话，我们就要把这个 Cache Block 里的数据<strong>写回到内存</strong>，然后再把当前要写入的数据从内存读入到 Cache Block 里，然后再把当前要写入的数据写入到 Cache Block，最后也把它标记为脏的；</li>
<li>如果不是脏的话，把当前要写入的数据先从内存读入到 Cache Block 里，接着将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么缓存没命中时需要先从内存读取数据再写缓存？</strong></p>
<p>应该是为了配合下面的MESI协议保持多核之间的缓存一致性，MESI协议中一个cache从失效到独占状态都需要从内存读数据。</p>
<p>如果其他核心中存在已修改的数据，则需要写入到内存，然后当前核心从内存中读取。而如果其他核心无数据或数据为共享、独占状态，这样做的原因可能是为了统一操作。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317162141317.png" style="zoom:80%;" />

<hr>
<h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>由于 L1&#x2F;L2 Cache 是多个核心各自独有的，那么会带来多核心的<strong>缓存一致性</strong></p>
<p>通常使用以下两点来同步两个不同核心里面的缓存数据：</p>
<ul>
<li>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播</strong><ul>
<li>当某个核心在 Cache 更新了数据，就需要同步到其他核心的 Cache 里</li>
</ul>
</li>
<li>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串行化</strong><ul>
<li>串行化是指其他核心要看到相同的数据变化顺序，否则即使有写传播也会造成混乱</li>
</ul>
</li>
</ul>
<p><strong>MESI 协议</strong></p>
<p>MESI 协议是写传播和事务串行化的实现，其通过总线来传播消息，每个核心都会监听总线上的广播事件。</p>
<p>可分为四种状态：</p>
<ul>
<li><em>Modified</em>，已修改：代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里</li>
<li><em>Exclusive</em>，独占：代表 Cache Block 里的数据和内存里面的数据是一致性的，但只存储在一个 CPU 核心的 Cache 里。<ul>
<li>如果要向独占的 Cache 写数据，就可以直接自由地写入，而不需要通知其他 CPU 核心</li>
<li>当核心读取了数据时，其会向其他核心发送通知，如果在其他核心是独占状态，则会将其改为共享状态。</li>
</ul>
</li>
<li><em>Shared</em>，共享：代表 Cache Block 里的数据和内存里面的数据是一致性的，但相同的数据在多个 CPU 核心的 Cache 里都有。<ul>
<li>要更新 Cache 里面的共享状态数据时，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。</li>
</ul>
</li>
<li><em>Invalidated</em>，已失效：表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据</li>
</ul>
<p>注意！这几个状态都是标记的一整个cache line。</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317165044798.png" style="zoom:80%;" />



<h2 id="1-5-CPU-是如何执行任务的？"><a href="#1-5-CPU-是如何执行任务的？" class="headerlink" title="1.5 CPU 是如何执行任务的？"></a>1.5 CPU 是如何执行任务的？</h2><h3 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h3><p>因为多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为<strong>伪共享</strong></p>
<ul>
<li>例如AB两个变量属于同一个cache line，A只会被1核心读写，B只会被2核心读写。如当1核心读取A时会将整个cache line读取，而其中又包括变量B，那么当改变变量A时，2核心的cache line也会通过MESI协议进行状态改变。同理2核心写B也会影响A。其实际并没有共享任何变量，从而造成性能影响。</li>
</ul>
<p><strong>避免伪共享的方法</strong></p>
<ul>
<li>在 Linux 内核中存在 <code>__cacheline_aligned_in_smp</code> 宏定义，是用于解决伪共享的问题。<ul>
<li>例如定义结构体时将其中的变量附上<code>__cacheline_aligned_in_smp</code>，就会使得变量分属于不同cache line，这其实是一种空间换时间的方法。</li>
</ul>
</li>
<li>Java 并发框架 Disruptor 使用「字节填充 + 继承」的方式，来避免伪共享的问题。</li>
</ul>
<hr>
<h3 id="CPU-如何选择线程的？"><a href="#CPU-如何选择线程的？" class="headerlink" title="CPU 如何选择线程的？"></a>CPU 如何选择线程的？</h3><blockquote>
<p>在 Linux 内核中，进程和线程都是用 <code>task_struct</code> 结构体表示的，区别在于线程的 task_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程</p>
</blockquote>
<p>在 Linux 系统中，根据任务的优先级以及响应要求，主要分为两种，其中优先级的数值越小，优先级越高：</p>
<ul>
<li>实时任务，对系统的响应时间要求很高，也就是要尽可能快的执行实时任务，优先级在 <code>0~99</code> 范围内的就算实时任务；</li>
<li>普通任务，响应时间没有很高的要求，优先级在 <code>100~139</code> 范围内都是普通任务级别</li>
</ul>
<p><strong>Linux 系统调度类</strong></p>
<ul>
<li>Deadline 和 Realtime 这两个调度类，都是应用于实时任务<ul>
<li><em>SCHED_DEADLINE</em>：距离当前时间点最近的 deadline 的任务会被优先调度；</li>
<li><em>SCHED_FIFO</em>：对于相同优先级的任务，按先来先服务的原则，但是优先级更高的任务，可以抢占低优先级的任务；</li>
<li><em>SCHED_RR</em>：对于相同优先级的任务，轮流着运行，每个任务都有一定的时间片，当用完时间片的任务会被放到队列尾部，以保证相同优先级任务的公平性，但是高优先级的任务依然可以抢占低优先级的任务；</li>
</ul>
</li>
<li>Fair 调度类是应用于普通任务，都是由 CFS 调度器管理的<ul>
<li><em>SCHED_NORMAL</em>：普通任务使用的调度策略；</li>
<li><em>SCHED_BATCH</em>：后台任务的调度策略，不和终端进行交互，因此在不影响其他需要交互的任务，可以适当降低它的优先级。</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317172758100.png" style="zoom:67%;" />

<p><strong>完全公平调度</strong></p>
<ul>
<li>为每个任务安排一个虚拟运行时间 vruntime，如果一个任务在运行，其运行的越久，该任务的 vruntime 自然就会越大，而没有被运行的任务，vruntime 是不会变化的。<strong>在 CFS 算法调度的时候，会优先选择 vruntime 少的任务</strong></li>
<li>当考虑任务权重时，存在以下公式进行计算vruntime，NICE_0_LOAD 是一个常量<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317173136791.png" style="zoom:80%;" /></li>
</ul>
<p><strong>CPU 运行队列</strong></p>
<p>每个 CPU 都有自己的<strong>运行队列</strong>，用于描述在此 CPU 上所运行的所有进程，其队列包含三个运行队列：</p>
<ul>
<li>Deadline 运行队列 dl_rq</li>
<li>实时任务运行队列 rt_rq </li>
<li>CFS 运行队列 cfs_rq，其中 cfs_rq 是用红黑树来描述的，按 vruntime 大小来排序的，最左侧的叶子节点，就是下次会被调度的任务。</li>
</ul>
<p>调度类是有优先级的，优先级如下：Deadline &gt; Realtime &gt; Fair，会优先调度优先级高的调度类，因此<strong>实时任务总是会比普通任务优先被执行</strong></p>
<p><strong>调整优先级</strong></p>
<p>Linux默认情况下都是普通任务，普通任务的调度类是 Fair，由 CFS 调度器来进行管理。</p>
<p>可以调整任务的 <code>nice</code> 值，来间接影响任务优先级，其范围是 <code>-20～19</code>（nice值可以看成对任务优先级的修正，priority(new) &#x3D; priority(old) + nice）</p>
<h2 id="1-6-什么是软中断？"><a href="#1-6-什么是软中断？" class="headerlink" title="1.6 什么是软中断？"></a>1.6 什么是软中断？</h2><blockquote>
<p>中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。</p>
</blockquote>
<p>Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」。</p>
<ul>
<li>上半部用来快速处理中断，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。<ul>
<li>上半部直接处理硬件请求，也就是<strong>硬中断</strong>，主要是负责耗时短的工作，特点是快速执行</li>
</ul>
</li>
<li>下半部用来延迟处理上半部未完成的工作，一般以「内核线程」的方式运行。<ul>
<li>下半部是由内核触发，也就是<strong>软中断</strong>，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；</li>
<li>软中断不只是包括硬件设备中断处理程序的下半部，一些内核自定义事件也属于软中断，比如内核调度等</li>
<li>每一个 CPU 都对应一个软中断内核线程，名字通常为「ksoftirqd&#x2F;CPU 编号」</li>
</ul>
</li>
</ul>
<h2 id="1-7-为什么-0-1-0-2-不等于-0-3-？"><a href="#1-7-为什么-0-1-0-2-不等于-0-3-？" class="headerlink" title="1.7 为什么 0.1 + 0.2 不等于 0.3 ？"></a>1.7 为什么 0.1 + 0.2 不等于 0.3 ？</h2><h3 id="为什么负数要用补码表示？"><a href="#为什么负数要用补码表示？" class="headerlink" title="为什么负数要用补码表示？"></a>为什么负数要用补码表示？</h3><ul>
<li>正数存储：最高位是作为「符号标志位」，剩余的 31 位则表示二进制数据。正数的符号位是 <code>0</code>，负数的符号位是 <code>1</code>。</li>
<li>负数存储：最高位是作为「符号标志位」，剩余的以「补码」表示的，所谓的补码就是把正数的二进制全部取反再加 1</li>
</ul>
<p>负数之所以用补码的方式来表示，主要是为了统一和正数的加减法，使得不必根据是否为负数来调整操作。</p>
<hr>
<h3 id="十进制小数怎么转成二进制？"><a href="#十进制小数怎么转成二进制？" class="headerlink" title="十进制小数怎么转成二进制？"></a>十进制小数怎么转成二进制？</h3><p>十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317202013256.png" style="zoom:50%;" />

<h3 id="计算机是怎么存小数的？"><a href="#计算机是怎么存小数的？" class="headerlink" title="计算机是怎么存小数的？"></a>计算机是怎么存小数的？</h3><p>计算机是以浮点数的形式存储小数的，包含三个部分：</p>
<ul>
<li>符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li>
<li>指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；</li>
<li>尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li>
</ul>
<p><strong>转换成二进制浮点数</strong></p>
<ul>
<li><p>先将数整体部分和小数部分都转换为二进制</p>
</li>
<li><p>然后把小数点，移动到第一个1后面，计算移动位数，小数点向左移为+，右移为减。然后小数点后的即为尾数。</p>
</li>
<li><p>指数位&#x3D;移动位数+偏移量，float 的话偏移量是 127。</p>
<blockquote>
<p>指数可能是正数，也可能是负数，为了减少不必要的麻烦，在实际存储指数的时候，需要把指数转换成<strong>无符号整数</strong>。</p>
<p>float 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 <code>-126 ~ +127</code>，于是为了把指数转换成无符号整数，就要加个<strong>偏移量</strong>，比如 float 的指数偏移量是 <code>127</code>，这样指数就不会出现负数了。</p>
</blockquote>
</li>
</ul>
<p> <strong>float 的二进制浮点数转换成十进制</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317202908467.png"></p>
<h3 id="0-1-0-2-x3D-x3D-0-3-吗？"><a href="#0-1-0-2-x3D-x3D-0-3-吗？" class="headerlink" title="0.1 + 0.2 &#x3D;&#x3D; 0.3 吗？"></a>0.1 + 0.2 &#x3D;&#x3D; 0.3 吗？</h3><p>0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。</p>
<h1 id="二、操作系统结构"><a href="#二、操作系统结构" class="headerlink" title="二、操作系统结构"></a>二、操作系统结构</h1><h2 id="2-1-Linux-内核-vs-Windows-内核"><a href="#2-1-Linux-内核-vs-Windows-内核" class="headerlink" title="2.1 Linux 内核 vs Windows 内核"></a>2.1 Linux 内核 vs Windows 内核</h2><p><strong>什么是内核？</strong></p>
<p>内核是应用连接硬件设备的桥梁，一般会提供 4 个基本能力：</p>
<ul>
<li>管理进程、线程，决定哪个进程、线程使用 CPU，也就是<strong>进程调度</strong>的能力；</li>
<li>管理内存，决定内存的分配和回收，也就是<strong>内存管理</strong>的能力；</li>
<li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是<strong>硬件通信</strong>能力；</li>
<li><strong>提供系统调用</strong>，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。</li>
</ul>
<p>多数操作系统，把内存分成了两个区域：</p>
<ul>
<li>内核空间，这个内存空间只有内核程序可以访问，即<strong>内核态</strong>执行；</li>
<li>用户空间，这个内存空间专门给应用程序使用，即<strong>用户态</strong>执行；</li>
</ul>
<p><strong>系统调用过程</strong></p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317204720389.png" style="zoom: 67%;" />

<hr>
<h3 id="Linux-的设计"><a href="#Linux-的设计" class="headerlink" title="Linux 的设计"></a>Linux 的设计</h3><p>Linux 内核设计的理念主要有这几个点：</p>
<ul>
<li><em>MultiTask</em>，多任务：可以有多个任务同时执行，这里的「同时」可以是并发或并行</li>
<li><em>SMP</em>，对称多处理：每个 CPU 的地位是相等的，对资源的使用权限也是相同的，多个 CPU 共享同一个内存，每个 CPU 都可以访问完整的内存和硬件资源。</li>
<li><em>ELF</em>，可执行文件链接格式：是 Linux 操作系统中可执行文件的存储格式</li>
<li><em>Monolithic Kernel</em>，宏内核：宏内核的特征是系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。</li>
</ul>
<blockquote>
<p><strong>微内核</strong></p>
<ul>
<li><p>微内核架构的内核只保留最基本的能力，比如进程调度、虚拟机内存、中断等，把一些应用放到了用户空间，比如驱动程序、文件系统等。</p>
</li>
<li><p>这样服务与服务之间是隔离的，单个服务出现故障或者完全攻击，也不会导致整个操作系统挂掉，提高了操作系统的稳定性和可靠性。</p>
</li>
<li><p>缺点：由于驱动程序不在内核中，其会频繁调用底层能力，于是就需要频繁切换到内核态，带来性能损耗</p>
</li>
</ul>
<p><strong>混合内核</strong></p>
<ul>
<li>是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序；</li>
</ul>
</blockquote>
<hr>
<h3 id="Windows-设计"><a href="#Windows-设计" class="headerlink" title="Windows 设计"></a>Windows 设计</h3><p>Window 的内核设计则是采用了混合内核</p>
<p>Windows 的可执行文件格式叫 PE，称为<strong>可移植执行文件</strong>，扩展名通常是<code>.exe</code>、<code>.dll</code>、<code>.sys</code>等</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317205424836.png" style="zoom:50%;" />



<h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><h2 id="3-1-为什么要有虚拟内存？"><a href="#3-1-为什么要有虚拟内存？" class="headerlink" title="3.1 为什么要有虚拟内存？"></a>3.1 为什么要有虚拟内存？</h2><p>如果程序都直接操纵物理地址，那么不仅内存利用率低，且程序的迁移性也差。</p>
<p>操作系统为每个进程分配独立的一套「<strong>虚拟地址</strong>」，并提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</p>
<blockquote>
<p><strong>如何转换地址？</strong></p>
<p>虚拟地址通过 CPU 芯片中的内存管理单元（MMU），来转换变成物理地址</p>
</blockquote>
<hr>
<h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段的形式把这些段分离出来。</p>
<p><strong>分段机制下，虚拟地址和物理地址是如何映射的？</strong></p>
<p>分段机制下的虚拟地址由两部分组成：</p>
<ul>
<li>段选择因子：保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。</li>
<li>段内偏移量：位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li>
</ul>
<p><strong>分段机制不足</strong></p>
<ul>
<li>内存碎片：由于每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以会出现外部<strong>内存碎片</strong>，其<strong>不存在内部碎片</strong>。可以使用<strong>内存交换</strong>解决外部内存碎片（将碎片合并）。</li>
<li>内存交换效率低：内存交换是将内存展示写入硬盘，但硬盘访问速度十分慢。如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</li>
</ul>
<hr>
<h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间叫<strong>页</strong>。在 Linux 下，每一页的大小为 4KB。</p>
<p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，页表是存储在内存里的</p>
<p>当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<p><strong>优缺点</strong></p>
<ul>
<li>采用了分页，页与页之间是紧密排列的，所以不会有外部碎片，但会有内部内存碎片。</li>
<li>当内存不足时，每次从硬盘读取写入的都只有几个页，内存交换的效率就相对比较高。</li>
<li>不再需要一次性都把程序加载到物理内存中，<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去</strong>。</li>
</ul>
<p><strong>分页机制下，虚拟地址和物理地址是如何映射的？</strong></p>
<p>虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。转换过程如下：</p>
<ul>
<li>把虚拟内存地址，切分成页号和偏移量；</li>
<li>根据页号，从页表里面，查询对应的物理页号；</li>
<li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li>
</ul>
<p><strong>多级页表</strong></p>
<p>一级页表会导致占用内存过大，解决办法即多级页表</p>
<ul>
<li>当前页表中存储下一级页表地址</li>
<li>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。从而达到节约内存作用。</li>
</ul>
<blockquote>
<p><strong>为什么不分级的页表就做不到这样节约内存呢？</strong></p>
<p>对于每个虚拟地址，查找页表时需要找到其对应（区间）位置，一级页表直接存储物理地址则就需要将所有地址进行存储，而多级页表存储的是一个页表位置，可以在下一页表中继续查找，而不会直接查找失败。</p>
</blockquote>
<p><strong>TLB</strong></p>
<p>多级页表需要多次地址转换，而程序是有局部性的，利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，因此加入了存储最常访问的页表项的 Cache，这个 Cache 就是 TLB。</p>
<p>CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表</p>
<hr>
<h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p>段页式内存管理实现的方式：</p>
<ul>
<li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</li>
<li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li>
</ul>
<p>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。</p>
<p><strong>地址转换过程</strong></p>
<ul>
<li>第一次访问段表，得到页表起始地址；</li>
<li>第二次访问页表，得到物理页号；</li>
<li>第三次将物理页号与页内位移组合，得到物理地址。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318105243087.png" style="zoom: 80%;" />

<hr>
<h3 id="Linux-内存布局"><a href="#Linux-内存布局" class="headerlink" title="Linux 内存布局"></a>Linux 内存布局</h3><p><strong>Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制</strong>。</p>
<ul>
<li>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。</li>
<li>Linux 把所有段的基地址设为 <code>0</code>，因此包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），段只被用于访问控制和内存保护。</li>
<li>通俗讲，由于段基地址都设为0，那么所有段其实就共用了一个地址空间，而段只是作为内存访问控制保护用。</li>
</ul>
<p>虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分：</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318160056933.png" style="zoom: 67%;" />

<p>虽然每个进程都各自有独立的虚拟内存，但是<strong>每个虚拟内存中的内核地址，其实关联的都是相同的物理内存</strong>。这样，进程切换到内核态后，就可以很方便地访问内核空间内存</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318160158361.png" style="zoom:67%;" />

<p><strong>用户空间分布的情况</strong></p>
<ul>
<li>代码段，包括二进制可执行代码；</li>
<li>数据段，包括已初始化的静态常量和全局变量；</li>
<li>BSS 段，包括未初始化的静态变量和全局变量；</li>
<li>堆段，包括动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长；</li>
<li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>，可以自定义。</li>
</ul>
<p>在这 7 个内存段中，只有<strong>堆和文件映射段的内存是动态分配</strong>的</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318160256561.png" style="zoom:67%;" />

<blockquote>
<p>上图中的内存布局可以看到，代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」。</p>
<p><strong>保留区作用</strong>：许多系统中比较小数值的地址不是一个合法地址，例如C中的NULL。设置保留区是防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞</p>
</blockquote>
<h2 id="3-2-malloc-是如何分配内存的？"><a href="#3-2-malloc-是如何分配内存的？" class="headerlink" title="3.2 malloc 是如何分配内存的？"></a>3.2 malloc 是如何分配内存的？</h2><p>malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存。</p>
<p>malloc 申请内存的时候，会有<strong>两种方式向操作系统申请堆内存</strong>：</p>
<ul>
<li><p>方式一：通过 brk() 系统调用从堆分配内存</p>
<ul>
<li><p>通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间</p>
</li>
<li><p>通过 brk() 方式申请的内存，free 释放内存的时候，并不一定会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用，这样就可以重复使用。</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318173542731.png" style="zoom:67%;" /></li>
</ul>
</li>
<li><p>方式二：通过 mmap() 系统调用在文件映射区域分配内存；</p>
<ul>
<li><p>通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318173508637.png" style="zoom: 67%;" /></li>
</ul>
</li>
</ul>
<p><strong>什么场景下 malloc() 会通过 brk() 分配内存？又是什么场景下通过 mmap() 分配内存？</strong></p>
<blockquote>
<p>malloc() 源码里默认定义了一个阈值：</p>
<ul>
<li>如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；</li>
<li>如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；</li>
</ul>
</blockquote>
<hr>
<h3 id="malloc-分配的是物理内存吗？"><a href="#malloc-分配的是物理内存吗？" class="headerlink" title="malloc() 分配的是物理内存吗？"></a>malloc() 分配的是物理内存吗？</h3><blockquote>
<p><strong>malloc() 分配的是虚拟内存</strong>。</p>
<ul>
<li><p>如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存。</p>
</li>
<li><p>只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。</p>
</li>
</ul>
</blockquote>
<hr>
<h3 id="malloc-1-会分配多大的虚拟内存？"><a href="#malloc-1-会分配多大的虚拟内存？" class="headerlink" title="malloc(1) 会分配多大的虚拟内存？"></a><strong>malloc(1) 会分配多大的虚拟内存？</strong></h3><blockquote>
<p>malloc() 在分配内存的时候，并不是按用户预期申请的字节数来分配内存空间大小，而是<strong>会预分配更大的空间作为内存池</strong>。</p>
</blockquote>
<hr>
<h3 id="free-释放内存，会归还给操作系统吗？"><a href="#free-释放内存，会归还给操作系统吗？" class="headerlink" title="free 释放内存，会归还给操作系统吗？"></a><strong>free 释放内存，会归还给操作系统吗？</strong></h3><blockquote>
<ul>
<li>malloc 通过 <strong>brk()</strong> 方式申请的内存，free 释放内存的时候，<strong>并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用</strong>；</li>
<li>malloc 通过 <strong>mmap()</strong> 方式申请的内存，free 释放内存的时候，<strong>会把内存归还给操作系统，内存得到真正的释放</strong>。</li>
</ul>
</blockquote>
<hr>
<h3 id="为什么不全部使用-mmap-来分配内存？"><a href="#为什么不全部使用-mmap-来分配内存？" class="headerlink" title="为什么不全部使用 mmap 来分配内存？"></a><strong>为什么不全部使用 mmap 来分配内存？</strong></h3><blockquote>
<ol>
<li>因为向操作系统申请内存，是要通过系统调用的，执行系统调用是要进入内核态的，然后在回到用户态，运行态的切换会耗费不少时间。如果都用 mmap 来分配内存，等于每次都要执行系统调用。</li>
<li>因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会<strong>触发缺页中断</strong>。</li>
</ol>
</blockquote>
<p>malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。</p>
<p>等下次在申请内存的时候，就直接从内存池取出对应的内存块就行，不仅减少了系统调用的次数，也减少了缺页中断的次数</p>
<hr>
<h3 id="既然-brk-那么牛逼，为什么不全部使用-brk-来分配？"><a href="#既然-brk-那么牛逼，为什么不全部使用-brk-来分配？" class="headerlink" title="既然 brk 那么牛逼，为什么不全部使用 brk 来分配？"></a><strong>既然 brk 那么牛逼，为什么不全部使用 brk 来分配？</strong></h3><blockquote>
<p>随着系统频繁地 malloc 和 free ，堆内将产生越来越多不可用的碎片</p>
</blockquote>
<hr>
<h3 id="free-函数只传入一个内存地址，为什么能知道要释放多大的内存？"><a href="#free-函数只传入一个内存地址，为什么能知道要释放多大的内存？" class="headerlink" title="free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？"></a><strong>free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？</strong></h3><blockquote>
<p>malloc 返回给用户态的内存起始地址比实际申请的地址会多16字节，这16个字节会存储内存块的头信息。</p>
<p>当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小</p>
</blockquote>
<h2 id="3-3-内存满了，会发生什么？"><a href="#3-3-内存满了，会发生什么？" class="headerlink" title="3.3 内存满了，会发生什么？"></a>3.3 内存满了，会发生什么？</h2><p><strong>虚拟内存作用</strong></p>
<ul>
<li>第一，虚拟内存可以使得进程对运行内存超过物理内存大小</li>
<li>第二，由于每个进程都有自己虚拟内存空间，这就解决了多进程之间地址冲突的问题。</li>
<li>第三，页表里的页表项还有一些读写权限、页是否存在等标记属性的比特，使得操作系统提供了更好的安全性。</li>
</ul>
<p><strong>申请物理内存的过程</strong></p>
<p>内核在给应用程序分配物理内存的时候，如果空闲物理内存不够，那么就会进行内存回收的工作，主要有两种方式：</p>
<ul>
<li>后台内存回收：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程异步的，不会阻塞进程的执行。</li>
<li>直接内存回收：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，会阻塞进程的执行。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/2f61b0822b3c4a359f99770231981b07.png" alt="img" style="zoom: 50%;" />

<hr>
<h3 id="哪些内存可以被回收？"><a href="#哪些内存可以被回收？" class="headerlink" title="哪些内存可以被回收？"></a>哪些内存可以被回收？</h3><blockquote>
<p>主要有两类内存可以被回收：</p>
<ul>
<li><strong>文件页</strong>：内核缓存的磁盘数据和文件数据都叫作文件页。<strong>回收干净文件页的方式是直接释放内存，回收脏文件页的方式是先写回磁盘后再释放内存</strong>。</li>
<li><strong>匿名页</strong>：这部分内存没有实际载体，比如堆、栈数据等。<strong>通过 Linux 的 Swap 机制进行回收</strong>，把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存。</li>
</ul>
</blockquote>
<p>文件页和匿名页的回收都是基于 <strong>LRU 算法</strong>，也就是优先回收不常访问的内存，其维护 两个双向链表：</p>
<ul>
<li><strong>active_list</strong> 活跃内存页链表，存放最近被访问过（活跃）的内存页；</li>
<li><strong>inactive_list</strong> 不活跃内存页链表，存放很少被访问（非活跃）的内存页；</li>
</ul>
<hr>
<h3 id="回收内存带来的性能影响"><a href="#回收内存带来的性能影响" class="headerlink" title="回收内存带来的性能影响"></a>回收内存带来的性能影响</h3><blockquote>
<p>回收内存的操作基本都会发生磁盘 I&#x2F;O 的，如果回收内存的操作很频繁，意味着磁盘 I&#x2F;O 次数会很多，这个过程势必会影响系统的性能，整个系统给人的感觉就是很卡。</p>
</blockquote>
<hr>
<h3 id="调整文件页和匿名页的回收倾向"><a href="#调整文件页和匿名页的回收倾向" class="headerlink" title="调整文件页和匿名页的回收倾向"></a>调整文件页和匿名页的回收倾向</h3><p>Linux 提供了一个 <code>/proc/sys/vm/swappiness</code> 选项，用来调整文件页和匿名页的回收倾向</p>
<ul>
<li>数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；</li>
<li>数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</li>
</ul>
<hr>
<h3 id="如何保护一个进程不被-OOM-杀掉呢"><a href="#如何保护一个进程不被-OOM-杀掉呢" class="headerlink" title="如何保护一个进程不被 OOM 杀掉呢"></a>如何保护一个进程不被 OOM 杀掉呢</h3><blockquote>
<p> Linux 内核里有一个 <code>oom_badness()</code> 函数，它会把系统中可以被杀掉的进程扫描一遍，并对每个进程打分，得分最高的进程就会被首先杀掉。进程得分的结果受下面这两个方面影响：</p>
<ul>
<li>第一，进程已经使用的物理内存页面数。</li>
<li>第二，每个进程的 OOM 校准值 oom_score_adj。</li>
</ul>
<p>因此可以调整该进程的 oom_score_adj，降低该进程被 OOM 杀死的概率。</p>
<p>如果想某个进程无论如何都不能被杀掉，那你可以将 oom_score_adj 配置为 -1000。</p>
</blockquote>
<h2 id="3-4-在-4GB-物理内存的机器上，申请-8G-内存会怎么样？"><a href="#3-4-在-4GB-物理内存的机器上，申请-8G-内存会怎么样？" class="headerlink" title="3.4 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？"></a>3.4 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？</h2><p>在不同位数操作系统上：</p>
<ul>
<li><strong>32 位操作系统</strong>：因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。</li>
<li><strong>64 位操作系统</strong>：因为进程最大只能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：<ul>
<li>如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；</li>
<li>如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；</li>
</ul>
</li>
</ul>
<p>程序申请的虚拟内存，如果没有被使用，它是不会占用物理空间的，但保存虚拟内存等结果需要占用物理内存。物理内存不足可通过开启swap来缓解。</p>
<blockquote>
<p><strong>Swap 机制</strong></p>
<p>当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中。</p>
</blockquote>
<h2 id="3-5-如何避免预读失效和缓存污染的问题？"><a href="#3-5-如何避免预读失效和缓存污染的问题？" class="headerlink" title="3.5 如何避免预读失效和缓存污染的问题？"></a>3.5 如何避免预读失效和缓存污染的问题？</h2><p>传统的 LRU 算法存在这两个问题：</p>
<ul>
<li><strong>「预读失效」导致缓存命中率下降</strong>：预读数据没有用到导致缓存命中率低</li>
<li><strong>「缓存污染」导致缓存命中率下降</strong>：批量读数据时可能会把热点数据挤出缓存从而导致命中率低</li>
</ul>
<hr>
<h3 id="如何避免预读失效造成的影响？"><a href="#如何避免预读失效造成的影响？" class="headerlink" title="如何避免预读失效造成的影响？"></a>如何避免预读失效造成的影响？</h3><blockquote>
<p>要避免预读失效带来影响，最好就是<strong>让预读页停留在内存里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在内存里的时间尽可能长</strong>。</p>
<p><strong>解决办法</strong>：设置两个区域，真正读取页插入活跃区域，预读页插入非活跃区域，只有当预读页真正被读取时才将其插入活跃区域。。</p>
<ul>
<li>例如Linux中，实现了active list 和 inactive list两个LRU链表，真正读取页插入active list表头，预读页插入inactive list表头，只有预读页真正被访问后才会将其移动到active list表头。</li>
</ul>
</blockquote>
<hr>
<h3 id="怎么避免缓存污染造成的影响？"><a href="#怎么避免缓存污染造成的影响？" class="headerlink" title="怎么避免缓存污染造成的影响？"></a>怎么避免缓存污染造成的影响？</h3><blockquote>
<p><strong>提高进入到活跃 LRU 链表（或者 young 区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young 区域）里的热点数据不会被轻易替换掉</strong>。</p>
<ul>
<li><strong>Linux 操作系统</strong>：在内存页被访问<strong>第二次</strong>的时候，才将页从 inactive list 升级到 active list 里。</li>
<li><strong>MySQL Innodb</strong>：在内存页被访问<strong>第二次</strong>的时候，并不会马上将该页从 old 区域升级到 young 区域，还需要判断与第一次访问时间间隔是否超过1秒，如超过则提升。</li>
</ul>
</blockquote>
<h2 id="3-6-深入理解-Linux-虚拟内存管理"><a href="#3-6-深入理解-Linux-虚拟内存管理" class="headerlink" title="3.6 深入理解 Linux 虚拟内存管理"></a>3.6 深入理解 Linux 虚拟内存管理</h2><h2 id="3-7-深入理解-Linux-物理内存管理"><a href="#3-7-深入理解-Linux-物理内存管理" class="headerlink" title="3.7 深入理解 Linux 物理内存管理"></a>3.7 深入理解 Linux 物理内存管理</h2><h1 id="四、进程管理"><a href="#四、进程管理" class="headerlink" title="四、进程管理"></a>四、进程管理</h1><hr>
<h2 id="4-1-进程、线程基础知识"><a href="#4-1-进程、线程基础知识" class="headerlink" title="4.1 进程、线程基础知识"></a>4.1 进程、线程基础知识</h2><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul>
<li><p>运行状态（<em>Running</em>）：该时刻进程占用 CPU；</p>
</li>
<li><p>就绪状态（<em>Ready</em>）：可运行，由于其他进程处于运行状态而暂时停止运行；</p>
</li>
<li><p>阻塞状态（<em>Blocked</em>）：该进程正在等待某一事件发生（如等待输入&#x2F;输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；</p>
</li>
<li><p>创建状态（<em>new</em>）：进程正在被创建时的状态；</p>
</li>
<li><p>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态；</p>
</li>
</ul>
<blockquote>
<p>挂起状态：</p>
<ul>
<li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li>
<li>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230320170008285.png" style="zoom:67%;" />

<hr>
<h3 id="进程的控制结构"><a href="#进程的控制结构" class="headerlink" title="进程的控制结构"></a>进程的控制结构</h3><p>在操作系统中，是用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程。<strong>PCB 是进程存在的唯一标识</strong></p>
<p><strong>PCB 具体包含信息</strong>：</p>
<ul>
<li><p><strong>进程描述信息：</strong></p>
<ul>
<li><p>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</p>
</li>
<li><p>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</p>
</li>
</ul>
</li>
<li><p><strong>进程控制和管理信息：</strong></p>
<ul>
<li><p>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</p>
</li>
<li><p>进程优先级：进程抢占 CPU 时的优先级；</p>
</li>
</ul>
</li>
<li><p><strong>资源分配清单：</strong></p>
<ul>
<li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I&#x2F;O 设备信息。</li>
</ul>
</li>
<li><p><strong>CPU 相关信息：</strong></p>
<ul>
<li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</li>
</ul>
</li>
</ul>
<p>PCB通过<strong>链表</strong>的方式进行组织，把具有<strong>相同状态的进程链在一起，组成各种队列</strong>，如就绪队列、阻塞队列。</p>
<hr>
<h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><p><strong>创建进程的过程</strong>：</p>
<ul>
<li>申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息，比如进程的唯一标识等；</li>
<li>为该进程分配运行时所必需的资源，比如内存资源；</li>
<li>将 PCB 插入到就绪队列，等待被调度运行；</li>
</ul>
<p><strong>进程可以有 3 种终止方式：正常结束、异常结束以及外界干预</strong>，终止进程的过程如下：</p>
<ul>
<li>查找需要终止的进程的 PCB；</li>
<li>如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；</li>
<li>如果其还有子进程，则应将该进程的子进程交给 1 号进程接管；</li>
<li>将该进程所拥有的全部资源都归还给操作系统；</li>
<li>将其从 PCB 所在队列中删除；</li>
</ul>
<p><strong>阻塞进程的过程</strong>：</p>
<ul>
<li>找到将要被阻塞进程标识号对应的 PCB；</li>
<li>如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；</li>
<li>将该 PCB 插入到阻塞队列中去；</li>
</ul>
<p><strong>唤醒进程的过程</strong>：</p>
<ul>
<li>在该事件的阻塞队列中找到相应进程的 PCB；</li>
<li>将其从阻塞队列中移出，并置其状态为就绪状态；</li>
<li>把该 PCB 插入到就绪队列中，等待调度程序调度；</li>
</ul>
<hr>
<h3 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h3><p><strong>CPU 上下文切换</strong>就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p>
<p>CPU 上下文切换可分成：<strong>进程上下文切换、线程上下文切换和中断上下文切换</strong>。</p>
<p><strong>进程的上下文切换</strong>包含虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p>
<hr>
<h3 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h3><ul>
<li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；</li>
<li>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；</li>
</ul>
<hr>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主要有三种线程的实现方式：</p>
<ul>
<li><strong>用户线程</strong>：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；<ul>
<li>优点：可用于不支持线程技术的操作系统；线程切换无需用户态与内核态切换，所以速度特别快；</li>
<li>缺点：如果一个线程阻塞，那进程所包含的用户线程都阻塞；一个线程运行，同进程中的其他线程都不能运行；内核是按进程进行时间片分配，可能会导致执行慢。</li>
</ul>
</li>
<li><strong>内核线程</strong>：在内核中实现的线程，是由内核管理的线程；<ul>
<li>优点：不存在阻塞同进程其他线程问题；多线程的进程获得更多的 CPU 运行时间；</li>
<li>缺点：需要内核来维护线程的上下文信息；会切换到内核态，系统开销较大。</li>
</ul>
</li>
<li><strong>轻量级进程</strong>：在内核中来支持用户线程；<ul>
<li>轻量级进程与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul>
<li><p><strong>先来先服务调度算法</strong>：非抢占式，对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p>
</li>
<li><p><strong>最短作业优先调度算法</strong>：优先选择运行时间最短的进程来运行；对长作业不利。</p>
</li>
<li><p><strong>高响应比优先</strong>：计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行。由于要求服务时间未知，所以是一种理想型算法。</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230320204258422.png" style="zoom:50%;" />
</li>
<li><p><strong>时间片轮转调度算法</strong>：每个进程被分配一个时间片，该进程在该时间段中运行。</p>
</li>
<li><p><strong>最高优先级调度算法</strong>：从就绪队列中选择最高优先级的进程运行。优先级可分为静态优先级和动态优先级，算法还可分为抢占式和非抢占式。</p>
</li>
<li><p><strong>多级反馈队列调度算法</strong>：是「时间片轮转算法」和「最高优先级算法」的综合和发展；</p>
<ul>
<li>设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短；</li>
<li>新的进程会被放入到第一级队列的末尾，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li>
<li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li>
</ul>
</li>
</ul>
<h2 id="4-2-进程间有哪些通信方式？"><a href="#4-2-进程间有哪些通信方式？" class="headerlink" title="4.2 进程间有哪些通信方式？"></a>4.2 进程间有哪些通信方式？</h2><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以<strong>进程之间要通信必须通过内核</strong>。</p>
<hr>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p><strong>管道传输数据是单向的</strong>，如果想相互通信，需要创建两个管道。</p>
<p><strong>匿名管道</strong>：没有名字标识，其是特殊文件只存在于内存，没有存在于文件系统中</p>
<ul>
<li><strong>通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</li>
</ul>
<p><strong>命名管道</strong>：也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p>
<ul>
<li><strong>可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</li>
</ul>
<p><strong>管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。管道传输的数据是无格式的流且大小受限。</p>
<p><strong>管道通信效率低，不适合进程间频繁地交换数据</strong>。</p>
<blockquote>
<p><strong>管道创建函数生成的两个描述符都在一个进程中，怎么起到进程间通信的作用？</strong></p>
<p>使用 fork 创建子进程，创建的子进程会复制父进程的文件描述符</p>
</blockquote>
<blockquote>
<p><strong>shell中使用管道</strong></p>
<p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p>
<p>所以在shell中要尽量少使用管道</p>
</blockquote>
<hr>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><strong>消息队列</strong>消息队列是保存在内核中的消息链表</p>
<ul>
<li>在发送数据时，会分成一个一个消息体，消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型</li>
<li>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在</li>
<li>缺点：<ul>
<li>通信不及时</li>
<li>消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限</li>
<li>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</li>
</ul>
</li>
</ul>
<hr>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p><strong>共享内存</strong>：是拿出一块虚拟地址空间来，映射到相同的物理内存中。因此无需多次拷贝，大大提高了进程间通信的速度。</p>
<ul>
<li>是最快的进程间通信方式，但多进程竞争同个共享资源会造成数据的错乱，需要使用信号量来控制。</li>
</ul>
<hr>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><strong>信号量</strong>是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。</p>
<p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p>
<ul>
<li><strong>P 操作</strong>，信号量减去 1，相减后如果信号量 &lt; 0，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li>
<li><strong>V 操作</strong>，把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将阻塞进程唤醒；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<p><strong>P V操作是必须成对出现的</strong></p>
<hr>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>以上进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p>
<p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，当有信号产生，有以下几种处理方式：</p>
<ul>
<li><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如 SIGTERM 信号就是终止进程。</p>
<p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
<p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p>
</li>
</ul>
<hr>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>若想<strong>跨网络与不同主机上的进程之间通信</strong>，就需要 Socket 通信，也可同主机上进程间通信。</p>
<p>根据创建 socket 类型的不同，可分为以下几种通信方式：</p>
<ul>
<li><strong>TCP 字节流通信</strong>： socket 类型是 AF_INET 和 SOCK_STREAM；</li>
<li><strong>UDP 数据报通信</strong>：socket 类型是 AF_INET 和 SOCK_DGRAM；</li>
<li><strong>本地进程间通信</strong>： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的。<ul>
<li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li>
<li>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</li>
</ul>
</li>
</ul>
<h2 id="4-3-多线程冲突了怎么办？"><a href="#4-3-多线程冲突了怎么办？" class="headerlink" title="4.3 多线程冲突了怎么办？"></a>4.3 多线程冲突了怎么办？</h2><p>由于多线程执行操作共享变量的这段代码可能会导致竞争状态，此段代码称为<strong>临界区</strong></p>
<p><strong>同步：</strong>就是并发进程&#x2F;线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程&#x2F;线程同步。</p>
<p>实现进程协作方法主要有两种：</p>
<ul>
<li><em>锁</em>：加锁、解锁操作；<ul>
<li><strong>自旋锁</strong>：获取不到锁时，线程就会一直 while 循环，不做任何事情<ul>
<li>通过 CPU 提供的 <code>CAS</code> 函数实现，在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换</li>
</ul>
</li>
<li><strong>无等待锁</strong>：当没获取到锁的时候，就把当前线程放入到锁的等待队列，然后执行调度程序</li>
</ul>
</li>
<li><em>信号量</em>：P、V 操作，其是原子操作；<ul>
<li>信号量不仅可以实现临界区的互斥访问控制，还可以线程间的事件同步。</li>
</ul>
</li>
</ul>
<h2 id="4-4-怎么避免死锁？"><a href="#4-4-怎么避免死锁？" class="headerlink" title="4.4 怎么避免死锁？"></a>4.4 怎么避免死锁？</h2><p>两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直相互等待，这就是<strong>死锁</strong>。</p>
<p><strong>死锁发生的必要条件</strong>：</p>
<ul>
<li>互斥条件：指多个线程不能同时使用同一个资源。</li>
<li>持有并等待条件：线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</li>
<li>不可剥夺条件：线程持有资源不能被其他线程剥夺获取</li>
<li>循环等待条件：两个线程获取资源的顺序构成了环形</li>
</ul>
<p>避免死锁问题就只需要破环其中一个条件，最常见的并且可行的就是<strong>使用资源有序分配法</strong></p>
<ul>
<li>即资源申请顺序一样，例如只能先申请A再申请B</li>
</ul>
<hr>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p><strong>思想</strong>：只要线程申请资源不超过拥有值，则尽可能满足其申请</p>
<ul>
<li>每一个新进程进入系统时，必须声明需要每种资源的最大数目，其数目不能超过系统所拥有的的资源总量。</li>
<li>当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程，若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态如果不会才将资源分配给它，否则让进程等待。</li>
</ul>
<h2 id="4-5-什么是悲观锁、乐观锁？"><a href="#4-5-什么是悲观锁、乐观锁？" class="headerlink" title="4.5 什么是悲观锁、乐观锁？"></a>4.5 什么是悲观锁、乐观锁？</h2><h3 id="互斥锁与自旋锁"><a href="#互斥锁与自旋锁" class="headerlink" title="互斥锁与自旋锁"></a><strong>互斥锁与自旋锁</strong></h3><ul>
<li>这两种锁是最底层的锁，其他高级锁都是基于此两种锁实现</li>
<li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li>
<li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li>
<li><strong>如果被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></li>
</ul>
<hr>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁，由「读锁」和「写锁」两部分构成，<strong>读写锁适用于能明确区分读操作和写操作的场景</strong>，工作原理：</p>
<ul>
<li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁</li>
<li>一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li>
</ul>
<p><strong>写锁是独占锁，而读锁是共享锁</strong></p>
<p>读写锁可以分为：</p>
<ul>
<li>「读优先锁」：当读锁被持有时，获取写锁的线程会被阻塞，且后续来的读线程仍然能获取读锁。知道所有读锁被释放，才能获取写锁成功。</li>
<li>「写优先锁」：当获取写锁时，持有读锁的线程会被阻塞，此时获取读锁的线程也会被阻塞</li>
</ul>
<p><strong>公平读写锁</strong>：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</p>
<hr>
<h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p><strong>悲观锁</strong>：认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。</p>
<ul>
<li>互斥锁、自旋锁、读写锁，都是属于悲观锁。</li>
</ul>
<p><strong>乐观锁</strong>：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p>
<ul>
<li>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></li>
</ul>
<blockquote>
<p><strong>CAS 不是乐观锁吗，为什么基于 CAS 实现的自旋锁是悲观锁？</strong></p>
<p>CAS 是乐观锁没错，但是 CAS 和自旋锁不同之处，自旋锁基于 CAS 加了while 或者睡眠 CPU 的操作而产生自旋的效果，加锁失败会忙等待直到拿到锁，自旋锁是要需要事先拿到锁才能修改数据的，所以算悲观锁。</p>
</blockquote>
<h2 id="4-6-一个进程最多可以创建多少个线程？"><a href="#4-6-一个进程最多可以创建多少个线程？" class="headerlink" title="4.6 一个进程最多可以创建多少个线程？"></a>4.6 一个进程最多可以创建多少个线程？</h2><blockquote>
<ul>
<li>32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。</li>
<li>64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。</li>
</ul>
</blockquote>
<p>创建进程个数受两个方面影响：</p>
<ul>
<li><strong>进程的虚拟内存空间上限</strong>，因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多。</li>
<li><strong>系统参数限制</strong>，虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数。<ul>
<li><em><strong>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;threads-max</strong></em>，表示系统支持的最大线程数，默认值是 <code>14553</code>；</li>
<li><em><strong>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max</strong></em>，表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败，默认值是 <code>32768</code>；</li>
<li><em><strong>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;max_map_count</strong></em>，表示限制一个进程可以拥有的VMA(虚拟内存区域)的数量，具体什么意思我也没搞清楚，反正如果它的值很小，也会导致创建线程失败，默认值是 <code>65530</code>。</li>
</ul>
</li>
</ul>
<h2 id="4-7-线程崩溃了，进程也会崩溃吗"><a href="#4-7-线程崩溃了，进程也会崩溃吗" class="headerlink" title="4.7 线程崩溃了，进程也会崩溃吗"></a>4.7 线程崩溃了，进程也会崩溃吗</h2><p>一般来说如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃。因为某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程。</p>
<blockquote>
<p><strong>进程是如何崩溃的</strong>？</p>
<ul>
<li>调用 kill 系统调用向进程发送信号</li>
<li>操作系统根据情况执行相应的信号处理程序（函数），一般执行完信号处理程序逻辑后会让进程退出</li>
</ul>
</blockquote>
<p>虽然给进程发送了 kill 信号，但如果进程自己定义了信号处理函数或者无视信号，那么可能会毫无影响。</p>
<p><strong>为什么线程崩溃不会导致 JVM 进程崩溃？</strong></p>
<p>因为 JVM 自定义了自己的信号处理函数，拦截了 SIGSEGV 信号，针对这两者不让它们崩溃。</p>
<h1 id="五、调度算法"><a href="#五、调度算法" class="headerlink" title="五、调度算法"></a>五、调度算法</h1><h2 id="5-1-进程调度算法"><a href="#5-1-进程调度算法" class="headerlink" title="5.1 进程调度算法"></a>5.1 进程调度算法</h2><ul>
<li><p><strong>先来先服务调度算法</strong>：非抢占式，对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p>
</li>
<li><p><strong>最短作业优先调度算法</strong>：优先选择运行时间最短的进程来运行；对长作业不利。</p>
</li>
<li><p><strong>高响应比优先</strong>：计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行。由于要求服务时间未知，所以是一种理想型算法。</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230320204258422.png" style="zoom:50%;" />
</li>
<li><p><strong>时间片轮转调度算法</strong>：每个进程被分配一个时间片，该进程在该时间段中运行。</p>
</li>
<li><p><strong>最高优先级调度算法</strong>：从就绪队列中选择最高优先级的进程运行。优先级可分为静态优先级和动态优先级，算法还可分为抢占式和非抢占式。</p>
</li>
<li><p><strong>多级反馈队列调度算法</strong>：是「时间片轮转算法」和「最高优先级算法」的综合和发展；</p>
<ul>
<li>设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短；</li>
<li>新的进程会被放入到第一级队列的末尾，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li>
<li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li>
</ul>
</li>
</ul>
<h2 id="5-2-页面置换算法"><a href="#5-2-页面置换算法" class="headerlink" title="5.2 页面置换算法"></a>5.2 页面置换算法</h2><p>当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它<strong>与一般中断的主要区别</strong>在于：</p>
<ul>
<li>缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</li>
<li>缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。</li>
</ul>
<p>页表项通常有如下字段：</p>
<ul>
<li><em>状态位</em>：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问时参考。</li>
<li><em>访问字段</em>：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考。</li>
<li><em>修改位</em>：表示该页在调入内存后是否有被修改过</li>
<li><em>硬盘地址</em>：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321160617503.png"></p>
<p>常见的页面置换算法有如下几种：</p>
<ul>
<li><strong>最佳页面置换算法（<em>OPT</em>）</strong>：基本思路是置换在「未来」最长时间不访问的页面。<ul>
<li>实际系统中无法实现，因为程序访问页面时是动态的，无法预知每个页面在「下一次」访问前的等待时间。</li>
</ul>
</li>
<li><strong>先进先出置换算法（<em>FIFO</em>）</strong>：选择在内存驻留时间很长的页面进行中置换。</li>
<li><strong>最近最久未使用的置换算法（<em>LRU</em>）</strong>：发生缺页时，选择最长时间没有被访问的页面进行置换。<ul>
<li>该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用，近似最优置换算法。</li>
<li>代价很高。需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。且每次内存访问都需要更新链表，非常耗时。</li>
</ul>
</li>
<li><strong>时钟页面置换算法（<em>Lock</em>）</strong>：把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。当发生缺页中断时，算法首先检查表针指向的页面：<ul>
<li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li>
<li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li>
</ul>
</li>
<li><strong>最不常用置换算法（<em>LFU</em>）</strong>：当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰。<ul>
<li>缺点：查找哪个页面访问次数最小是非常耗时的，效率不高。且没有考虑访问时间。</li>
</ul>
</li>
</ul>
<h2 id="5-3-磁盘调度算法"><a href="#5-3-磁盘调度算法" class="headerlink" title="5.3 磁盘调度算法"></a>5.3 磁盘调度算法</h2><p>常见的磁盘调度算法有：</p>
<ul>
<li><strong>先来先服务算法</strong>：先到来的请求，先被服务。<ul>
<li>如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法在性能上就会显得很差，因为寻道时间过长。</li>
</ul>
</li>
<li><strong>最短寻道时间优先算法</strong>：优先选择从当前磁头位置所需寻道时间最短的请求<ul>
<li>可能产生了饥饿现象，因为磁头在一小块区域来回移动。</li>
</ul>
</li>
<li><strong>扫描算法</strong>：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，也叫做<strong>电梯算法</strong>；<ul>
<li>不会产生饥饿现象，但中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异</li>
</ul>
</li>
<li><strong>循环扫描算法</strong>：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头<ul>
<li>该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong>。</li>
</ul>
</li>
<li><strong>LOOK <strong>：针对扫描算法的优化。磁头在移动到「最远的请求」位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，</strong>反向移动的途中会响应请求</strong>。</li>
<li><strong>C-LOOK</strong> ：针对循环扫描算法的优化。磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong>。</li>
</ul>
<h1 id="六、文件系统"><a href="#六、文件系统" class="headerlink" title="六、文件系统"></a>六、文件系统</h1><h2 id="6-1-文件系统全家桶"><a href="#6-1-文件系统全家桶" class="headerlink" title="6.1 文件系统全家桶"></a>6.1 文件系统全家桶</h2><p>文件系统是操作系统中负责管理持久数据的子系统，基本数据单位是文件。</p>
<p>Linux 文件系统会为每个文件分配两个数据结构：</p>
<ul>
<li><strong>索引节点</strong>：<em>inode</em>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、<em>数据在磁盘的位置</em>等等。索引节点是文件的<strong>唯一</strong>标识，也同样都会被存储在硬盘中，所以<strong>索引节点同样占用磁盘空间</strong>。<ul>
<li>索引节点和文件的关系是多对一，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li>
</ul>
</li>
<li><strong>目录项</strong>：<em>dentry</em>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构。<ul>
<li>与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>。</li>
</ul>
</li>
</ul>
<p><strong>目录也是文件</strong>，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p>
<blockquote>
<p><strong>目录项和目录是一个东西吗？</strong></p>
<p>不是。目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。</p>
<ul>
<li>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存</li>
</ul>
<p><strong>文件数据是如何存储在磁盘的呢？</strong></p>
<p>磁盘读写的最小单位是<strong>扇区</strong>，文件系统把多个扇区组成了一个<strong>逻辑块</strong>，每次读写的最小单位就是逻辑块。</p>
</blockquote>
<p>磁盘进行格式化的时候，会被分成三个存储区域：</p>
<ul>
<li><em>超级块</em>，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。<ul>
<li>当文件系统挂载时进入内存；</li>
</ul>
</li>
<li><em>索引节点区</em>，用来存储索引节点；<ul>
<li>当文件被访问时进入内存；</li>
</ul>
</li>
<li><em>数据块区</em>，用来存储文件或目录数据；</li>
</ul>
<p>操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「<strong>文件描述符</strong>」，所以说文件描述符是打开文件的标识。操作系统在打开文件表中维护着打开文件的状态和信息：</p>
<ul>
<li>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；</li>
<li>文件打开计数器：该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；</li>
<li>文件磁盘位置：该信息保存在内存中，以免每个操作都从磁盘中读取；</li>
<li>访问权限：权限信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I&#x2F;O 请求；</li>
</ul>
<hr>
<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>操作系统希望<strong>对用户提供一个统一的接口</strong>，于是在用户层与文件系统层引入了中间层，被称为<strong>虚拟文件系统（VFS）。</strong></p>
<p>文件系统可分为三类：</p>
<ul>
<li><em><strong>磁盘的文件系统</strong></em>，它是直接把数据存储在磁盘中，比如 Ext 2&#x2F;3&#x2F;4、XFS 等都是这类文件系统。</li>
<li><em><strong>内存的文件系统</strong></em>，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 <code>/proc</code> 和 <code>/sys</code> 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。</li>
<li><em><strong>网络的文件系统</strong></em>，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。</li>
</ul>
<p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p>
<p><strong>文件系统的基本操作单位是数据块</strong></p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321163639861.png" style="zoom:33%;" />

<hr>
<h3 id="文件的存储"><a href="#文件的存储" class="headerlink" title="文件的存储"></a>文件的存储</h3><p>文件有以下两种存储方式：</p>
<ul>
<li><p><strong>连续空间存放方式</strong>：文件存放在磁盘「连续的」物理空间中。inode里需要指定「起始块的位置」和「长度」。</p>
<ul>
<li>优点：读写效率很高</li>
<li>缺点：磁盘空间碎片问题；文件长度不易扩展；</li>
</ul>
</li>
<li><p><strong>非连续空间存放方式</strong></p>
<ul>
<li><p><strong>链表</strong></p>
<ul>
<li><strong>隐式链表</strong>：inode中要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置。<ul>
<li>缺点：无法直接访问数据块；稳定性较差，如果其中一个指针丢失，会导致文件数据丢失。</li>
</ul>
</li>
<li><strong>显式链接</strong>：把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，该表在<strong>整个磁盘仅设置一张</strong>，每个表项中存放链接指针，指向下一个数据块号。如win曾经的FAT。它的<strong>主要的缺点是不适用于大磁盘</strong>。</li>
</ul>
</li>
<li><p><strong>索引</strong>：为每个文件创建一个「索引数据块」，里面存放的是指向文件数据块的指针列表。另外，inode需要包含指向「索引数据块」的指针。</p>
<ul>
<li>优点：文件的创建、增大、缩小很方便；不会有碎片的问题；支持顺序读写和随机读写；</li>
<li>缺点：<strong>索引数据存放在磁盘块</strong>，会带来存储索引的开销</li>
</ul>
<blockquote>
<p><strong>链式索引</strong>：链表 + 索引。在索引数据块留出一个存放下一个索引数据块的指针，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。</p>
<p><strong>多级索引</strong>：通过一个索引块来存放多个索引数据块，一层套一层索引</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321170248979.png" style="zoom:80%;" />

<hr>
<h3 id="Unix-文件的实现方式"><a href="#Unix-文件的实现方式" class="headerlink" title="Unix 文件的实现方式"></a>Unix 文件的实现方式</h3><p>根据文件的大小，存放的方式会有所变化：</p>
<ul>
<li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；</li>
<li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；</li>
<li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；</li>
<li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；</li>
</ul>
<p>因此，文件头（<em>Inode</em>）就需要包含 13 个指针：</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321170712531.png" style="zoom:50%;" />

<hr>
<h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><p>查找空闲块需要高效，有以下几种方法：</p>
<ul>
<li><strong>空闲表法</strong>：为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数。注意，这个方式是连续分配的。<ul>
<li>当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。</li>
<li>当用户撤销一个文件时，也需顺序扫描寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。</li>
<li>仅当有少量的空闲区时才有较好的效果</li>
</ul>
</li>
<li><strong>空闲链表法</strong>：每一个数据空闲块里有一个指针指向下一个数据空闲块。<ul>
<li>其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I&#x2F;O 操作，同时数据块的指针消耗了一定的存储空间。</li>
</ul>
</li>
<li><strong>位图法</strong>：利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。<ul>
<li>Linux 文件系统就采用了位图的方式来管理空闲空间，还用于 inode 空闲块的管理</li>
</ul>
</li>
</ul>
<hr>
<h3 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h3><p>一个块存放的位图能表示的存储大小是有限的，如只能128M。因此，在linux中使用了一个结构体<strong>块组</strong>来表示，然后大量块组就可以表示超大的文件，块组内容如下：</p>
<ul>
<li><em><strong>超级块</strong></em>，包含文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等。</li>
<li><em><strong>块组描述符</strong></em>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</li>
<li><em><strong>数据位图和 inode 位图</strong></em>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。</li>
<li><em><strong>inode 列表</strong></em>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</li>
<li><em><strong>数据块</strong></em>，包含文件的有用数据。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321212613348.png" style="zoom:67%;" />

<blockquote>
<p>为什么每个块组中都有超级块和块组描述符表？</p>
<ul>
<li>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。</li>
<li>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。</li>
</ul>
</blockquote>
<hr>
<h3 id="目录的存储"><a href="#目录的存储" class="headerlink" title="目录的存储"></a>目录的存储</h3><p>普通文件的块里面保存的是文件数据，而<strong>目录文件的块里面保存的是目录里面一项一项的文件信息</strong>。</p>
<p>目录内容如下：</p>
<ul>
<li>第一项是「<code>.</code>」，表示当前目录，第二项是「<code>..</code>」，表示上一级目录</li>
<li>保存目录是使用<strong>哈希表</strong>，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希来匹配。<ul>
<li>种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321213002362.png" style="zoom: 67%;" />

<hr>
<h3 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h3><p><strong>硬链接</strong></p>
<ul>
<li><strong>多个目录项中的「索引节点」指向一个文件</strong>，也就是指向同一个 inode</li>
<li>每个文件系统都有各自的 inode 数据结构和列表，所以<strong>硬链接是不可用于跨文件系统的</strong>。</li>
<li>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件</li>
</ul>
<p><strong>软链接</strong></p>
<ul>
<li>相当于重新创建一个文件，这个文件有<strong>独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件</li>
<li><strong>软链接是可以跨文件系统的</strong>，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</li>
</ul>
<hr>
<h3 id="文件-I-x2F-O"><a href="#文件-I-x2F-O" class="headerlink" title="文件 I&#x2F;O"></a>文件 I&#x2F;O</h3><p><strong>缓冲与非缓冲 I&#x2F;O</strong>：根据「是否利用标准库缓冲」，可以把文件 I&#x2F;O 分为缓冲 I&#x2F;O 和非缓冲，「缓冲」特指标准库内部实现的缓冲。</p>
<ul>
<li>缓冲 I&#x2F;O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。</li>
<li>非缓冲 I&#x2F;O，直接通过系统调用访问文件，不经过标准库缓存。</li>
</ul>
<p><strong>直接与非直接 I&#x2F;O</strong>： Linux 内核为了减少磁盘 I&#x2F;O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来只有当缓存满足某些条件的时候，才发起磁盘 I&#x2F;O 的请求。根据是「否利用操作系统的缓存」，可以把文件 I&#x2F;O 分为直接 I&#x2F;O 与非直接 I&#x2F;O：</p>
<ul>
<li><p>直接 I&#x2F;O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。</p>
<ul>
<li>如果你在使用文件操作类的系统调用函数时，指定了 <code>O_DIRECT</code> 标志，则表示使用直接 I&#x2F;O。如果没有设置过，默认使用的是非直接 I&#x2F;O。</li>
</ul>
</li>
<li><p>非直接 I&#x2F;O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。</p>
<blockquote>
<p>以下几种场景会触发内核缓存的数据写入磁盘：</p>
<ul>
<li>在调用 <code>write</code> 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；</li>
<li>用户主动调用 <code>sync</code>，内核缓存会刷到磁盘上；</li>
<li>当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；</li>
<li>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>阻塞与非阻塞 I&#x2F;O VS 同步与异步 I&#x2F;O</strong>：这两类IO其实是内核数据准备和数据拷贝的不同区分。</p>
<ul>
<li><p>阻塞 I&#x2F;O：阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</p>
<ul>
<li>当用户程序执行 <code>read</code> ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，<code>read</code> 才会返回。</li>
</ul>
</li>
<li><p>非阻塞 I&#x2F;O：非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，<code>read</code> 调用才可以获取到结果</p>
<ul>
<li>注意，成功获取数据 的那次read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。</li>
</ul>
<blockquote>
<p>无论是阻塞 I&#x2F;O、非阻塞 I&#x2F;O，还是基于非阻塞 I&#x2F;O 的多路复用<strong>都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。</strong></p>
</blockquote>
</li>
<li><p>异步 I&#x2F;O ：「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待</p>
<blockquote>
<p>I&#x2F;O 是分为两个过程的：</p>
<ol>
<li>数据准备的过程</li>
<li>数据从内核空间拷贝到用户进程缓冲区的过程</li>
</ol>
<p>阻塞 I&#x2F;O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I&#x2F;O 和基于非阻塞 I&#x2F;O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I&#x2F;O。</p>
<p>异步 I&#x2F;O 则不同，「过程 1 」和「过程 2 」都不会阻塞。</p>
</blockquote>
</li>
</ul>
<h2 id="6-2-进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"><a href="#6-2-进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？" class="headerlink" title="6.2 进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"></a>6.2 进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？</h2><p>答案：不会丢失。</p>
<ul>
<li>因为进程在执行 write （使用缓冲 IO）系统调用的时候，实际上是将文件数据写到了内核的 page cache，它是文件系统中用于缓存文件数据的缓冲，所以即使进程崩溃了，文件数据还是保留在内核的 page cache</li>
<li>内核会找个合适的时机，将 page cache 中的数据持久化到磁盘。但是如果 page cache 里的文件数据，在持久化到磁盘化到磁盘之前，系统发生了崩溃，那这部分数据就会丢失了。</li>
<li>也可以在程序里调用 fsync 函数，在写文文件的时候，立刻将文件数据持久化到磁盘，这样就可以解决系统崩溃导致的文件数据丢失的问题。</li>
</ul>
<hr>
<h3 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h3><p>Page Cache 的本质是由 Linux 内核管理的内存区域。我们通过 mmap 以及 buffered I&#x2F;O 将文件读取到内存空间实际上都是读取到 Page Cache 中</p>
<p><strong>优势</strong></p>
<ul>
<li>加快数据访问</li>
<li>减少 I&#x2F;O 次数，提高系统磁盘 I&#x2F;O 吞吐量</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>需要占用额外物理内存空间，物理内存在比较紧俏的时候可能会导致频繁的 swap 操作，最终导致系统的磁盘 I&#x2F;O 负载的上升</li>
<li>对应用层并没有提供很好的管理 API，导致想优化 Page Cache 的使用策略很难进行</li>
<li>在某些应用场景下比 Direct I&#x2F;O 多一次磁盘读 I&#x2F;O 以及磁盘写 I&#x2F;O</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321215335466.png"></p>
<blockquote>
<p><strong>page 与 Page Cache</strong></p>
<p>page 是内存管理分配的基本单位， Page Cache 由多个 page 构成。page 在操作系统中通常为 4KB 大小（32bits&#x2F;64bits），而 Page Cache 的大小则为 4KB 的整数倍。</p>
</blockquote>
<hr>
<h3 id="Page-Cache-与-buffer-cache"><a href="#Page-Cache-与-buffer-cache" class="headerlink" title="Page Cache 与 buffer cache"></a>Page Cache 与 buffer cache</h3><p>执行 free 命令，注意到会有两列名为 buffers 和 cached，也有一行名为 “-&#x2F;+ buffers&#x2F;cache”。</p>
<p><strong>Page Cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据。</strong></p>
<ul>
<li>页是逻辑上的概念，因此 Page Cache 是与文件系统同级的；</li>
<li>块是物理上的概念，因此 buffer cache 是与块设备驱动程序同级的。</li>
</ul>
<p>Page Cache 与 buffer cache 的<strong>共同目的都是加速数据 I&#x2F;O</strong>：</p>
<ul>
<li>写数据时首先写到缓存，将写入的页标记为 dirty，然后向外部存储 flush，也就是缓存写机制中的 write-back（另一种是 write-through，Linux 默认情况下不采用）；</li>
<li>读数据时首先读取缓存，如果未命中，再去外部存储读取，并且将读取来的数据也加入缓存。操作系统总是积极地将所有空闲内存都用作 Page Cache 和 buffer cache，当内存不够用时也会用 LRU 等算法淘汰缓存页。</li>
</ul>
<p><strong>在 2.4 版本内核之后，两块缓存近似融合在了一起：如果一个文件的页加载到了 Page Cache，那么同时 buffer cache 只需要维护块指向页的指针就可以了</strong></p>
<hr>
<h3 id="Page-Cache-与文件持久化的一致性-amp-可靠性"><a href="#Page-Cache-与文件持久化的一致性-amp-可靠性" class="headerlink" title="Page Cache 与文件持久化的一致性&amp;可靠性"></a>Page Cache 与文件持久化的一致性&amp;可靠性</h3><p>Linux 下以两种方式实现文件一致性：</p>
<ol>
<li><strong>Write Through（写穿）</strong>：向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性；<ul>
<li>以牺牲系统 I&#x2F;O 吞吐量作为代价，向上层应用确保一旦写入，数据就已经落盘，不会丢失</li>
</ul>
</li>
<li><strong>Write back（写回）</strong>：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的 Linux 一致性方案；<ul>
<li>在系统发生宕机的情况下无法确保数据已经落盘，因此存在数据丢失的问题。</li>
</ul>
</li>
</ol>
<p>上述两种方式最终都依赖于系统调用，主要分为如下三种系统调用：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fsync(intfd)</td>
<td align="left">fsync(fd)：将 fd 代表的文件的脏数据和脏元数据全部刷新至磁盘中。</td>
</tr>
<tr>
<td align="left">fdatasync(int fd)</td>
<td align="left">fdatasync(fd)：将 fd 代表的文件的脏数据刷新至磁盘，同时对必要的元数据刷新至磁盘中，这里所说的必要的概念是指：对接下来访问文件有关键作用的信息，如文件大小，而文件修改时间等不属于必要信息</td>
</tr>
<tr>
<td align="left">sync()</td>
<td align="left">sync()：则是对系统中所有的脏的文件数据元数据刷新至磁盘中</td>
</tr>
</tbody></table>
<ol>
<li>系统中存在一个管理线程和多个刷新线程（每个持久存储设备对应一个刷新线程）。<ul>
<li>管理线程监控设备上的脏页面情况，若设备一段时间内没有产生脏页面，就销毁设备上的刷新线程；若监测到设备上有脏页面需要回写且尚未为该设备创建刷新线程，那么创建刷新线程处理脏页面回写。</li>
<li>刷新线程的任务较为单调，只负责将设备中的脏页面回写至持久存储设备中。</li>
</ul>
</li>
<li>刷新线程刷新设备上脏页面大致设计如下：<ul>
<li>每个设备保存脏文件链表，保存的是该设备上存储的脏文件的 inode 节点。所谓的回写文件脏页面即回写该 inode 链表上的某些文件的脏页面；</li>
<li>系统中存在多个回写时机，第一是应用程序主动调用回写接口，第二管理线程周期性地唤醒设备上的回写线程进行回写，第三是某些应用程序&#x2F;内核任务发现内存不足时要回收部分缓存页面而事先进行脏页面回写</li>
</ul>
</li>
</ol>
<h1 id="七、设备管理"><a href="#七、设备管理" class="headerlink" title="七、设备管理"></a>七、设备管理</h1><h2 id="7-1-键盘敲入-A-字母时，操作系统期间发生了什么？"><a href="#7-1-键盘敲入-A-字母时，操作系统期间发生了什么？" class="headerlink" title="7.1 键盘敲入 A 字母时，操作系统期间发生了什么？"></a>7.1 键盘敲入 A 字母时，操作系统期间发生了什么？</h2><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p>为了屏蔽设备之间的差异，每个设备都有一个叫<strong>设备控制器</strong>，CPU 是通过设备控制器来和设备打交道的</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230322174034974.png" style="zoom:33%;" />

<p>设备控制器里有芯片，也有寄存器用来与 CPU 进行通信，可分为三类：</p>
<ul>
<li><em><strong>数据寄存器</strong></em>，CPU 向 I&#x2F;O 设备写入需要传输的数据，比如要打印的内容是「Hello」，CPU 就要先发送一个 H 字符给到对应的 I&#x2F;O 设备。</li>
<li><em><strong>命令寄存器</strong></em>，CPU 发送一个命令，告诉 I&#x2F;O 设备，要进行输入&#x2F;输出操作，于是就会交给 I&#x2F;O 设备去工作，任务完成后，会把状态寄存器里面的状态标记为完成。</li>
<li><em><strong>状态寄存器</strong></em>，目的是告诉 CPU ，现在已经在工作或工作已经完成，如果已经在工作状态，CPU 再发送数据或者命令过来，都是没有用的，直到前面的工作已经完成，状态寄存标记成已完成，CPU 才能发送下一个字符和命令。</li>
</ul>
<p> 输入输出设备可分为两大类 ：</p>
<ul>
<li><em><strong>块设备</strong></em>，把数据存储在固定大小的块中，每个块有自己的地址，硬盘、USB 是常见的块设备。<ul>
<li>块设备通常传输的数据量会非常大，于是控制器设立了一个可读写的<strong>数据缓冲区</strong>。无论读写都是囤够了一部分，才会发给设备或拷贝到内存。</li>
</ul>
</li>
<li><em><strong>字符设备</strong></em>，以字符为单位发送或接收一个字符流，字符设备是不可寻址的，也没有任何寻道操作，鼠标是常见的字符设备。</li>
</ul>
<p>CPU 设备的控制寄存器和数据缓冲区通信方法：</p>
<ul>
<li><em><strong>端口 I&#x2F;O</strong></em>，每个控制寄存器被分配一个 I&#x2F;O 端口，可以通过特殊的汇编指令操作这些寄存器，比如 <code>in/out</code> 类似的指令。</li>
<li><em><strong>内存映射 I&#x2F;O</strong></em>，将所有控制寄存器映射到内存空间中，这样就可以像读写内存一样读写数据缓冲区。</li>
</ul>
<hr>
<h3 id="I-x2F-O-控制方式"><a href="#I-x2F-O-控制方式" class="headerlink" title="I&#x2F;O 控制方式"></a>I&#x2F;O 控制方式</h3><p><strong>轮询等待</strong>：CPU 一直检查寄存器的状态</p>
<p><strong>中断</strong>：当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU</p>
<p><strong>DMA</strong>：可以使得设备在 CPU 不参与的情况下，能够自行完成把设备 I&#x2F;O 数据放入到内存，工作方式如下：</p>
<ul>
<li>CPU 需对 DMA 控制器下发指令，告诉它想读取多少数据，读完的数据放在内存的某个地方就可以了；</li>
<li>接下来，DMA 控制器会向磁盘控制器发出指令，通知它从磁盘读数据到内存缓冲区中，接着磁盘控制器将缓冲区的数据传输到内存；</li>
<li>当磁盘控制器把数据传输到内存的操作完成后，磁盘控制器在总线上发出一个确认成功的信号到 DMA 控制器；</li>
<li>DMA 控制器收到信号后，DMA 控制器发中断通知 CPU 指令完成，CPU 就可以直接用内存里面现成的数据了；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230322173920982.png" style="zoom:80%;" />

<hr>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>每种设备的控制器的寄存器、缓冲区等使用模式都是不同的，所以为了屏蔽「设备控制器」的差异，引入了<strong>设备驱动程序</strong>。设备驱动程序会提供统一的接口给操作系统。</p>
<p>设备驱动程序里会响应控制器发来的中断请求，并根据这个中断的类型调用响应的<strong>中断处理程序</strong>进行处理。通常，设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数。</p>
<p><strong>中断处理程序的处理流程</strong>：</p>
<ol>
<li>在 I&#x2F;O 时，设备控制器如果已经准备好数据，则会通过中断控制器向 CPU 发送中断请求；</li>
<li>保护被中断进程的 CPU 上下文；</li>
<li>转入相应的设备中断处理函数；</li>
<li>进行中断处理；</li>
<li>恢复被中断进程的上下文；</li>
</ol>
<hr>
<h3 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h3><p>对于块设备，为了减少不同块设备的差异带来的影响，Linux 通过一个统一的<strong>通用块层</strong>，来管理不同的块设备。</p>
<p>通用块层是处于文件系统和磁盘驱动中间的一个块设备抽象层，它主要有两个功能：</p>
<ul>
<li>向上为文件系统和应用程序，提供访问块设备的标准接口，向下把各种不同的磁盘设备抽象为统一的块设备，并在内核层面，提供一个框架来管理这些设备的驱动程序；</li>
<li>通用块层还会给文件系统和应用程序发来的 I&#x2F;O 请求排队，接着会对队列重新排序、请求合并等方式，也就是 I&#x2F;O 调度，主要目的是为了提高磁盘读写的效率。</li>
</ul>
<p>Linux 内存支持 5 种 I&#x2F;O 调度算法，分别是：</p>
<ul>
<li><strong>没有调度算法</strong>：不做任何处理，通常用于虚拟机IO</li>
<li><strong>先入先出调度算法</strong></li>
<li><strong>完全公平调度算法</strong>：为每个进程维护了一个 I&#x2F;O 调度队列，并按照时间片来均匀分布每个进程的 I&#x2F;O 请求，常作为默认调度算法。</li>
<li><strong>优先级调度</strong>：优先级高的 I&#x2F;O 请求先发生， 它适用于运行大量进程的系统</li>
<li><strong>最终期限调度算法</strong>：分别为读、写请求创建了不同的 I&#x2F;O 队列，这样可以提高机械磁盘的吞吐量，并确保达到最终期限的请求被优先处理，适用于在 I&#x2F;O 压力比较大的场景，比如数据库等。</li>
</ul>
<hr>
<h3 id="存储系统-I-x2F-O-软件分层"><a href="#存储系统-I-x2F-O-软件分层" class="headerlink" title="存储系统 I&#x2F;O 软件分层"></a>存储系统 I&#x2F;O 软件分层</h3><p>Linux 存储系统的 I&#x2F;O 由上到下可以分为三个层次：</p>
<ul>
<li><strong>文件系统层</strong>，包括虚拟文件系统和其他文件系统的具体实现，它向上为应用程序统一提供了标准的文件访问接口，向下会通过通用块层来存储和管理磁盘数据。</li>
<li><strong>通用块层</strong>，包括块设备的 I&#x2F;O 队列和 I&#x2F;O 调度器，它会对文件系统的 I&#x2F;O 请求进行排队，再通过 I&#x2F;O 调度器，选择一个 I&#x2F;O 发给下一层的设备层。</li>
<li><strong>设备层</strong>，包括硬件设备、设备控制器和驱动程序，负责最终物理设备的 I&#x2F;O 操作。</li>
</ul>
<p>存储系统的 I&#x2F;O 是整个系统最慢的一个环节，所以 Linux 提供了不少缓存机制来提高 I&#x2F;O 的效率。</p>
<ul>
<li>为了提高文件访问的效率，会使用<strong>页缓存、索引节点缓存、目录项缓存</strong>等多种缓存机制，目的是为了减少对块设备的直接调用。</li>
<li>为了提高块设备的访问效率， 会使用<strong>缓冲区</strong>，来缓存块设备的数据</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230322175046656.png" style="zoom:50%;" />

<hr>
<h3 id="键盘敲入字母时，期间发生了什么？"><a href="#键盘敲入字母时，期间发生了什么？" class="headerlink" title="键盘敲入字母时，期间发生了什么？"></a>键盘敲入字母时，期间发生了什么？</h3><ul>
<li>当用户输入了键盘字符，<strong>键盘控制器</strong>就会产生扫描码数据，并将其缓冲在键盘控制器的寄存器中，紧接着键盘控制器通过总线给 CPU 发送<strong>中断请求</strong>。</li>
<li>CPU 收到中断请求后，操作系统会<strong>保存被中断进程的 CPU 上下文</strong>，然后调用键盘的<strong>中断处理程序</strong>。</li>
<li>键盘的中断处理程序是在<strong>键盘驱动程序</strong>初始化时注册的，即从键盘控制器的寄存器的缓冲区读取扫描码，再根据扫描码找到用户在键盘输入的字符。如果输入的字符是显示字符，那就会把扫描码翻译成对应显示字符的 ASCII 码</li>
<li>把 ASCII 码放到「读缓冲区队列」，显示设备的驱动程序会定时从「读缓冲区队列」读取数据放到「写缓冲区队列」，最后把「写缓冲区队列」的数据写入到显示设备控制器的寄存器中的数据缓冲区</li>
<li>最后，恢复被中断进程的上下文</li>
</ul>
<h1 id="八、网络系统"><a href="#八、网络系统" class="headerlink" title="八、网络系统"></a>八、网络系统</h1><h2 id="8-1-什么是零拷贝？"><a href="#8-1-什么是零拷贝？" class="headerlink" title="8.1 什么是零拷贝？"></a>8.1 什么是零拷贝？</h2><h3 id="传统的文件传输有多糟糕？"><a href="#传统的文件传输有多糟糕？" class="headerlink" title="传统的文件传输有多糟糕？"></a>传统的文件传输有多糟糕？</h3><p>将磁盘上的文件读取出来，然后通过网络协议发送给客户端<strong>发生了 4 次用户态与内核态的上下文切换</strong>，<strong>发生了 4 次数据拷贝</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323153949122.png" style="zoom:67%;" />

<hr>
<h3 id="如何优化文件传输的性能？"><a href="#如何优化文件传输的性能？" class="headerlink" title="如何优化文件传输的性能？"></a>如何优化文件传输的性能？</h3><p><strong>如何减少「用户态与内核态的上下文切换」的次数？</strong>  </p>
<p> 减少系统调用的次数</p>
<p><strong>如何减少「数据拷贝」的次数？</strong> </p>
<p>「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」这个过程是没有必要的。因为在用户空间我们并不会对数据「再加工」，因此<strong>用户的缓冲区是没有必要存在的</strong>。</p>
<hr>
<h3 id="如何实现零拷贝？"><a href="#如何实现零拷贝？" class="headerlink" title="如何实现零拷贝？"></a>如何实现零拷贝？</h3><p>零拷贝技术实现的方式通常有 2 种：</p>
<ul>
<li><p><strong>mmap + write</strong>：用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p>
<ul>
<li><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。而write函数直接从内核缓冲区将数据拷贝到socket缓冲区中。</li>
<li>可以减少一次数据拷贝的过程，但仍然需要 4 次上下文切换，因为系统调用还是 2 次</li>
</ul>
</li>
<li><p><strong>sendfile</strong>：这是一个专门发送文件的系统调用函数。</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">ssize_t</span> <span class="token function">sendfile</span><span class="token punctuation">(</span><span class="token keyword">int</span> out_fd<span class="token punctuation">,</span> <span class="token keyword">int</span> in_fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> <span class="token operator">*</span>offset<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用</li>
<li>该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝</li>
</ul>
<blockquote>
<p>如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术，那么可以将拷贝次数缩小为2此，从而实现<strong>零拷贝</strong>，其过程如下：</p>
<ul>
<li>通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li>
<li>缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，减少了一次数据拷贝；</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h3 id="PageCache-有什么作用？"><a href="#PageCache-有什么作用？" class="headerlink" title="PageCache 有什么作用？"></a>PageCache 有什么作用？</h3><p>把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是<strong>磁盘高速缓存（*PageCache*）</strong>。</p>
<p><strong>PageCache 的优点</strong>主要是两个：</p>
<ul>
<li>缓存最近被访问的数据；</li>
<li>预读功能；</li>
</ul>
<p><strong>但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能</strong>，这是因为：</p>
<ul>
<li>PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；</li>
<li>PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；</li>
</ul>
<p><strong>所以大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术</strong></p>
<hr>
<h3 id="大文件传输用什么方式实现？"><a href="#大文件传输用什么方式实现？" class="headerlink" title="大文件传输用什么方式实现？"></a>大文件传输用什么方式实现？</h3><p><strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I&#x2F;O + 直接 I&#x2F;O」来替代零拷贝技术</strong>。</p>
<p>异步 I&#x2F;O 工作方式如下图，异步 I&#x2F;O 并没有涉及到 PageCache，所以使用异步 I&#x2F;O 就意味着要绕开 PageCache。对于磁盘，异步 I&#x2F;O 只支持直接 I&#x2F;O。</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323160634929.png" style="zoom:67%;" />

<blockquote>
<p>直接 I&#x2F;O 应用场景常见的两种：</p>
<ul>
<li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存</li>
<li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销</li>
</ul>
<p>由于直接 I&#x2F;O 绕过了 PageCache，就无法享受内核的这两点的优化：</p>
<ul>
<li>合并IO请求从而减少磁盘寻址操作</li>
<li>预读数据从而减少对磁盘的操作</li>
</ul>
</blockquote>
<p>传输文件的时候，要根据文件的大小来使用不同的方式：</p>
<ul>
<li>传输大文件的时候，使用「异步 I&#x2F;O + 直接 I&#x2F;O」；</li>
<li>传输小文件的时候，则使用「零拷贝技术」；</li>
</ul>
<h2 id="8-2-I-x2F-O-多路复用：select-x2F-poll-x2F-epoll"><a href="#8-2-I-x2F-O-多路复用：select-x2F-poll-x2F-epoll" class="headerlink" title="8.2 I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll"></a>8.2 I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll</h2><p><strong>文件描述符的作用是什么？</strong></p>
<blockquote>
<p>每一个进程都有一个数据结构 <code>task_struct</code>，该结构体里有一个指向「文件描述符数组」的成员指针。该数组里列出这个进程打开的所有文件的文件描述符。数组的下标是文件描述符，是一个整数，而数组的内容是一个指针，指向内核中所有打开的文件的列表，也就是说内核可以通过文件描述符找到对应打开的文件。</p>
</blockquote>
<p>每个文件都有一个 inode，Socket 文件的 inode 指向了内核中的 Socket 结构，在这个结构体里有两个队列，分别是<strong>发送队列</strong>和<strong>接收队列</strong>，这个两个队列里面保存的是一个个 <code>struct sk_buff</code>，用链表的组织形式串起来。</p>
<hr>
<h3 id="select-x2F-poll"><a href="#select-x2F-poll" class="headerlink" title="select&#x2F;poll"></a>select&#x2F;poll</h3><p>select 实现多路复用的方式：</p>
<ul>
<li>将已连接的 Socket 都放到一个<strong>文件描述符集合</strong></li>
<li>然后调用 select 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生</li>
<li>检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写</li>
<li>接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里</li>
<li>发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中</li>
<li>所支持的文件描述符的个数是有限制的，但可以通过修改内核参数FD_SETSIZE 来解决</li>
</ul>
<p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p>
<p>poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong></p>
<hr>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><strong>使用</strong>:先用e poll_create 创建一个 epol l对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据</p>
<p>epoll 通过两个方面，很好解决了 select&#x2F;poll 的问题:</p>
<ul>
<li>epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，增删改一般时间复杂度是 <code>O(logn)</code>。 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</li>
<li>epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li>
</ul>
<p>epoll_wait返回数据时会将数据从内核拷贝到用户空间。</p>
<hr>
<h3 id="边缘触发和水平触发"><a href="#边缘触发和水平触发" class="headerlink" title="边缘触发和水平触发"></a>边缘触发和水平触发</h3><p>epoll 支持两种事件触发模式:</p>
<ul>
<li><strong>边缘触发</strong>：当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没一次读完数据。</li>
<li><strong>水平触发</strong>：当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong><ul>
<li>由于I&#x2F;O 事件发生时只会通知一次，因此需要<strong>循环</strong>从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里。所以，<strong>边缘触发模式一般和非阻塞 I&#x2F;O 搭配使用</strong>。</li>
</ul>
</li>
</ul>
<p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p>
<h2 id="8-3-高性能网络模式：Reactor-和-Proactor"><a href="#8-3-高性能网络模式：Reactor-和-Proactor" class="headerlink" title="8.3 高性能网络模式：Reactor 和 Proactor"></a>8.3 高性能网络模式：Reactor 和 Proactor</h2><h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p>Reactor 模式是<strong>非阻塞同步网络模式</strong>，主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：</p>
<ul>
<li>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；</li>
<li>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</li>
</ul>
<p>Reactor一般使用以下三种方案：</p>
<ul>
<li><p><strong>单 Reactor 单进程 &#x2F; 线程</strong></p>
<ul>
<li><p>Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发</p>
</li>
<li><p>如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；</p>
</li>
<li><p>如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；</p>
</li>
<li><p>缺点：</p>
<ul>
<li>无法充分利用 多核 CPU 的性能；</li>
<li>Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就造成响应的延迟；</li>
</ul>
</li>
<li><p>不适用计算机密集型的场景，只适用于业务处理非常快速的场景。</p>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323175338913.png" style="zoom:67%;" /></li>
</ul>
</li>
<li><p><strong>单 Reactor 多进程 &#x2F; 线程</strong></p>
<ul>
<li>监听和事件分发和单Reactor单线程方案一样，不一样的步骤是：<ul>
<li>Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理；</li>
<li>子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client；</li>
</ul>
</li>
<li>因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323175718048.png" style="zoom:67%;" />
</li>
<li><p><strong>多 Reactor 多进程 &#x2F; 线程</strong></p>
<ul>
<li>主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程；</li>
<li>子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。</li>
<li>如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。</li>
<li>Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h3><p><strong>Proactor 是异步网络模式</strong></p>
<p>无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 <strong>Reactor 模式是基于「待完成」的 I&#x2F;O 事件，而 Proactor 模式则是基于「已完成」的 I&#x2F;O 事件</strong>。</p>
<blockquote>
<p>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」，而 Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</p>
<ul>
<li><strong>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件</strong>。在每次感知到有事件发生后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</li>
<li><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read&#x2F;write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</li>
</ul>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323180503685.png" style="zoom:80%;" />

<p>Proactor 模式的工作流程：</p>
<ul>
<li>Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核；</li>
<li>Asynchronous Operation Processor 负责处理注册请求，并处理 I&#x2F;O 操作；</li>
<li>Asynchronous Operation Processor 完成 I&#x2F;O 操作后通知 Proactor；</li>
<li>Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理；</li>
<li>Handler 完成业务处理；</li>
</ul>
<blockquote>
<p>在 Linux 下的异步 I&#x2F;O 是不完善的， <code>aio</code> 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的</p>
<p> Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 <code>IOCP</code></p>
</blockquote>
<h1 id="8-4-什么是一致性哈希？"><a href="#8-4-什么是一致性哈希？" class="headerlink" title="8.4 什么是一致性哈希？"></a>8.4 什么是一致性哈希？</h1><blockquote>
<p>对于分布式系统，由于需要考虑负载均衡，因此需要将数据水平切分到不同节点上，访问数据的时候寻址存储该数据的节点。</p>
<p>哈希算法虽然能建立数据和节点的映射关系，但是每次在节点数量发生变化的时候，最坏情况下所有数据都需要迁移，这样太麻烦了，所以不适用节点数量变化的场景。</p>
</blockquote>
<p><strong>一致性哈希</strong>是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上（例如2^32大小的环），如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。</p>
<ul>
<li>对存储节点进行哈希计算，比如根据节点的 IP 地址进行哈希，将其映射到哈希环上；</li>
<li>当对数据进行存储或访问时，对数据进行哈希映射；</li>
</ul>
<p><strong>一致性哈希算法不能够均匀的分布节点</strong>，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。</p>
<p>解决办法：引入虚拟节点。不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，而真实节点包含多个虚拟节点。</p>
<ul>
<li>引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">mujiubai</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://mujiubai.github.io/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%94%E8%AE%B0/">https://mujiubai.github.io/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%94%E8%AE%B0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">mujiubai</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">操作系统</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/02/15/%E9%A1%B9%E7%9B%AE/Mit-6.824/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="Mit-6.824">
                        
                        <span class="card-title">Mit-6.824</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-02-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E9%A1%B9%E7%9B%AE/" class="post-category">
                                    项目
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/">
                        <span class="chip bg-color">分布式存储</span>
                    </a>
                    
                    <a href="/tags/Go/">
                        <span class="chip bg-color">Go</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/02/15/%E9%A1%B9%E7%9B%AE/mprpc-%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="mprpc-分布式通信网络框架">
                        
                        <span class="card-title">mprpc-分布式通信网络框架</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-02-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E9%A1%B9%E7%9B%AE/" class="post-category">
                                    项目
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                    <a href="/tags/RPC/">
                        <span class="chip bg-color">RPC</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">mujiubai</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">316.3k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/mujiubai" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1057378931@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1057378931" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1057378931" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/star.js"><\/script>');
            }
        </script>
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
