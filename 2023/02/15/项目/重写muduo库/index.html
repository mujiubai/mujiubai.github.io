<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="重写Muduo库笔记, w">
    <meta name="description" content="根据施磊剖析muduo网络库核心代码项目所写, 视频地址


1. 基础知识储备

1、TCP协议和UDP协议
2、TCP编程和UDP编程步骤
3、IO复用接口编程select、poll、epoll编程
4、Linux的多线程编程pthre">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>重写Muduo库笔记 | w</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">w</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">

      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/categories/C/">
          
          <span>C++</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/LeetCode/">
          
          <span>LeetCode</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
          
          <span>计算机基础知识</span>
        </a>
      </li>
      
      <li>
        <a href="/categories/%E9%A1%B9%E7%9B%AE/">
          
          <span>项目</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">w</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-bookmark"></i>
			
			分类
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/categories/C/ " style="margin-left:75px">
				  
		          <span>C++</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/LeetCode/ " style="margin-left:75px">
				  
		          <span>LeetCode</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ " style="margin-left:75px">
				  
		          <span>计算机基础知识</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories/%E9%A1%B9%E7%9B%AE/ " style="margin-left:75px">
				  
		          <span>项目</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">重写Muduo库笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/C/">
                                <span class="chip bg-color">C++</span>
                            </a>
                        
                            <a href="/tags/muduo/">
                                <span class="chip bg-color">muduo</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E9%A1%B9%E7%9B%AE/" class="post-category">
                                项目
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-02-15
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-06-20
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    14.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    58 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><em>根据施磊<strong>剖析muduo网络库核心代码</strong>项目所写</em>, <a target="_blank" rel="noopener" href="https://fixbug.ke.qq.com/">视频地址</a></p>
<hr>
<hr>
<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><p><strong>知识储备</strong></p>
<ul>
<li>1、TCP协议和UDP协议</li>
<li>2、TCP编程和UDP编程步骤</li>
<li>3、IO复用接口编程select、poll、epoll编程</li>
<li>4、Linux的多线程编程pthread、进程和线程模型 C++20标准加入了协程的支持</li>
</ul>
<h2 id="1-1-阻塞、非阻塞、同步、异步"><a href="#1-1-阻塞、非阻塞、同步、异步" class="headerlink" title="1.1 阻塞、非阻塞、同步、异步"></a>1.1 <strong>阻塞、非阻塞、同步、异步</strong></h2><blockquote>
<p>典型的一次IO的两个阶段是什么？ 数据准备 和 数据读写</p>
</blockquote>
<p> 在数据准备上，根据系统IO操作的就绪状态可以分为：</p>
<ul>
<li>阻塞：调用IO方法的线程会进入阻塞状态。比如epoll_wait（阻塞类sockfd），调用此方法，会使得线程被阻塞</li>
<li>非阻塞：调用IO方法的线程不会进入阻塞状态，不改变线程的状态，其通过调用方法返回值进行判断。</li>
</ul>
<p>在数据读写上，根据应用程序和内核的交互方式可以分为：</p>
<ul>
<li>同步：当前线程需要等待数据读写完成才能进行下一步操作。例如，当epoll_wait返回之后使用recv去读数据，此时需要等recv读完数据才能进行下一步操作</li>
<li>异步：当前线程将数据读写工作交给其他线程（如内核），读写操作完成后再通知当前线程，其无需等待当前线程完成就能进行下一步操作（在IO异步上一般都需要操作系统提供支持，如Linux下使用aio_read）。</li>
</ul>
<p><strong>陈硕大神原话：在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步IO。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328153046452.png"></p>
<p><strong>总结</strong>：无论是同步异步、阻塞非阻塞，其差异都是等待任务完成或不等任务完成而是完成后发出通知提醒（等通知，这通知是系统级别实现，而无需死等。如果应用层面则也可以是回调）。</p>
<p>上面说的同步异步指的是IO层级，应用级别的同步异步也一样（比如A需要处理任务，A向B传入需要处理的任务和任务结束后的回调函数，B在任务处理完后进行回调）</p>
<blockquote>
<p><strong>作者总结</strong>：</p>
<ul>
<li><p>一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪”和“数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。</p>
</li>
<li><p>同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。</p>
</li>
</ul>
</blockquote>
<h2 id="1-2-Unix-x2F-Linux上的五种IO模型"><a href="#1-2-Unix-x2F-Linux上的五种IO模型" class="headerlink" title="1.2 Unix&#x2F;Linux上的五种IO模型"></a>1.2 <strong>Unix&#x2F;Linux上的五种IO模型</strong></h2><p><strong>（同步）阻塞blocking</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105628921.png"></p>
<p><strong>同步非阻塞 non-blocking</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105721152.png"></p>
<p><strong>IO复用（IO multiplexing）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105734893.png"></p>
<p><strong>信号驱动（signal-driven）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105744974.png"></p>
<p>内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。</p>
<p><strong>异步不阻塞（asynchronous）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105758521.png"></p>
<p>aio_read所使用的结构体</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">aiocb</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> aio_fildes
	off_t aio_offset
	<span class="token keyword">volatile</span> <span class="token keyword">void</span> <span class="token operator">*</span>aio_buf
	size_t aio_nbytes
	<span class="token keyword">int</span> aio_reqprio
	<span class="token keyword">struct</span> <span class="token class-name">sigevent</span> aio_sigevent <span class="token comment">//信号量</span>
	<span class="token keyword">int</span> aio_lio_opcode
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="1-3-好的网络服务器设计"><a href="#1-3-好的网络服务器设计" class="headerlink" title="1.3 好的网络服务器设计"></a>1.3 <strong>好的网络服务器设计</strong></h2><blockquote>
<p>在这个多核时代，服务端网络编程如何选择线程模型呢？ 赞同libev作者的观点：one loop per thread is usually a good model，这样多线程服务端编程的问题就转换为如何设计一个高效且易于使用的event loop，然后每个线程run一个event loop就行了（当然线程间的同步、互斥少不了，还有其它的耗时事件需要起另外的线程来做）。</p>
</blockquote>
<p>event loop 是 non-blocking 网络编程的核心，在现实生活中，non-blocking 几乎总是和 IO multiplexing 一起使用，原因有两点：</p>
<ul>
<li><p>没有人真的会用轮询 (busy-pooling) 来检查某个 non-blocking IO 操作是否完成，这样太浪费</p>
<p>CPU资源了。</p>
</li>
<li><p>IO-multiplex 一般不能和 blocking IO 用在一起，因为 blocking IO 中read() &#x2F;write() &#x2F;accept() &#x2F;connect() 都有可能阻塞当前线程，这样线程就没办法处理其他 socket上的 IO 事件了。</p>
</li>
</ul>
<p>所以，当我们提到 non-blocking 的时候，实际上指的是 non-blocking + IO-multiplexing，单用其中任何一个都没有办法很好的实现功能。（这里的非阻塞主要指的还是异步，是指在当前线程中除了IO复用时进行阻塞，其他操作都不能阻塞当前线程，其实就是把处理事件交给其他线程</p>
<blockquote>
<p>epoll + fork不如epoll + pthread？</p>
<p>强大的nginx服务器采用了epoll+fork模型作为网络模块的架构设计，实现了简单好用的负载算法，使各个fork网络进程不会忙的越忙、闲的越闲，并且通过引入一把乐观锁解决了该模型导致的<strong>服务器惊群</strong>现象，功能十分强大。</p>
</blockquote>
<h2 id="1-4-Reactor模型"><a href="#1-4-Reactor模型" class="headerlink" title="1.4 Reactor模型"></a>1.4 <strong>Reactor模型</strong></h2><blockquote>
<p>The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.</p>
</blockquote>
<p><strong>重要组件</strong>：<strong>Event事件、Reactor反应堆、Demultiplex事件分发器（应该叫事件解码器，将多个事件进行聚合，如epoll）、Evanthandler事件处理器</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024113236711.png"></p>
<p>muduo库的Multiple Reactors模型如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024113253413.png"></p>
<p>在这个模型中，其实是将reactor和demultiplex都结合到reactor中，mainReactor将事件进一步细分到subReactor中（例如mainReactor负责新用户的链接，然后将这些链接分发到subReactor中）</p>
<h2 id="1-5-epoll"><a href="#1-5-epoll" class="headerlink" title="1.5 epoll"></a>1.5 <strong>epoll</strong></h2><p><strong>select的缺点</strong></p>
<ul>
<li>1、单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，当然可以更改数量，但由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；(在linux内核头文件中，有这样的定义：#define __FD_SETSIZE 1024</li>
<li>2、内核 &#x2F; 用户空间内存拷贝问题，select需要复制大量的句柄数据结构，产生巨大的开销</li>
<li>3、select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件</li>
<li>4、select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程（也不能算缺点，只是不支持ET）</li>
</ul>
<p>相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依</p>
<p>然存在。</p>
<blockquote>
<p>以select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核&#x2F;用户空间大量的句柄结构内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到100万级别的并发访问，是一个很难完成的任务。</p>
</blockquote>
<p><strong>epoll原理以及优势</strong></p>
<blockquote>
<p><strong>设想一下如下场景</strong>：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在select&#x2F;poll时代，服务器进程每次都把这100万个连接告诉操作系统（从用户态复制句柄数据结构到内核态），让操作系统内核去查询这些套接字上是否有事件发生，轮询完成后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select&#x2F;poll一般只能处理几千的并发连接。</p>
</blockquote>
<p>epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统（文件系统一般用什么数据结构实现？B+树，磁盘IO消耗低，效率很高）。把原先的select&#x2F;poll调用分成以下3个部分：</p>
<ul>
<li>调用epoll_create()建立一个epoll对象（在epoll文件系统中为这个句柄对象分配资源）</li>
<li>调用epoll_ctl向epoll对象中添加这100万个连接的套接字</li>
<li>调用epoll_wait收集发生的事件的fd资源</li>
</ul>
<p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除事件。</p>
<p>epoll_wait的效率也非常高，因为调用epoll_wait时，并没有向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接（猜测当内核得知某sockfd有消息时，会去epoll中找到对应的sockfd进行标记，而epoll的实现使得查找非常块）。</p>
<p>epoll_create在内核上创建的eventpoll结构如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span><span class="token punctuation">&#123;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span>
<span class="token keyword">struct</span> <span class="token class-name">rb_root</span> rbr<span class="token punctuation">;</span>
<span class="token comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span>
<span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdlist<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>LT模式</strong></p>
<p>内核数据没被读完，就会一直上报数据。</p>
<p><strong>ET模式</strong></p>
<p>内核数据只上报一次。</p>
<p><strong>muduo采用的是LT</strong></p>
<ul>
<li>不会丢失数据或者消息<ul>
<li>应用没有读取完数据，内核是会不断上报的</li>
</ul>
</li>
<li>低延迟处理<ul>
<li>每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息</li>
</ul>
</li>
<li>跨平台处理<ul>
<li>像select一样可以跨平台使用</li>
</ul>
</li>
</ul>
<h1 id="2-muduo"><a href="#2-muduo" class="headerlink" title="2. muduo"></a>2. muduo</h1><p>muduo主要分为了以下几大类：</p>
<ul>
<li><strong>Channel</strong>：封装了每个sockfd设置感兴趣事件和对发生事件的处理，其成员主要包括fd、events、revents、callbacks </li>
<li><strong>Poller</strong>：封装系统IO复用的通用接口，其主要成员包括ownerLoop、记录注册的channels<ul>
<li><strong>EPollPoller</strong>：Poller类的派生类，使用epoll实现了Poller类的各种接口，其成员包括epollfd、记录发生事件的events_</li>
</ul>
</li>
<li><strong>EventLoop</strong>：是一个Reactor，其作为Poller类和Channel类的使用者，Poller和Channel的通信都是通过EventLoop来完成，其使用Poller类来获得发生事件的Channel，然后调用Channel的相应回调。<ul>
<li>主要成员包括poller、wakeupfd（唤醒当前Eventloop）、activeChannels_(记录发生事件的channel)、pendingFuctors_（当前需要执行的回调）。</li>
</ul>
</li>
<li><strong>Thread</strong>：封装了线程创建、线程启动等线程基础操作</li>
<li><strong>EventLoopThread</strong>：将EventLoop和Thread绑定，封装成一个Thread执行一个loop<ul>
<li><strong>EventLoopThreadPool</strong>：EventLoopThread的线程池封装，使得mainLoop更方便进行subLoop任务的分发</li>
</ul>
</li>
<li><strong>Socket</strong>：封装socket的常用操作，如设置非阻塞、监听、noDelay等，但并不包含创建sockfd</li>
<li><strong>Acceptor</strong>：主要封装了listenfd相关的操作，其监听新连接用户，并分发给subLoop</li>
<li><strong>Buffer</strong>：封装缓冲区常见操作，其内部是一个char类型的vector</li>
<li><strong>TcpConnection</strong>：封装一个连接信息，其内包含本地地址、对端地址、socket、channel、以及读写buffer</li>
<li><strong>TcpServer</strong>：上述所有类的综合使用者，用户通过使用此类来设置各种回调，通过此类来管理subLoop个数等</li>
</ul>
<p><strong>读</strong>：</p>
<ul>
<li>设置读事件回调</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110214049385.png"></p>
<ul>
<li>当读事件发生</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110214042301.png"></p>
<p><strong>写</strong>：</p>
<ul>
<li><p>发送数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110215931048.png"></p>
</li>
<li><p>当写事件发生：和读事件发生流程一样，只是最后一步执行的writeCallback</p>
</li>
</ul>
<p><strong>新用户到来</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110214730307.png"></p>
<p><strong>服务器启动</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110215755177.png"></p>
<p>流程图都在飞书的processon上</p>
<h2 id="2-1-Channel"><a href="#2-1-Channel" class="headerlink" title="2.1 Channel"></a>2.1 Channel</h2><p>封装了每个sockfd设置感兴趣事件函数和对发生事件的处理，注意！Channel不直接与Poller打交道，其通过EventLoop来与Poller进行通信，比如向Poller中设置感兴趣事件，Poller返回事件等。</p>
<p>通过设置sockfd的各种回调，当有事件发生时，Poller调用每个事件对应channel的<em>HandleEvent</em>函数进行判断处理发生了哪些事件以及调用相应回调</p>
<p><strong>成员变量</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//这三个是作为事件标识</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kNoneEvent<span class="token punctuation">;</span>   <span class="token comment">// 0</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kReadEvent<span class="token punctuation">;</span>   <span class="token comment">// EPOLLIN | EPOLLPRI</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kWriteEvent<span class="token punctuation">;</span>  <span class="token comment">// EPOLLOUT;</span>

EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>  <span class="token comment">//事件循环</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> fd_<span class="token punctuation">;</span>     <span class="token comment">//监听的sockfd</span>
<span class="token keyword">int</span> revents_<span class="token punctuation">;</span>      <span class="token comment">//返回的事件</span>
<span class="token keyword">int</span> events_<span class="token punctuation">;</span>       <span class="token comment">// sockfd上监听的事件</span>
<span class="token keyword">int</span> index_<span class="token punctuation">;</span>  <span class="token comment">// 此Poller的状态，如新添加、已删除等，主要是用于Poller中判断状态</span>

<span class="token comment">//绑定TcpConnection对象的弱引用，可用于判断对象是否存活和得到shared指针</span>
<span class="token comment">//用于观察注册回调的TcpConnection对象是否存活，避免调用回调函数时出错</span>
std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> tie_<span class="token punctuation">;</span>
<span class="token keyword">bool</span> tied_<span class="token punctuation">;</span>  <span class="token comment">//是否绑定标志</span>

<span class="token comment">//用于处理revents的四种回调函数</span>
ReadEventCallback readCallback_<span class="token punctuation">;</span>
EventCallback writeCallback_<span class="token punctuation">;</span>
EventCallback closeCallback_<span class="token punctuation">;</span>
EventCallback errorCallback_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>成员函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>
 <span class="token keyword">using</span> EventCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>
 <span class="token keyword">using</span> ReadEventCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>Timestamp<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>
 <span class="token function">Channel</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">~</span><span class="token function">Channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// fd得到poller通知以后，处理事件的函数</span>
 <span class="token keyword">void</span> <span class="token function">HandleEvent</span><span class="token punctuation">(</span>Timestamp receiveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">//设置回调函数</span>
 <span class="token keyword">void</span> <span class="token function">setReadCallback</span><span class="token punctuation">(</span>ReadEventCallback cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   readCallback_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>  <span class="token comment">//这里使用move感觉没啥用，除非function中有申请的资源</span>
 <span class="token keyword">void</span> <span class="token function">setWriteCallback</span><span class="token punctuation">(</span>EventCallback cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> writeCallback_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token keyword">void</span> <span class="token function">setCloseCallback</span><span class="token punctuation">(</span>EventCallback cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> closeCallback_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token keyword">void</span> <span class="token function">setErrorCallback</span><span class="token punctuation">(</span>EventCallback cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> errorCallback_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

 <span class="token comment">//绑定TcpConnection对象，防止当TcpConnection对象被手动remove后，channel还在执行回调操作</span>
 <span class="token keyword">void</span> <span class="token function">tie</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">int</span> <span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> fd_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
 <span class="token comment">//获取当前设置的Event</span>
 <span class="token keyword">int</span> <span class="token function">events</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> events_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token comment">//供poller设置发生事件</span>
 <span class="token keyword">int</span> <span class="token function">setRevents</span><span class="token punctuation">(</span><span class="token keyword">int</span> revt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> revents_ <span class="token operator">=</span> revt<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  

 <span class="token comment">//设置或取消读 写事件:</span>
 <span class="token keyword">void</span> <span class="token function">enableReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   events_ <span class="token operator">|=</span> kReadEvent<span class="token punctuation">;</span>
   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>
 <span class="token keyword">void</span> <span class="token function">disableReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   events_ <span class="token operator">&amp;=</span> <span class="token operator">~</span>kReadEvent<span class="token punctuation">;</span>
   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>
 <span class="token keyword">void</span> <span class="token function">enableWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   events_ <span class="token operator">|=</span> kWriteEvent<span class="token punctuation">;</span>
   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>
 <span class="token keyword">void</span> <span class="token function">disableWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   events_ <span class="token operator">&amp;=</span> <span class="token operator">~</span>kWriteEvent<span class="token punctuation">;</span>
   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>
 <span class="token keyword">void</span> <span class="token function">disableAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   events_ <span class="token operator">=</span> kNoneEvent<span class="token punctuation">;</span>
   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>

 <span class="token comment">//判断当前事件状态，是否设置读或写事件或无事件</span>
 <span class="token keyword">bool</span> <span class="token function">isWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> events_ <span class="token operator">&amp;</span> kWriteEvent<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token keyword">bool</span> <span class="token function">isReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> events_ <span class="token operator">&amp;</span> kReadEvent<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token keyword">bool</span> <span class="token function">isNoneEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> events_ <span class="token operator">==</span> kNoneEvent<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

 <span class="token comment">//得到Channel状态</span>
 <span class="token keyword">int</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> index_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token comment">//设置Channel状态</span>
 <span class="token keyword">void</span> <span class="token function">setIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> index_ <span class="token operator">=</span> index<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

 <span class="token comment">//返回此channel所属的eventloop</span>
 EventLoop <span class="token operator">*</span><span class="token function">ownerLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> loop_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token comment">//在所属的eventloop移除此channel</span>
 <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
 <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//更新poller中对应的channel的事件</span>
 <span class="token comment">//安全的处理事件，作为handleEvent函数的底层函数</span>
 <span class="token keyword">void</span> <span class="token function">handleEventWithGuard</span><span class="token punctuation">(</span>Timestamp receiveTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-2-Poller"><a href="#2-2-Poller" class="headerlink" title="2.2 Poller"></a>2.2 Poller</h2><h3 id="2-2-1-Poller基类"><a href="#2-2-1-Poller基类" class="headerlink" title="2.2.1 Poller基类"></a>2.2.1 Poller基类</h3><p>主要封装统一IO复用的接口，以便实现Poll、Epoll等。其成员比较简单，就一个channels记录管理的channel和ownerLoop记录所属的EventLoop</p>
<p><strong>成员变量</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">protected</span><span class="token operator">:</span>
 <span class="token comment">// key:sockfd value:sockfd所属的channel通道类型</span>
 <span class="token keyword">using</span> ChannelMap <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> Channel <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span>
 ChannelMap channels_<span class="token punctuation">;</span><span class="token comment">//记录管理的Channel</span>

<span class="token keyword">private</span><span class="token operator">:</span>
 EventLoop <span class="token operator">*</span>ownerLoop_<span class="token punctuation">;</span><span class="token comment">//记录poller绑定的EventLoop</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>成员函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>
 <span class="token keyword">using</span> ChannelList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Channel <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span>
 <span class="token function">Poller</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Poller</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>

 <span class="token comment">//统一IO复用接口，扩展类如select、poll和Epoll都必须实现这几个接口</span>
 <span class="token keyword">virtual</span> Timestamp <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">int</span> timeousMs<span class="token punctuation">,</span> ChannelList <span class="token operator">*</span>activeChannels<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">updateChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">removeChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

 <span class="token comment">//判断channel是否存在此poller中</span>
 <span class="token keyword">bool</span> <span class="token function">hasChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

 <span class="token comment">// eventloop通过该接口获取默认的IO复用的具体实现</span>
 <span class="token comment">//为避免基类引用派生类头文件，此函数是在一个单独的cc文件中进行实现</span>
 <span class="token keyword">static</span> Poller <span class="token operator">*</span><span class="token function">newDefaultPoller</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>关键</strong></p>
<p>hasChannel函数中通过判断channel指针避免了由于sockfd复用而导致的错乱情况</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token class-name">Poller</span><span class="token double-colon punctuation">::</span><span class="token function">hasChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> it<span class="token operator">=</span>channels_<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>channel<span class="token operator">-></span><span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//it->second==channel应该是为了避免sockfd被复用时而channel不对的情况</span>
    <span class="token keyword">return</span> it<span class="token operator">!=</span>channels_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>it<span class="token operator">-></span>second<span class="token operator">==</span>channel<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-2-2-EPollPoller"><a href="#2-2-2-EPollPoller" class="headerlink" title="2.2.2 EPollPoller"></a>2.2.2 EPollPoller</h3><p>基于Poller接口实现了Epoll，相比Poller，主要增加了epollfd和events成员以及epoll常用函数的封装</p>
<p><strong>成员变量</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> EventList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>epoll_event<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token keyword">int</span> epollfd_<span class="token punctuation">;</span><span class="token comment">//epoll的fd</span>
EventList events_<span class="token punctuation">;</span><span class="token comment">//记录epoll返回的发生事件</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kInitEventListSize <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>  <span class="token comment">//给events的初始长度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>成员函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>
 <span class="token function">EPollPoller</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">~</span><span class="token function">EPollPoller</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>
 
 <span class="token comment">//重写Poller的抽象方法</span>
 Timestamp <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">int</span> timeoutMs<span class="token punctuation">,</span> ChannelList <span class="token operator">*</span>activeChannels<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">updateChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">removeChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
 <span class="token comment">//将poll返回的发生事件的channel写入到activeChannels中</span>
 <span class="token keyword">void</span> <span class="token function">fillActiveChannels</span><span class="token punctuation">(</span><span class="token keyword">int</span> numEvents<span class="token punctuation">,</span> ChannelList <span class="token operator">*</span>activeChannels<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
 <span class="token comment">//更新channel通道设置的事件</span>
 <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> operation<span class="token punctuation">,</span> Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-3-EventLoop"><a href="#2-3-EventLoop" class="headerlink" title="2.3 EventLoop"></a>2.3 EventLoop</h2><p>EventLoop相当于提供了一个Reactor，通过Poller来获取发生的事件，再调用相应的channel的回调函数</p>
<p><strong>成员变量</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> ChannelList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Channel <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>atomic_bool looping_<span class="token punctuation">;</span>  <span class="token comment">//原子操作，通过CAS实现</span>
std<span class="token double-colon punctuation">::</span>atomic_bool quit_<span class="token punctuation">;</span>     <span class="token comment">//标志是否退出loop循环</span>
<span class="token keyword">const</span> pid_t threadId_<span class="token punctuation">;</span>      <span class="token comment">//当前loop所在线程id</span>
Timestamp pollReturnTime_<span class="token punctuation">;</span>  <span class="token comment">// poller返回发生事件的时间点</span>
std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Poller<span class="token operator">></span> poller_<span class="token punctuation">;</span>

<span class="token comment">//唤醒当前loop所在线程的fd</span>
<span class="token keyword">int</span> wakeupFd_<span class="token punctuation">;</span>  <span class="token comment">//当mainLoop获取新用户channel时，通过轮询算法选择一个subloop，通过该成员唤醒subLoop处理channel</span>
std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Channel<span class="token operator">></span> wakeupChanel_<span class="token punctuation">;</span>  <span class="token comment">// wakeupfd_的channel的指针</span>

ChannelList activeChannels_<span class="token punctuation">;</span>  <span class="token comment">//记录发生事件的所有channel</span>
Channel <span class="token operator">*</span>currentActiveChannel_<span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>atomic_bool callingPendingFuctors_<span class="token punctuation">;</span>  <span class="token comment">//当前loop是否有需要执行的回调操作</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Functor<span class="token operator">></span> pendingFuctors_<span class="token punctuation">;</span>  <span class="token comment">//存储loop需要执行的所有回调操作</span>
std<span class="token double-colon punctuation">::</span>mutex mutex_<span class="token punctuation">;</span>  <span class="token comment">//保护pendingFuctors_的线程安全操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>成员函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>
 <span class="token keyword">using</span> Functor <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>

 <span class="token function">EventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">~</span><span class="token function">EventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">//开启事件循环</span>
 <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//退出事件循环</span>
 <span class="token keyword">void</span> <span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 Timestamp <span class="token function">pollReturnTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> pollReturnTime_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

 <span class="token comment">//在当前loop中执行</span>
 <span class="token keyword">void</span> <span class="token function">runInLoop</span><span class="token punctuation">(</span>Functor cb<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//把cb放入队列中，唤醒loop所在的线程，再执行cb</span>
 <span class="token keyword">void</span> <span class="token function">queueInLoop</span><span class="token punctuation">(</span>Functor cb<span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">//唤醒loop所在线程</span>
 <span class="token keyword">void</span> <span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">// eventloop使用poller对channel操作的方法</span>
 <span class="token keyword">void</span> <span class="token function">updateChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">removeChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">bool</span> <span class="token function">hasChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">//判断eventloop对象是否在自己线程中</span>
 <span class="token keyword">bool</span> <span class="token function">isInLoopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> threadId_ <span class="token operator">==</span> <span class="token class-name">CurrentThread</span><span class="token double-colon punctuation">::</span><span class="token function">tid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
 <span class="token keyword">void</span> <span class="token function">handleRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// wakeupfd_的读回调函数</span>
 <span class="token keyword">void</span> <span class="token function">doPendingFunctors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//执行需要执行的回调操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-4-Thread"><a href="#2-4-Thread" class="headerlink" title="2.4 Thread"></a>2.4 Thread</h2><p><strong>成员变量</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> started_<span class="token punctuation">;</span><span class="token comment">//是否已经启动</span>
<span class="token keyword">bool</span> joined_<span class="token punctuation">;</span><span class="token comment">//是否join</span>
<span class="token comment">//使用智能指针，避免使用thread初始化是就开始启动线程</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">></span> thread_<span class="token punctuation">;</span>
pid_t tid_<span class="token punctuation">;</span><span class="token comment">//记录线程id</span>
ThreadFunc func_<span class="token punctuation">;</span><span class="token comment">//线程执行的回调函数</span>
std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span><span class="token comment">//线程名</span>

<span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>atomic_int numCreated_<span class="token punctuation">;</span><span class="token comment">//现有线程创建个数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>成员函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>
 <span class="token keyword">using</span> ThreadFunc <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>

 <span class="token keyword">explicit</span> <span class="token function">Thread</span><span class="token punctuation">(</span>ThreadFunc<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">~</span><span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">//启动线程</span>
 <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">//获取线程是否启动</span>
 <span class="token keyword">bool</span> <span class="token function">started</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> started_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token comment">//获取线程id</span>
 pid_t <span class="token function">tid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> tid_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token comment">//获取设置的线程名</span>
 <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> name_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

 <span class="token comment">//获取当前通过Thread创建的线程数量</span>
 <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numCreated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> numCreated_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
 <span class="token keyword">void</span> <span class="token function">setDefaultName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>关键</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//一个thread对象记录的就是一个新线程的详细信息</span>
<span class="token keyword">void</span> <span class="token class-name">Thread</span><span class="token double-colon punctuation">::</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  started_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  sem_t sem<span class="token punctuation">;</span>  <span class="token comment">//信号量 muduo书中说多线程别用信号量？？</span>
  <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//开启线程，</span>
  thread_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//获取线程的tid值</span>
    tid_ <span class="token operator">=</span> <span class="token class-name">CurrentThread</span><span class="token double-colon punctuation">::</span><span class="token function">tid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//开启一个新线程，专门执行该线程函数</span>
    <span class="token function">func_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//必须等待上面新创建的线程的tid值</span>
  <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-5-EventLoopThread"><a href="#2-5-EventLoopThread" class="headerlink" title="2.5 EventLoopThread"></a>2.5 EventLoopThread</h2><p>将EventLoop和Thread绑定，封装成一个Thread执行一个loop</p>
<p><strong>成员变量</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>
<span class="token keyword">bool</span> exiting_<span class="token punctuation">;</span>      <span class="token comment">//线程是否正在退出</span>
Thread thread_<span class="token punctuation">;</span>     <span class="token comment">//线程</span>
std<span class="token double-colon punctuation">::</span>mutex mutex_<span class="token punctuation">;</span>  <span class="token comment">//互斥访问loop_</span>
std<span class="token double-colon punctuation">::</span>condition_variable cond_<span class="token punctuation">;</span>  <span class="token comment">//条件变量，用于是否已经成功创建通信</span>
ThreadInitCallback callback_<span class="token punctuation">;</span>  <span class="token comment">//上层设置的回调函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>成员函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>
 <span class="token keyword">using</span> ThreadInitCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>
 <span class="token function">EventLoopThread</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadInitCallback <span class="token operator">&amp;</span>cb <span class="token operator">=</span> <span class="token function">ThreadInitCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                 <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">~</span><span class="token function">EventLoopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">//创建线程，启动loop</span>
 EventLoop <span class="token operator">*</span><span class="token function">startLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
 <span class="token comment">//线程创建时传入的回调函数，里面进行创建loop等操作</span>
 <span class="token keyword">void</span> <span class="token function">threadFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-5-1-EventLoopThreadPool"><a href="#2-5-1-EventLoopThreadPool" class="headerlink" title="2.5.1 EventLoopThreadPool"></a>2.5.1 EventLoopThreadPool</h3><p>封装成一个线程池，使得TcpServer能更方便管理多个subLoop。</p>
<p><strong>成员变量</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// mainReactor，设置这个成员是考虑轮询算法寻找subLoop时，当不存在subLoop时能将mainLoop作为作为返回结果</span>
EventLoop <span class="token operator">*</span>baseLoop_<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span>
<span class="token keyword">bool</span> started_<span class="token punctuation">;</span>
<span class="token keyword">int</span> numThreads_<span class="token punctuation">;</span>
<span class="token comment">//轮询时下一个位置指向</span>
<span class="token keyword">int</span> next_<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>EventLoopThread<span class="token operator">>></span> threads_<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>EventLoop <span class="token operator">*</span><span class="token operator">></span> loops_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>成员函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>
 <span class="token keyword">using</span> ThreadInitCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>

 <span class="token function">EventLoopThreadPool</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>baseLoop<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>nameArg<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">~</span><span class="token function">EventLoopThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">void</span> <span class="token function">setThreadNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> numThreads<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> numThreads_ <span class="token operator">=</span> numThreads<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadInitCallback <span class="token operator">&amp;</span>cb <span class="token operator">=</span> <span class="token function">ThreadInitCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">//如果工作在多线程中，baseLoop以轮询方式分配channel给subloop</span>
 EventLoop <span class="token operator">*</span><span class="token function">getNextLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>EventLoop <span class="token operator">*</span><span class="token operator">></span> <span class="token function">getAllLoops</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">bool</span> <span class="token function">started</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> started_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> name_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>关键</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">EventLoopThreadPool</span><span class="token double-colon punctuation">::</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadInitCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  started_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numThreads_<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>name_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> buf<span class="token punctuation">,</span> <span class="token string">"%s%d"</span><span class="token punctuation">,</span> name_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    EventLoopThread <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">EventLoopThread</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    threads_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>EventLoopThread<span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//底层创建线程，绑定一个新的Eventloop，并记录该loop地址</span>
    loops_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token operator">-></span><span class="token function">startLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">//没有创建其他线程，只有一个mainLoop</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>numThreads_ <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">cb</span><span class="token punctuation">(</span>baseLoop_<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//如果用户传了cb则需执行下回调******************</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-6-Socket"><a href="#2-6-Socket" class="headerlink" title="2.6 Socket"></a>2.6 Socket</h2><p>Socket封装socket的常用操作，如设置非阻塞、监听、noDelay等，但并不包含创建sockfd。</p>
<p>注意与Channel的区别，Channel是管理事件和事件发生回调，而Socket则设置socket的属性、绑定监听等</p>
<p><strong>成员变量</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> sockfd_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>成员函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>
 <span class="token keyword">explicit</span> <span class="token function">Socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">sockfd_</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
 <span class="token operator">~</span><span class="token function">Socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">int</span> <span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> sockfd_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token keyword">void</span> <span class="token function">bindAddress</span><span class="token punctuation">(</span><span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>localAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span>InetAddress <span class="token operator">*</span>peeraddr<span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">void</span> <span class="token function">shutdownWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">//设置不等待而直接发送</span>
 <span class="token keyword">void</span> <span class="token function">setTcpNoDelay</span><span class="token punctuation">(</span><span class="token keyword">bool</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//设置端口释放后立即就可以被再次使用</span>
 <span class="token keyword">void</span> <span class="token function">setReuseAddr</span><span class="token punctuation">(</span><span class="token keyword">bool</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//允许许多个线程或进程，绑定在同一个端口上</span>
 <span class="token keyword">void</span> <span class="token function">setReusePort</span><span class="token punctuation">(</span><span class="token keyword">bool</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//设置是否开启心跳</span>
 <span class="token keyword">void</span> <span class="token function">setKeepAlive</span><span class="token punctuation">(</span><span class="token keyword">bool</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-7-Acceptor"><a href="#2-7-Acceptor" class="headerlink" title="2.7 Acceptor"></a>2.7 Acceptor</h2><p>封装了listenfd相关的操作，其监听新连接用户，并分发给subLoop</p>
<p><strong>成员变量</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>  <span class="token comment">// acceptor使用的用户定义的loop，也叫mainloop</span>
Socket acceptSocket_<span class="token punctuation">;</span><span class="token comment">//listenfd对应的socket</span>
Channel acceptChannel_<span class="token punctuation">;</span><span class="token comment">//listenfd对应的channel</span>
NewConnectionCallback newConnectionCallback_<span class="token punctuation">;</span>  <span class="token comment">//当有新连接到来，需要做的回调</span>
<span class="token keyword">bool</span> listenning_<span class="token punctuation">;</span><span class="token comment">//是否监听标志</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>成员函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>
 <span class="token keyword">using</span> NewConnectionCallback <span class="token operator">=</span>
     std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>

 <span class="token function">Acceptor</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>listenAddr<span class="token punctuation">,</span> <span class="token keyword">bool</span> reuseport<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">~</span><span class="token function">Acceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">void</span> <span class="token function">setNewConnectionCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> NewConnectionCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   newConnectionCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>

 <span class="token keyword">bool</span> <span class="token function">listenning</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> listenning_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token comment">//开始监听</span>
 <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
 <span class="token comment">// listenfd有事件发生即有新用户连接，调用此函数</span>
 <span class="token keyword">void</span> <span class="token function">handleRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>关键</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// listenfd有事件发生即有新用户连接，调用此函数</span>
<span class="token keyword">void</span> <span class="token class-name">Acceptor</span><span class="token double-colon punctuation">::</span><span class="token function">handleRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  InetAddress peerAddr<span class="token punctuation">;</span>
  <span class="token keyword">int</span> connfd <span class="token operator">=</span> acceptSocket_<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>peerAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>connfd <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newConnectionCallback_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">//轮询找到subloop，将其唤醒，分发当前客户端的channel</span>
      <span class="token function">newConnectionCallback_</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> peerAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
      <span class="token double-colon punctuation">::</span><span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"%s:%s:%d accept err:%d \n"</span><span class="token punctuation">,</span> <span class="token constant">__FILE__</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span>
              errno<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// EMFILE表示服务器sockfd资源用完</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EMFILE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"%s:%s:%d sockfd reached limit \n"</span><span class="token punctuation">,</span> <span class="token constant">__FILE__</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">,</span>
                <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-8-Buffer"><a href="#2-8-Buffer" class="headerlink" title="2.8 Buffer"></a>2.8 <strong>Buffer</strong></h2><p>封装缓冲区常见操作，其内部是一个char类型的vector</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer</span>
<span class="token comment">///</span>
<span class="token comment">/// @code</span>
<span class="token comment">/// +-------------------+------------------+------------------+</span>
<span class="token comment">/// | prependable bytes |  readable bytes  |  writable bytes  |</span>
<span class="token comment">/// |                   |     (CONTENT)    |                  |</span>
<span class="token comment">/// +-------------------+------------------+------------------+</span>
<span class="token comment">/// |                   |                  |                  |</span>
<span class="token comment">/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>成员变量</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> buffer_<span class="token punctuation">;</span>  <span class="token comment">//缓冲区</span>
size_t readerIndex_<span class="token punctuation">;</span>        <span class="token comment">//可读位置</span>
size_t writerIndex_<span class="token punctuation">;</span>        <span class="token comment">//可写位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>成员函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>
 <span class="token keyword">static</span> <span class="token keyword">const</span> size_t kCheapPrepend <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
 <span class="token keyword">static</span> <span class="token keyword">const</span> size_t kInitialSize <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
 <span class="token keyword">explicit</span> <span class="token function">Buffer</span><span class="token punctuation">(</span>size_t initialSize <span class="token operator">=</span> kInitialSize<span class="token punctuation">)</span>
     <span class="token operator">:</span> <span class="token function">buffer_</span><span class="token punctuation">(</span>kCheapPrepend <span class="token operator">+</span> initialSize<span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token function">readerIndex_</span><span class="token punctuation">(</span>kCheapPrepend<span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token function">writerIndex_</span><span class="token punctuation">(</span>kCheapPrepend<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

 <span class="token comment">//可读数据长度</span>
 size_t <span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> writerIndex_ <span class="token operator">-</span> readerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token comment">//可写数据长度</span>
 size_t <span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> buffer_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> writerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token comment">//预留空间长度，初始的预留空间是为消息长度而准备</span>
 size_t <span class="token function">prependableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> readerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

 <span class="token comment">//返回缓冲区中可读地址的起始地址</span>
 <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> readerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

 <span class="token comment">//读取len长度后调用此函数</span>
 <span class="token keyword">void</span> <span class="token function">retrieve</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token comment">//如果数据没读完</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
     readerIndex_ <span class="token operator">+=</span> len<span class="token punctuation">;</span>  <span class="token comment">//应用只读取了可读缓冲区的一部分，</span>
   <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
     <span class="token function">retrieveAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//已经读完，需将缓冲区复位为初始状态</span>
   <span class="token punctuation">&#125;</span>
 <span class="token punctuation">&#125;</span>
 <span class="token keyword">void</span> <span class="token function">retrieveAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> readerIndex_ <span class="token operator">=</span> writerIndex_ <span class="token operator">=</span> kCheapPrepend<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

 <span class="token comment">//把onMessage函数上报的buffer数据，转成string类型返回</span>
 std<span class="token double-colon punctuation">::</span>string <span class="token function">retrieveAllAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">return</span> <span class="token function">retrieveAsString</span><span class="token punctuation">(</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>

 std<span class="token double-colon punctuation">::</span>string <span class="token function">retrieveAsString</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   std<span class="token double-colon punctuation">::</span>string <span class="token function">result</span><span class="token punctuation">(</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">//上面已经把缓冲区的数据读出，需要对缓冲区进行复位操作</span>
   <span class="token function">retrieve</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> result<span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>

 <span class="token comment">//确保len长度的数据能被写入</span>
 <span class="token keyword">void</span> <span class="token function">ensureWriteableBytes</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
     <span class="token function">makeSpace</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
 <span class="token punctuation">&#125;</span>

 <span class="token comment">//把data中的len长的数据添加到缓冲区中</span>
 <span class="token keyword">void</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> data<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token function">ensureWriteableBytes</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
   std<span class="token double-colon punctuation">::</span><span class="token function">copy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> data <span class="token operator">+</span> len<span class="token punctuation">,</span> <span class="token function">beginWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   writerIndex_ <span class="token operator">+=</span> len<span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>

 <span class="token comment">//从fd上读取数据</span>
 size_t <span class="token function">readFd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> saveErrno<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//通过fd发送数据</span>
 size_t <span class="token function">writeFd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> saveErrno<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
 <span class="token comment">//返回buffer首元素地址，即数组的起始地址，&amp;*不能抵消，因为*被重写过</span>
 <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token operator">*</span>buffer_<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token operator">*</span>buffer_<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

 <span class="token comment">//通过整理buffer空间或增加buffer空间使得容量够写</span>
 <span class="token keyword">void</span> <span class="token function">makeSpace</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token comment">//如果可写空间加上前面预留空间（预留空间可能由于依次被读完而变长）还是小于要求的长度</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">prependableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> len <span class="token operator">+</span> kCheapPrepend<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
     buffer_<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>writerIndex_ <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
     <span class="token comment">//如果数据空间够用，则将现有数据前移</span>
     size_t readable <span class="token operator">=</span> <span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     std<span class="token double-colon punctuation">::</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> readerIndex_<span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
               <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> kCheapPrepend<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
 <span class="token punctuation">&#125;</span>

 <span class="token comment">//返回可写处的指针</span>
 <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">beginWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> writerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">beginWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> writerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>关键</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/**
 * @brief 从fd上读取数据  低层的Poller工作在LT模式
 * buffer缓冲区有大小，但是从fd上读数据时，却不知道tcp数据最终的大小，
 * 如果不断将buffer进行扩容，效率很低;而如果预先就设为很大空间，当用户数量很多时，内存容量消耗极大
 * 因此，使用一个栈上临时变量来存储现有缓冲区不够存的数据，最后将其写入缓冲区中
 * @param fd sockfd
 * @param saveErrno 错误
 * @return size_t 成功读取大小
 */</span>
size_t <span class="token class-name">Buffer</span><span class="token double-colon punctuation">::</span><span class="token function">readFd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> saveErrno<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">char</span> extrabuf<span class="token punctuation">[</span><span class="token number">65536</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">//栈上空间 64k</span>
  <span class="token keyword">struct</span> <span class="token class-name">iovec</span> vec<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// buffer缓冲区剩余的可写空间大小</span>
  <span class="token keyword">const</span> size_t writeable <span class="token operator">=</span> <span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_base <span class="token operator">=</span> <span class="token function">beginWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_len <span class="token operator">=</span> writeable<span class="token punctuation">;</span>

  vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_base <span class="token operator">=</span> extrabuf<span class="token punctuation">;</span>
  vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_len <span class="token operator">=</span> <span class="token keyword">sizeof</span> extrabuf<span class="token punctuation">;</span>

  <span class="token comment">/**************************************************************************/</span>
  <span class="token comment">//当缓冲区可写空间小于extrabuf时，使用buffer和extrabuf一起作为readv写入的空间</span>
  <span class="token comment">//反之，如果可写空间大于extrabuf空间时，就没有必要再使用一个extrabuf来作为暂存了</span>
  <span class="token comment">//因为buffer在写入数据时，如果空间不够会自动扩容为原来2倍，而即使加上一个extrabuf能存储的数据也没有扩容后的大</span>
  <span class="token comment">//这样效率效率还没有直接使用一个buffer让其自动扩容效率高，毕竟buffer</span>
  <span class="token comment">//resize时也会进行拷贝复制</span>
  <span class="token comment">//使用extra就会在readv中写入一次数据，还需再将其拷贝到buffer中，而不使用的话就是只有readv将数据写入到buf中</span>
  <span class="token comment">// extrabuf的使用原因是为了避免buffer不断扩容而导致效率低</span>
  <span class="token comment">//这里不用担心如果空间不够存，使用的是LT模式，没读完的数据后面会不断唤醒读</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> iovcnt <span class="token operator">=</span> <span class="token punctuation">(</span>writeable <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span> extrabuf<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token comment">// readv能自动将数据写入到多个缓冲区中，缓冲区都在vec数组中</span>
  <span class="token keyword">const</span> size_t n <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">readv</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> vec<span class="token punctuation">,</span> iovcnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">*</span>saveErrno <span class="token operator">=</span> errno<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> writeable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// buffer的缓冲区够存储数据</span>
    writerIndex_ <span class="token operator">+=</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// extrabuf里也写入了数据</span>
    writerIndex_ <span class="token operator">=</span> buffer_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将extrabuf追加到buffer中</span>
    <span class="token function">append</span><span class="token punctuation">(</span>extrabuf<span class="token punctuation">,</span> n <span class="token operator">-</span> writeable<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-9-TcpConnection"><a href="#2-9-TcpConnection" class="headerlink" title="2.9 TcpConnection"></a>2.9 <strong>TcpConnection</strong></h2><p>封装一个连接信息，其内包含本地地址、对端地址、socket、channel、以及读写buffer</p>
<p><strong>成员变量</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>  <span class="token comment">// subLoop地址</span>
  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>atomic_int state_<span class="token punctuation">;</span><span class="token comment">//TcpConnection状态</span>
  <span class="token keyword">bool</span> reading_<span class="token punctuation">;</span>  <span class="token comment">//可读标志</span>

  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Socket<span class="token operator">></span> socket_<span class="token punctuation">;</span><span class="token comment">//one Tcpconnection one socket</span>
  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Channel<span class="token operator">></span> channel_<span class="token punctuation">;</span><span class="token comment">//one Tcpconnection one channel</span>

  <span class="token keyword">const</span> InetAddress localAddr_<span class="token punctuation">;</span>  <span class="token comment">//本地地址</span>
  <span class="token keyword">const</span> InetAddress peerAddr_<span class="token punctuation">;</span>   <span class="token comment">//对端地址</span>

  ConnectionCallback connectionCallback_<span class="token punctuation">;</span>        <span class="token comment">//有新连接时的回调</span>
  MessageCallback messageCallback_<span class="token punctuation">;</span>              <span class="token comment">//有读写消息的回调</span>
  WriteCompleteCallback writeCompleteCallback_<span class="token punctuation">;</span>  <span class="token comment">//消息发送完成的回调</span>
  <span class="token comment">// HighWaterMarkCallback:读写数据达到警戒线的回调。比如当发送数据过快，接收方来不及接受时，此时发送方需要进行处理比如需要停止发送，</span>
  HighWaterMarkCallback highWaterMarkCallback_<span class="token punctuation">;</span>
  CloseCallback closeCallback_<span class="token punctuation">;</span>

  size_t highWaterMark_<span class="token punctuation">;</span>  <span class="token comment">//水位线标志，超过此数则表示达到警戒线</span>

  Buffer inputBuffer_<span class="token punctuation">;</span>   <span class="token comment">//接受数据缓冲</span>
  Buffer outputBuffer_<span class="token punctuation">;</span>  <span class="token comment">//发送数据缓冲</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>成员函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">TcpConnection</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span> sockfd<span class="token punctuation">,</span>
                <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>localAddr<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>peerAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">~</span><span class="token function">TcpConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  EventLoop <span class="token operator">*</span><span class="token function">getLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> loop_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> name_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span><span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> localAddr_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span><span class="token function">peerAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> peerAddr_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

  <span class="token keyword">bool</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> state_ <span class="token operator">==</span> kConnected<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

  <span class="token comment">//发送数据</span>
  <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// void send(const void *message, int len);</span>
  <span class="token comment">//关闭连接</span>
  <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//设置回调函数</span>
  <span class="token keyword">void</span> <span class="token function">setConnectionCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> ConnectionCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    connectionCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">void</span> <span class="token function">setMessageCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> MessageCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> messageCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
  <span class="token keyword">void</span> <span class="token function">setWriteCompleteCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> WriteCompleteCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    writeCompleteCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">void</span> <span class="token function">setHighWaterMarkCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> HighWaterMarkCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    highWaterMarkCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">void</span> <span class="token function">setCloseCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> CloseCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> closeCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

  <span class="token comment">//连接建立时的回调函数</span>
  <span class="token keyword">void</span> <span class="token function">connectEstablished</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//连接销毁的回调函数</span>
  <span class="token keyword">void</span> <span class="token function">connectDestroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">enum</span> <span class="token class-name">StateE</span> <span class="token punctuation">&#123;</span> kDisconnected<span class="token punctuation">,</span> kConnecting<span class="token punctuation">,</span> kConnected<span class="token punctuation">,</span> kDisconnecting <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>StateE state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> state_ <span class="token operator">=</span> state<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>关键</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//发送数据</span>
<span class="token comment">//应用写得快，而内核发送数据慢，需要把待发送数据写入缓冲区，而且设置水位回调</span>
<span class="token keyword">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">sendInLoop</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>message<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  size_t nwrote <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  size_t remaining <span class="token operator">=</span> len<span class="token punctuation">;</span>
  <span class="token keyword">bool</span> faultError <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token comment">//之前已经调用过shutdown，不能再进行发送了</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>state_ <span class="token operator">==</span> kDisconnected<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"disconnected, give up writing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">// channel未设置写感兴趣事件（说明无数据待从缓冲区中写入）且缓冲区没有待发送数据</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel_<span class="token operator">-></span><span class="token function">isWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> outputBuffer_<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    nwrote <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">write</span><span class="token punctuation">(</span>channel_<span class="token operator">-></span><span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> message<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nwrote <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      remaining <span class="token operator">=</span> len <span class="token operator">-</span> nwrote<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> writeCompleteCallback_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//当一次将数据发送完成，就不用再给channel设置epollout事件了</span>
        loop_<span class="token operator">-></span><span class="token function">queueInLoop</span><span class="token punctuation">(</span>
            std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>writeCompleteCallback_<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
      nwrote <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> EWOULDBLOCK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"TcpConnection::sendInLoop\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EPIPE <span class="token operator">||</span> errno <span class="token operator">==</span> ECONNREFUSED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          faultError <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">/****************************************************/</span>
  <span class="token comment">//说明这次write没有全部发送出去，剩余数据需要保存到缓冲区中，</span>
  <span class="token comment">//然后给channel注册epollout事件，poller发现tcp的发送缓冲区有空间，会通知相应的sock-channel，调用WriteCallback方法</span>
  <span class="token comment">//最终也就是调用handleWrite方法，把发送缓冲区中的数据全部发送完成</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>faultError <span class="token operator">&amp;&amp;</span> remaining <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//目前发送缓冲区剩余的待发送数据长度</span>
    size_t oldLen <span class="token operator">=</span> outputBuffer_<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldLen <span class="token operator">+</span> remaining <span class="token operator">>=</span> highWaterMark_ <span class="token operator">&amp;&amp;</span> oldLen <span class="token operator">&lt;</span> highWaterMark_ <span class="token operator">&amp;&amp;</span>
        highWaterMarkCallback_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      loop_<span class="token operator">-></span><span class="token function">queueInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>highWaterMarkCallback_<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                   oldLen <span class="token operator">+</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    outputBuffer_<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>message <span class="token operator">+</span> nwrote<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel_<span class="token operator">-></span><span class="token function">isWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">//这里一定要注册channel的写事件，否则poller不会给channel通知epollout</span>
      channel_<span class="token operator">-></span><span class="token function">enableWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//啥时候执行写回调？poller怎么通知写回调，数据不是都先到buffer中的吗</span>
<span class="token comment">//这是因为只要注册了EPOLLOUT事件，当内核写缓冲可写时，会不断发送EPOLLOUT信号，然后调用此函数将buffer中的数据进行发送</span>
<span class="token keyword">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">handleWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>channel_<span class="token operator">-></span><span class="token function">isWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> savedError <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ssize_t n <span class="token operator">=</span> outputBuffer_<span class="token punctuation">.</span><span class="token function">writeFd</span><span class="token punctuation">(</span>channel_<span class="token operator">-></span><span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>savedError<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      outputBuffer_<span class="token punctuation">.</span><span class="token function">retrieve</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>outputBuffer_<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        channel_<span class="token operator">-></span><span class="token function">disableWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>writeCompleteCallback_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token comment">//唤醒loop_对应的thread线程，执行回调</span>
          <span class="token comment">//其实此时就是在loop_对应的thread线程中</span>
          loop_<span class="token operator">-></span><span class="token function">queueInLoop</span><span class="token punctuation">(</span>
              std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>writeCompleteCallback_<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">//当用户shutdown时数据如果没发送完成，不会真的shutdown，只是将标志置为kDisconnecting，而是会等待用户把数据发送完成</span>
        <span class="token comment">//当数据发送完成后，则再执行一次shutdownInLoop</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>state_ <span class="token operator">==</span> kDisconnecting<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token function">shutdownInLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
      <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"TcpConnection::handleWrite() error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"TcpConnection fd=%d is down, no more writing \n"</span><span class="token punctuation">,</span>
              channel_<span class="token operator">-></span><span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-10-TcpServer"><a href="#2-10-TcpServer" class="headerlink" title="2.10 TcpServer"></a>2.10 <strong>TcpServer</strong></h2><p>上述所有类的综合使用者，用户通过使用此类来设置各种回调，通过此类来管理subLoop个数等</p>
<p><strong>成员变量</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> ConnectionMap <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> TcpConnectionPtr<span class="token operator">></span><span class="token punctuation">;</span>

EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>  <span class="token comment">//用户定义的loop</span>
<span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string ipPort_<span class="token punctuation">;</span>
<span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Acceptor<span class="token operator">></span> acceptor_<span class="token punctuation">;</span>  <span class="token comment">// mainLoop的监听新连接事件</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>EventLoopThreadPool<span class="token operator">></span> threadPool_<span class="token punctuation">;</span>  <span class="token comment">// one loop per thread</span>

ConnectionCallback connectionCallback_<span class="token punctuation">;</span>        <span class="token comment">//有新连接时的回调</span>
MessageCallback messageCallback_<span class="token punctuation">;</span>              <span class="token comment">//有读写消息的回调</span>
WriteCompleteCallback writeCompleteCallback_<span class="token punctuation">;</span>  <span class="token comment">//消息发送完成的回调</span>

ThreadInitCallback threadInitCallback_<span class="token punctuation">;</span>  <span class="token comment">//线程初始化的回调</span>
std<span class="token double-colon punctuation">::</span>atomic_int started_<span class="token punctuation">;</span>

<span class="token keyword">int</span> nextConnId_<span class="token punctuation">;</span><span class="token comment">//TcpConnection的id，是用来加到TcpConnection名字中</span>
ConnectionMap connections_<span class="token punctuation">;</span>  <span class="token comment">//保存所有的连接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>成员函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>
 <span class="token keyword">using</span> ThreadInitCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>

 <span class="token keyword">enum</span> <span class="token class-name">Option</span> <span class="token punctuation">&#123;</span>
   kNoReusePort<span class="token punctuation">,</span>
   kReusePort<span class="token punctuation">,</span>
 <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

 <span class="token function">TcpServer</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>listenAddr<span class="token punctuation">,</span>
           <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string nameArg<span class="token punctuation">,</span> Option option <span class="token operator">=</span> kNoReusePort<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">~</span><span class="token function">TcpServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">void</span> <span class="token function">setThreadInitCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadInitCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   threadInitCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>
 <span class="token keyword">void</span> <span class="token function">setConnectionCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> ConnectionCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   connectionCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>
 <span class="token keyword">void</span> <span class="token function">setMessageCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> MessageCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> messageCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
 <span class="token keyword">void</span> <span class="token function">setWriteCompleteCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> WriteCompleteCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   writeCompleteCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>

 <span class="token comment">//设置低层subloop的个数</span>
 <span class="token keyword">void</span> <span class="token function">setThreadNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> numThreads<span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">//开启服务器监听</span>
 <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
 <span class="token comment">//当Acceptor有新连接时会调用的回调函数</span>
 <span class="token keyword">void</span> <span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>peerAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
 <span class="token keyword">void</span> <span class="token function">removeConnection</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr <span class="token operator">&amp;</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">void</span> <span class="token function">removeConnectionInLoop</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr <span class="token operator">&amp;</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>关键</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//当有新的客户端连接，acceptor会执行这个回调</span>
<span class="token comment">//根据轮询算法选择一个subLoop，唤醒subLoop，把当前connfd封装成channel分发给subloop</span>
<span class="token keyword">void</span> <span class="token class-name">TcpServer</span><span class="token double-colon punctuation">::</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>peerAddr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">//根据轮询选择一个subloop来管理channel</span>
  EventLoop <span class="token operator">*</span>ioLoop <span class="token operator">=</span> threadPool_<span class="token operator">-></span><span class="token function">getNextLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> buf<span class="token punctuation">,</span> <span class="token string">"-%s#%d"</span><span class="token punctuation">,</span> ipPort_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nextConnId_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">++</span>nextConnId_<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string connName <span class="token operator">=</span> name_ <span class="token operator">+</span> buf<span class="token punctuation">;</span>
  <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"TcpServer::newConnection [%s] - new connection [%s] from %s\n"</span><span class="token punctuation">,</span>
           name_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> connName<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> peerAddr<span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//通过sockfd获取其绑定的ip地址和端口信息</span>
  sockaddr_in local<span class="token punctuation">;</span>
  <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>local<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> local<span class="token punctuation">)</span><span class="token punctuation">;</span>
  socklen_t addrlen <span class="token operator">=</span> <span class="token keyword">sizeof</span> local<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token double-colon punctuation">::</span><span class="token function">getsockname</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>sockaddr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>local<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addrlen<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"sockets::getLocalAddr\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  InetAddress <span class="token function">localAddr</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//根据连接成功的sockfd，创建TcpConnection连接对象</span>
  TcpConnectionPtr <span class="token function">conn</span><span class="token punctuation">(</span>
      <span class="token keyword">new</span> <span class="token function">TcpConnection</span><span class="token punctuation">(</span>ioLoop<span class="token punctuation">,</span> connName<span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> localAddr<span class="token punctuation">,</span> peerAddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  connections_<span class="token punctuation">[</span>connName<span class="token punctuation">]</span> <span class="token operator">=</span> conn<span class="token punctuation">;</span>
  <span class="token comment">//下面的回调都来源于用户设置给TcpServer => TcpConnection => channel =>Poller</span>
  <span class="token comment">//=>notify channel调用回调</span>
  conn<span class="token operator">-></span><span class="token function">setConnectionCallback</span><span class="token punctuation">(</span>connectionCallback_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  conn<span class="token operator">-></span><span class="token function">setMessageCallback</span><span class="token punctuation">(</span>messageCallback_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  conn<span class="token operator">-></span><span class="token function">setWriteCompleteCallback</span><span class="token punctuation">(</span>writeCompleteCallback_<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//设置如何关闭连接的回调 用户调用shutdwon => socket关闭写端 =></span>
  <span class="token comment">// poller通知channel EPOLLHUP事件 => channel调用closeCallback =></span>
  <span class="token comment">// TcpConnection::handleClose() => TcpServer::removeConnection</span>
  conn<span class="token operator">-></span><span class="token function">setCloseCallback</span><span class="token punctuation">(</span>
      std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpServer<span class="token double-colon punctuation">::</span>removeConnection<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//直接调用connectEstablished方法</span>
  ioLoop<span class="token operator">-></span><span class="token function">runInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpConnection<span class="token double-colon punctuation">::</span>connectEstablished<span class="token punctuation">,</span> conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h1 id="3-问题"><a href="#3-问题" class="headerlink" title="3. 问题"></a>3. 问题</h1><h2 id="介绍一下项目"><a href="#介绍一下项目" class="headerlink" title="介绍一下项目"></a>介绍一下项目</h2><p>此项目是一个基于Reactor模式的web服务器，采用epoll多路复用机制+线程池来高效处理并发连接。在实现中，使用epoll的水平触发模式来进行监听，使用C++11提供的智能指针来避免内存泄露，使用了eventfd来高效唤醒线程，为统一管理日志文件，实现了一个简单的异步日志系统。</p>
<h2 id="什么是优雅关闭连接？"><a href="#什么是优雅关闭连接？" class="headerlink" title="什么是优雅关闭连接？"></a>什么是优雅关闭连接？</h2><blockquote>
<p>优雅关闭：如果发送缓存中还有数据未发出则将其发出去，并且收到所有数据的ACK之后，发送FIN包，开始关闭过程。使用shutdown函数。</p>
<p>强制关闭：如果缓存中还有数据，则这些数据都将被丢弃，然后发送RST包，直接重置TCP连接。使用close()函数。</p>
<p>close()和shutdown()的区别：</p>
<ul>
<li>close会关闭连接，并释放所有连接对应的资源，而shutdown并不会释放掉套接字和所有资源。</li>
<li>close有引用计数，例如父子进程都打开了某个文件描述符，其中某个进程调用了close函数，会使close函数的引用计数减1，直到套接字的引用计数为0，才会真正的关闭连接。而shutdown函数可以无视引用计数，直接关闭连接。</li>
<li>close的引用计数的存在导致不一定会发出FIN结束报文，而shutdown一定会发出FIN报文。</li>
<li>shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() &#x2F; closesocket() 将套接字从内存清除。</li>
<li>调用 close()关闭套接字时，或调用 shutdown() 关闭输出流时，都会向对方发送 FIN 包。FIN 包表示数据传输完毕，计算机收到 FIN 包就知道不会再有数据传送过来。</li>
<li>默认情况下，close()引用计数为0后会立即往网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。<em><strong>*也就意味着，调用 close()将丢失输出缓冲区中的数据，而调用 shutdown() 不会。*</strong></em></li>
</ul>
</blockquote>
<p>在代码实现中，当用户调用shutdown函数时，不会马上就调用shutdown关闭socket，而是先将状态置为disconnecting，如果当前连接发送缓冲区无数据则调用shutdown函数关闭socket，否则等到每次处理写事件时当数据发送完成都会判断当前状态是否是disconnecting，如果是则调用shutdown关闭socket</p>
<h2 id="eventfd是什么？有什么好处？"><a href="#eventfd是什么？有什么好处？" class="headerlink" title="eventfd是什么？有什么好处？"></a>eventfd是什么？有什么好处？</h2><blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903592457928711">1</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/40572954">2</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/424198922">3</a></p>
</blockquote>
<p><strong>简介</strong></p>
<ul>
<li>eventfd是linux系统提供的一个轻量级的进程间通信的系统调用，eventfd通过一个进程间共享的64位计数器完成进程间通信，这个计数器由在linux内核空间维护，用户可以通过调用write方法向内核空间写入一个64位的值，也可以调用read方法读取这个值。</li>
</ul>
<p><strong>使用</strong></p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/eventfd.h></span></span>
<span class="token keyword">int</span> <span class="token function">eventfd</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> initval<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li><p>flags可以设置以下三个标志位：</p>
<ul>
<li>EFD_CLOEXEC：简单说就是fork子进程时不继承，对于多线程的程序设上这个值不会有错的。</li>
<li>EFD_NONBLOCK：如果没有设置了这个标志位，那read操作将会阻塞直到计数器中有值。如果有设置这个标志位，计数器没有值的时候也会立即返回-1；</li>
<li>EFD_SEMAPHORE：支持semophore语义的read，简单说就值递减1。</li>
</ul>
</li>
</ul>
<p><strong>典型应用场景及优势</strong></p>
<p>在信号通知的场景下，相比pipe有非常大的资源和性能优势。其根本在于counter（计数器）和channel（数据信道）的区别。</p>
<ul>
<li>第一，是打开文件数量的巨大差别。由于pipe是半双工的传统IPC方式，所以两个线程通信需要两个pipe文件，而用eventfd只要打开一个文件，省了一半。另外，pipe只能在两个进程&#x2F;线程间使用，即需要之前准备好两个pipe；而eventfd是广播式的通知，可以多对多的。</li>
<li>第二，是内存使用的差别。eventfd是一个计数器，内核维护几乎成本忽略不计，大概是自旋锁+唤醒队列，8个字节的传输成本也微乎其微。但pipe可就完全不是了，一来一回数据在用户空间和内核空间有多达4次的复制，而且更糟糕的是，内核还要为每个pipe分配至少4K的虚拟内存页，即便传输的数据长度为0。</li>
</ul>
<p><strong>实现原理</strong></p>
<ul>
<li><p>eventfd在内核中的数据结构如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">eventfd_ctx</span> <span class="token punctuation">&#123;</span>
        wait_queue_head_t wqh<span class="token punctuation">;</span><span class="token comment">//等待队列头节点</span>
        __u64 count<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">//等待队列是内核中的重要数据结构，在进程调度、异步通知等多种场景都有很多的应用。其节点结构并不复杂，即自带自旋锁的双向循环链表的节点</span>
<span class="token keyword">struct</span> <span class="token class-name">__wait_queue_head</span> <span class="token punctuation">&#123;</span>
	spinlock_t lock<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> task_list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">__wait_queue_head</span> wait_queue_head_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>read()函数：read操作目的是要将count值返回用户空间并清零。ctx中的count值是共享数据，通过加irq自旋锁实现对其的独占安全访问。</p>
</li>
</ul>
<p><strong>进程是如何被唤醒的</strong></p>
<ul>
<li>当写进程调用eventfd_write过程中，会调用 waitqueue_active(&amp;ctx-&gt;wqh) 判断ctx-&gt;wqh是否为空，若不为空，则调用 wake_up_locked_poll(&amp;ctx-&gt;wqh, EPOLLIN); 激活可写事件（因为读进程读取时发现不可读，会生成一个 wait 对象放到 ctx-&gt;wqh队列中，然后休眠，所以此时 ctx-&gt;wqh）。</li>
</ul>
<h2 id="实现一个无锁队列-用原子操作"><a href="#实现一个无锁队列-用原子操作" class="headerlink" title="实现一个无锁队列(用原子操作)"></a>实现一个无锁队列(用原子操作)</h2><blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://www.cnlzhnn.com/cas%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/">1</a> <a target="_blank" rel="noopener" href="https://luyuhuang.tech/2022/10/30/lock-free-queue.html">2</a> <a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/497473">3</a></p>
<p><code>c++</code>提供了<code>atomic</code>模板支持一系列原子操作的类，提供的方法能保证操作具有原子性，即获取该类型变量的值时，永远能获得修改前或修改后的值，不会获得修改过程中的值，以确保不会在并发操作时产生不明确的行为。</p>
<p>该模板不具有拷贝构造函数，因为原子读和原子写是两个独立的原子操作，不能确保两个独立的操作加在一起仍然能保证原子性。</p>
<p>该类提供了如下几种接口：</p>
<ul>
<li><code>stroe</code> 原子写操作</li>
<li><code>load</code> 原子读操作</li>
<li><code>exchange</code> 修改当前值，并保证过程具有原子性</li>
<li><code>compare_exchange_weak</code></li>
<li><code>compare_exchange_strong</code></li>
</ul>
<p><code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>即为<code>CAS</code>操作，参数要求传入期待值和设定值：</p>
<ul>
<li>若当前值与期待值相等，则将当前值修改为设定值，返回<code>true</code></li>
<li>若当前值与期待值不等，则将期待值修改为当前值，返回<code>false</code></li>
</ul>
<p><code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>的区别：</p>
<ul>
<li><code>weak</code>允许偶然出乎意料的返回，比如当前值和期待值相等时候返回<code>false</code>，但在多数循环算法中是可以接受的，通常比<code>strong</code>具有更高的性能。</li>
</ul>
</blockquote>
<p><strong>CAS无锁栈</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*  CAS无锁栈  */</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">ConcurrentStack</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        Node<span class="token operator">*</span> new_node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        new_node<span class="token operator">-></span>m_next <span class="token operator">=</span> m_head<span class="token punctuation">;</span>
        <span class="token comment">//如果m_head没有发生变化，则将其置为new_node；如果m_head发生变化，此时compare_exchange_weak函数返回false，并将new_node->m_next更改为新的m_head值，此时继续循环。</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>m_head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>new_node<span class="token operator">-></span>m_next<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    T <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        Node<span class="token operator">*</span> _now <span class="token operator">=</span> m_head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Node<span class="token operator">*</span> _next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">do</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>_now <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
            _next <span class="token operator">=</span> _now<span class="token operator">-></span>m_next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>m_head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>_now<span class="token punctuation">,</span> _next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//如果m_head没有发生变化，则将其更改为_next；否则将now更改为新的m_head，继续不断循环遍历</span>
        T _tmp <span class="token operator">=</span> _now<span class="token operator">-></span>m_data<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> _now<span class="token punctuation">;</span>
        <span class="token keyword">return</span> _tmp<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
            <span class="token operator">:</span> <span class="token function">m_data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

        T m_data<span class="token punctuation">;</span>
        Node<span class="token operator">*</span> m_next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span> m_head <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>CAS无锁队列</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*  CAS无锁队列  */</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">lock_free_queue</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span>
    <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> data<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">></span> next<span class="token punctuation">;</span>
        <span class="token function">node</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> data_<span class="token punctuation">)</span> <span class="token operator">:</span>
            <span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>data_<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">></span> head <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">></span> tail <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        node<span class="token operator">*</span> new_node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token operator">*</span> _ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token comment">//判断是否是空队列</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>tail<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">)</span>
            _ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        node<span class="token operator">*</span> old_tail <span class="token operator">=</span> tail<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//感觉原来的有点问题，做了一点修改 old_tail不是原子变量         </span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>old_tail <span class="token operator">&amp;&amp;</span>
            <span class="token operator">!</span>tail<span class="token operator">-></span>next<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            old_tail <span class="token operator">=</span> tail<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            _ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        tail<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>old_tail<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        node<span class="token operator">*</span> old_head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>old_head <span class="token operator">&amp;&amp;</span>
            <span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>old_head<span class="token punctuation">,</span> old_head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            old_head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//感觉不太需要这一步，这一步应该是为了最后返回的时候判断值是否更改</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> old_head <span class="token operator">?</span> old_head<span class="token operator">-></span>data <span class="token operator">:</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="双缓冲区异步日志是什么？为什么要这样做？"><a href="#双缓冲区异步日志是什么？为什么要这样做？" class="headerlink" title="双缓冲区异步日志是什么？为什么要这样做？"></a>双缓冲区异步日志是什么？为什么要这样做？</h2><p>由于消费者的写文件速度比较慢，一定不能影响了生产者的写入效率，所以我们可以用两个消息队列来分别存储：正在写入的日志信息，正在读取的日志信息，也就是所谓的“双缓冲”技术。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230311205746535.png"></p>
<p><strong>缓冲区什么时候交换？</strong></p>
<p>当生产者所写的缓冲区已满时，需要将两个缓冲区进行交换，为了加快交换效率只需交换两个缓冲区地址即可。例如可使用queue来作为缓冲区。</p>
<ul>
<li>满足一定大小时进行交换。每次生产者像缓冲区中写数据时，如果缓冲区带下超过限制，则交换缓冲区（缓冲区2如果此时如果还有数据则不进行交换，继续写）</li>
<li>超过一定时间进行交换。可能写日志频率较低，很久都无法满足交换数量，此时应该设定一个timerfd，每当达到一定时间就交换缓冲区，避免过久不写日志导致日志丢失。</li>
</ul>
<h2 id="定时器是怎么实现的？还有什么实现方式？"><a href="#定时器是怎么实现的？还有什么实现方式？" class="headerlink" title="定时器是怎么实现的？还有什么实现方式？"></a>定时器是怎么实现的？还有什么实现方式？</h2><p>定时器可使用timerfd实现，timerfd 可以和 epoll 配合起来，让 epoll 监听 timerfd 的可读事件，这样 timerfd 超时触发可读事件，<code>epoll_wait</code> 被唤醒，业务进行周期处理，从而也能达到定时器的目的。</p>
<p><strong>timerfd简介</strong>：</p>
<ul>
<li><p>timerfd 被 new 出来之后 （ <code>timerfd_create</code> ），可以设置超时时间（ <code>timerfd_setting</code> ），超时之后，该句柄可读，读出来的是超时的次数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 创建一个 timerfd 句柄</span>
<span class="token keyword">int</span> <span class="token function">timerfd_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> clockid<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 启动或关闭 timerfd 对应的定时器</span>
<span class="token keyword">int</span> <span class="token function">timerfd_settime</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">itimerspec</span> <span class="token operator">*</span>new_value<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">itimerspec</span> <span class="token operator">*</span>old_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取指定 timerfd 距离下一次超时还剩的时间</span>
<span class="token keyword">int</span> <span class="token function">timerfd_gettime</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">itimerspec</span> <span class="token operator">*</span>curr_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p><strong>timerfd原理</strong></p>
<ul>
<li><p>核心结构体：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">timerfd_ctx</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 真正的内核定时器</span>
    <span class="token keyword">union</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">struct</span> <span class="token class-name">hrtimer</span> tmr<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">alarm</span> alarm<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> t<span class="token punctuation">;</span>
    <span class="token comment">// wait 对象挂接的表头</span>
    wait_queue_head_t wqh<span class="token punctuation">;</span>
    <span class="token comment">// 记录超时的次数</span>
    u64 ticks<span class="token punctuation">;</span>
    <span class="token comment">// 定时器类型</span>
    <span class="token keyword">int</span> clockid<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>timerfd_create内部过程</p>
<ul>
<li>创建并初始化了一个 <code>timerfd_ctx</code> 的结构体（在这个 ctx 结构体内有个表头 <code>ctx-&gt;wqh</code> 很重要，是和 epoll 产生联系的关键点）；</li>
<li>初始化了定时器，根据类型可以创建 <code>alarm</code> 类型或者高精度的 <code>hrtimer</code> 类型的定时器（ 注意：timerfd 本身并没有实现定时器的功能，定时器直接使用的是内核封装好的定时器，timerfd 只针对“文件”的封装）；</li>
<li>创建一个匿名 fd，绑定 <code>timerfd_fops</code> 操作表；</li>
</ul>
</li>
<li><p>timerfd_settime</p>
<ul>
<li>通过 fd 获取到 file，再获取到核心结构体 timerfd_ctx；</li>
<li>然后再操作定时器，启动定时器即可；</li>
</ul>
</li>
<li><p>timerfd_gettime</p>
<ul>
<li>通过 fd 获取到 file，再获取到核心结构体 <code>timerfd_ctx</code> ；</li>
<li>然后通过 <code>timerfd_ctx</code> 里面存储的信息，计算举例下一次超时的时间即可；</li>
</ul>
</li>
</ul>
<p><strong>timerfd 怎么唤醒 epoll_wait？</strong></p>
<ul>
<li><p>定时器到期之后，内核调用回调：</p>
<pre class="line-numbers language-none"><code class="language-none">timerfd_tmrproc (在初始化的时候配置)
-&gt; timerfd_trigger
    -&gt; wake_up_locked_poll （唤醒 timerfd 上所有的等待对象）
        -&gt; ep_poll_callback<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>应该就是epoll_ctl注册时像timerfd的wqh注册事件，然后当定时器到期后，内核不断唤醒队列中的事件，调用回调操作</p>
</li>
</ul>
<p><strong>定时器其他实现方法</strong></p>
<p>linux提供以下多种计时函数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230311214830639.png"></p>
<ul>
<li>前四个函数比较鸡肋，会让调用线程挂起，原地等待定时器超时。但是在非阻塞网络编程中，绝对不能用让线程挂起的方式来等待一段时间，这样一来程序会失去响应。</li>
<li>alarm()和setitimer()，它们的通知机制采用了信号SIGALRM，由于SIGALRM信号不可靠，会造成超时通知不可靠，而且多线程中处理信号也是一个麻烦事，也不考虑。</li>
<li>timer_create()&#x2F;timer_settime()系列函数是POSIX规定，精度达到纳秒级，提供了一个数据结构<code>struct sigevent</code>可以指定一个实时信号作为通知信号，同时也可以设置线程ID，将信号传递到指定的线程。</li>
</ul>
<h2 id="epoll的边沿触发和水平触发有什么区别？"><a href="#epoll的边沿触发和水平触发有什么区别？" class="headerlink" title="epoll的边沿触发和水平触发有什么区别？"></a>epoll的边沿触发和水平触发有什么区别？</h2><p><strong>定义</strong></p>
<ul>
<li>水平触发：只要套接字可读&#x2F;可写epollwait都会将描述符返回。即只要套接字的接收缓冲中尚有数据或发送缓冲有空间容纳要发送的数据。这个套接字都会被epoll_wait返回。</li>
<li>边缘触发：当套接字的缓冲状态发生变化时返回。对于读缓冲，有新到达的数据被添加到读缓冲时触发。对于写缓冲，当缓冲发生容量变更的时候触发</li>
</ul>
<p><strong>内核调度实现方式</strong></p>
<ul>
<li>在epoll_wait的时候，阻塞等待事件发生， 事件发生时通过回调挂到ready list链表中</li>
<li>epoll_wait返回， 处理ready list, 返回事件给调用者</li>
<li>此时ET模式已经将事件从ready list中删除，LT模式中还存在</li>
<li>此时假设应用程序处理完了事件， 再次epoll_wait.  ET模式继续阻塞</li>
<li>LT模式由于ready list中依然存在事件则不会阻塞， 对这些socket调用poll方法获取最新的事件信息，如果确认没事件了才会删除。</li>
</ul>
<p><strong>边缘触发可能造成饥饿</strong></p>
<p>如果用边缘触发处理，对一个套接字就需要循环读取，直到没有数据可读为止。如果其中一个连接源源不断的发送数据，这个套接口的读循环就无法退出，导致其它连接没有机会被处理。</p>
<p><strong>边缘触发优势场景</strong></p>
<p>对于水平触发模式out事件必须按需注册。主要的注册方式有以下两种：</p>
<ul>
<li>上层调用send，将数据添加到应用层的发送缓冲，如果当前没有注册out则注册out,当epoll通知out激活时，发送应用缓冲中的数据，如果数据发送完毕注销out。</li>
<li>上层调用send，直接发送，如果数据未发送完或返回EAGAIN,则注册out，当epoll通知out激活时，继续发送未发送完成的数据，如果数据发送完毕注销out。</li>
</ul>
<p>上述的添加和注销out都是通过epoll_ctl完成，因此水平触发需要不断开关out信号，当数据频繁发送但一次不能写成功时就会不断开关out信号。</p>
<p>而对于边缘触发模式则无此需要。</p>
<ul>
<li>假如发送每次均能将数据全部发完。那么out的注册和注销都不会发生。</li>
<li>如果接收方慢导致每次均无法将数据全部发送完，那么out将只会注册一次，注销不会发生。</li>
</ul>
<p><strong>为什么选择使用LT？</strong></p>
<p>虽然ET在某些场景如一直读写下会更高效，但可能会遗漏事件产生bug，从而导致代码编写逻辑更为复杂。</p>
<h2 id="epoll为什么高效，相比select和poll"><a href="#epoll为什么高效，相比select和poll" class="headerlink" title="epoll为什么高效，相比select和poll"></a>epoll为什么高效，相比select和poll</h2><blockquote>
<p>自己简单理解</p>
<p>select使用一个结构体来管理sockfd，其内有一个bitmap，向select添加sockfd也就是将bitmap对应值进行更改为1。同理，当有事件发生时，系统返回的bitmap中如果值为1则代表此sockfd有事件 发生。</p>
<ul>
<li>由于select返回的是一个bitmap而不是发生事件的集合，因此还需要遍历整个bitmap找出有事件发生的sockfd，导致其效率很低。</li>
<li>且bitmap需要在内核态和用户态不断复制，导致效率很低。</li>
</ul>
<p>相比select，poll变化不大，原理也相同，poll使用数组来取代bitmap，因而也就没有大小限制。同样，poll也需要遍历整个数组来找出有事件发生的sockfd，其也只有水平触发。</p>
<p>epoll的一个巨大改进之处在于将发生事件的sockfd使用一个数据进行保存（通过在内核空间直接建立一个文件系统，使用红黑树），提高了效率</p>
</blockquote>
<blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://heapdump.cn/article/3841322">1</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/530640921">2</a></p>
</blockquote>
<p><strong>epoll原理详解</strong></p>
<ul>
<li><p><em>当</em>某一进程调用 epoll_create 方法时，Linux 内核会创建一个 eventpoll 结构体，这个结构体中有两个成员与epoll的使用方式密切相关，如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token punctuation">&#123;</span>
　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
　　<span class="token comment">/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，
　　也就是这个epoll监控的事件*/</span>
　　<span class="token keyword">struct</span> <span class="token class-name">rb_root</span> rbr<span class="token punctuation">;</span>
　　<span class="token comment">/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span>
　　<span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdllist<span class="token punctuation">;</span>
　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>在调用 epoll_create 时，内核除了帮我们在 epoll 文件系统里建了个 file 结点，在内核 cache 里建了个红黑树用于存储以后 epoll_ctl 传来的 socket 外，还会再建立一个 rdllist 双向链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 rdllist 双向链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到 timeout 时间到后即使链表没数据也返回。所以，epoll_wait 非常高效。</p>
</li>
<li><p>所有添加到epoll中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的事件放到上面的rdllist双向链表中。</p>
</li>
<li><p>当调用 epoll_wait 检查是否有发生事件的连接时，只是检查eventpoll对象中的rdllist双向链表是否有元素而已，如果rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx效率非常高。epoll_ctl在向epoll对象中添加、修改、删除事件时，从rbr红黑树中查找事件也非常快，也就是说epoll是非常高效的，它可以轻易地处理百万级别的并发连接。</p>
</li>
</ul>
<h2 id="假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？-其实就是不间断的提供服务，参考nginx的平滑升级"><a href="#假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？-其实就是不间断的提供服务，参考nginx的平滑升级" class="headerlink" title="假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？(其实就是不间断的提供服务，参考nginx的平滑升级)"></a>假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？(其实就是不间断的提供服务，参考nginx的平滑升级)</h2><blockquote>
<p>参考 <a target="_blank" rel="noopener" href="http://www.manongjc.com/detail/55-ddjnjhttaswtzpx.html">1</a></p>
</blockquote>
<p>简单想法：向代理服务器中添加新服务器ip，新服务器上运行新任务，新来的连接均导向新服务器。</p>
<h2 id="HTTP报文都有哪些字段？"><a href="#HTTP报文都有哪些字段？" class="headerlink" title="HTTP报文都有哪些字段？"></a>HTTP报文都有哪些字段？</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230313115843376.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230313120014727.png"></p>
<p><strong>url和host区别</strong></p>
<p>url里面除了域名还包括端口号，当不指定时是默认端口号，url可使得同一台主机提供多个http服务。</p>
<p>通过host指定应用，你可以用相同的IP+端口访问不同的应用，而不必担心端口问题。例如nginx以下配置，server_name就是通过host来比较：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json">server<span class="token punctuation">&#123;</span>
    listen <span class="token number">80</span>;
    server_name www.webkit.cc;
    root /path/to/your/root/directory/;
    index  index.html;
<span class="token punctuation">&#125;</span>

server<span class="token punctuation">&#123;</span>
    listen <span class="token number">80</span>;
    server_name another—website.com;
    root /another/root/directory/;
    index  index.html;
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="一个请求到来具体的处理过程是怎样的"><a href="#一个请求到来具体的处理过程是怎样的" class="headerlink" title="一个请求到来具体的处理过程是怎样的"></a>一个请求到来具体的处理过程是怎样的</h2><ol>
<li>首先通过listenfd建立TCP连接，然后使用epoll通知程序调用listenfd的accept来获取连接</li>
<li>然后使用封装好的TcpConnection类来封装连接信息，为平衡个处理线程的负载，采取不断循环将此连接信息分配到各线程，然后使用eventfd将处理线程唤醒。</li>
<li>处理线程将此连接注册到所属线程的epoll上，当有消息进入时epoll_wait不再阻塞，将信息读入此连接所属缓存区中，然后从缓冲区中读出信息并进行处理。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110214042301.png"></p>
<h2 id="线程的唤醒还有哪些方式？"><a href="#线程的唤醒还有哪些方式？" class="headerlink" title="线程的唤醒还有哪些方式？"></a>线程的唤醒还有哪些方式？</h2><blockquote>
<p>参考 <a href="handleR">1</a></p>
</blockquote>
<p>epoll等机制本身可以设置一个超时时间，但有时需要将epoll立即唤醒处理事件，可使用以下机制：</p>
<ol>
<li>使用eventfd方式，每个线程所使用的eventloop都会有一个eventfd，并将其注册到所属的epoll上，当需要唤醒此线程时，只需要向此eventfd写入一个1个64位的数即可。</li>
<li>使用管道<code>fd</code>，创建一个管道，将管道的一端（管道<code>fd</code>中的一个）绑定到<code>epollfd</code>上，需要唤醒时，向管道的另一端写入1字节，工作线程就立即被唤醒；</li>
<li>使用<code>socketpair</code>，<code>socketpair</code>是一对相互连接的<code>socket</code>，相当于服务器和客户端的两个端点，每一端都可以读写数据，向其中一端写入数据后，就可以从另一端读取数据了。</li>
</ol>
<p>其他的诸如pthread_cond_wait&#x2F;signal、semaphore等机制不好与epoll等结合。</p>
<h2 id="怎么检查内存泄漏的？"><a href="#怎么检查内存泄漏的？" class="headerlink" title="怎么检查内存泄漏的？"></a>怎么检查内存泄漏的？</h2><blockquote>
<p>参考<a href="%E6%80%8E%E4%B9%88%E6%A3%80%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%EF%BC%9F">1</a> <a target="_blank" rel="noopener" href="https://sites.google.com/site/shuzhifeng/linux-ping-tai-zhong-diao-shi-c-c-nei-cun-xie-lou-fang-fa">2</a></p>
</blockquote>
<p>主要分为静态分析和动态分析：</p>
<ul>
<li>静态分析：<ul>
<li>review原来带，判断申请内存和释放内存是否匹配</li>
<li>参考1，重载new和delete等操作符，每次申请内存时多申请一块内存作为一个链表节点，当释放内存时重链表中删除此节点。最终如果链表为空则说明不存在内存泄露。</li>
</ul>
</li>
<li>动态分析：使用一些实时检测工具valgrind, Rational purify</li>
</ul>
<h2 id="用到了哪些智能指针和RAII机制，几种锁的区别是什么"><a href="#用到了哪些智能指针和RAII机制，几种锁的区别是什么" class="headerlink" title="用到了哪些智能指针和RAII机制，几种锁的区别是什么"></a>用到了哪些智能指针和RAII机制，几种锁的区别是什么</h2><p><strong>智能指针使用</strong>：</p>
<ul>
<li>unique_ptr: 包括Poller，Channel，Socket等</li>
<li>shared_ptr：TcpConnection、thread、EventLoopThreadPoll</li>
<li>weak_ptr：Channel中使用一个tie_来判断此channel是否被释放</li>
</ul>
<p><strong>几种锁定义及特点</strong>：</p>
<ul>
<li>互斥锁：对于读者和写者来说。只要有一方获取了锁，另一方则不能继续获取，进而执行临界区代码。</li>
<li>读写锁：读写锁适合于对数据结构的读次数比写次数多得多的情况.因为,读模式锁定时可以共享,以写 模式锁住时意味着独占,所以读写锁又叫共享-独占锁.</li>
<li>自旋锁：轮询忙等待。被自旋锁保护的临界区代码执行时不能进行挂起状态。自旋锁的初衷就是在短期间内进行轻量级的锁定。一个被争用的自旋锁使得请求它的线程在等待锁重新可用的期间进行不断轮询，所以自旋锁不应该被持有时间过长。如果需要长时间锁定的话, 最好使用信号量。</li>
</ul>
<h2 id="任务队列是怎么实现的，除了加锁还有什么方式"><a href="#任务队列是怎么实现的，除了加锁还有什么方式" class="headerlink" title="任务队列是怎么实现的，除了加锁还有什么方式"></a>任务队列是怎么实现的，除了加锁还有什么方式</h2><p>可用CAS原子操作实现，见无锁队列实现</p>
<h2 id="如何解决死锁"><a href="#如何解决死锁" class="headerlink" title="如何解决死锁"></a>如何解决死锁</h2><p><strong>死锁的必要条件</strong></p>
<ol>
<li>互斥：一个执行流获取互斥锁后，其它执行流不能再获取该锁；</li>
<li>不可剥夺：A执行流拿着锁，其它执行流不能释放；</li>
<li>循环等待：多个执行流拿着对方想要的锁，并且各执行流还去请求对方的锁；</li>
<li>请求与保持：执行流本身使用着一把锁并不释放，还在请求别的锁；</li>
</ol>
<p><strong>解决死锁的几种算法</strong></p>
<ol>
<li>有序资源分配法：所有资源的使用都要有序的使用，要保证资源一次申请完且在申请不同类资源时，必须按各类设备的编号依次申请</li>
<li>银行家算法：一个银行家的借贷业务，必须保证其借贷人在一定时间内归还本金，以至于资金可以顺利周转，不至于倒闭。</li>
</ol>
<p><strong>死锁的预防和恢复</strong></p>
<ol>
<li>资源掠夺法：当前系统中存在多个死锁程序时，选择葫芦一部分死锁程序，并抢占他的资源，将这些稀有分配给其他进程使用，直到死锁不存在为止；</li>
<li>撤销进程法：放弃处于死锁进程中的进程，直接撤销该进程，直到死锁不存在为止；</li>
<li>进程回退法：进程自按获取顺序自愿放弃获取的资源，系统保存进程的历史信息，设置还原点。</li>
</ol>
<h2 id="怎么进行压测的"><a href="#怎么进行压测的" class="headerlink" title="怎么进行压测的"></a>怎么进行压测的</h2><h2 id="为什么要用非阻塞io"><a href="#为什么要用非阻塞io" class="headerlink" title="为什么要用非阻塞io"></a>为什么要用非阻塞io</h2><p>如果使用阻塞io，会在数据准备阶段等待大量时间，而在等待期间线程会被挂起，若想此时处理其他任务就只能开启其他线程进行处理。</p>
<p>网络任务通常会有大量连接，如果每个连接都阻塞在数据准备阶段，则需要巨量线程来处理连接，会给线程调度带来巨大挑战，并导致数据处理效率降低、</p>
<h2 id="为什么要做这个项目"><a href="#为什么要做这个项目" class="headerlink" title="为什么要做这个项目"></a>为什么要做这个项目</h2><p>。。</p>
<h2 id="Reactor模式是什么"><a href="#Reactor模式是什么" class="headerlink" title="Reactor模式是什么"></a>Reactor模式是什么</h2><p>见1.4节</p>
<h1 id="5-出现哪些问题，如何解决"><a href="#5-出现哪些问题，如何解决" class="headerlink" title="5. 出现哪些问题，如何解决"></a>5. 出现哪些问题，如何解决</h1><p>一些小错误，使用eventfd唤醒时，向其中写入64位的数，判断的是写入1个字节，应该判断写入8个字节。</p>
<h2 id="5-1-有的连接shutdown错误，且会出现有的连接revent报错-errno-x3D-32，"><a href="#5-1-有的连接shutdown错误，且会出现有的连接revent报错-errno-x3D-32，" class="headerlink" title="5.1 有的连接shutdown错误，且会出现有的连接revent报错 errno&#x3D;32，"></a>5.1 有的连接shutdown错误，且会出现有的连接revent报错 errno&#x3D;32，</h2><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p>1000个客户端 60s</p>
<p>短连接</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328164436193.png"></p>
<p>线程池为4</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328170702370.png"></p>
<p>长连接</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328164909909.png"></p>
<p>线程池为4</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328170456563.png"></p>
<p>muduo测试</p>
<p>短连接</p>
<p>线程池为0</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328165926466.png"></p>
<p>线程池为4</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328170105847.png"></p>
<p>长连接</p>
<p>线程池为0</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328165709766.png"></p>
<p>线程池为4</p>
<p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328165352821.png"></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">mujiubai</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://mujiubai.github.io/2023/02/15/%E9%A1%B9%E7%9B%AE/%E9%87%8D%E5%86%99muduo%E5%BA%93/">https://mujiubai.github.io/2023/02/15/%E9%A1%B9%E7%9B%AE/%E9%87%8D%E5%86%99muduo%E5%BA%93/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">mujiubai</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/C/">
                                    <span class="chip bg-color">C++</span>
                                </a>
                            
                                <a href="/tags/muduo/">
                                    <span class="chip bg-color">muduo</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/02/15/leetcode/other/leetcode-179-%E6%9C%80%E5%A4%A7%E6%95%B0-middle/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="179. 最大数">
                        
                        <span class="card-title">179. 最大数</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-02-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/LeetCode/" class="post-category">
                                    LeetCode
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Alg-%E6%8E%92%E5%BA%8F/">
                        <span class="chip bg-color">Alg-排序</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/02/15/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4-middle/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="475. 供暖器">
                        
                        <span class="card-title">475. 供暖器</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-02-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/LeetCode/" class="post-category">
                                    LeetCode
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">
                        <span class="chip bg-color">二分查找</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">mujiubai</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">317.1k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/mujiubai" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1057378931@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1057378931" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1057378931" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/star.js"><\/script>');
            }
        </script>
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
