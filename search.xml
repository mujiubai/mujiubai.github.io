<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>拼多多2021笔试真题集</title>
      <link href="/2023/10/16/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E6%8B%BC%E5%A4%9A%E5%A4%9A2021%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E9%9B%86/"/>
      <url>/2023/10/16/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E6%8B%BC%E5%A4%9A%E5%A4%9A2021%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="拼多多2021笔试真题集"><a href="#拼多多2021笔试真题集" class="headerlink" title="拼多多2021笔试真题集"></a><a href="https://www.nowcoder.com/exam/test/72444321/detail?pid=30579184&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=732&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">拼多多2021笔试真题集</a></h1><p>就a了一道，其他只过了部分用例。。</p><hr><p><strong>1</strong>：<strong>多多的数字组合</strong></p><blockquote><p>多多君最近在研究某种数字组合：<br>定义为：每个数字的十进制表示中(0~9)，每个数位<strong>各不相同</strong>且各个数位之和等于N。<br>满足条件的数字可能很多，找到其中的最小值即可。</p><p>多多君还有很多研究课题，于是多多君找到了你–未来的计算机科学家寻求帮助。</p></blockquote><p>method1：使用深度遍历，找到最小的值，效率较低，</p><p>method2：贪心，一定是先固定最后面一位数，让它最大，这样高位数才能小</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>string path<span class="token punctuation">;</span>string ans<span class="token punctuation">;</span><span class="token keyword">bool</span> success<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span><span class="token keyword">int</span> goal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// cout&lt;&lt;idx&lt;&lt;" "&lt;&lt;goal&lt;&lt;endl;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>success<span class="token operator">||</span>goal<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>goal<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> ans<span class="token operator">=</span>path<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ans<span class="token operator">=</span>path<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> ans<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>idx<span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token operator">&amp;&amp;</span>i<span class="token operator">&lt;=</span>goal<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        path<span class="token operator">+=</span><span class="token char">'0'</span><span class="token operator">+</span>i<span class="token punctuation">;</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>goal<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> flag<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;=</span>flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum<span class="token operator">+=</span><span class="token function">min</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            cout<span class="token operator">&lt;&lt;</span>sum<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            sum<span class="token operator">+=</span>flag<span class="token operator">*</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>i<span class="token punctuation">;</span>            n<span class="token operator">-=</span>flag<span class="token punctuation">;</span>            <span class="token operator">--</span>flag<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        <span class="token function">method2</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// if(n&lt;10) &#123;</span>        <span class="token comment">//     cout&lt;&lt;n&lt;&lt;endl;</span>        <span class="token comment">//     continue;</span>        <span class="token comment">// &#125;</span>        <span class="token comment">// if(n>45)&#123;</span>        <span class="token comment">//     cout&lt;&lt;-1&lt;&lt;endl;</span>        <span class="token comment">//     continue;</span>        <span class="token comment">// &#125;</span>        <span class="token comment">// ans="";</span>        <span class="token comment">// path="";</span>        <span class="token comment">// success=false;</span>        <span class="token comment">// DFS(1,n);</span>        <span class="token comment">// cout&lt;&lt;ans&lt;&lt;endl;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>2</strong>：<strong>多多的字符变换</strong></p><blockquote><p>多多君最近在研究字符串之间的变换，可以对字符串进行若干次变换操作:</p><ol><li>交换任意两个相邻的字符，代价为0。</li><li>将任意一个字符a修改成字符b，代价为 |a - b|（绝对值）。</li></ol><p>现在有两个长度相同的字符串X和Y，多多君想知道，如果要将X和Y变成两个一样的字符串，需要的最少的代价之和是多少。</p></blockquote><p>因为交换字符没有代价，因此可以先对两个字符串进行排序，然后依次计算交换代价。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        string str1<span class="token punctuation">,</span>str2<span class="token punctuation">;</span>        cin<span class="token operator">>></span>str1<span class="token operator">>></span>str2<span class="token punctuation">;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>str1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>str2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token operator">+=</span><span class="token function">abs</span><span class="token punctuation">(</span>str1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>str2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>3</strong>：<strong>多多的求和计算</strong></p><blockquote><p>多多路上从左到右有N棵树（编号1～N），其中第i个颗树有和谐值Ai。</p><p>多多鸡认为，如果一段连续的树，它们的和谐值之和可以被M整除，那么这个区间整体看起来就是和谐的。<br>现在多多鸡想请你帮忙计算一下，满足和谐条件的区间的数量。</p></blockquote><p>使用前缀和，使用哈希表存储，每个前缀和除以m的余数作为key，个数作为value。那么相同余数为m的两个前缀和相减一定能被m整除，需要注意key为0时，一个前缀和也是满足要求的。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span> cin<span class="token operator">>></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> mmap<span class="token punctuation">;</span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token operator">:</span>nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum<span class="token operator">=</span><span class="token punctuation">(</span>sum<span class="token operator">+</span>a<span class="token punctuation">)</span><span class="token operator">%</span>m<span class="token punctuation">;</span>            <span class="token operator">++</span>mmap<span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> kv<span class="token operator">:</span>mmap<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token operator">+=</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>kv<span class="token punctuation">.</span>second<span class="token operator">*</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>second<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ans<span class="token operator">+=</span>mmap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>4</strong>：<strong>多多的骰子组合</strong></p><blockquote><p>多多君拼团购买了N个骰子，为了方便后面进行活动，多多君需要将这些骰子进行分类。</p></blockquote><p>首先将所有输入数据进行整理，整理成按1为上面，然后可能通过观察1周围数字的顺序来判断两个骰子是否属于同一类，同一类的数字顺序是经过循环后能编程相同的，例如（6543和5436是相同的）</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">compare</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> suma<span class="token operator">=</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">1000</span><span class="token operator">+</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">100</span><span class="token operator">+</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sumb<span class="token operator">=</span>b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">1000</span><span class="token operator">+</span>b<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">100</span><span class="token operator">+</span>b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>b<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> rest<span class="token operator">=</span>suma<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>        suma<span class="token operator">/=</span><span class="token number">10</span><span class="token punctuation">;</span>        suma<span class="token operator">=</span>rest<span class="token operator">*</span><span class="token number">1000</span><span class="token operator">+</span>suma<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>suma<span class="token operator">==</span>sumb<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solid1top</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>nums<span class="token punctuation">,</span><span class="token keyword">int</span> pos1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pos1<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pos1<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pos1<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pos1<span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pos1<span class="token operator">==</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> pos1<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                cin<span class="token operator">>></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> pos1<span class="token operator">=</span>j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">solid1top</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>pos1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> classes<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> counts<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">bool</span> success<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>classes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>classes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    counts<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>                    success<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                classes<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                counts<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>counts<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>counts<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>counts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token operator">:</span>counts<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>c<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试真题 </tag>
            
            <tag> 拼多多 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心技术-卷I</title>
      <link href="/2023/10/04/Java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7I/"/>
      <url>/2023/10/04/Java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7I/</url>
      
        <content type="html"><![CDATA[<p>阅读《Java核心技术卷1：基础知识》笔记</p><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><p>Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性。</p><p>与C和C++不同，Java规范中没有“依赖具体实现”的地方。基本数据类型的大小以及有关运算都做了明确的说明。</p><p>Java高性能一个原因：即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“内联”）。即时编译器知道哪些类已经加载。基于当前加载的类集，如果特定的函数不会被覆盖，就可以使用内联</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004172020459.png"></p><p>Ubuntu安装JDK（open-jdk）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> default-jdk<span class="token function">java</span> <span class="token parameter variable">-version</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>手动编译Java程序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">javac <span class="token class-name">Welcome</span><span class="token punctuation">.</span>javajava <span class="token class-name">Welcome</span> <span class="token comment">//不能加后缀，大小写敏感</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h1><h4 id="helloworld示例"><a href="#helloworld示例" class="headerlink" title="helloworld示例"></a><strong>helloworld示例</strong></h4><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004192445225.png" alt="" style="zoom:50%;" /><ul><li>关键字public称为访问修饰符，这些修饰符用于控制程序的其他部分对这段代码的访问级别</li><li>标准的命名规范为：类名是以大写字母开头的名词。如果名字由多个单词组成，每个单词的第一个字母都应该大写</li><li>源代码的文件名必须与公共类的名字相同，并用 .java 作为扩展名</li><li>如果main方法正常退出，那么Java应用程序的退出代码为0，表示成功地运行了程序。如果希望在终止程序时返回其他的代码，那就需要调用System. exit方法。</li></ul><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h4><ul><li>&#x2F;&#x2F;，其注释内容从&#x2F;&#x2F;开始到本行结尾</li><li>&#x2F;* *&#x2F;，设置一段较长的注释，注意不能嵌套</li><li>以&#x2F;* * 开始，以*&#x2F;结束，可以用来自动地生成文档</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li><strong>整型</strong>：整型的范围与运行Java代码的机器无关<ul><li><strong>int</strong>：4字节</li><li><strong>short</strong>：2字节</li><li><strong>long</strong>：8字节。长整型数值有一个后缀L或l</li><li><strong>byte</strong>：1字节</li></ul></li><li><strong>浮点类型</strong>：<ul><li><strong>float</strong>：4字节。float类型的数值有一个后缀F或f，没有则默认为double类型。</li><li><strong>double</strong>：8字节</li></ul></li><li><strong>char类型</strong>：1字节。采用UTF-16编码，char类型的字面量值要用单引号括起来。</li><li><strong>boolean类型</strong>：1字节。整型值和布尔值之间不能进行相互转换。</li></ul><blockquote><p>常量Double.POSITIVE_INFINITY、Double.NEGATIVE_INFINITY和Double.NaN分别表示：正无穷大、负无穷大、NaN（不是一个数字）。</p><ul><li>注意，不能使用 if(x&#x3D;&#x3D;Double.NaN)判断是否等于Double.NaN，因为所有“非数值”的值都认为是不相同的。可以使用if(Double.isNaN(x))进行检测</li></ul></blockquote><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在声明变量时，变量的类型位于变量名之前。</p><ul><li>变量名必须是一个以字母开头并由字母或数字构成的序列。注意，java中字母和数字范围还包括一些其他字符。<ul><li>尽管$是一个合法的Java字符，但不要在你自己的代码中使用这个字符。它只用在Java编译器或其他工具生成的名字中。</li></ul></li><li>声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量。使用 &#x3D; 进行赋值。</li><li>利用关键字final指示常量，表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。</li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><p>使用算术运算符+、-、*、&#x2F;表示加、减、乘、除运算</p></li><li><p>整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NaN结果</p></li><li><p>strictfp关键字标记的方法和类，计算浮点数时需要使用严格的浮点计算：即计算中间值时也需要截断为64位</p></li><li><p>数值类型之间的转换如下图。实心箭头，表示无信息丢失的转换。箭头，表示可能有精度损失的转换</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004195744315.png" alt="" style="zoom:50%;" /></li><li><p>强制类型转换格式：( 目标类型 ) 源类型，如 (int) x</p><ul><li>如果想对浮点数进行舍入运算，以得到最接近的整数，使用Math.round方法</li><li>不要在boolean类型与任何数值类型之间进行强制类型转换，这样可以防止发生错误。只有极少数的情况才需要将布尔类型转换为数值类型，这时可以使用条件表达式b?1:0。</li></ul></li><li><p>和C++具有同样的自增自减运算符，使用规则也相同：++n、n++</p></li><li><p>&amp;&amp;和||运算符和C++一样同样具有“短路”性质，但&amp;和|运算符不采用“短路”方式来求值</p></li><li><p>‘&gt;&gt;’和’&lt;&lt;’运算符将位模式左移或右移。&gt;&gt;&gt;运算符会用0填充高位，这与&gt;&gt;不同，它会用符号位填充高位。不存在&lt;&lt;&lt;运算符。</p><ul><li>移位运算符的右操作数要完成模32的运算（除非左操作数是long类型，在这种情况下需要对右操作数模64）。例如，1 &lt;&lt; 35的值等同于1 &lt;&lt; 3。</li></ul></li><li><p>运算符优先级如下所示</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004200737908.png" alt="" style="zoom:50%;" /></li><li><p>枚举示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Size</span><span class="token punctuation">&#123;</span><span class="token constant">SMALL</span><span class="token punctuation">,</span><span class="token constant">MEDIUM</span><span class="token punctuation">,</span><span class="token constant">LARGE</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">Size</span> s<span class="token operator">=</span><span class="token class-name">Size</span><span class="token punctuation">.</span><span class="token constant">MEDIUM</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Java字符串就是Unicode字符序列</p><ul><li>String类提供substring获取子串，允许使用+号连接（拼接）两个字符串<ul><li>当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串</li></ul></li><li><strong>String类对象是不可变字符串，没有提供用于修改字符串的方法</strong>，只能用拼接方法来进行替换<ul><li>但可以修改字符串变量，让它引用另外一个字符串</li></ul></li><li>使用equals方法检测两个字符串是否相等，或使用compareTo方法<ul><li>不要使用&#x3D;&#x3D;运算符检测两个字符串是否相等！其操作方式类似于指针，只能够确定两个字符串是否放置在同一个位置上。</li><li>要想检测两个字符串是否相等，而不区分大小写，可以使用equalsIgnoreCase方法</li></ul></li><li>空串””是长度为0的字符串。空串是一个Java对象，有自己的串长度（0）和内容（空）。<ul><li>String变量还可以存放一个特殊的值，名为null，这表示目前没有任何对象与该变量关联</li></ul></li><li>length方法将返回采用UTF-16编码表示的给定字符串所需要的代码单元数量<ul><li>要想得到实际的长度，即码点数量，可以调用codePointCount方法</li></ul></li><li>如果需要用许多小段的字符串构建一个字符串，那么使用StringBuilder类，其线程不安全<ul><li>StringBuilder前身是StringBuffer，其效率稍有些低，但允许采用多线程的方式执行添加或删除字符的操作。这两个类的API是相同的。</li></ul></li></ul><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><ul><li><p>打印输出到“标准输出流”（即控制台窗口）只要调用System.out.println即可</p></li><li><p>输入代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>tuil<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token class-name">Scanner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> name <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取一整行</span>string firstName <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取一个单词（空白符分割）</span>string age <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取一个整数，获取浮点数则为nextDouble</span><span class="token comment">//boolean hasNext( ) 检测输入中是否还有其他单词。 同理还有hasNextInt( )和hasNextDouble( )</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>因为输入是可见的，所以Scanner类不适用于从控制台读取密码，可使用Console类：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004205427251.png" alt="" style="zoom:50%;" /></li><li><p>沿用了C语言库函数中的printf方法用于格式化输出</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004205741352.png" alt="" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004205844897.png" alt="" style="zoom:67%;" /></li><li><p>可以使用静态的String.format方法创建一个格式化的字符串，而不打印输出</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004205927568.png" alt="" style="zoom: 50%;" /></li><li><p>要想对文件进行读取，用File对象构造一个Scanner对象。如果文件不存在，创建该文件。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004210028304.png" alt="" style="zoom: 50%;" /><ul><li>用一个不能被创建的文件名构造一个PrintWriter，那么就会发生异常</li></ul></li></ul><h4 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h4><ul><li>在C++中，可以在嵌套的块中重定义一个变量，在内层定义的变量会覆盖在外层定义的变量。但是在Java中不允许这样做。</li><li>while循环语句首先检测循环条件。因此，循环体中的代码有可能不被执行。如果希望循环体至少执行一次，则应该将检测条件放在最后。使用do&#x2F;while循环语句可以实现这种操作方式</li><li>switch语句将从与选项值相匹配的case标签处开始执行直到遇到break语句，或者执行到switch语句的结束处为止。如果没有相匹配的case标签，而有default子句，就执行这个子句。<ul><li>如果在case分支语句的末尾没有break语句，那么就会接着执行下一个case分支语句。</li><li>case标签可以是：类型为char、byte、short或int的常量表达式、枚举常量、字符串字面量</li></ul></li><li>Java还提供了一种带标签的break语句，用于跳出多重嵌套的循环语句<ul><li>标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号。注意，只能跳出语句块，而不能跳入语句块。</li></ul></li></ul><h4 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h4><ul><li><p>BigInteger类实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。</p></li><li><p>使用静态的valueOf方法可以将普通的数值转换为大数值：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231005164855603.png" alt="" style="zoom:67%;" /><p>不能使用算术运算符（如：+和*）处理大数值，而需要使用大数值类中的add和multiply方法。</p></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><p>声明数组变量时，需要指出数组类型（数据元素类型紧跟[]）和数组变量的名字，以下两种形式皆可</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>声明数组之后，需要使用new将数组变量初始化为真正的数组</p></li><li><p>创建一个数字数组时，所有元素都初始化为0。boolean数组的元素会初始化为false。对象数组的元素则初始化为一个特殊值null，这表示这些元素未存放任何对象。</p></li><li><p>支持for each语句对数组或实现了Iterable接口的类对象进行遍历：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>variable <span class="token operator">:</span> collection<span class="token punctuation">)</span> statement<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>允许以下初始化方法，且不需要调用new</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>两个数组变量直接进行赋值，那么两个变量将引用同一个数组。如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的copyOf方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token operator">=</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Java数组与C++数组在堆栈上有很大不同，但基本上与分配在堆（heap）上的数组指针一样。</p></li><li><p>在Java应用程序的main方法中，程序名并没有存储在args数组中</p></li><li><p>，可以使用Arrays类中的sort方法对数值型数组进行排序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">Array</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>二维数组声明和初始化：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>java中的二维数组类似c++中的包含多个指针的数组，因此快速交换两行，且每行长度可以不同</li></ul></li></ul><hr><h1 id="3-对象和类"><a href="#3-对象和类" class="headerlink" title="3. 对象和类"></a>3. 对象和类</h1><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul><li>类之间的关系：依赖（“uses-a”）、聚合（“has-a”）、 继承（“is-a”）</li><li>用于控制可见性的4个访问修饰符：<ol><li>仅对本类可见——private。</li><li>对所有类可见——public。</li><li>对本包和所有子类可见——protected。</li><li>对本包可见——默认（很遗憾），不需要修饰符。</li></ol></li><li>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象<ul><li>在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。可以将Java的对象变量看作C++的对象指针。</li><li>所有的Java对象都存储在堆中。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。</li></ul></li><li>源文件名必须与public类的名字相匹配。在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类</li><li>关键字public意味着任何类的任何方法都可以调用这些方法。关键字private确保只有Employee类自身的方法能够访问这些实例域，而其他类的方法不能够读写这些域。</li><li>所有的Java对象都是在堆中构造的，构造器总是伴随着new操作符一起使用。</li><li>不能在构造方法中定义与类成员重名的局部变量。</li><li>所有的方法都必须在类的内部定义，但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。</li><li>final关键字只是表示存储在变量中的对象引用不会再指示其他对象。不过这个对象本身可以更改，类似c++中的指针常量，修饰的是该指针，而不是指向的对象</li><li>可以通过类对象或者类名调用静态方法</li><li>main方法不对任何对象进行操作。在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象。<ul><li>每一个类可以有一个main方法。这是一个常用于对类进行单元测试的技巧</li></ul></li><li>Java程序设计语言总是采用按值调用，方法得到的是所有参数值的一个拷贝。而对象类其实是一个指针，其值拷贝的也是指向的地址，因而可以改变原来的实参。<ul><li>注意，不能将类对象传参当成引用传递，只能看成指针传递。</li></ul></li></ul><h4 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h4><ul><li><p>如果多个方法有相同的名字、不同的参数，便产生了重载。返回类型不是方法签名的一部分，因此不能有两个名字相同、参数类型也相同却返回不同类型值的方法。</p></li><li><p>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null</p></li><li><p>如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。</p></li><li><p>如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。</p></li><li><p>可以在类成员变量定义时进行赋值，其在执行构造器之前，先执行赋值操作。</p><ul><li>定义时赋值，除了常量外，还能调用函数进行赋值</li></ul></li><li><p>如果构造函数的第一个语句形如this(…)，这个构造函数将调用同一个类的另一个构造函数</p></li><li><p>Java还提供初始化块方法进行初始化。先运行初始化块，然后才运行构造器的主体部分。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token punctuation">&#123;</span>id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>调用构造器的具体处理步骤：</p><ol><li>所有数据域被初始化为默认值（0、false或null）。</li><li>按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。</li><li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。</li><li>执行这个构造器的主体。</li></ol></li><li><p>由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。但当某些对象使用了内存之外的其他资源，需要对其进行回收，则可以为一个类添加<strong>finalize方法</strong>。finalize方法将在垃圾回收器清除对象之前调用。</p></li></ul><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><ul><li>一个类可以使用所属包中的所有类，以及其他包中的公有类。可以采用两种方式访问另一个包中的公有类：<ul><li>在每个类名之前添加完整的包名</li><li>使用import语句导入一个特定的类或者整个包。import语句应该位于源文件的顶部（但位于package语句的后面）</li></ul></li><li>import与#include并没有共同之处。在C++中，必须使用#include将外部特性的声明加载进来，这是因为C++编译器无法查看任何文件的内部，除了正在编译的文件以及在头文件中明确包含的文件。Java编译器可以查看其他文件的内部，只要告诉它到哪里去查看就可以了。<ul><li>在Java中，通过显式地给出包名，如java.util.Date，就可以不使用import</li><li>在Java中，package与import语句类似于C++中的namespace和using指令。</li></ul></li><li>要想将一个类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包</li><li>标记为public的部分可以被任意的类使用；标记为private的部分只能被定义它们的类使用。如果没有指定public或private，这个部分（类、方法或变量）可以被同一个包中的所有方法访问。</li></ul><h4 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h4><ul><li><p>类存储在文件系统的子目录中。类的路径必须与包名匹配。类文件也可以存储在JAR(Java归档)文件中。在一个JAR文件中，可以包含多个压缩形式的类文件和子目录，这样既可以节省又可以改善性能。</p></li><li><p>javac编译器总是在当前的目录中查找文件，但Java虚拟机仅在类路径中有“.”目录的时候才查看当前目录。如果没有设置类路径，那也并不会产生什么问题，默认的类路径包含“.”目录。然而如果设置了类路径却忘记了包含“.”目录，则程序仍然可以通过编译，但不能运行。</p></li><li><p>采用-classpath（或-cp）选项指定类路径（linux下用 ：分割，win下用；分割）：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231006162129360.png" alt="" style="zoom: 50%;" /></li></ul><h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h4><ul><li>javadoc，可以由源文件生成一个HTML文档。在源代码中添加以专用的定界符&#x2F;**开始的注释，可以容易地生成一个专业文档。<ul><li>&#x2F;** *&#x2F;格式中，第一句应该是一个概要性的句子，内容中可以使用HTML修饰符。例如，用于强调的<em>…</em>、用于着重强调的<strong>…</strong>以及包含图像的&lt;img …&gt;等</li></ul></li><li>javadoc实用程序（utility）从下面几个特性中抽取信息：包、公有类与接口、公有的和受保护的构造器及方法、公有的和受保护的域</li><li>类注释必须放在import语句之后，类定义之前</li><li>方法注释必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记：<ul><li>@param变量描述：对当前方法的“param”（参数）部分添加一个条目。这个描述可以占据多行，并可以使用HTML标记。一个方法的所有@param标记必须放在一起。</li><li>@return描述：对当前方法添加“return”（返回）部分。这个描述可以跨越多行，并可以使用HTML标记。</li><li>@throws类：将添加一个注释，用于表示这个方法有可能抛出异常。</li></ul></li><li>以下标记可以用在类文档的注释中：<ul><li>@author姓名：产生一个“author”（作者）条目。可以使用多个@author标记，每个@author标记对应一个作者。</li><li>@version文本：产生一个“version”（版本）条目。这里的文本可以是对当前版本的任何描述。</li><li>@since文本：产生一个“since”（始于）条目。这里的text可以是对引入特性的版本描述。例如，@since version 1.7.1。</li><li>@deprecated文本：将对类、方法或变量添加一个不再使用的注释。文本中给出了取代的建议。例如，@deprecated Use <code> setVisible(true) </code> instead通过@see和@link标记，可以使用超级链接，链接到javadoc文档的相关部分或外部文档。</li><li>@see引用：将在“see also”部分增加一个超级链接。它可以用于类中，也可以用于方法中。</li></ul></li><li>要想产生包注释，就需要在每一个包目录中添加一个单独的文件<ul><li>提供一个以package.html命名的HTML文件。在标记<body>…</body>之间的所有文本都会被抽取出来。</li><li>提供一个以package-info.java命名的Java文件。这个文件必须包含一个初始的以&#x2F;*<em>和</em>&#x2F;界定的Javadoc注释，跟随在一个包语句之后。它不应该包含更多的代码或注释。</li></ul></li><li>可以为所有的源文件提供一个概述性的注释。这个注释将被放置在一个名为overview. html的文件中，这个文件位于包含所有源文件的父目录中。标记<body>… </body>之间的所有文本将被抽取出来。当用户从导航栏中选择“Overview”时，就会显示出这些注释内容</li></ul><h4 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h4><ul><li><strong>一定要保证数据私有</strong></li><li><strong>一定要对数据初始化</strong><ul><li>Java不对局部变量进行初始化，但是会对对象的实例域进行初始化。应该显式地初始化所有的数据</li></ul></li><li><strong>不要在类中使用过多的基本类型</strong><ul><li>用其他的类代替多个相关的基本类型的使用。</li></ul></li><li><strong>不是所有的域都需要独立的域访问器和域更改器</strong></li><li><strong>将职责过多的类进行分解</strong></li><li><strong>类名和方法名要能够体现它们的职责</strong><ul><li>命名类名的良好习惯是采用一个名词（Order）、前面有形容词修饰的名词（RushOrder）或动名词（有“-ing”后缀）修饰名词（例如，BillingAddress）。</li><li>对于方法来说，习惯是访问器方法用小写get开头（getSalary），更改器方法用小写的set开头（setSalary）。</li></ul></li><li><strong>优先使用不可变的类</strong></li></ul><hr><h1 id="4-继承"><a href="#4-继承" class="headerlink" title="4. 继承"></a>4. 继承</h1><h4 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h4><ul><li><p>Java用关键字extends代替了C++中的冒号（:）继承。在Java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承。</p></li><li><p>派生类不能访问基类的成员变量（相当于对成员变量是private继承），只能采用提供的方法接口进行访问。</p></li><li><p>当重写函数时，如果需要调用基类的同名函数，需要使用super关键字，例如 super.getSalary()。</p><ul><li>super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。</li></ul></li><li><p>调用基类构造函数方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>使用super调用构造器的语句必须是子类构造器的第一条语句。</p></li><li><p>如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。</p><blockquote><p>super关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。</p></blockquote></li></ul></li><li><p>在Java中，不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征，可以将它标记为final</p></li><li><p>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。</p></li><li><p>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法一定要声明为public</p></li><li><p>在定义类的时候使用了final修饰符就表明这个类是final类。</p><ul><li>将方法或类声明为final主要目的是：确保它们不会在子类中改变语义。</li></ul></li><li><p>对象引用的转换语法与数值表达式的类型转换类似，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前</p><ul><li>只能在继承层次内进行类型转换。</li><li>在将超类转换成子类之前，应该使用instanceof进行检查。</li><li>Java使用的类型转换语法处理过程类似C++的dynamic_cast操作，它们之间只有一点重要的区别：当类型转换失败时，Java不会生成一个null对象，而是抛出一个异常。</li></ul></li><li><p>使用abstract可以声明抽象类和抽象方法</p><ul><li>除了抽象方法之外，抽象类还可以包含具体数据和具体方法。类即使不含抽象方法，也可以将类声明为抽象类</li></ul></li><li><p>声明为protected，对所有子类及同一个包中的所有其他类都可见</p></li></ul><h4 id="Object：所有类的超类"><a href="#Object：所有类的超类" class="headerlink" title="Object：所有类的超类"></a>Object：所有类的超类</h4><ul><li>Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。<ul><li>只有基本类型（primitive types）不是对象，例如，数值、字符和布尔类型的值都不是对象。</li><li>所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。</li></ul></li><li>Object类中的equals方法用于检测一个对象是否等于另外一个对象，这个方法将判断两个对象是否具有相同的引用。</li><li>Java语言规范要求equals方法具有下面的特性：<ol><li>自反性：对于任何非空引用x, x.equals(x)应该返回true。</li><li>对称性：对于任何引用x和y，当且仅当y.equals(x)返回true, x.equals(y)也应该返回true。</li><li>传递性：对于任何引用x、y和z，如果x.equals(y)返回true, y.equals(z)返回true, x.equals(z)也应该返回true。</li><li>一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果。</li><li>对于任意非空引用x, x.equals(null)应该返回false。</li></ol></li><li>由于hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。</li><li>toString方法，用于返回表示对象值的字符串，格式：类的名字，随后是一对方括号括起来的域值<ul><li>只要对象与一个字符串通过操作符“+”连接起来，Java编译就会自动地调用toString方法</li></ul></li></ul><h4 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h4><ul><li><p>ArrayList是一个采用类型参数的泛型类。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Test</span><span class="token punctuation">></span></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Test</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//()里加上数字的话可以指定预分配空间大小</span>a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//添加一个元素</span>a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//向第i个位置添加一个元素</span>a<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除一个元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果调用add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</p></li><li><p>如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用ensureCapacity方法，其可以预分配空间（类似c++中的reserve函数）</p></li><li><p>一旦能够确认数组列表的大小不再发生变化，就可以调用trimToSize方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。</p></li><li><p>使用get和set方法实现访问或改变数组元素的操作，而不使用人们喜爱的[ ]语法格式</p><ul><li>使用add方法为数组添加新元素，而不要使用set方法，它只能替换数组中已经存在的元素内容</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">a<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//只有i小于或等于数组列表的大小时，才能够调用</span><span class="token class-name">Test</span> t <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>带有类型的ArrayList传值给不带类型的ArrayList不会有任何报错或警告，反之会有警告</p></li></ul><h4 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h4><ul><li>所有的基本类型都有一个与之对应的类，这些类称为包装器。<ul><li>Integer、Long、Float、Double、Short、Byte、Character、Void和Boolean</li><li>对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。</li><li>对象包装器类还是final，因此不能定义它们的子类。</li></ul></li><li>ArrayList&lt; Integer &gt; 的add方法可以直接将数字3添加到列表，其会被自动转换成一个Integer对象，这种变换被称为<strong>自动装箱</strong>。相反地，当将一个Integer对象赋给一个int值时，将会<strong>自动拆箱</strong></li><li>由于包装器类引用可以为null，所以自动装箱有可能会抛出一个NullPointerException异常</li><li>如果在一个条件表达式中混合使用Integer和Double类型，Integer值就会拆箱，提升为double，再装箱为Double</li></ul><h4 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h4><ul><li><p>Java SE 5.0以后的版本提供了可变函数参数，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>实际上，printf方法接收两个参数，一个是格式字符串，另一个是Object[ ]数组，其中保存着所有的参数</li><li>编译器会自动创建一个数组，其中包含传递的参数</li></ul></li></ul><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><ul><li><p>示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">&#123;</span><span class="token constant">SMALL</span><span class="token punctuation">,</span> <span class="token constant">MEDIUM</span><span class="token punctuation">,</span> <span class="token constant">LARGE</span><span class="token punctuation">,</span> <span class="token constant">EXTRA_LARGE</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>实际上，这个声明定义的类型是一个类，它刚好有4个实例，在此尽量不要构造新对象</li><li>在比较两个枚举类型的值时，永远不需要调用equals，而直接使用“&#x3D; &#x3D;”</li></ul></li><li><p>可以在枚举类型中添加一些构造器、方法和域。当然，构造器只是在构造枚举常量的时候被调用</p></li><li><p>所有的枚举类型都是Enum类的子类。它们继承了这个类的许多方法，例如toString</p></li><li><p>每个枚举类型都有一个静态的values方法，它将返回一个包含全部枚举值的数组。</p></li></ul><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ul><li><p>能够分析类能力的程序称为<strong>反射（reflective）</strong>。反射机制可以用来：</p><ul><li>在运行时分析类的能力</li><li>在运行时查看对象，例如，编写一个toString方法供所有类使用</li><li>实现通用的数组操作代码</li><li>利用Method对象，这个对象很像C++中的函数指针。</li></ul></li><li><p>Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。</p><ul><li>保存这些信息的类被称为Class，Object类中的getClass( )方法将会返回一个Class类型的实例。</li><li>一个Class对象将表示一个特定类的属性。最常用的Class方法是getName。这个方法将返回类的名字。</li></ul></li><li><p>可以调用静态方法forName获得类名对应的Class对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span> cl <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.util.Random"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>如果T是任意的Java类型（或void关键字）, T.class将代表匹配的类对象</p><pre class="line-numbers language-none"><code class="language-none">Class cl1 &#x3D; Random.class;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>newInstance( )，可以用来动态地创建一个类的实例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> m <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>Class类与C++中的type_info类相似，getClass方法与C++中的typeid运算符等价。但Java中的Class比C++中的type_info的功能强。C++中的type_info只能以字符串的形式显示一个类型的名字，而不能创建那个类型的对象。</p></blockquote></li><li><p>异常有两种类型：未检查异常和已检查异常</p><ul><li>对于已检查异常，编译器将会检查是否提供了处理器。</li><li>然而，有很多常见的异常，例如，访问null引用，都属于未检查异常。编译器不会查看是否为这些错误提供了处理器</li></ul></li><li><p>在java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的域、方法和构造器。</p></li><li><p>查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象（例如，通过getDeclaredFields得到的对象）, obj是某个包含f域的类的对象，f.get(obj)将返回一个对象，其值为obj域的当前值。</p></li><li><p><strong>调用任意方法</strong></p><ul><li><p>Java没有提供方法指针，但Method类中有一个invoke方法，它允许调用包装在当前Method对象中的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//invoke方法原型</span><span class="token class-name">String</span> n<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>m1<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>harry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用示例，m1是Employee类的getName方法，被包装成一个Method对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>如果返回类型是基本类型，invoke方法会返回其包装器类型</p></li></ul></li></ul><h4 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h4><ul><li><strong>将公共操作和域放在超类</strong></li><li><strong>不要使用受保护的域</strong><ul><li>子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的实例域，从而破坏了封装性。</li><li>在同一个包中的所有类都可以访问proteced域，而不管它是否为这个类的子类。</li></ul></li><li><strong>使用继承实现“is-a”关系</strong></li><li><strong>除非所有继承的方法都有意义，否则不要使用继承</strong></li><li><strong>在覆盖方法时，不要改变预期的行为</strong></li><li><strong>使用多态，而非类型信息</strong></li><li><strong>不要过多地使用反射</strong><ul><li>反射是很脆弱的，即编译器很难帮助人们发现程序中的错误，因此只有在运行时才发现错误并导致异常。</li></ul></li></ul><hr><h1 id="5-接口、lambda表达式与内部类"><a href="#5-接口、lambda表达式与内部类" class="headerlink" title="5. 接口、lambda表达式与内部类"></a>5. 接口、lambda表达式与内部类</h1><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li><p>要将类声明为实现某个接口，需要使用关键字implements，每个类可以实现多个接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Test</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//实现泛型接口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。</p><ul><li><p>不能使用new运算符实例化一个接口，但能声明接口的变量，接口变量必须引用实现了接口的类对象：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//error</span><span class="token class-name">Comparable</span> x<span class="token punctuation">;</span><span class="token comment">//ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p>接口中的所有方法自动地属于public。因此，在接口中声明方法时，不必提供关键字public。</p><ul><li>但是！在实现接口时，必须把方法声明为public；否则，编译器将认为这个方法的访问属性是包可见性，即类的默认访问属性</li></ul></li><li><p>接口中还可以定义常量（被自动设为public static final）。接口绝不能含有实例域，在Java SE 8之前，也不能在接口中实现方法。</p></li><li><p>可以使用instance检查一个对象是否实现了某个特定的接口。接口和类一样，都可以使用extend关键字进行扩展。</p></li><li><p>在Java SE 8中，允许在接口中增加静态方法。只是这有违于将接口作为抽象规范的初衷。目前为止，通常的做法都是将静态方法放在伴随类中</p></li><li><p>可以为接口方法提供一个默认实现，必须用default修饰符标记这样一个方法。默认方法可以调用任何其他方法。</p></li><li><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况？</p><ul><li>超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li><li>接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突。</li><li>一个类扩展了一个超类，同时实现了一个接口，并从超类和接口继承了相同的方法。在这种情况下，只会考虑超类方法，接口的所有默认方法都会被忽略。</li></ul></li></ul><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><ul><li><p>lambda表达式形式:</p><ul><li>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。</li><li>即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样</li><li>如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span><span class="token operator">-></span> <span class="token punctuation">&#123;</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//无需指定lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出。</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> cmp <span class="token operator">=</span> <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token operator">-></span>    first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//编译器可以推导出first和second必然是字符串，因为这个lambda表达式将赋给一个字符串比较器。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为<strong>函数式接口</strong></p></li><li><p><strong>方法引用</strong>：</p><ul><li>方法引用等价于提供方法参数的lambda表达式</li><li>表达式System.out::println是一个方法引用（method reference），它等价于lambda表达式x -&gt;System.out.println(x)。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007153241587.png" alt="" style="zoom:50%;" /></li><li><p><strong>构造器引用</strong>：构造器引用与方法引用很类似，只不过方法名为new。例如Person::new</p></li><li><p>lambda表达式可以捕获外围作用域中变量的值，但是只能引用值不会改变的变量，即捕获的变量必须实际上是最终变量（变量初始化之后就不会再为它赋新值）</p></li><li><p>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的类的this参数。</p></li><li><p>常用函数式接口</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007154819408.png" alt="" style="zoom:50%;" /></li><li><p>如果设计你自己的接口，其中只有一个抽象方法，可以用@FunctionalInterface注解来标记这个接口。这样做有两个优点。如果你无意中增加了另一个非抽象方法，编译器会产生一个错误消息。另外javadoc页里会指出你的接口是一个函数式接口。</p></li></ul><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><ul><li><p>内部类（inner class）是定义在另一个类中的类。其特点如下：</p><ol><li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。</li><li>内部类可以对同一个包中的其他类隐藏起来。</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。</li><li>内部类的对象有一个隐式引用，它引用了实例化该内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态<ul><li>外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加一个外围类引用的参数。</li></ul></li></ol></li><li><p>内部类示例如下</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007161056404.png" alt="" style="zoom:50%;" /></li><li><p>使用外围类引用的语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">OutClass</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>可以允许有静态方法，但只能访问外围类的静态域和方法。</p></li><li><p><strong>局部内部类</strong></p><ul><li>局部类不能用public或private访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。</li><li>局部类有一个优势，即对外部世界可以完全地隐藏起来。</li><li>不仅能够访问包含它们的外部类，还可以访问局部变量，变量必须事实上为final。</li></ul></li><li><p><strong>匿名内部类</strong></p><ul><li><p>将局部内部类的使用再深入一步。假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类。语法格式如下：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007162537124.png" alt="" style="zoom: 33%;" /></li><li><p>SuperType可以是ActionListener这样的接口，于是内部类就要实现这个接口。SuperType也可以是一个类，于是内部类就要扩展它。</p></li><li><p>由于构造器的名字必须与类名相同，而匿名类没有类名，所以，匿名类不能有构造器。取而代之的是，将构造器参数传递给超类（superclass）构造器。尤其是在内部类实现接口的时候，不能有任何构造参数。</p></li></ul></li><li><p><strong>匿名列表</strong></p><ul><li><p>注意这里的双括号。外层括号建立了ArrayList的一个匿名子类。内层括号则是一个对象构造块</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007162912407.png" alt="" style="zoom:50%;" /></li></ul></li><li><p><strong>静态内部类</strong></p><ul><li>public 后添加static关键字后，即可成为静态内部类。</li><li>静态内部类的对象除了没有对生成它的外围类对象的引用特权外，与其他所有内部类完全一样。</li><li>在内部类不需要访问外围类对象的时候，应该使用静态内部类。</li><li>声明在接口中的内部类自动成为static和public类。</li></ul></li></ul><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><ul><li><p>利用代理可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。</p></li><li><p>代理类可以在运行时创建全新的类。这样的代理类能够实现指定的接口，它具有下列方法：</p><ol><li>指定接口所需要的全部方法。</li><li>Object类中的全部方法，例如，toString、equals等。</li></ol></li><li><p>要想创建一个代理对象，需要使用Proxy类的newProxyInstance方法。这个方法有三个参数：一个类加载器、一个Class对象数组，每个元素都是需要实现的接口、一个调用处理器</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007164851121.png" alt="" style="zoom:50%;" /></li><li><p>代理类是在程序运行过程中创建的。然而，一旦被创建，就变成了常规类，与虚拟机中的任何其他类没有什么区别。</p></li><li><p>所有的代理类都扩展于Proxy类。一个代理类只有一个实例域——调用处理器，它定义在Proxy的超类中。为了履行代理对象的职责，所需要的任何附加数据都必须存储在调用处理器中</p></li><li><p>所有的代理类都覆盖了Object类中的方法toString、equals和hashCode。</p></li><li><p>对于特定的类加载器和预设的一组接口来说，只能有一个代理类。也就是说，如果使用同一个类加载器和接口数组调用两次newProxyInstance方法的话，那么只能够得到同一个类的两个对象</p></li><li><p>代理类一定是public和final。如果代理类实现的所有接口都是public，代理类就不属于某个特定的包；否则，所有非公有的接口都必须属于同一个包，同时，代理类也属于这个包。</p></li></ul><hr><h1 id="6-异常、断言和日志"><a href="#6-异常、断言和日志" class="headerlink" title="6. 异常、断言和日志"></a>6. 异常、断言和日志</h1><h4 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h4><ul><li><p>异常对象都是派生于Throwable类的一个实例</p><ul><li><p>Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了通告给用户，并尽力使程序安全地终止之外，再也无能为力了。</p></li><li><p>由程序错误导致的异常属于RuntimeException；而程序本身没有问题，但由于像I&#x2F;O错误这类问题导致的异常属于其他异常</p><ul><li>派生于RuntimeException的异常包含下面几种情况：● 错误的类型转换。● 数组访问越界。● 访问null指针。</li><li>不是派生于RuntimeException的异常包括：● 试图在文件尾部后面读取数据。● 试图打开一个不存在的文件。● 试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在。</li></ul></li><li><p>派生于Error类或RuntimeException类的所有异常称为非受查（unchecked）异常，所有其他的异常称为受查（checked）异常。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007170431987.png" alt="" style="zoom:50%;" /></li></ul></li></ul><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a><strong>抛出异常</strong></h4><ul><li>方法应该在其首部声明所有可能抛出的异常。这样可以从首部反映出这个方法可能抛出哪类受查异常。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007170912030.png" alt="" style="zoom: 50%;" /><ul><li><p>下面4种情况时应该抛出异常：</p><ol><li><p>调用一个抛出受查异常的方法</p></li><li><p>程序运行过程中发现错误，并且利用throw语句抛出一个受查异常（</p></li><li><p>程序出现错误</p></li><li><p>Java虚拟机和运行时库出现的内部错误。</p><blockquote><p>如果出现前两种情况之一，则必须告诉调用这个方法的程序员有可能抛出异常。为什么？因为任何一个抛出异常的方法都有可能是一个死亡陷阱。如果没有处理器捕获这个异常，当前执行的线程就会结束。</p></blockquote></li></ol></li><li><p>一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控制（Error），要么就应该避免发生（RuntimeException）。如果方法没有声明所有可能发生的受查异常，编译器就会发出一个错误消息。</p></li><li><p>如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常</p></li><li><p>定义的异常类应该包含两个构造器，一个是默认的构造器；另一个是带有详细描述信息的构造器（超类Throwable的toString方法将会打印出这些详细信息，这在调试中非常有用）</p></li></ul><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a><strong>捕获异常</strong></h4><ul><li><p>如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息，其中包括异常的类型和堆栈的内容。</p></li><li><p>要想捕获一个异常，必须设置try&#x2F;catch语句块。如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类，那么程序将跳过try语句块的其余代码、程序将执行catch子句中的处理器代码。</p></li><li><p>通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续进行传递。</p><ul><li>如果想传递一个异常，就必须在方法的首部添加一个throws说明符，以便告知调用者这个方法可能会抛出异常。</li><li>如果调用了一个抛出受查异常的方法，就必须对它进行处理，或者继续传递。</li></ul></li><li><p>在一个try语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理，为每个异常类型使用一个单独的catch子句</p><ul><li>在Java SE 7中，同一个catch子句中可以捕获多个异常类型。使用 | 符号进行连接</li></ul></li><li><p>在catch子句中可以抛出一个异常，这样做的目的是改变异常的类型。</p><ul><li><p>以下方法可以重新得到原始异常</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007172529749.png" alt="" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007172559915.png" alt="" style="zoom:33%;" /></li></ul></li><li><p>不管是否有异常被捕获，finally子句中的代码都被执行</p><ul><li>代码没有抛出异常。在这种情况下，程序首先执行try语句块中的全部代码，然后执行finally子句中的代码。</li><li>抛出一个在catch子句中捕获的异常。在这种情况下，程序将执行try语句块中的所有代码，直到发生异常为止。此时，将跳过try语句块中的剩余代码，转去执行与该异常匹配的catch子句中的代码，最后执行finally子句中的代码。</li><li>代码抛出了一个异常，但这个异常不是由catch子句捕获的。在这种情况下，程序将执行try语句块中的所有语句，直到有异常被抛出为止。此时，将跳过try语句块中的剩余代码，然后执行finally子句中的语句，并将异常抛给这个方法的调用者。</li></ul></li><li><p>当finally子句中的return值会覆盖try语句中的return值。类似，finally块中抛出的异常会覆盖try中抛出的异常（没有catch语句时）</p></li><li><p>带资源的try语句（try-with-resources）的最简形式为：</p><ul><li>try块退出时或者存在一个异常时，会自动调用res.close()，就好像使用了finally块一样。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007173823756.png" alt="" style="zoom: 33%;" /></li><li><p><strong>分析堆栈轨迹元素</strong></p><ul><li>堆栈轨迹（stack trace）是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。</li><li>可以调用Throwable类的printStackTrace方法访问堆栈轨迹的文本描述信息。</li><li>使用getStackTrace方法，会得到StackTraceElement对象的一个数组，可以在程序中分析这个对象数组</li></ul></li><li><p><strong>使用异常机制的技巧</strong></p><ul><li>异常处理不能代替简单的测试<ul><li>与执行简单的测试相比，捕获异常所花费的时间大大超过了前者，因此使用异常的基本规则是：只在异常情况下使用异常机制。</li></ul></li><li>不要过分地细化异常</li><li>利用异常层次结构<ul><li>不要只抛出RuntimeException异常。应该寻找更加适当的子类或创建自己的异常类。</li><li>不要只捕获Thowable异常，否则，会使程序代码更难读、更难维护。</li></ul></li><li>不要压制异常</li><li>在检测错误时，“苛刻”要比放任更好</li><li>不要羞于传递异常</li></ul></li></ul><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><ul><li><p>断言机制允许在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句将会被自动地移走：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">assert</span> 条件；<span class="token keyword">assert</span> 条件<span class="token operator">:</span> 表达式<span class="token punctuation">;</span><span class="token comment">//表达式将被传入AssertionError的构造器，并转换成一个消息字符串。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>这两种形式都会对条件进行检测，如果结果为false，则抛出一个AssertionError异常</li><li>“表达式”部分的唯一目的是产生一个消息字符串。</li></ul></li><li><p>在默认情况下，断言被禁用。可以在运行程序时用-enableassertions或-ea选项启用</p></li><li><p>在Java中，条件并不会自动地成为错误报告中的一部分。如果希望看到这个条件，就必须将它以字符串的形式传递给AssertionError对象，例如assert x &gt;&#x3D; 0 : “x &gt;&#x3D; 0”。</p></li><li><p>什么时候应该选择使用断言呢？</p><ul><li>断言失败是致命的、不可恢复的错误。断言检查只用于开发和测阶段</li></ul></li></ul><h4 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h4><ul><li><p>生成简单的日志记录，可以使用全局日志记录器（global logger）并调用其info方法：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007192557988.png" alt="" style="zoom:50%;" /></li><li><p>可以调用getLogger方法创建或获取记录器：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007192800558.png" alt="" style="zoom:50%;" /><ul><li>未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，用一个静态变量存储日志记录器的一个引用。</li></ul></li><li><p>有以下7个日志记录器级别： SEVERE、 WARNING、INFO、CONFIG、FINE、FINER、FINEST</p><ul><li>如果将记录级别设计为INFO或者更低，则需要修改日志处理器的配置。默认的日志处理器不会处理低于INFO级别的信息。</li></ul></li><li><p>日志记录方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">logger<span class="token punctuation">.</span><span class="token function">warning</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Leve</span><span class="token punctuation">.</span><span class="token constant">FINE</span><span class="token punctuation">,</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>默认的日志记录将显示包含日志调用的类名和方法名，如同堆栈所显示的那样。但是，如果虚拟机对执行过程进行了优化，就得不到准确的调用信息。此时，可以调用logp方法获得调用类和方法的确切位置</p></li><li><p>记录日志的常见用途是记录那些不可预料的异常。可以使用下面两个方法提供日志记录中包含的异常描述内容</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007193212147.png" alt="" style="zoom:50%;" /></li><li><p><strong>日志消息本地化</strong></p><ul><li><p>在请求日志记录器时，可以指定一个资源包：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007193502797.png" alt="" style="zoom:50%;" /></li><li><p>然后，为日志消息指定资源包的关键字，而不是实际的日志消息字符串</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231007193521587.png" alt="" style="zoom:50%;" /></li></ul></li><li><p>在默认情况下，日志记录器将记录发送到ConsoleHandler中，并由它输出到System.err流中。</p></li><li><p>过滤器根据日志记录的级别进行过滤，可以通过实现Filter接口并定义下列方法来自定义过滤器</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009194405588.png" alt="" style="zoom:50%;" /></li><li><p>自定义格式需要扩展Formatter类并覆盖下面这个方法：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009194516657.png" alt="" style="zoom:50%;" /></li></ul><h4 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h4><ul><li>打印或记录任意变量的值</li><li>在每一个类中放置一个单独的main方法</li><li>JUnit是一个非常常见的单元测试框架，利用它可以很容易地组织测试用例套件。只要修改类，就需要运行测试。在发现bug时，还要补充一些其他的测试用例。</li><li>日志代理（logging proxy）是一个子类的对象，它可以截获方法调用，并进行日志记录，然后调用超类中的方法。</li><li>利用Throwable类提供的printStackTrace方法，可以从任何一个异常对象中获得堆栈情况</li><li>可以使用jmap实用工具获得一个堆的转储，其中显示了堆中的每个对象</li></ul><hr><h1 id="7-泛型程序设计"><a href="#7-泛型程序设计" class="headerlink" title="7. 泛型程序设计"></a>7. 泛型程序设计</h1><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><ul><li><p>泛型类引入类型变量T，用尖括号（&lt; &gt;）括起来，并放在类名的后面。泛型类可以有多个类型变量。例如，可以定义Pair类，其中第一个域和第二个域使用不同的类型：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009195551179.png" alt="" style="zoom:50%;" /></li><li><p>定义一个带有类型参数的简单方法：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009195737223.png" alt="" style="zoom:50%;" /><ul><li><p>泛型方法可以定义在普通类中，也可以定义在泛型类中</p></li><li><p>当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型（也可以省略类型，编译器能自动推导）：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009195826580.png" alt="" style="zoom: 50%;" /></li></ul></li><li><p>将T限制为实现了Comparable接口的类（注意是extends而不是implements）</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009200216570.png" alt="" style="zoom:50%;" /><ul><li><p>一个类型变量或通配符可以有多个限定，例如：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009200414548.png" alt="" style="zoom:50%;" /></li></ul></li></ul><h4 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h4><ul><li><p>无论何时定义一个泛型类型，都自动提供了一个相应的原始类型（raw type）。原始类型的名字就是删去类型参数后的泛型类型名，然后将泛型类型变量替换为限定类型（无限定的变量用Object）。</p><ul><li>原始类型用第一个限定的类型变量来替换，如果没有给定限定就用Object替换（限定是指T extend后的）</li><li>类型擦除也会出现在泛型方法中</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009201245303.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009201252999.png" alt="" style="zoom:50%;" /></li><li><p>当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换</p></li></ul><h4 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h4><ul><li>不能用基本类型实例化类型参数</li><li>运行时类型查询只适用于原始类型</li><li>不能创建参数化类型的数组<ul><li>擦除之后，会被转换为Object[]，数组会记住它的元素类型，如果试图存储其他类型的元素，就会抛出一个Array-StoreException异常</li></ul></li><li>Varargs警告<ul><li>可变参数是用一个数组实现的，因此根据上一条会出现一个警告</li></ul></li><li>不能实例化类型变量。不能使用像new T(…), new T[…]或T.class这样的表达式中的类型变量</li><li>不能构造泛型数组</li><li>泛型类的静态上下文中类型变量无效。即不能设置泛型类型的静态变量或静态方法</li><li>不能抛出或捕获泛型类的实例</li><li>可以消除对受查异常的检查</li><li>注意擦除后的冲突。当泛型类型被擦除时，无法创建引发冲突的条件。</li><li>泛型类型指定基类，不能使用子类作为参数</li></ul><h4 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h4><ul><li><p>通配符类型中，允许类型参数变化。例如以下表示任何泛型Pair类型，它的类型参数是Employee的子类</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009204322457.png" alt="" style="zoom:50%;" /></li><li><p>通配符可以指定一个超类型限定，以下通配符限制为Manager的所有超类型</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009204617832.png" alt="" style="zoom:50%;" /></li><li><p>还可以使用无限定的通配符，例如，Pair&lt;? &gt;</p></li></ul><h4 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h4><ul><li>反射允许你在运行时分析任意的对象。如果对象是泛型类的实例，关于泛型类型参数则得不到太多信息，因为它们会被擦除。</li></ul><hr><h1 id="8-集合"><a href="#8-集合" class="headerlink" title="8. 集合"></a>8. 集合</h1><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231011205113971.png" alt="" style="zoom:50%;" /><h4 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h4><ul><li><p><strong>将集合的接口与实现分离</strong></p><ul><li>Java集合类库将接口与实现分离。</li><li>例如队列接口指出可以在队列的尾部添加元素，在队列的头部删除元素，并且可以查找队列中元素的个数。而实现则由实现了该接口的类进行完成。</li></ul></li><li><p><strong>Collection接口</strong></p><ul><li><p>集合类的基本接口是Collection接口。这个接口有两个基本方法</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009205927811.png" alt="" style="zoom:50%;" /></li><li><p>add方法用于向集合中添加元素，iterator方法用于返回一个实现了Iterator接口的对象</p></li></ul></li><li><p><strong>迭代器</strong></p><ul><li><p>Iterator接口包含4个方法：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009210046748.png" alt="" style="zoom:50%;" /></li><li><p>反复调用next方法，可以逐个访问集合中的每个元素。但是，如果到达了集合的末尾，next方法将抛出一个NoSuchElementException。因此，需要在调用next之前调用hasNext方法。</p><ul><li><p>当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用</p></li><li><p>用“for each”循环可以更加简练地表示同样的循环操作。编译器简单地将“for each”循环翻译为带有迭代器的循环。</p></li><li><p>“for each”循环可以与任何实现了Iterable接口的对象一起工作</p></li><li><p>可以调用forEachRemaining方法并提供一个lambda表达式。将对迭代器的每一个元素调用这个lambda表达式，直到再没有元素为止。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231009210920972.png" alt="" style="zoom:50%;" /></li></ul></li><li><p>remove方法将会删除上次调用next方法时返回的元素。如果想要删除指定位置上的元素，仍然需要越过这个元素。</p><ul><li>如果调用remove之前没有调用next将是不合法的。如果这样做，将会抛出一个IllegalStateException异常。</li></ul></li></ul></li><li><p><strong>集合框架中的接口</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231010162501658.png" alt="" style="zoom:50%;" /></li></ul><h4 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h4><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231010171150800.png" alt="" style="zoom:50%;" /><p><strong>链表LinkedList</strong></p><ul><li>链表是一个有序集合。</li><li>LinkedList.add方法将对象添加到链表的尾部。但是将元素添加到链表的中间某位置时，可以使用迭代器的add方法，该Add方法在迭代器位置之前添加一个新对象。</li><li>调用next之后，remove方法删除了迭代器左侧的元素。但是，如果调用previous就会将右侧的元素删除掉，并且不能连续调用两次remove。<ul><li>add方法只依赖于迭代器的位置，而remove方法依赖于迭代器的状态。</li></ul></li><li>set方法用一个新元素取代调用next或previous方法返回的上一个元素。</li><li>get方法可以用来访问某个特定元素，但效率很低</li></ul><blockquote><p>从概念上讲，由于Java迭代器指向两个元素之间的位置，所以可以同时产生两个索引：nextIndex方法返回下一次调用next方法时返回元素的整数索引；previousIndex方法返回下一次调用previous方法时返回元素的整数索引。当然，这个索引只比nextIndex返回的索引值小1。这两个方法的效率非常高，这是因为迭代器保持着当前位置的计数值。</p></blockquote><p><strong>数组列表ArrayList</strong></p><ul><li>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象，因此当由一个线程访问Vector，代码要在同步操作上耗费大量的时间。而ArrayList方法不是同步的，因此，建议在不需要同步时使用ArrayList，而不要使用Vector。</li></ul><p><strong>散列集</strong></p><ul><li>如果自定义类，就要负责实现这个类的hashCode方法。注意，自己实现的hashCode方法应该与equals方法兼容，即如果a.equals(b)为true，a与b必须具有相同的散列码。</li><li>散列表用链表数组实现，使用链表法解决冲突<ul><li>在Java SE 8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突，或者如果有恶意代码试图在散列表中填充多个有相同散列码的值，这样就能提高性能。</li></ul></li></ul><p><strong>树集</strong></p><ul><li>树集是一个有序集合。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。</li><li>要使用树集，必须能够比较元素。这些元素必须实现Comparable接口，或者构造集时必须提供一个Comparator</li></ul><p><strong>队列与双端队列</strong></p><ul><li>在Java SE 6中引入了Deque接口，并由ArrayDeque和LinkedList类实现。这两个类都提供了双端队列，而且在必要时可以增加队列的长度。</li></ul><p><strong>优先级队列</strong></p><ul><li>优先级队列（priority queue）中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索</li><li>优先级队列使用了堆作为底层，调用remove方法，会获得当前优先级队列中最小的元素</li><li>优先级队列既可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供的Comparator对象。</li></ul><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><ul><li><p>Java类库为映射提供了两个通用的实现：HashMap和TreeMap。这两个类都实现了Map接口。</p></li><li><p>将键值加1时，可能存在键不存在这类情况，可以使用以下方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">counts<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果键原先不存在，将把word与1关联，否则使用Integer::sum函数组合原值和1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>映射视图</strong></p><ul><li><p>集合框架不认为映射本身是一个集合。（其他数据结构框架认为映射是一个键&#x2F;值对集合，或者是由键索引的值集合。）不过，可以得到映射的视图（view）——这是实现了Collection接口或某个子接口的对象</p></li><li><p>有3种视图：键集、值集合（不是一个集）以及键&#x2F;值对集。键和键&#x2F;值对可以构成一个集，因为映射中一个键只能有一个副本。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231011163211700.png" alt="" style="zoom:50%;" /></li><li><p>keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象。Set接口扩展了Collection接口。因此，可以像使用集合一样使用keySet。</p></li><li><p>如果在键集视图上调用迭代器的remove方法，实际上会从映射中删除这个键和与它关联的值。不过，不能向键集视图增加元素。</p></li></ul></li><li><p><strong>弱散列映射</strong></p><ul><li>WeakHashMap使用弱引用保存键。WeakReference对象将引用保存到另外一个对象中，在这里，就是散列键。</li><li>对于这种类型的对象，垃圾回收器用一种特有的方式进行处理。通常，如果垃圾回收器发现某个特定的对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由WeakReference引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放入队列中。</li><li>WeakHashMap将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进入队列意味着这个键不再被他人使用，并且已经被收集起来。于是，WeakHashMap将删除对应的条目。</li></ul></li><li><p><strong>链接散列集与映射</strong></p><ul><li><p>LinkedHashSet和LinkedHashMap类用来记住插入元素项的顺序。这样就可以避免在散列表中的项从表面上看是随机排列的。当条目插入到表中时，就会并入到双向链表中</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231011170340812.png" alt="" style="zoom:50%;" /></li><li><p>链接散列映射将用访问顺序，而不是插入顺序，对映射条目进行迭代</p></li></ul></li><li><p><strong>枚举集与映射</strong></p><ul><li>EnumSet是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以EnumSet内部用位序列实现。如果对应的值在集中，则相应的位被置为1。<ul><li>可以使用Set接口的常用方法来修改EnumSet。</li></ul></li><li>EnumMap是一个键类型为枚举类型的映射。它可以直接且高效地用一个值数组实现。在使用时，需要在构造器中指定键类型</li></ul></li><li><p><strong>标识散列映射</strong></p><ul><li>类IdentityHashMap中，键的散列值不是用hashCode函数计算的，而是用System.identityHashCode方法计算的。这是Object.hashCode方法根据对象的内存地址来计算散列码时所使用的方式。</li><li>在对两个对象进行比较时，IdentityHashMap类使用&#x3D;&#x3D;，而不使用equals。也就是说，不同的键对象，即使内容相同，也被视为是不同的对象。</li><li>在实现对象遍历算法（如对象串行化）时，这个类非常有用，可以用来跟踪每个对象的遍历状况。</li></ul></li></ul><h4 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h4><ul><li><p>Arrays类的静态方法asList将返回一个包装了普通Java数组的List包装器。这个方法可以将数组传递给一个期望得到列表或集合参数的方法。</p><ul><li>返回的对象不是ArrayList。它是一个视图对象，带有访问底层数组的get和set方法。改变数组大小的所有方法（例如，与迭代器相关的add和remove方法）都会抛出一个异常。</li></ul></li><li><p>可以为很多集合建立子范围（subrange）视图。例如，假设有一个列表staff，想从中取出第10个～第19个元素。可以使用subList方法来获得一个列表的子范围视图。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231012111418167.png" alt="" style="zoom:50%;" /></li><li><p>可以使用下面8种方法获得不可修改视图：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231012112015778.png" alt="" style="zoom:50%;" /></li><li><p>类库的设计者使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类。例如，Collections类的静态synchronizedMap方法可以将任何一个映射表转换成具有同步访问方法的Map：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231012112134937.png" alt="" style="zoom:50%;" /></li><li><p>受查视图可以探测：将错误类型的元素混入泛型集合中。下面定义了一个安全列表：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231012112356977.png" alt="" style="zoom:50%;" /><ul><li>视图的add方法将检测插入的对象是否属于给定的类。如果不属于给定的类，就立即抛出一个ClassCastException。</li></ul></li></ul><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul><li><p><strong>排序</strong></p><ul><li><p>Collections类中的sort方法可以对实现了List接口的集合进行排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>staff<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//假定列表元素实现了Comparable接口。</span>staff<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这个方法假定列表元素实现了Comparable接口。</span>staff<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingDouble</span><span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token operator">::</span><span class="token function">getSalary</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传入一个比较器</span>staff<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//按照降序对列表进行排序</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果想采用其他方式对列表进行排序，可以使用List接口的sort方法并传入一个Comparator对象。</li></ul></li><li><p>排序算法采用归并排序，而非快速排序，主要原因是稳定。对列表进行排序时，直接将所有元素转入一个数组，对数组进行排序，然后，再将排序后的序列复制回列表。</p></li><li><p>Collections类有一个算法shuffle，其功能与排序刚好相反，即随机地混排列表中元素的顺序。</p><ul><li>如果提供的列表没有实现RandomAccess接口，shuffle方法将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。</li></ul></li></ul></li><li><p><strong>二分查找</strong></p><ul><li>Collections类的binarySearch方法实现二分查找算法，集合必须是排好序的，否则算法将返回错误的答案。</li></ul></li><li><p><strong>简单算法</strong></p><ul><li>在Collections类中包含了几个简单且很有用的算法：查找集合中最大元素、将一个列表中的元素复制到另外一个列表中、用一个常量值填充容器、逆置一个列表的元素顺序。</li></ul></li><li><p><strong>批操作</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">coll1<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>coll2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从coll1中删除coll2中出现的所有元素</span>coll1<span class="token punctuation">.</span><span class="token function">retainAll</span><span class="token punctuation">(</span>coll2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从coll1中删除所有未在coll2中出现的元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>集合与数组的转换</strong></p><ul><li><p>如果需要把一个数组转换为集合，Arrays.asList包装器可以达到这个目的</p></li><li><p>可以使用toArray方法从集合得到数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结果是一个对象数组,且不能使用强制类型转换</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> staff<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//ERROR!</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//提供一个所需类型而且长度为0的数组。这样一来，返回的数组就会创建为相同的数组类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>如果编写自己的算法（实际上，是以集合作为参数的任何方法），应该尽可能地使用接口，而不要使用具体的实现。</p></li></ul><h4 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h4><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231012165109066.png" alt="" style="zoom: 33%;" /><ul><li><strong>Hashtable类</strong><ul><li>Hashtable类与HashMap类的作用一样，拥有相同的接口。</li><li>Hashtable的方法也是同步的。如果对同步性或与遗留代码的兼容性没有任何要求，就应该使用HashMap。如果需要并发访问，则要使用ConcurrentHashMap</li></ul></li><li><strong>枚举</strong><ul><li>遗留集合使用Enumeration接口对元素序列进行遍历。Enumeration接口有两个方法，即hasMoreElements和nextElement。这两个方法与Iterator接口的hasNext方法和next方法十分类似</li></ul></li><li><strong>属性映射</strong><ul><li>属性映射（property map）是一个类型非常特殊的映射结构。它有下面3个特性：<ol><li>键与值都是字符串。</li><li>表可以保存到一个文件中，也可以从文件中加载。</li><li>使用一个默认的辅助表。实现属性映射的Java平台类称为Properties。属性映射通常用于程序的特殊配置选项</li></ol></li></ul></li><li><strong>栈</strong><ul><li>从1.0版开始，标准类库中就包含了Stack类，其中push方法和pop方法。但是，Stack类扩展为Vector类，从理论角度看，Vector类并不太令人满意，它可以让栈使用不属于栈操作的insert和remove方法，即可以在任何地方进行插入或删除操作，而不仅仅是在栈顶。</li></ul></li><li><strong>位集</strong><ul><li>BitSet类用于存放一个位序列。如果需要高效地存储位序列就可以使用位集。由于位集将位包装在字节里，所以，使用位集要比使用Boolean对象的ArrayList更加高效。</li></ul></li></ul><hr><h1 id="9-并发"><a href="#9-并发" class="headerlink" title="9. 并发"></a>9. 并发</h1><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><ul><li><p>创建一个新线程：将任务代码移到实现了Runnable接口的类的run方法中，由于Runnable是一个函数式接口，可以用lambda表达式建立一个实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runable</span> r<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>task code<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>也可以通过构建一个Thread类的子类定义一个线程，然后构造一个子类的对象，并调用start方法。</p><ul><li>这种方法已不再推荐。应该将要并行运行的任务与运行机制解耦合。如果有很多任务，要为每个任务创建一个独立的线程所付出的代价太大了。可以使用线程池来解决这个问题</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231013170202144.png" alt="" style="zoom:50%;" /></li><li><p>不要调用Thread类或Runnable对象的run方法。直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用Thread.start方法。这个方法将创建一个执行run方法的新线程。</p></li></ul><h4 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h4><ul><li><p>当线程的run方法执行方法体中最后一条语句后，并经由执行return语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止</p></li><li><p>没有可以强制线程终止的方法。interrupt方法可以用来请求终止线程：当对一个线程调用interrupt方法时，线程的中断状态将被置位。这是每一个线程都具有的boolean标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断。</p></li><li><p>没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后，继续执行，而不理会中断。但是，更普遍的情况是，线程将简单地将中断作为一个终止的请求。这种线程的run方法具有如下形式：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231013171720836.png" alt="" style="zoom: 33%;" /><ul><li>如果在每次工作迭代之后都调用sleep方法（或者其他的可中断方法）, isInterrupted检测既没有必要也没有用处。如果在中断状态被置位时调用sleep方法，它不会休眠。相反，它将清除这一状态（!）并抛出InterruptedException。因此，如果循环调用sleep，不会检测中断状态。相反，需要捕获InterruptedException异常</li></ul></li></ul><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>线程可以有如下6种状态：</p><ul><li><strong>New（新创建）</strong><ul><li>当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。</li></ul></li><li><strong>Runnable（可运行）</strong><ul><li>一旦调用start方法，线程处于runnable状态。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。</li><li>在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行</li></ul></li><li><strong>Blocked（被阻塞）</strong><ul><li>当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。</li><li>当一个线程试图获取一个内部的对象锁，而该锁被其他线程持有，则该线程进入阻塞状态</li></ul></li><li><strong>Waiting（等待）</strong><ul><li>当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态</li></ul></li><li><strong>Timed waiting（计时等待）</strong><ul><li>有几个方法有一个超时参数。调用它们导致线程进入计时等待状态。带有超时参数的方法有Thread.sleep和Object.wait、Thread.join、Lock.tryLock以及Condition.await的计时版。</li></ul></li><li><strong>Terminated（被终止）</strong><ul><li>线程因如下两个原因之一而被终止：因为run方法正常退出而自然死亡、 因为一个没有捕获的异常终止了run方法而意外死亡。</li></ul></li></ul><h4 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h4><ul><li><p><strong>线程优先级</strong></p><ul><li>一个线程继承它的父线程的优先级。可以用setPriority方法提高或降低任何一个线程的优先级。可以将优先级设置为在MIN_PRIORITY（在Thread类中定义为1）与MAX_PRIORITY（定义为10）之间的任何值。NORM_PRIORITY被定义为5。</li><li>每当线程调度器有机会选择新线程时，首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的，Java线程的优先级被映射到宿主机平台的优先级上，因此不确定。<strong>不要将程序构建为功能的正确性依赖于优先级。</strong></li><li>如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中进行选择，尽管这样会使低优先级的线程完全饿死。</li></ul></li><li><p><strong>守护线程</strong></p><ul><li><p>守护线程的唯一用途是为其他线程提供服务。当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没必要继续运行程序了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将线程转换为守护线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。</p></li></ul></li><li><p><strong>未捕获异常处理器</strong></p><ul><li><p>线程的run方法不能抛出任何受查异常，但是非受查异常会导致线程终止。在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。该处理器必须属于一个实现Thread.UncaughtExceptionHandler接口的类。这个接口只有一个方法</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016103732128.png" alt="" style="zoom:50%;" /></li><li><p>可以用setUncaughtExceptionHandler方法为任何线程安装一个处理器。也可以用Thread类的静态方法setDefaultUncaughtExceptionHandler为所有线程安装一个默认的处理器。替换处理器可以使用日志API发送未捕获异常的报告到日志文件。</p></li><li><p>如果不安装默认的处理器，默认的处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。</p></li></ul><blockquote><p>线程组是一个可以统一管理的线程集合。默认情况下，创建的所有线程属于相同的线程组，但是，也可能会建立其他的组。现在引入了更好的特性用于线程集合的操作，所以建议不要在自己的程序中使用线程组。</p></blockquote></li></ul><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul><li><p>提供两种机制进行同步：</p><ul><li><p>synchronized关键字</p><ul><li><p>Java中的每一个对象都有一个内部锁。如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须获得内部的对象锁。</p></li><li><p>内部对象锁只有一个相关条件。wait方法添加一个线程到等待集中，notifyAll &#x2F;notify方法解除等待线程的阻塞状态</p></li><li><p>将静态方法声明为synchronized也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。例如，如果Bank类有一个静态同步的方法，那么当该方法被调用时，Bank.class对象的锁被锁住。因此，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。</p></li><li><p>当线程进入如下形式的阻塞，它获得obj的锁。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016112247819.png" alt="" style="zoom:50%;" /></li></ul></li><li><p>用ReentrantLock保护代码块</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016110358627.png" alt="" style="zoom:50%;" /><ul><li>把解锁操作括在finally子句之内是至关重要的。如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞。</li></ul></li></ul></li><li><p>锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数（hold count）来跟踪对lock方法的嵌套调用。线程在每一次调用lock都要调用unlock来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。</p></li><li><p><strong>条件变量</strong></p><ul><li><p>一个锁对象可以有一个或多个相关的条件对象。可以用newCondition方法获得一个条件变量</p></li><li><p>一旦一个线程调用await方法，它进入该条件的等待集。当锁可用时，该线程不能马上解除阻塞。相反，它处于阻塞状态，直到另一个线程调用同一条件上的signalAll方法时为止。</p></li><li><p>signalAll方法仅仅是通知正在等待的线程：此时有可能已经满足条件，值得再次去检测该条件。</p></li><li><p>通常，对await的调用应该在如下形式的循环体中</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016111611276.png" alt="" style="zoom:50%;" /></li><li><p>signal随机解除等待集中某个线程的阻塞状态。这比解除所有线程的阻塞更加有效，但也存在危险。如果随机选择的线程发现自己仍然不能运行，那么它再次被阻塞。如果没有其他线程再次调用signal，那么系统就死锁了。</p></li></ul></li><li><p>volatile关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。</p><ul><li>假设对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变量声明为volatile。</li><li>Volatile变量不能提供原子性</li></ul></li><li><p><strong>原子性</strong></p><ul><li><p>AtomicInteger类提供了方法incrementAndGet和decrementAndGet，它们分别以原子方式将一个整数自增或自减。</p></li><li><p>如果希望完成更复杂的更新，就必须使用compareAndSet方法，应当在一个循环中计算新值和使用compareAndSet：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016145945044.png" alt="" style="zoom:50%;" /></li><li><p>可以提供一个lambda表达式更新变量</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016150057598.png" alt="" style="zoom:50%;" /></li><li><p>如果有大量线程要访问相同的原子值，性能会大幅下降，因为乐观更新需要太多次重试。Java SE 8提供了LongAdder和LongAccumulator类来解决这个问题。LongAdder包括多个变量（加数），其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下，只有当所有工作都完成之后才需要总和的值，对于这种情况，这种方法会很高效。性能会有显著的提升。</p></li></ul></li><li><p>使用ThreadLocal辅助类为各个线程提供各自的实例，要为每个线程构造一个实例，可以使用以下代码：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016151428104.png" alt="" style="zoom:50%;" /></li><li><p>tryLock方法试图申请一个锁，在成功获得锁后返回true，否则，立即返回false，而且线程可以立即离开去做其他事情。且可以使用超时参数。</p></li><li><p>提供了一个读写锁类：ReentrantReadWriteLock类，允许对读者线程共享访问，写者线程互斥访问的</p></li></ul><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016153154831.png" alt="" style="zoom:50%;" /><p>java.util.concurrent包提供了阻塞队列的几个变种：</p><ul><li><p>默认情况下，LinkedBlockingQueue的容量是没有上边界的，但是，也可以选择指定最大容量。其是一个双端的版本。</p></li><li><p>ArrayBlockingQueue在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性。若设置了公平参数，则那么等待了最长时间的线程会优先得到处理。通常，公平性会降低性能，只有在确实非常需要时才使用它。</p></li><li><p>PriorityBlockingQueue是一个带优先级的队列，而不是先进先出队列。元素按照它们的优先级顺序被移出。该队列是没有容量上限，但是，如果队列是空的，取元素的操作会阻塞。</p></li><li><p>DelayQueue包含实现Delayed接口的对象：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016153437946.png" alt="" style="zoom:50%;" /></li><li><p>Java SE 7增加了一个TransferQueue接口，允许生产者线程等待，直到消费者准备就绪可以接收一个元素。</p></li></ul><h4 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h4><ul><li><p><strong>高效的映射、集和队列</strong></p><ul><li>java.util.concurrent包提供了映射、有序集和队列的高效实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet和ConcurrentLinkedQueue</li><li>并发的散列映射表，可高效地支持大量的读者和一定数量的写者。默认情况下，假定可以有多达16个写者线程同时执行。可以有更多的写者线程，但是，如果同一时间多于16个，其他线程将暂时被阻塞。</li></ul></li><li><p><strong>映射条目的原子更新</strong></p><ul><li><p>使用replace操作，它会以原子方式用一个新值替换原值，需要使用一个循环直至成功</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016154155382.png" alt="" style="zoom:50%;" /></li><li><p>使用一个ConcurrentHashMap&lt;String, AtomicLong&gt;，或者在Java SE 8中，还可以使用ConcurrentHashMap&lt;String, LongAdder&gt;</p></li><li><p>Java SE 8提供了compute方法，可以提供一个键和一个计算新值的函数。</p></li></ul></li><li><p><strong>对并发散列映射的批操作</strong></p><ul><li>Java SE 8为并发散列映射提供了批操作，即使有其他线程在处理映射，这些操作也能安全地执行。批操作会遍历映射，处理遍历过程中找到的元素。无须冻结当前映射的快照。有3种不同的操作：<ul><li>搜索（search）为每个键或值提供一个函数，直到函数生成一个非null的结果。然后搜索终止，返回这个函数的结果。</li><li>归约（reduce）组合所有键或值，这里要使用所提供的一个累加函数。</li><li>forEach为所有键或值提供一个函数。</li></ul></li><li>每个操作都有4个版本：<ul><li>operationKeys：处理键。</li><li>operationValues：处理值。</li><li>operation：处理键和值。</li><li>operationEntries：处理Map.Entry对象。</li></ul></li></ul></li><li><p><strong>并发集视图</strong></p><ul><li>没有一个ConcurrentHashSet类。静态newKeySet方法会生成一个Set<K>，这实际上是ConcurrentHashMap&lt;K, Boolean&gt;的一个包装器。</li></ul></li><li><p>CopyOnWriteArrayList和CopyOnWriteArraySet是线程安全的集合，其中所有的修改线程对底层数组进行复制。</p></li><li><p><strong>并行数组算法</strong></p><ul><li>Arrays类提供了大量并行化操作。静态Arrays.parallelSort方法可以对一个基本类型值或对象的数组排序。</li><li>parallelSetAll方法会用由一个函数计算得到的值填充一个数组。这个函数接收元素索引，然后计算相应位置上的值。</li><li>parallelPrefix方法，它会用对应一个给定结合操作的前缀的累加结果替换各个数组元素。</li></ul></li></ul><h4 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a>Callable与Future</h4><ul><li><p>Runnable封装一个异步运行的任务，可以把它想象成为一个没有参数和返回值的异步方法。Callable与Runnable类似，但是有返回值。Callable接口是一个参数化的类型，只有一个方法call，其类型参数是返回值的类型</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016173922696.png" alt="" style="zoom:50%;" /></li><li><p>Future保存异步计算的结果。可以启动一个计算，将Future对象交给某个线程，然后忘掉它。Future对象的所有者在结果计算好之后就可以获得它。Future接口具有下面的方法：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016174034554.png" alt="" style="zoom:50%;" /></li><li><p>FutureTask包装器是一种非常便利的机制，可将Callable转换成Future和Runnable，它同时实现二者的接口</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016193445333.png" alt="" style="zoom:50%;" /></li></ul><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>执行器（Executor）类有许多静态工厂方法用来构建线程池：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016193650182.png" alt="" style="zoom:67%;" /><ul><li><p>newCachedThreadPool方法构建了一个线程池，对于每个任务，如果有空闲线程可用，立即让它执行任务，如果没有可用的空闲线程，则创建一个新线程</p></li><li><p>newFixedThreadPool方法构建一个具有固定大小的线程池。如果提交的任务数多于空闲的线程数，那么把得不到服务的任务放置到队列中。当其他任务完成以后再运行它们。</p></li><li><p>newSingleThreadExecutor是一个退化了的大小为1的线程池：由一个线程执行提交的任务，一个接着一个。</p></li><li><p>Executors类的newScheduledThreadPool和newSingleThreadScheduledExecutor方法将返回实现了ScheduledExecutorService接口的对象。</p><ul><li>ScheduledExecutorService接口具有为预定执行或重复执行任务而设计的方法。它是一种允许使用线程池机制的java.util.Timer的泛化</li></ul></li><li><p>可用下面的方法之一将一个Runnable对象或Callable对象提交给ExecutorService，都会得到一个Future对象，可用来查询该任务的状态</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016193943533.png" alt="" style="zoom:50%;" /></li><li><p>当用完一个线程池的时候，调用shutdown。该方法启动该池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成以后，线程池中的线程死亡。另一种方法是调用shutdownNow。该池取消尚未开始的所有任务并试图中断正在运行的线程。</p></li></ul><blockquote><p>使用线程池的步骤顺序：</p><ul><li>调用Executors类中静态的方法newCachedThreadPool或newFixedThreadPool。</li><li>调用submit提交Runnable或Callable对象。</li><li>如果想要取消一个任务，或如果提交Callable对象，那就要保存好返回的Future对象。</li><li>当不再提交任何任务时，调用shutdown。</li></ul></blockquote><p><strong>Fork-Join框架</strong></p><ul><li>fork-join框架使用了一种有效的智能方法来平衡可用线程的工作负载，这种方法称为工作密取（work stealing）。每个工作线程都有一个双端队列（deque）来完成任务。一个工作线程将子任务压入其双端队列的队头。（只有一个线程可以访问队头，所以不需要加锁。）一个工作线程空闲时，它会从另一个双端队列的队尾“密取”一个任务。由于大的子任务都在队尾，这种密取很少出现。</li></ul><h4 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h4><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231016195005873.png" alt="" style="zoom:50%;" /><ul><li><strong>倒计时门栓</strong><ul><li>一个倒计时门栓（CountDownLatch）让一个线程集等待直到计数变为0。倒计时门栓是一次性的。一旦计数为0，就不能再重用</li></ul></li><li><strong>障栅</strong><ul><li>CyclicBarrier类实现了一个集结点（rendezvous）称为障栅（barrier）。考虑大量线程运行在一次计算的不同部分的情形。当所有部分都准备好时，需要把结果组合在一起。当一个线程完成了它的那部分任务后，我们让它运行到障栅处。一旦所有的线程都到达了这个障栅，障栅就撤销，线程就可以继续运行。</li></ul></li><li><strong>交换器</strong><ul><li>当两个线程在同一个数据缓冲区的两个实例上工作的时候，就可以使用交换器（Exchanger）。典型的情况是，一个线程向缓冲区填入数据，另一个线程消耗这些数据。当它们都完成以后，相互交换缓冲区。</li></ul></li><li><strong>同步队列</strong><ul><li>同步队列是一种将生产者与消费者线程配对的机制。当一个线程调用SynchronousQueue的put方法时，它会阻塞直到另一个线程调用take方法为止，反之亦然。</li><li>与Exchanger的情况不同，数据仅仅沿一个方向传递，从生产者到消费者。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis设计与实现-笔记</title>
      <link href="/2023/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>学习《Redis设计与实现》笔记</p><hr><hr><h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><h2 id="1-1-简单动态字符串"><a href="#1-1-简单动态字符串" class="headerlink" title="1.1 简单动态字符串"></a>1.1 简单动态字符串</h2><h4 id="SDS结构"><a href="#SDS结构" class="headerlink" title="SDS结构"></a><strong>SDS结构</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">sdshdr</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span><span class="token comment">//记录buf数组中已使用字节的数量//等于SDS所保存字符串的长度</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span><span class="token comment">//记录buf数组中未使用字节的数量</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//字节数组，用于保存字符串</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230927112900679.png" alt="" style="zoom: 67%;" /><h4 id="SDS原理"><a href="#SDS原理" class="headerlink" title="SDS原理"></a><strong>SDS原理</strong></h4><ul><li>遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间；因此SDS可以直接重用一部分C字符串函数库里面的函数。</li><li>对于未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略（类似vector）：<ul><li>空间预分配<ul><li>如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。</li><li>如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间</li></ul></li><li>惰性空间释放<ul><li>需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用</li></ul></li></ul></li><li>二进制安全：以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。</li></ul><p><strong>SDS与C字符串的区别</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230927113918427.png"></p><h4 id="SDSAPI"><a href="#SDSAPI" class="headerlink" title="SDSAPI"></a><strong>SDSAPI</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230927114552206.png"></p><h2 id="1-2-链表"><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h2><h4 id="listNode结构"><a href="#listNode结构" class="headerlink" title="listNode结构"></a><strong>listNode结构</strong></h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span> prev<span class="token punctuation">;</span><span class="token comment">// 前置节点</span>    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token comment">// 后置节点</span>    <span class="token keyword">void</span> <span class="token operator">*</span> value<span class="token punctuation">;</span><span class="token comment">//节点的值</span><span class="token punctuation">&#125;</span>listNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230927114726690.png"></p><h4 id="list结构"><a href="#list结构" class="headerlink" title="list结构"></a><strong>list结构</strong></h4><ul><li>使用list来持有链表，操作更方便。提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">list</span> <span class="token punctuation">&#123;</span>    listNode <span class="token operator">*</span> head<span class="token punctuation">;</span><span class="token comment">//表头节点</span>    listNode <span class="token operator">*</span> tail<span class="token punctuation">;</span><span class="token comment">//表尾节点</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span><span class="token comment">//链表所包含的节点数量</span>    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//节点值复制函数</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//节点值释放函数</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//节点值对比函数</span><span class="token punctuation">&#125;</span> list<span class="token punctuation">;</span>              <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230927114956428.png" alt="" style="zoom:80%;" /><h4 id="redis链表特性"><a href="#redis链表特性" class="headerlink" title="redis链表特性"></a><strong>redis链表特性</strong></h4><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O（1）。</li><li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O（1）。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ul><h4 id="链表API"><a href="#链表API" class="headerlink" title="链表API"></a><strong>链表API</strong></h4><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230927142526201.png" alt="" style="zoom:67%;" /><hr><h2 id="1-3-字典"><a href="#1-3-字典" class="headerlink" title="1.3 字典"></a>1.3 字典</h2><p>字典是一种用于保存键值对的抽象数据结构</p><h4 id="哈希表结构"><a href="#哈希表结构" class="headerlink" title="哈希表结构"></a><strong>哈希表结构</strong></h4><ul><li>使用链表法解决哈希冲突</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">&#123;</span>    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span><span class="token comment">//哈希表数组,每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span><span class="token comment">//哈希表大小</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span><span class="token comment">//哈希表大小掩码，用于计算索引值//总是等于size-1</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span><span class="token comment">//该哈希表已有节点的数量</span><span class="token punctuation">&#125;</span> dictht<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a><strong>哈希表节点</strong></h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span><span class="token comment">//键</span>    <span class="token keyword">union</span><span class="token punctuation">&#123;</span><span class="token comment">//值</span>        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>        uint64_tu64<span class="token punctuation">;</span>        int64_ts64<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> v<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token comment">//指向下个哈希表节点，形成链表</span><span class="token punctuation">&#125;</span> dictEntry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字典结构"><a href="#字典结构" class="headerlink" title="字典结构"></a><strong>字典结构</strong></h4><ul><li>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：<ul><li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</li><li>而privdata属性则保存了需要传给那些类型特定函数的可选参数。</li></ul></li><li>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。</li><li>rehashidx，记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">&#123;</span>    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span><span class="token comment">//类型特定函数</span>    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span><span class="token comment">//私有数据</span>    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//哈希表</span>    <span class="token comment">// rehash索引//当rehash不在进行时，值为-1</span>    in trehashidx<span class="token punctuation">;</span> <span class="token comment">/* rehashing not in progress if rehashidx == -1 */</span><span class="token punctuation">&#125;</span> dict<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a><strong>rehash</strong></h4><p>当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。步骤如下：</p><ol><li>为字典的ht[1]哈希表分配空间：<ul><li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n（2的n次方幂）</li><li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n。</li></ul></li><li>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</li></ol><blockquote><p><strong>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</strong></p><ul><li>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。</li><li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。这是避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。</li></ul><p><strong>负载因子</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#负载因子<span class="token operator">=</span>哈希表已保存节点数量<span class="token operator">/</span>哈希表大小load_factor <span class="token operator">=</span> ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">/</span> ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。</li></ol><blockquote><p>在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表</p></blockquote><h4 id="字典API"><a href="#字典API" class="headerlink" title="字典API"></a><strong>字典API</strong></h4><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004152400671.png" alt="" style="zoom:50%;" /><hr><h2 id="1-4-跳跃表"><a href="#1-4-跳跃表" class="headerlink" title="1.4 跳跃表"></a>1.4 跳跃表</h2><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><ul><li>跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点</li><li>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且跳跃表的实现比平衡树更为简单</li><li>Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004153213163.png" alt="" style="zoom:50%;" /><h4 id="跳跃表节点结构"><a href="#跳跃表节点结构" class="headerlink" title="跳跃表节点结构"></a>跳跃表节点结构</h4><ul><li>level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度<ul><li>每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”</li><li>每个层都有一个指向表尾方向的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点</li><li>层的跨度用于记录两个节点之间的距离，跨度实际上是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</li></ul></li><li>节点的后退指针用于从表尾向表头方向访问节点：每个节点只有一个后退指针，所以每次只能后退至前一个节点。</li><li>节点的分值（score属性）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序</li><li>节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值<ul><li>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">&#123;</span><span class="token comment">//层</span>        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span><span class="token comment">//前进指针</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span><span class="token comment">//跨度</span>    <span class="token punctuation">&#125;</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span><span class="token comment">//后退指针</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span><span class="token comment">//分值</span>    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span><span class="token comment">//成员对象</span><span class="token punctuation">&#125;</span> zskiplistNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="跳跃表结构"><a href="#跳跃表结构" class="headerlink" title="跳跃表结构"></a>跳跃表结构</h4><ul><li>header和tail指针分别指向跳跃表的表头和表尾节点</li><li>level属性则用于在O（1）复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头节点的层高并不计算在内。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">&#123;</span>    structz skiplistNode <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span><span class="token comment">//表头节点和表尾节点</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span><span class="token comment">//表中节点的数量</span>    <span class="token keyword">int</span> level<span class="token punctuation">;</span><span class="token comment">//表中层数最大的节点的层数</span><span class="token punctuation">&#125;</span> zskiplist<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="跳跃表api"><a href="#跳跃表api" class="headerlink" title="跳跃表api"></a><strong>跳跃表api</strong></h4><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004153404446.png" alt="" style="zoom:50%;" /><hr><h2 id="1-5-整数集合"><a href="#1-5-整数集合" class="headerlink" title="1.5 整数集合"></a>1.5 整数集合</h2><p>整数集合（intset）是用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><h4 id="整数集合结构"><a href="#整数集合结构" class="headerlink" title="整数集合结构"></a><strong>整数集合结构</strong></h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">intset</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> encoding<span class="token punctuation">;</span><span class="token comment">//编码方式</span>    <span class="token class-name">uint32_t</span> length<span class="token punctuation">;</span><span class="token comment">//集合包含的元素数量</span>    <span class="token class-name">int8_t</span> contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//保存元素的数组</span><span class="token punctuation">&#125;</span> intset<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</li><li>虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值</li></ul><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级:</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ol><p><strong>升级的好处</strong>：提升整数集合的灵活性、尽可能地节约内存</p><p><strong>整数集合不支持降级操作</strong>，一旦对数组进行了升级，编码就会一直保持升级后的状态</p><blockquote><p>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素：</p><ul><li>在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头（索引0）；</li><li>在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾（索引length-1）。</li></ul></blockquote><h4 id="整数集合api"><a href="#整数集合api" class="headerlink" title="整数集合api"></a>整数集合<strong>api</strong></h4><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004154231467.png" alt="" style="zoom:50%;" /><hr><h2 id="1-6-压缩列表"><a href="#1-6-压缩列表" class="headerlink" title="1.6 压缩列表"></a>1.6 压缩列表</h2><p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p><ul><li>压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</li></ul><h4 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h4><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004155450767.png"></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004155513045.png" alt="" style="zoom:67%;" /><h4 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h4><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004155709835.png"></p><ul><li><p>previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。</li><li>如果前一节点的长度大于等于254字节，那么长度为5字节：其中第一字节会被设置为0xFE，而之后的四个字节则用于保存前一节点的长度。</li></ul></li><li><p>encoding属性记录了节点的content属性所保存数据的类型以及长度：</p><ul><li><p>一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，<strong>数组的长度由编码除去最高两位之后的其他位记录</strong>；</p></li><li><p>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，<strong>整数值的类型和长度由编码除去最高两位之后的其他位记录</strong>；</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004160512933.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004160522916.png" alt="" style="zoom:50%;" /></li></ul></li><li><p>content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p></li></ul><blockquote><p><strong>压缩列表遍历过程</strong>：</p><ul><li>从尾到首遍历</li><li>先通过zltail属性得到尾结点地址，然后通过当前节点的previous_entry_length属性得到前一个节点地址，从而完成遍历</li></ul></blockquote><h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>在一个压缩列表中，有多个连续的、长度介于250字节到253字节之间的节点e1至eN，如果将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点，那么new将成为e1的前置节点：</p><ul><li>因为e1的previous_entry_length属性仅长1字节，需要将其扩展为5字节长</li><li>而e1又会导致e2的previous_entry_length属性进行扩展，不断影响，从而形成连锁更新</li><li>类似，删除节点也可能会引发连锁更新</li><li>因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O（N），所以连锁更新的最坏复杂度为O（N 2）。</li></ul><h4 id="压缩列表API"><a href="#压缩列表API" class="headerlink" title="压缩列表API"></a>压缩列表API</h4><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004161017424.png" alt="" style="zoom:50%;" /><hr><h2 id="1-7-对象"><a href="#1-7-对象" class="headerlink" title="1.7 对象"></a>1.7 对象</h2><p>Redis基于上述数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象</p><ul><li>可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令</li><li>可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</li><li>对象系统还实现了基于引用计数技术的内存回收机制，通过引用计数技术实现了对象共享机制</li><li>对象带有访问时间记录信息，可以用于计算数据库键的空转时长，空转时长较大的那些键可能会优先被服务器删除。</li></ul><p>Redis使用对象来表示数据库中的键和值，当新创建一个键值对时，会创建两个对象，一个用作键值对的键（键对象），另一个用作键值对的值（值对象）</p><h4 id="redisObject结构"><a href="#redisObject结构" class="headerlink" title="redisObject结构"></a>redisObject结构</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">//类型</span>    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">//编码</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token comment">//指向底层实现数据结构的指针</span><span class="token punctuation">&#125;</span> robj<span class="token punctuation">;</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>对象的type属性记录了对象的类型.键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种</p></li><li><p>encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004161856258.png" alt="" style="zoom:50%;" /></li></ul><hr><h3 id="1-7-1-对象实现"><a href="#1-7-1-对象实现" class="headerlink" title="1.7.1 对象实现"></a>1.7.1 对象实现</h3><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串对象的编码可以是int、raw或者embstr：</p><ul><li>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw</li><li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。<ul><li>raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构</li><li>embstr编码好处：内存分配和释放次数都降为1次、所有数据都在一块连续的内存里面，更好地利用缓存带来的优势</li></ul></li><li>用long double类型表示的浮点数在Redis中也是作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。<ul><li>程序会将保存在字符串对象里面的字符串值转换回浮点数值，再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面</li></ul></li></ul><blockquote><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象：</p><ul><li>对于int编码的字符串对象来说，如果向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw。</li><li>对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令</li></ul></blockquote><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>列表对象的编码可以是ziplist或者linkedlist</p><ul><li>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素</li><li>linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素</li></ul><blockquote><p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节；</li><li>列表对象保存的元素数量小于512个；</li></ul><p>不能满足这两个条件的列表对象需要使用linkedlist编码。</p></blockquote><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>哈希对象的编码可以是ziplist或者hashtable</p><ul><li><p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾</p><ul><li><p>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后</p></li><li><p>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231004164443645.png" alt="" style="zoom:67%;" /></li></ul></li><li><p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存</p></li></ul><blockquote><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p><ul><li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个；</li></ul></blockquote><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>集合对象的编码可以是intset或者hashtable</p><ul><li>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面</li><li>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL</li></ul><blockquote><p>当集合对象可以同时满足以下两个条件时，对象使用intset编码：</p><ul><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过512个。</li></ul></blockquote><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>有序集合的编码可以是ziplist或者skiplist</p><ul><li><p>ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）</p></li><li><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zset</span> <span class="token punctuation">&#123;</span>    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> zset<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素。通过这个跳跃表，程序可以对有序集合进行范围型操作</li><li>dict字典为有序集合创建了一个从成员到分值的映射，通过这个字典，程序可以用O（1）复杂度查找给定成员的分值</li><li>虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值，因此不会浪费内存</li></ul></li></ul><blockquote><p>当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：</p><ul><li>有序集合保存的元素数量小于128个；</li><li>有序集合保存的所有元素成员的长度都小于64字节；</li></ul></blockquote><hr><h3 id="1-7-2-其他"><a href="#1-7-2-其他" class="headerlink" title="1.7.2 其他"></a>1.7.2 其他</h3><h4 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h4><ul><li>类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：<ul><li>在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令；</li><li>否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。</li></ul></li><li>根据值对象的编码方式，选择正确的命令实现代码来执行命令，从而实现命令多态</li></ul><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p><ul><li>每个对象的引用计数信息由redisObject结构的refcount属性记录</li></ul><h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>让多个键共享同一个值对象需要执行以下两个步骤：</p><ol><li>将数据库键的值指针指向一个现有的值对象；</li><li>将被共享的值对象的引用计数增一。</li></ol><blockquote><p><strong>Redis只对包含整数值的字符串对象进行共享</strong></p><ul><li>Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。</li></ul><p><strong>为什么Redis不共享包含字符串的对象？</strong></p><ul><li>当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同</li><li>而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高<ul><li>如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为O（1）</li><li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O（N）</li><li>如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O（N2）。</li></ul></li></ul></blockquote><h4 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h4><p>redisObject结构的lru属性记录了对象最后一次被命令程序访问的时间</p><ul><li>OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的</li><li>OBJECT IDLETIME命令在访问键的值对象时，不会修改值对象的lru属性</li></ul><hr><h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><h2 id="2-1-数据库"><a href="#2-1-数据库" class="headerlink" title="2.1 数据库"></a>2.1 数据库</h2><h3 id="2-1-1-数据存储结构"><a href="#2-1-1-数据存储结构" class="headerlink" title="2.1.1 数据存储结构"></a>2.1.1 数据存储结构</h3><p>Redis服务器将所有数据库都保存在服务器状态redis.h&#x2F;redisServer结构的db数组中，db数组的每个项都是一个redis.h&#x2F;redisDb结构，每个redisDb结构代表一个数据库。dbnum默认为16</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span><span class="token comment">//一个数组，保存着服务器中的所有数据库</span>    <span class="token keyword">int</span> dbnum<span class="token punctuation">;</span><span class="token comment">//服务器的数据库数量</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>         <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230927204806263.png" alt="" style="zoom:67%;" /><h4 id="redisDb结构"><a href="#redisDb结构" class="headerlink" title="redisDb结构"></a><strong>redisDb结构</strong></h4><ul><li>其dict字典保存了数据库中的所有键值对，将这个字典称为键空间</li><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">&#123;</span>     dict <span class="token operator">*</span>dict<span class="token punctuation">;</span><span class="token comment">//数据库键空间，保存着数据库中的所有键值对</span>    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span><span class="token comment">//过期字典，保存着键的过期时间</span><span class="token punctuation">&#125;</span> redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a><strong>切换数据库</strong></h4><ul><li><p>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。</p></li><li><p>客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针，指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">&#123;</span>redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span><span class="token comment">//记录客户端当前正在使用的数据库</span><span class="token punctuation">&#125;</span> redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a><strong>读写键空间时的维护操作</strong></h4><ul><li>在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数</li><li>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。</li><li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作</li><li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过</li><li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作</li><li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知，本章稍后讨论数据库通知功能的实现时会详细说明这一点。</li></ul><hr><h3 id="2-1-2-过期时间设置及策略"><a href="#2-1-2-过期时间设置及策略" class="headerlink" title="2.1.2 过期时间设置及策略"></a>2.1.2 过期时间设置及策略</h3><h4 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a><strong>过期时间</strong></h4><ul><li><p>设置生存或过期时间：</p><ul><li><p>EXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl秒。</p></li><li><p>PEXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl毫秒。</p></li><li><p>EXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。</p></li><li><p>PEXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230927205221587.png" alt="" style="zoom:50%;" /></li></ul></li><li><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，称为过期字典：</p><ul><li><p>过期字典的键是一个指针，这个指针指向键空间中的某个键对象。</p></li><li><p>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//过期字典，保存着键的过期时间</span>    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a><strong>Redis的过期键删除策略</strong></h4><p>采用惰性删除和定期删除两种策略</p><ul><li>惰性删除<ul><li>所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：<ul><li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。</li><li>如果输入键未过期，那么expireIfNeeded函数不做动作。</li></ul></li></ul></li><li>定期删除<ul><li>每当Redis的服务器周期性操作redis.c&#x2F;serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。<ul><li>函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。</li><li>全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。</li><li>随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。</li></ul></li></ul></li></ul><hr><h3 id="2-1-3-AOF、RDB和复制功能对过期键的处理"><a href="#2-1-3-AOF、RDB和复制功能对过期键的处理" class="headerlink" title="2.1.3 AOF、RDB和复制功能对过期键的处理"></a>2.1.3 <strong>AOF、RDB和复制功能对过期键的处理</strong></h3><ul><li>生成RDB文件：在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</li><li>载入RDB文件：在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：<ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以过期键对载入RDB文件的从服务器也不会造成影响。</li></ul></li><li>AOF文件写入：当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，来显式地记录该键已被删除。</li><li>AOF重写：在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</li><li>复制：当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：<ul><li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li></ul></li></ul><hr><h3 id="2-1-4-数据库通知"><a href="#2-1-4-数据库通知" class="headerlink" title="2.1.4 数据库通知"></a>2.1.4 数据库通知</h3><p>使用SUBSCRIBE命令来获知数据库中键的变化（键空间通知），以及数据库中命令的执行情况（键事件通知，某个命令被什么键执行了）。</p><p>发送数据库通知的功能是由notify.c&#x2F;notifyKeyspaceEvent函数实现的：</p><ul><li>type参数是当前想要发送的通知的类型，event、keys和dbid分别是事件的名称、产生事件的键，以及产生事件的数据库号码，函数会根据type参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。其执行以下操作：<ul><li>server.notify_keyspace_events属性就是服务器配置notify-keyspace-events选项所设置的值，如果给定的通知类型type不是服务器允许发送的通知类型，那么函数会直接返回，不做任何动作。</li><li>如果给定的通知是服务器允许发送的通知，那么下一步函数会检测服务器是否允许发送键空间通知，如果允许的话，程序就会构建并发送事件通知。</li><li>最后，函数检测服务器是否允许发送键事件通知，如果允许的话，程序就会构建并发送事件通知。</li></ul></li><li>当一个Redis命令需要发送数据库通知的时候，该命令的实现函数就会调用notify-KeyspaceEvent函数，并向函数传递传递该命令所引发的事件的相关信息。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">,</span> event<span class="token punctuation">,</span> key<span class="token punctuation">,</span> dbid<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#如果给定的通知不是服务器允许发送的通知，那么直接返回</span>    <span class="token keyword">if</span> <span class="token keyword">not</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>notify_keyspace_events <span class="token operator">&amp;</span> <span class="token builtin">type</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span>    <span class="token comment">#发送键空间通知</span>    <span class="token keyword">if</span> server<span class="token punctuation">.</span>notify_keyspace_events <span class="token operator">&amp;</span> REDIS_NOTIFY_KEYSPACE<span class="token punctuation">:</span>        <span class="token comment">#将通知发送给频道__keyspace@＜dbid＞__:＜key＞</span>        <span class="token comment">#内容为键所发生的事件 ＜event＞</span>        <span class="token comment">#构建频道名字</span>        chan <span class="token operator">=</span> <span class="token string">"__keyspace@&#123;dbid&#125;__:&#123;key&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>dbid<span class="token operator">=</span>dbid<span class="token punctuation">,</span> key<span class="token operator">=</span>key<span class="token punctuation">)</span>        <span class="token comment">#发送通知</span>        pubsubPublishMessage<span class="token punctuation">(</span>chan<span class="token punctuation">,</span> event<span class="token punctuation">)</span>    <span class="token comment">#发送键事件通知</span>    <span class="token keyword">if</span> server<span class="token punctuation">.</span>notify_keyspace_events <span class="token operator">&amp;</span> REDIS_NOTIFY_KEYEVENT<span class="token punctuation">:</span>        <span class="token comment">#将通知发送给频道__keyevent@＜dbid＞__:＜event＞</span>        <span class="token comment">#内容为发生事件的键 ＜key＞</span>        <span class="token comment">#构建频道名字</span>        chan <span class="token operator">=</span> <span class="token string">"__keyevent@&#123;dbid&#125;__:&#123;event&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>dbid<span class="token operator">=</span>dbid<span class="token punctuation">,</span>event<span class="token operator">=</span>event<span class="token punctuation">)</span>        <span class="token comment">#发送通知</span>        pubsubPublishMessage<span class="token punctuation">(</span>chan<span class="token punctuation">,</span> key<span class="token punctuation">)</span>            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-RDB持久化"><a href="#2-2-RDB持久化" class="headerlink" title="2.2 RDB持久化"></a>2.2 RDB持久化</h2><p>RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态</p><p>Redis并没有专门用于载入RDB文件的命令，载入工作是在服务器启动时自动执行的，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p><hr><h3 id="2-2-1-RDB文件的创建与载入"><a href="#2-2-1-RDB文件的创建与载入" class="headerlink" title="2.2.1 RDB文件的创建与载入"></a>2.2.1 RDB文件的创建与载入</h3><h4 id="生成RDB文件命令"><a href="#生成RDB文件命令" class="headerlink" title="生成RDB文件命令"></a><strong>生成RDB文件命令</strong></h4><ul><li><p>SAVE：会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求</p></li><li><p>BGSAVE：命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求</p><ul><li>在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。</li><li>在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。</li><li>BGREWRITEAOF和BGSAVE两个命令不能同时执行，因为BGREWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行，不能同时执行它们只是一个性能方面的考虑，会涉及大量磁盘IO<ul><li>如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行。</li><li>如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</li></ul></li></ul><blockquote><p>创建RDB文件的实际工作由rdb.c&#x2F;rdbSave函数完成，SAVE命令是直接调用rdbsave函数，而BGSAVE是先fork一个子进程，然后再子进程中调用rdbsave函数</p></blockquote></li></ul><p>因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p><ul><li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</li><li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li></ul><h4 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a><strong>自动间隔性保存</strong></h4><ul><li><p>可通过指定配置文件或者传入启动参数的方式设置save选项，从而自动执行BGSAVE命令</p></li><li><p>服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">saveparam</span> <span class="token operator">*</span>saveparams<span class="token punctuation">;</span><span class="token comment">//记录了保存条件的数组</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">saveparam</span> <span class="token punctuation">&#123;</span>    time_t seconds<span class="token punctuation">;</span><span class="token comment">//秒数</span>    <span class="token keyword">int</span> changes<span class="token punctuation">;</span><span class="token comment">//修改数</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>除了saveparams数组之外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性：</p><ul><li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）</li><li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。</li></ul></li><li><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p></li></ul><hr><h3 id="2-2-2-RDB文件结构"><a href="#2-2-2-RDB文件结构" class="headerlink" title="2.2.2 RDB文件结构"></a>2.2.2 RDB文件结构</h3><h4 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a><strong>RDB文件结构</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230928171609125.png"></p><ul><li>用”REDIS”五个字符作为开始，以此检测该文件是否为rdb文件</li><li>db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号</li><li>databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据：<ul><li>如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。</li><li>如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。</li></ul></li><li>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束</li><li>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的</li></ul><h4 id="databases结构"><a href="#databases结构" class="headerlink" title="databases结构"></a><strong>databases结构</strong></h4><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230928171946913.png" alt="" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230928171959685.png" alt="" style="zoom:80%;" /><ul><li>SELECTDB常量的长度为1字节，表示接下来要读入的将是一个数据库号码。</li><li>db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。</li><li>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。</li><li>存储示例如下<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230928172220695.png"></li></ul><h4 id="key-value-pairs结构"><a href="#key-value-pairs结构" class="headerlink" title="key_value_pairs结构"></a><strong>key_value_pairs结构</strong></h4><ul><li>不带过期时间的键值对结构如下：<ul><li>TYPE记录了value的类型，长度为1字节，共有9种</li><li>key总是一个字符串对象，根据TYPE类型的不同，以及保存内容长度的不同，保存value的结构和长度也会有所不同</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230928172449759.png" alt="" style="zoom:80%;" /><ul><li>带有过期时间的键值对在RDB文件中的结构如下<ul><li>EXPIRETIME_MS常量的长度为1字节，表示接下来要读入的将是一个以毫秒为单位的过期时间。</li><li>ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230928172748954.png" alt="" style="zoom:80%;" /><h4 id="value的编码"><a href="#value的编码" class="headerlink" title="value的编码"></a><strong>value的编码</strong></h4><ul><li><p><strong>字符串对象</strong>：TYPE的值为REDIS_RDB_TYPE_STRING</p><ul><li><p>如果字符串对象的编码为REDIS_ENCODING_INT，那么说明对象中保存的是长度不超过32位的整数</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230928173356342.png" alt="" style="zoom:50%;" /></li><li><p>如果字符串对象的编码为REDIS_ENCODING_RAW，那么保存的是一个字符串值</p><ul><li><p>如果字符串的长度小于等于20字节，那么这个字符串会直接被原样保存。结构如下，string部分保存了字符串值本身，而len保存了字符串值的长度</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230928173526660.png"></p></li><li><p>如果字符串的长度大于20字节，那么这个字符串会被压缩之后再保存。结构如下：</p><ul><li>REDIS_RDB_ENC_LZF常量标志着字符串已经被LZF算法压缩</li><li>compressed_len记录的是字符串被压缩之后的长度，而origin_len记录的是字符串原来的长度，compressed_string记录的则是被压缩之后的字符串。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230928173815129.png"></p></li></ul></li></ul></li><li><p><strong>列表对象</strong>：TYPE的值为REDIS_RDB_TYPE_LIST</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231001161452143.png" alt="" style="zoom:80%;" /></li><li><p><strong>集合对象</strong>：TYPE的值为REDIS_RDB_TYPE_SET</p><ul><li>set_size是集合的大小，它记录集合保存了多少个元素</li><li>因为每个集合元素都是一个字符串对象，所以程序会以处理字符串对象的方式来保存和读入集合元素。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231001161851397.png" alt="" style="zoom:80%;" /></li><li><p><strong>哈希表对象</strong>：TYPE的值为REDIS_RDB_TYPE_HASH</p><ul><li><p>hash_size记录了哈希表的大小，也即是这个哈希表保存了多少键值对</p></li><li><p>以key_value_pair开头的部分代表哈希表中的键值对，键值对的键和值都是字符串对象，所以程序会以处理字符串对象的方式来保存和读入键值对。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231001162104213.png"></p></li><li><p>结构中的每个键值对都以键紧挨着值的方式排列在一起，因此更详细的结构为</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231001162201721.png" alt="" style="zoom:80%;" /></li></ul></li><li><p><strong>有序集合对象</strong>：TYPE的值为REDIS_RDB_TYPE_ZSET</p><ul><li><p>sorted_set_size记录了有序集合的大小</p></li><li><p>以element开头的部分代表有序集合中的元素，每个元素又分为成员（member）和分值（score）两部分，成员是一个字符串对象，分值则是一个double类型的浮点数，程序在保存RDB文件时会先将分值转换成字符串对象，然后再用保存字符串对象的方法将分值保存起来。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231001162332343.png" alt="" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231001162345677.png" alt="" style="zoom:80%;" /></li></ul></li><li><p><strong>INTSET编码的集合</strong>：TYPE的值为REDIS_RDB_TYPE_SET_INTSET</p><ul><li>先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面</li></ul></li><li><p><strong>ZIPLIST编码的列表、哈希表或者有序集合</strong>：TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST</p><ul><li>将压缩列表转换成一个字符串对象，再将转换所得的字符串对象保存到RDB文件。</li></ul></li></ul><h2 id="2-3-AOF持久化"><a href="#2-3-AOF持久化" class="headerlink" title="2.3 AOF持久化"></a>2.3 AOF持久化</h2><p>AOF（Append Only File）持久化通过保存Redis服务器所执行的写命令来记录数据库状态的</p><h3 id="2-3-1-AOF持久化的实现"><a href="#2-3-1-AOF持久化的实现" class="headerlink" title="2.3.1 AOF持久化的实现"></a>2.3.1 AOF持久化的实现</h3><p><strong>命令追加（append）</strong>：当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    sds aof_buf<span class="token punctuation">;</span><span class="token comment">// AOF缓冲区</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>文件写入</strong>：在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token comment">#处理文件事件，接收命令请求以及发送命令回复</span>        <span class="token comment">#处理命令请求时可能会有新内容被追加到 aof_buf缓冲区中</span>        processFileEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#处理时间事件</span>        processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#考虑是否要将 aof_buf中的内容写入和保存到 AOF文件里面</span>        flushAppendOnlyFile<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p></blockquote><p><strong>文件同步（sync）</strong>：使用fsync和fdatasync两个同步函数，强制让操作系统立即将缓冲区中的数据写入到硬盘里面</p><blockquote><p>操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。</p></blockquote><blockquote><p><strong>appendfsync选项的值直接决定AOF持久化功能的效率和安全性</strong></p><ul><li>当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所以always的效率是appendfsync选项三个值当中最慢的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，AOF持久化也只会丢失一个事件循环中所产生的命令数据。</li><li>当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。从效率上来讲，everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。</li><li>当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。因为处于no模式下的flushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。</li></ul></blockquote><hr><h3 id="2-3-2-AOF文件的载入与数据还原"><a href="#2-3-2-AOF文件的载入与数据还原" class="headerlink" title="2.3.2 AOF文件的载入与数据还原"></a>2.3.2 AOF文件的载入与数据还原</h3><p>服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态</p><p>Redis读取AOF文件并还原数据库状态的详细步骤如下：</p><ol><li>创建一个不带网络连接的伪客户端</li><li>从AOF文件中分析并读取出一条写命令。</li><li>使用伪客户端执行被读出的写命令。</li><li>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</li></ol><hr><h3 id="2-3-4-AOF重写"><a href="#2-3-4-AOF重写" class="headerlink" title="2.3.4 AOF重写"></a>2.3.4 AOF重写</h3><p>AOF文件中的内容会越来越多，体积过大的AOF文件很进行数据还原所需的时间就越多。</p><p>Redis提供了AOF文件重写（rewrite）功能，创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件体积要小得多。</p><p><strong>AOF重写原理</strong>：</p><ul><li>AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</li><li>直接重数据库中读取当前值，然后将其转化为一条插入或添加命令，从而代替之前的命令</li></ul><blockquote><p>注意：</p><ul><li>重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了redis.h&#x2F;REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。</li><li>如果一个集合键包含了超过64个元素，那么重写程序会用多条SADD命令来记录这个集合</li><li>如果一个列表键包含了超过64个项，那么重写程序会用多条RPUSH命令来保存这个列表</li></ul></blockquote><h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><ul><li>redis将AOF重写程序放到子进程里执行，从而使得服务器进程可以继续处理命令请求，且在避免使用锁的情况下，保证数据的安全性。<ul><li>子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。</li></ul></li><li>Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区</li><li>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：<ul><li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231001171455090.png" alt="" style="zoom:67%;" /><blockquote><p>在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞</p></blockquote><hr><h2 id="2-4-事件"><a href="#2-4-事件" class="headerlink" title="2.4 事件"></a>2.4 事件</h2><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p><ol><li>文件事件（file event）：Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ol><h3 id="2-4-1-文件事件"><a href="#2-4-1-文件事件" class="headerlink" title="2.4.1 文件事件"></a>2.4.1 文件事件</h3><p>Redis基于Reactor模式开发了自己的网络事件处理器，即文件事件处理器（file event handler）：</p><ul><li>文件事件处理器使用I&#x2F;O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231001191522996.png" alt="" style="zoom:50%;" /><p>Redis的I&#x2F;O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I&#x2F;O多路复用函数库来实现的，程序会在编译时自动选择系统中性能最高的I&#x2F;O多路复用函数库来作为Redis的I&#x2F;O多路复用程序的底层实现</p><p>Redis为文件事件编写了多个处理器：</p><ul><li>为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</li><li>为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</li><li>为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。</li><li>当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器</li></ul><blockquote><p>示例：</p><ol><li>有一个Redis客户端向服务器发起连接，那么监听套接字将产生AE_READABLE事件，触发连接应答处理器执行。处理器会创建客户端套接字，以及客户端状态，并将客户端套接字的AE_READABLE事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。</li><li>客户端向主服务器发送一个命令请求，那么客户端套接字将产生AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。</li><li>执行命令将产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的AE_WRITABLE事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITABLE事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会解除客户端套接字的AE_WRITABLE事件与命令回复处理器之间的关联。</li></ol><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231001192040300.png" alt="" style="zoom:33%;" /></blockquote><hr><h3 id="2-4-2-时间事件"><a href="#2-4-2-时间事件" class="headerlink" title="2.4.2 时间事件"></a>2.4.2 时间事件</h3><p>一个时间事件主要由以下三个属性组成：</p><ul><li>id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li><li>when：毫秒精度的UNIX时间戳，记录了时间事件的到达时间（执行时间）。</li><li>timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>Redis的时间事件分为以下两类：</p><ul><li>定时事件：让一段程序在指定的时间之后执行一次。</li><li>周期性事件：让一段程序每隔指定时间就执行一次。</li></ul><blockquote><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p><ul><li>如果事件处理器返回ae.h&#x2F;AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除</li><li>如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。</li></ul></blockquote><p><strong>实现原理</strong></p><ul><li><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p></li><li><p>保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序。正因为链表没有按when属性进行排序，所以必须遍历链表中的所有时间事件。</p></li><li><p><strong>无序链表并不影响时间事件处理器的性能</strong></p><ul><li>正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件。</li><li>在这种情况下，服务器几乎是将无序链表退化成一个指针来使用，所以使用无序链表来保存时间事件，并不影响事件执行的性能。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#遍历服务器中的所有时间事件</span>    <span class="token keyword">for</span> time_event <span class="token keyword">in</span> all_time_event<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">#检查事件是否已经到达</span>        <span class="token keyword">if</span> time_event<span class="token punctuation">.</span>when ＜<span class="token operator">=</span> unix_ts_now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#事件已到达</span>            <span class="token comment">#执行事件处理器，并获取返回值</span>            retval <span class="token operator">=</span> time_event<span class="token punctuation">.</span>timeProc<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">#如果这是一个定时事件</span>            <span class="token keyword">if</span> retval <span class="token operator">==</span> AE_NOMORE<span class="token punctuation">:</span>                <span class="token comment">#那么将该事件从服务器中删除</span>                delete_time_event_from_server<span class="token punctuation">(</span>time_event<span class="token punctuation">)</span>        <span class="token comment">#如果这是一个周期性事件</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment">#那么按照事件处理器的返回值更新时间事件的 when属性</span>            <span class="token comment">#让这个事件在指定的时间之后再次到达</span>            update_when<span class="token punctuation">(</span>time_event<span class="token punctuation">,</span> retval<span class="token punctuation">)</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>serverCron函数</strong>：定期对自身的资源和状态进行检查和调整主要工作包括：</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li><li>清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF或RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><hr><h3 id="2-4-3-事件的调度与执行"><a href="#2-4-3-事件的调度与执行" class="headerlink" title="2.4.3 事件的调度与执行"></a>2.4.3 事件的调度与执行</h3><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件。事件的调度和执行由ae.c&#x2F;aeProcessEvents函数负责：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#获取到达时间离当前时间最接近的时间事件</span>    time_event <span class="token operator">=</span> aeSearchNearestTimer<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#计算最接近的时间事件距离到达还有多少毫秒</span>    remaind_ms <span class="token operator">=</span> time_event<span class="token punctuation">.</span>when <span class="token operator">-</span> unix_ts_now<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#如果事件已到达，那么remaind_ms的值可能为负数，将它设定为0</span>    <span class="token keyword">if</span> remaind_ms ＜ <span class="token number">0</span><span class="token punctuation">:</span>        remaind_ms <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment">#根据remaind_ms的值，创建timeval结构</span>    timeval <span class="token operator">=</span> create_timeval_with_ms<span class="token punctuation">(</span>remaind_ms<span class="token punctuation">)</span>    <span class="token comment">#阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定</span>    <span class="token comment">#如果remaind_ms的值为0，那么aeApiPoll调用之后马上返回，不阻塞</span>    aeApiPoll<span class="token punctuation">(</span>timeval<span class="token punctuation">)</span>    <span class="token comment">#处理所有已产生的文件事件</span>    processFileEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#处理所有已到达的时间事件</span>    processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>事件的调度和执行规则：</strong></p><ul><li>aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保aeApiPoll函数不会阻塞过长时间。</li><li>如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间</li><li>对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。<ul><li>比如说，在命令回复处理器将一个命令回复写入到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</li></ul></li></ul><p><strong>Redis服务器的主函数</strong></p><ul><li><p>将aeProcessEvents函数置于一个循环里面，加上初始化和清理函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#初始化服务器</span>    init_server<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#一直处理事件，直到服务器关闭为止</span>    <span class="token keyword">while</span> server_is_not_shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        aeProcessEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#服务器关闭，执行清理操作</span>    clean_server<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231001194134891.png" alt="" style="zoom: 50%;" /></li></ul><hr><h2 id="2-5-客户端"><a href="#2-5-客户端" class="headerlink" title="2.5 客户端"></a>2.5 客户端</h2><p>通过使用由I&#x2F;O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p><p>Redis服务器状态结构的clients属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构。</p><h3 id="2-5-1-客户端属性"><a href="#2-5-1-客户端属性" class="headerlink" title="2.5.1 客户端属性"></a>2.5.1 客户端属性</h3><ul><li><p><strong>套接字描述符</strong>：一个fd来描述</p><ul><li>伪客户端（fake client）的fd属性的值为-1：伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络</li><li>普通客户端的fd属性的值为大于-1的整数</li></ul></li><li><p><strong>名字</strong>：默认没名字</p></li><li><p><strong>标志值</strong>：记录了客户端的角色（role），以及客户端目前所处的状态</p><ul><li>flags属性的值可以是单个标志，也可以是多个标志的二进制或</li></ul></li><li><p><strong>正在使用的数据库的指针，以及该数据库的号码</strong></p></li><li><p><strong>当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针</strong></p><ul><li>服务器对输入缓冲区的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性</li><li>argv属性是一个数组，数组中的每个项都是一个字符串对象，其中argv[0]是要执行的命令，而之后的其他项则是传给命令的参数。argc属性则负责记录argv数组的长度。</li><li>根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数。</li></ul></li><li><p><strong>输入缓冲区和输出缓冲区</strong></p><ul><li>输入缓冲区用于保存客户端发送的命令请求。输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但它的最大大小不能超过1GB，否则服务器将关闭这个客户端。</li><li>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的：<ul><li>固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。</li><li>可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">&#123;</span>    sds querybuf<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>REDIS_REPLY_CHUNK_BYTES<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//固定大小缓冲区</span>    <span class="token keyword">int</span> bufpos<span class="token punctuation">;</span><span class="token comment">//记录了buf数组目前已使用的字节数量</span>    list <span class="token operator">*</span>reply<span class="token punctuation">;</span><span class="token comment">//可变大小缓冲区由reply链表和一个或多个字符串对象组成</span><span class="token punctuation">&#125;</span> redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>复制状态信息，以及进行复制所需的数据结构</strong></p></li><li><p><strong>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</strong></p></li><li><p><strong>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</strong></p></li><li><p><strong>客户端执行发布与订阅功能时用到的数据结构。</strong></p></li><li><p><strong>客户端的身份验证标志</strong></p><ul><li>客户端状态的authenticated属性用于记录客户端是否通过了身份验证。0即未通过，1通过。</li></ul></li><li><p><strong>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制（soft limit）的时间</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">time_t</span> ctime<span class="token punctuation">;</span><span class="token comment">//记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒</span>    <span class="token class-name">time_t</span> lastinteraction<span class="token punctuation">;</span><span class="token comment">//记录了客户端与服务器最后一次进行互动（interaction）的时间</span>    <span class="token class-name">time_t</span> obuf_soft_limit_reached_time<span class="token punctuation">;</span><span class="token comment">//记录了输出缓冲区第一次到达软性限制（soft limit）的时间</span><span class="token punctuation">&#125;</span> redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>Redis只会将那些对数据库进行了修改的命令写入到AOF文件，并复制到各个从服务器，但PUBSUB命令和SCRIPT LOAD命令是其中的例外。</p><ul><li>PUBSUB命令虽然没有修改数据库，但PUBSUB命令向频道的所有订阅者发送消息这一行为带有副作用，接收到消息的所有客户端的状态都会因为这个命令而改变。因此，服务器需要使用REDIS_FORCE_AOF标志，强制将这个命令写入AOF文件，这样在将来载入AOF文件时，服务器就可以再次执行相同的PUBSUB命令，并产生相同的副作用。</li><li>SCRIPT LOAD命令的情况与PUBSUB命令类似：虽然SCRIPT LOAD命令没有修改数据库，但它修改了服务器状态，所以它是一个带有副作用的命令，服务器需要使用REDIS_FORCE_AOF标志，强制将这个命令写入AOF文件，使得将来在载入AOF文件时，服务器可以产生相同的副作用。</li></ul></blockquote><hr><h3 id="2-5-2-客户端的创建与关闭"><a href="#2-5-2-客户端的创建与关闭" class="headerlink" title="2.5.2 客户端的创建与关闭"></a>2.5.2 客户端的创建与关闭</h3><p><strong>创建普通客户端</strong></p><ul><li>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么使用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并添加到服务器状态结构clients链表末尾。</li></ul><p><strong>关闭普通客户端的原因</strong></p><ul><li><p>如果客户端进程退出或者被杀死，那么网络连接将被关闭，从而造成客户端被关闭</p></li><li><p>如果向服务器发送了带有不符合协议格式的命令请求，那么这个客户端也会被服务器关闭。</p></li><li><p>如果客户端成为了CLIENT KILL命令的目标，那么它也会被关闭。</p></li><li><p>如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关闭。</p><ul><li>如果客户端是主服务器，从服务器正在被BLPOP等命令阻塞，或者正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令，那么即使客户端的空转时间超过了timeout选项的值，客户端也不会被服务器关闭。</li></ul></li><li><p>如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB），那么这个客户端会被服务器关闭。</p></li><li><p>如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。</p><blockquote><p>服务器使用两种模式来限制客户端输出缓冲区的大小：</p><ul><li>硬性限制（hard limit）：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</li><li>软性限制（soft limit）：如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间；<ul><li>之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端；相反地，如果输出缓冲区的大小在指定时间之内，不再超出软性限制，那么客户端就不会被关闭，并且obuf_soft_limit_reached_time属性的值也会被清零。</li></ul></li></ul></blockquote></li></ul><p><strong>Redis还会创建两种伪客户端</strong></p><ul><li>在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中。其在服务器运行的整个生命期中会一直存在，只有服务器被关闭时，这个客户端才会被关闭。</li><li>在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。</li></ul><hr><h2 id="2-6-服务器"><a href="#2-6-服务器" class="headerlink" title="2.6 服务器"></a>2.6 服务器</h2><p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p><h3 id="2-6-1-命令请求的执行过程"><a href="#2-6-1-命令请求的执行过程" class="headerlink" title="2.6.1 命令请求的执行过程"></a>2.6.1 命令请求的执行过程</h3><p>一个命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作：</p><ul><li><strong>发送命令请求</strong>：将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器</li><li><strong>读取命令请求</strong>：<ul><li>读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。</li><li>对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</li><li>调用命令执行器，执行客户端指定的命令。</li></ul></li><li><strong>命令执行器（1）：查找命令实现</strong><ul><li>根据客户端状态的argv[0]参数，在命令表（command table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。</li><li>命令表是一个字典，字典的键是命令名字，值则是redisCommand结构，其记录了一个Redis命令的实现信息<ul><li>命令表使用的是大小写无关的查找算法</li></ul></li></ul></li><li><strong>命令执行器（2）：执行预备操作</strong><ul><li>检查客户端状态的cmd指针是否指向NULL，如果是，向客户端返回一个错误。</li><li>根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误。</li><li>检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令</li><li>如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如果内存回收失败，那么不再执行后续步骤，向客户端返回一个错误。</li><li>如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误。</li><li>如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令，其他命令都会被服务器拒绝。</li><li>如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（比如INFO、SHUTDOWN、PUBLISH等等）才会被服务器执行，其他命令都会被服务器拒绝。</li><li>如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令，其他命令都会被服务器拒绝。</li><li>如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。</li><li>如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后，服务器就可以开始真正执行命令了。</li></ul></li><li><strong>命令执行器（3）：调用命令的实现函数</strong><ul><li>被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会被保存在客户端状态的输出缓冲区里面（buf属性和reply属性），</li><li>之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端。</li></ul></li><li><strong>命令执行器（4）：执行后续工作</strong><ul><li>如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</li><li>根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</li><li>如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面。</li><li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</li></ul></li><li><strong>将命令回复发送给客户端</strong><ul><li>命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</li><li>当命令回复发送完毕之后，回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备</li></ul></li><li><strong>客户端接收并打印命令回复</strong><ul><li>接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看</li></ul></li></ul><hr><h3 id="2-6-2-serverCron函数"><a href="#2-6-2-serverCron函数" class="headerlink" title="2.6.2 serverCron函数"></a>2.6.2 serverCron函数</h3><p>serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p><ul><li><p><strong>更新服务器时间缓存</strong></p><ul><li>每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存</li><li>serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以精确度并不高：<ul><li>服务器只会在打印日志、更新服务器的LRU时钟、决定是否执行持久化任务、计算服务器上线时间（uptime）这类对时间精确度要求不高的功能上。</li><li>对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间。</li></ul></li></ul></li><li><p><strong>更新LRU时钟</strong></p><ul><li><p>服务器状态中的lruclock属性保存了服务器的LRU时钟</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//默认每10秒更新一次的时钟缓存，</span>    <span class="token comment">//用于计算键的空转（idle）时长。</span>    <span class="token keyword">unsigned</span> lruclock<span class="token operator">:</span><span class="token number">22</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>每个Redis对象都会有一个lru属性，保存了对象最后一次被命令访问的时间。因此用服务器的lruclock减去对象的lru，就是这个对象的空转时间。</p></li></ul></li><li><p><strong>更新服务器每秒执行命令次数</strong></p><ul><li>trackOperationsPerSecond函数会以每100毫秒一次的频率执行，其功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量</li><li>trackOperationsPerSecond函数每次运行，都会根据ops_sec_last_sample_time记录的上一次抽样时间和服务器的当前时间，以及ops_sec_last_sample_ops记录的上一次抽样的已执行命令数量和服务器当前的已执行命令数量，计算出两次trackOperationsPerSecond调用之间，服务器平均每一毫秒处理了多少个命令请求，然后将这个平均值乘以1000</li></ul></li><li><p><strong>更新服务器内存峰值记录</strong></p><ul><li>服务器状态中的stat_peak_memory属性记录了服务器的内存峰值大小</li><li>每次serverCron函数执行时，程序都会查看服务器当前使用的内存数量，并与stat_peak_memory保存的数值进行比较，若大则进行更新</li></ul></li><li><p><strong>处理SIGTERM信号</strong></p><ul><li>在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识</li><li>每次serverCron函数运行时，程序都会对服务器状态的shutdown_asap属性进行检查，并根据属性的值决定是否关闭服务器</li></ul></li><li><p><strong>管理客户端资源</strong></p><ul><li>每次执行都会调用clientsCron函数，其会对一定数量的客户端进行以下两个检查：<ul><li>如果客户端与服务器之间的连接已经超时，那么程序释放这个客户端。</li><li>如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。</li></ul></li></ul></li><li><p><strong>管理数据库资源</strong></p><ul><li>对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作</li></ul></li><li><p><strong>执行被延迟的BGREWRITEAOF</strong></p><ul><li>在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后</li><li>服务器的aof_rewrite_scheduled标识记录了服务器是否延迟了BGREWRITEAOF命令</li><li>检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行，如果这两个命令都没在执行，并且aof_rewrite_scheduled属性的值为1，那么服务器就会执行之前被推延的BGREWRITEAOF命令</li></ul></li><li><p><strong>检查持久化操作的运行状态</strong></p><ul><li><p>服务器状态使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，这两个属性也可以用于检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行</p></li><li><p>程序都会检查rdb_child_pid和aof_child_pid两个属性的值，只要其中一个属性的值不为-1，程序就会执行一次wait3函数，检查子进程是否有信号发来服务器进程：</p><ul><li>如果有信号到达，那么表示新的RDB文件已经生成完毕（对于BGSAVE命令来说），或者AOF文件已经重写完毕（对于BGREWRITEAOF命令来说），服务器需要进行相应命令的后续操作，比如用新的RDB文件替换现有的RDB文件，或者用重写后的AOF文件替换现有的AOF文件。</li><li>如果没有信号到达，那么表示持久化操作未完成，程序不做动作。</li></ul></li><li><p>如果两个属性的值都为-1，那么表示服务器没有在进行持久化操作，执行以下检查：</p><ul><li>查看是否有BGREWRITEAOF被延迟了，如果有，那么开始一次新的BGREWRITEAOF操作</li><li>检查服务器的自动保存条件是否已经被满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器开始一次新的BGSAVE操作（因为条件1可能会引发一次BGREWRITEAOF，所以在这个检查中，程序会再次确认服务器是否已经在执行持久化操作了）。</li><li>检查服务器设置的AOF重写条件是否满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器将开始一次新的BGREWRITEAOF操作（因为条件1和条件2都可能会引起新的持久化操作，所以在这个检查中，我们要再次确认服务器是否已经在执行持久化操作了）。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002142250220.png" alt="" style="zoom:80%;" /></li></ul></li><li><p><strong>将AOF缓冲区中的内容写入AOF文件</strong></p><ul><li>如果服务器开启了AOF持久化功能，并且AOF缓冲区里面还有待写入的数据，那么serverCron函数会调用相应的程序，将AOF缓冲区中的内容写入到AOF文件里面</li></ul></li><li><p><strong>关闭异步客户端</strong></p><ul><li>关闭那些输出缓冲区大小超出限制的客户端</li></ul></li><li><p><strong>增加cronloops计数器的值</strong></p><ul><li>服务器状态的cronloops属性记录了serverCron函数执行的次数</li><li>cronloops属性目前在服务器中的唯一作用，就是在复制模块中实现“每执行serverCron函数N次就执行一次指定代码”的功能</li></ul></li></ul><hr><h3 id="2-6-3-初始化服务器"><a href="#2-6-3-初始化服务器" class="headerlink" title="2.6.3 初始化服务器"></a>2.6.3 初始化服务器</h3><ul><li><strong>初始化服务器状态结构</strong><ul><li>初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。由redis.c&#x2F;initServerConfig函数完成。</li><li>initServerConfig函数完成的主要工作：设置服务器的运行ID、默认运行频率、默认配置文件路径、运行架构、默认端口号、默认RDB持久化条件和AOF持久化条件、初始化服务器的LRU时钟、创建命令表。</li><li>除了命令表之外，initServerConfig函数没有创建服务器状态的其他数据结构，数据库、慢查询日志、Lua环境、共享对象这些数据结构在之后的步骤才会被创建出来。</li></ul></li><li><strong>载入配置选项</strong><ul><li>载入用户给定的配置参数和配置文件，并根据用户设定的配置，对server变量相关属性的值进行修改。</li></ul></li><li><strong>初始化服务器数据结构</strong><ul><li>服务器将调用initServer函数，为以下数据结构分配内存：server.clients链表、server.db数组、用于保存频道订阅信息的server.pubsub_channels字典、用于保存模式订阅信息的server.pubsub_patterns链表、用于执行Lua脚本的Lua环境server.lua、用于保存慢查询日志的server.slowlog属性</li><li>nitServer还进行了一些非常重要的设置操作，包括：<ul><li>为服务器设置进程信号处理器、</li><li>创建共享对象：这些对象包含Redis服务器经常用到的一些值，比如包含”OK”回复的字符串对象，包含”ERR”回复的字符串对象，包含整数1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象。</li><li>打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接。</li><li>为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数。</li><li>如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做好准备。</li><li>初始化服务器的后台I&#x2F;O模块（bio），为将来的I&#x2F;O操作做好准备。</li></ul></li></ul></li><li><strong>还原数据库状态</strong><ul><li>载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。</li><li>如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来还原数据库状态。相反地，如果服务器没有启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态。</li></ul></li><li><strong>执行事件循环</strong></li></ul><h1 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h1><h2 id="3-1-复制"><a href="#3-1-复制" class="headerlink" title="3.1 复制"></a>3.1 复制</h2><p>通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002150423552.png" alt="" style="zoom:67%;" /><hr><h3 id="3-1-1-旧版复制功能的实现"><a href="#3-1-1-旧版复制功能的实现" class="headerlink" title="3.1.1 旧版复制功能的实现"></a>3.1.1 旧版复制功能的实现</h3><p>Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p><ul><li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态</li></ul><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>当客户端向从服务器发送SLAVEOF命令，从服务器首先需要执行同步操作，执行步骤如下：</p><ol><li><p>从服务器向主服务器发送SYNC命令。</p></li><li><p>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。</p></li><li><p>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。</p></li><li><p>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002151029834.png" alt="" style="zoom:50%;" /></li></ol><h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><ul><li>主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。</li></ul><blockquote><p><strong>旧版复制功能的缺陷</strong></p><p>如果从服务器掉线，当重新上线后，会重新执行同步流程（同步RDB和缓冲区操作），但这种方法效率很低，因为只需同步掉线期间的操作即可，而生成RDB文件对主服务器来说非常消耗性能</p></blockquote><hr><h3 id="3-1-2-新版复制功能的实现"><a href="#3-1-2-新版复制功能的实现" class="headerlink" title="3.1.2 新版复制功能的实现"></a>3.1.2 新版复制功能的实现</h3><p>Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作。</p><p>PSYNC命令具有完整重同步和部分重同步两种模式：</p><ul><li>完整重同步用于处理初次复制情况：和SYNC命令的执行步骤基本一样，通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。</li><li>部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</li></ul><h4 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h4><ul><li><p><strong>复制偏移量</strong></p><ul><li>执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量：<ul><li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。</li><li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。</li></ul></li><li>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态</li></ul></li><li><p><strong>主服务器的复制积压缓冲区</strong></p><ul><li><p>复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB</p><ul><li>固定长度先进先出队列的入队和出队规则跟普通的先进先出队列一样，只是大小固定，当入队元素的数量大于队列长度时，最先入队的元素会被弹出</li></ul></li><li><p>当主服务器进行命令传播时，还会将写命令入队到复制积压缓冲区里面。因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量</p></li><li><p>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，根据这个复制偏移量来决定执行何种同步操作：</p><ul><li>如果offset偏移量之后的数据仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作。</li><li>相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。</li></ul><blockquote><p>复制积压缓冲区的最小大小可以根据公式second*write_size_per_second来估算：</p><ul><li>second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）。</li><li>write_size_per_second则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）。</li></ul></blockquote></li></ul></li><li><p><strong>服务器的运行ID</strong></p><ul><li>当进行初次复制后，从服务器会保存主服务id，当断线重连后，从服务器将向当前连接的主服务器发送之前保存的运行ID：<ul><li>如果相同，说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作。</li><li>如果不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作</li></ul></li></ul></li></ul><h4 id="PSYNC命令的实现"><a href="#PSYNC命令的实现" class="headerlink" title="PSYNC命令的实现"></a>PSYNC命令的实现</h4><p>PSYNC命令的调用方法有两种：</p><ul><li>向主服务器发送PSYNC ? -1命令，主动请求主服务器进行完整重同步</li><li>向主服务器发送PSYNC ＜runid＞ ＜offset＞命令：其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作</li></ul><p>根据情况，接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：</p><ul><li>如果主服务器返回+FULLRESYNC ＜runid＞ ＜offset＞回复，那么表示主服务器将与从服务器执行完整重同步操作：其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量。</li><li>如果主服务器返回+CONTINUE回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了。</li><li>如果主服务器返回-ERR回复，那么表示主服务器的版本低于Redis 2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002153944175.png" alt="" style="zoom:67%;" /><hr><h3 id="3-1-3-复制的详细实现步骤"><a href="#3-1-3-复制的详细实现步骤" class="headerlink" title="3.1.3 复制的详细实现步骤"></a>3.1.3 复制的详细实现步骤</h3><p>通过向从服务器发送SLAVEOF命令，可以让一个从服务器去复制一个主服务器：</p><pre class="line-numbers language-none"><code class="language-none">SLAVEOF ＜master_ip＞ ＜master_port＞<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其执行步骤如下：</p><ul><li><p><strong>设置主服务器的地址和端口</strong></p><ul><li>将客户端给定的主服务器IP地址127.0.0.1以及端口6379保存到服务器状态的masterhost属性和masterport属性里面</li></ul></li><li><p><strong>建立套接字连接</strong></p><ul><li>根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接</li><li>在从服务器上，如果成功连接，为其关联一个文件事件处理器，负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令</li><li>主服务器在accept成功后，为其创建相应的客户端状态，并将其看做一个客户端。这时从服务器将同时具有服务器和客户端两个身份：从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复</li></ul></li><li><p><strong>发送PING命令</strong></p><ul><li><p>从服务器成为主服务器的客户端之后，做的第一件事就是向主服务器发送一个PING命令，其作用如下：</p><ul><li>通过发送PING命令可以检查套接字的读写状态是否正常</li><li>通过发送PING命令可以检查主服务器能否正常处理命令请求</li></ul></li><li><p>从服务器在发送PING命令之后可能遇到以下情况：</p><ul><li>如果主服务器向从服务器返回了一个命令回复，但从服务器却不能在规定的时限（timeout）内读取出命令回复的内容，那么从服务器断开套接字。</li><li>如果主服务器向从服务器返回一个错误，那么表示主服务器暂时没办法处理从服务器的命令请求，从服务器断开套接字。</li><li>如果从服务器读取到”PONG”回复，那么表示主从服务器之间的网络连接状态正常，并可以正常处理从服务器发送的命令请求</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002154925774.png" alt="" style="zoom:50%;" /></li></ul></li><li><p><strong>身份验证</strong></p><ul><li>在需要进行身份验证的情况下，从服务器将向主服务器发送一条AUTH命令，命令的参数为从服务器masterauth选项的值</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002155110045.png" alt="" style="zoom:50%;" /></li><li><p><strong>发送端口信息</strong></p><ul><li>在身份验证步骤之后，向主服务器发送从服务器的监听端口号，并记录在从服务器所对应的客户端状态的slave_listening_port属性中，其唯一的作用就是在主服务器执行INFO replication命令时打印出从服务器的端口号。</li></ul></li><li><p><strong>同步</strong></p><ul><li>从服务器将向主服务器发送PSYNC命令，执行同步操作</li><li>在同步操作执行之前，只有从服务器是主服务器的客户端，但是在执行同步操作之后，主服务器也会成为从服务器的客户端：<ul><li>主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行或向从服务器发送保存在复制积压缓冲区里面的写命令。</li></ul></li></ul></li><li><p><strong>命令传播</strong></p><ul><li>主服务器一直将执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令</li></ul></li></ul><hr><h3 id="3-1-4-心跳检测"><a href="#3-1-4-心跳检测" class="headerlink" title="3.1.4 心跳检测"></a>3.1.4 心跳检测</h3><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：</p><pre class="line-numbers language-none"><code class="language-none">REPLCONF ACK ＜replication_offset＞#replication_offset是从服务器当前的复制偏移量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>发送REPLCONF ACK命令对于主从服务器有三个作用：</p><ul><li><strong>检测主从服务器的网络连接状态</strong><ul><li>如果主服务器超过一秒钟没有收到从服务器发来的REPLCONF ACK命令，那么连接出现问题</li></ul></li><li><strong>辅助实现min-slaves选项</strong><ul><li>min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令</li><li>在从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令，这里的延迟值就是上面提到的INFO replication命令的lag值</li></ul></li><li><strong>检测命令丢失</strong><ul><li>类似TCP的确认机制，确保丢失的数据可以重发，使用偏移量作为序列号</li></ul></li></ul><hr><h2 id="3-2-Sentinel"><a href="#3-2-Sentinel" class="headerlink" title="3.2 Sentinel"></a>3.2 Sentinel</h2><p><strong>Sentinel</strong>（哨岗、哨兵）是Redis的高可用性解决方案：</p><ul><li>由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，</li><li>在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002164803663.png" alt="" style="zoom:50%;" /><hr><h3 id="3-2-1-启动并初始化Sentinel"><a href="#3-2-1-启动并初始化Sentinel" class="headerlink" title="3.2.1 启动并初始化Sentinel"></a>3.2.1 启动并初始化Sentinel</h3><p>启动一个Sentinel可以使用以下命令之一：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis-sentinel /path/to/your/sentinel.confredis-server /path/to/your/sentinel.conf <span class="token parameter variable">--sentinel</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当一个Sentinel启动时，执行以下步骤：</p><ul><li><p><strong>初始化服务器</strong></p><ul><li><em>Sentinel本质上只是一个运行在特殊模式下的Redis服务器</em>，初始化Sentinel时就不会载入RDB文件或者AOF文件</li></ul></li><li><p><strong>将普通Redis服务器使用的代码替换成Sentinel专用代码</strong></p><ul><li>例如更改服务器端口、INFO命令实现代码等</li></ul></li><li><p><strong>初始化Sentinel状态</strong></p><ul><li>在Sentinel模式下，Redis服务器不能执行诸如SET、DBSIZE、EVAL等等这些命令，因为服务器根本没有在命令表中载入这些命令。<ul><li>PING、SENTINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE和PUNSUBSCRIBE这七个命令就是客户端可以对Sentinel执行的全部命令</li></ul></li></ul></li><li><p><strong>根据给定的配置文件，初始化Sentinel的监视主服务器列表</strong></p><ul><li><p>服务器会初始化一个sentinel.c&#x2F;sentinelState结构，保存了服务器中所有和Sentinel功能有关的状态</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sentinelState</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">uint64_t</span> current_epoch<span class="token punctuation">;</span><span class="token comment">//当前纪元，用于实现故障转移</span>    dict <span class="token operator">*</span>masters<span class="token punctuation">;</span><span class="token comment">//保存了所有被这个sentinel监视的主服务器//字典的键是主服务器的名字//字典的值则是一个指向sentinelRedisInstance结构的指针</span>    <span class="token keyword">int</span> tilt<span class="token punctuation">;</span><span class="token comment">//是否进入了TILT模式？</span>    <span class="token keyword">int</span> running_scripts<span class="token punctuation">;</span><span class="token comment">//目前正在执行的脚本的数量</span>    <span class="token class-name">mstime_t</span> tilt_start_time<span class="token punctuation">;</span><span class="token comment">//进入TILT模式的时间</span>    <span class="token class-name">mstime_t</span> previous_time<span class="token punctuation">;</span><span class="token comment">//最后一次执行时间处理器的时间</span>    list <span class="token operator">*</span>scripts_queue<span class="token punctuation">;</span><span class="token comment">//一个FIFO队列，包含了所有需要执行的用户脚本</span><span class="token punctuation">&#125;</span> sentinel<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>初始化Sentinel状态的masters属性</strong></p><ul><li>每个sentinelRedisInstance结构代表一个被Sentinel监视的Redis服务器实例，这个实例可以是主服务器、从服务器，或者另外一个Sentinel</li></ul></li><li><p><strong>创建连向主服务器的网络连接</strong></p><ul><li><p>创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息。</p></li><li><p>对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接：</p><ul><li>一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复</li><li>另一个是订阅连接，这个连接专门用于订阅主服务器的__sentinel__:hello频道</li></ul><blockquote><p><strong>为什么有两个连接？</strong></p><ul><li>在Redis目前的发布与订阅功能中，被发送的信息都不会保存在Redis服务器里面，如果在信息发送时，想要接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息。因此，为了不丢失__sentinel__:hello频道的任何信息，Sentinel必须专门用一个订阅连接来接收该频道的信息。</li><li>除了订阅频道之外，Sentinel还必须向主服务器发送命令，以此来与主服务器进行通信，所以Sentinel还必须向主服务器创建命令连接。</li></ul></blockquote></li></ul></li></ul><hr><h3 id="3-2-2-获取主服务器信息"><a href="#3-2-2-获取主服务器信息" class="headerlink" title="3.2.2 获取主服务器信息"></a>3.2.2 获取主服务器信息</h3><p>Sentinel默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。</p><p>通过分析INFO命令回复，Sentinel可以获取以下信息：</p><ul><li>关于主服务器本身的信息，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色<ul><li>根据run_id域和role域记录的信息，Sentinel将对主服务器的实例结构进行更新</li></ul></li><li>关于主服务器属下所有从服务器的信息，每个从服务器都由一个”slave”字符串开头的行记录，每行的ip&#x3D;域记录了从服务器的IP地址，而port&#x3D;域则记录了从服务器的端口号<ul><li>从服务器信息，则会被用于更新主服务器实例结构的slaves字典。字典的键是由Sentinel自动设置的从服务器名字，格式为ip:port；至于字典的值则是从服务器对应的实例结构</li></ul></li></ul><hr><h3 id="3-2-3-获取从服务器信息"><a href="#3-2-3-获取从服务器信息" class="headerlink" title="3.2.3 获取从服务器信息"></a>3.2.3 获取从服务器信息</h3><p>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接。以每十秒一次的频率通过命令连接向从服务器发送INFO命令</p><p>根据INFO命令的回复，Sentinel会提取出以下信息：</p><ul><li>从服务器的运行ID run_id</li><li>从服务器的角色role</li><li>主服务器的IP地址master_host，以及主服务器的端口号master_port</li><li>主从服务器的连接状态master_link_status</li><li>从服务器的优先级slave_priority</li><li>从服务器的复制偏移量slave_repl_offset</li></ul><hr><h3 id="3-2-4-向主服务器和从服务器发送信息"><a href="#3-2-4-向主服务器和从服务器发送信息" class="headerlink" title="3.2.4 向主服务器和从服务器发送信息"></a>3.2.4 向主服务器和从服务器发送信息</h3><p>在默认情况下，Sentinel会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令：</p><pre class="line-numbers language-none"><code class="language-none">PUBLISH __sentinel__:hello &quot;＜s_ip＞,＜s_port＞,＜s_runid＞,＜s_epoch＞,＜m_name＞,＜m_ip＞,＜m_port＞,＜m_epoch＞&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002172146947.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002172204260.png"></p><hr><h3 id="3-2-5-接收来自主服务器和从服务器的频道信息"><a href="#3-2-5-接收来自主服务器和从服务器的频道信息" class="headerlink" title="3.2.5 接收来自主服务器和从服务器的频道信息"></a>3.2.5 接收来自主服务器和从服务器的频道信息</h3><p>当Sentinel与一个主服务器或者从服务器建立起订阅连接之后，Sentinel就会通过订阅连接，向服务器发送以下命令：</p><pre class="line-numbers language-none"><code class="language-none">SUBSCRIBE __sentinel__:hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于每个与Sentinel连接的服务器，Sentinel既通过命令连接向服务器的__sentinel__:hello频道发送信息，又通过订阅连接从服务器的__sentinel__:hello频道接收信息</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002172445045.png" alt="" style="zoom:50%;" /><p>对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到，这些信息会被用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知。</p><p>当一个Sentinel从__sentinel__:hello频道收到一条信息时，Sentinel会对这条信息进行分析，提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查：</p><ul><li>如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID相同，那么说明这条信息是Sentinel自己发送的，丢弃</li><li>如果不相同，那么说明是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，对相应主服务器的实例结构进行更新。</li></ul><p><strong>更新sentinels字典</strong></p><ul><li>Sentinel为主服务器创建的实例结构中的sentinels字典保存了除Sentinel本身之外，所有同样监视这个主服务器的其他Sentinel的资料：<ul><li>sentinels字典的键是其中一个Sentinel的名字，格式为ip:port；值则是键所对应Sentinel的实例结构</li></ul></li><li>当一个Sentinel接收到其他Sentinel发来的信息时，会从信息中分析并提取出以下两方面参数：<ul><li>与Sentinel有关的参数：源Sentinel的IP地址、端口号、运行ID和配置纪元。</li><li>与主服务器有关的参数：源Sentinel正在监视的主服务器的名字、IP地址、端口号和配置纪元。</li></ul></li><li>根据提取参数，会在自己的Sentinel状态的masters字典中查找相应的主服务器实例结构，然后根据提取出的Sentinel参数，检查主服务器实例结构的sentinels字典中，源Sentinel的实例结构是否存在</li></ul><p><strong>创建连向其他Sentinel的命令连接</strong></p><ul><li>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，还会创建一个连向新Sentinel的命令连接，而新Sentinel也同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的多个Sentinel将形成相互连接的网络</li></ul><blockquote><p>Sentinel在连接其他Sentinel时，不创建订阅连接。这是因为Sentinel需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新Sentinel，所以才需要建立订阅连接，而相互已知的Sentinel只要使用命令连接来进行通信就足够了。</p></blockquote><hr><h3 id="3-2-6-检测主观下线状态"><a href="#3-2-6-检测主观下线状态" class="headerlink" title="3.2.6 检测主观下线状态"></a>3.2.6 检测主观下线状态</h3><p>Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。</p><p>Sentinel配置文件中的down-after-milliseconds选项指定了Sentinel判断实例进入主观下线所需的时间长度：</p><ul><li>如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构，在结构的flags属性中打开SRI_S_DOWN标识，以此来表示这个实例已经进入主观下线状态。</li><li>用户设置的down-after-milliseconds选项的值，不仅会被Sentinel用来判断主服务器的主观下线状态，还会被用于判断主服务器属下的所有从服务器，以及所有同样监视这个主服务器的其他Sentinel的主观下线状态。</li></ul><blockquote><p>对于监视同一个主服务器的多个Sentinel来说，这些Sentinel所设置的down-after-milliseconds选项的值也可能不同，因此，当一个Sentinel将主服务器判断为主观下线时，其他Sentinel可能仍然会认为主服务器处于在线状态。</p></blockquote><hr><h3 id="3-2-7-检查客观下线状态"><a href="#3-2-7-检查客观下线状态" class="headerlink" title="3.2.7 检查客观下线状态"></a>3.2.7 检查客观下线状态</h3><p>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）</p><ul><li>当Sentinel从其他Sentinel那里接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作。</li></ul><p>流程如下：</p><ul><li><p><strong>发送SENTINEL is-master-down-by-addr命令</strong></p><ul><li><p>询问其他Sentinel是否同意主服务器已下线</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SENTINEL is-master-down-by-addr ＜ip＞ ＜port＞ ＜current_epoch＞ ＜runid＞<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002173819860.png" alt="" style="zoom:50%;" /></li></ul></li><li><p><strong>接收SENTINEL is-master-down-by-addr命令</strong></p><ul><li><p>分析并取出命令请求中包含的各个参数，检查主服务器是否已下线，然后向源Sentinel返回一条包含三个参数的Multi Bulk回复：</p><pre class="line-numbers language-none"><code class="language-none">1) ＜down_state＞2) ＜leader_runid＞3) ＜leader_epoch＞<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002173750040.png" alt="" style="zoom:50%;" /></li></ul></li><li><p><strong>接收SENTINEL is-master-down-by-addr命令的回复</strong></p><ul><li>Sentinel将统计其他Sentinel同意主服务器已下线的数量，当这一数量达到配置指定的判断客观下线所需的数量时，Sentinel会将主服务器实例结构flags属性的SRI_O_DOWN标识打开，表示主服务器已经进入客观下线状态，</li></ul></li></ul><hr><h3 id="3-2-8-选举领头Sentinel"><a href="#3-2-8-选举领头Sentinel" class="headerlink" title="3.2.8 选举领头Sentinel"></a>3.2.8 选举领头Sentinel</h3><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。选举方法如下：</p><ul><li>所有在线的Sentinel都有被选为领头Sentinel的资格，换句话说，监视同一个主服务器的多个在线Sentinel中的任意一个都有可能成为领头Sentinel。</li><li>每次进行领头Sentinel选举之后，不论选举是否成功，所有Sentinel的配置纪元（configuration epoch）的值都会自增一次。配置纪元实际上就是一个计数器，并没有什么特别的。</li><li>在一个配置纪元里面，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，并且局部领头一旦设置，在这个配置纪元里面就不能再更改。</li><li>每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel。</li><li>当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送SENTINEL is-master-down-by-addr命令，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel。</li><li>Sentinel设置局部领头Sentinel的规则是先到先得：最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝。</li><li>目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，将向源Sentinel返回一条命令回复，回复中的leader_runid参数和leader_epoch参数分别记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元。</li><li>源Sentinel在接收到目标Sentinel返回的命令回复之后，会检查回复中leader_epoch参数的值和自己的配置纪元是否相同，如果相同的话，那么源Sentinel继续取出回复中的leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标Sentinel将源Sentinel设置成了局部领头Sentinel。</li><li>如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel。</li><li>因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，所以在一个配置纪元里面，只会出现一个领头Sentinel。</li><li>如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后再次进行选举，直到选出领头Sentinel为止。</li></ul><hr><h3 id="3-2-9-故障转移"><a href="#3-2-9-故障转移" class="headerlink" title="3.2.9 故障转移"></a>3.2.9 故障转移</h3><p>在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤：</p><ul><li>在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。</li><li>让已下线主服务器属下的所有从服务器改为复制新的主服务器。</li><li>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</li></ul><p><strong>新的主服务器是怎样挑选出来的</strong></p><ul><li>领头Sentinel会将已下线主服务器的所有从服务器保存到一个列表里面，然后按照以下规则进行过滤：<ul><li>删除列表中所有处于下线或者断线状态的从服务器</li><li>删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器</li><li>删除所有与已下线主服务器连接断开超过down-after-milliseconds*10毫秒的从服务器</li></ul></li><li>对列表中剩余的从服务器进行排序，并选出其中优先级最高的从服务器。<ul><li>具有相同最高优先级的从服务器，选择其中偏移量最大的从服务器</li><li>如果有多个优先级最高、复制偏移量最大的从服务器，选择其中运行ID最小的从服务器</li></ul></li></ul><hr><h2 id="3-3-集群"><a href="#3-3-集群" class="headerlink" title="3.3 集群"></a>3.3 集群</h2><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p><h3 id="3-3-1-节点"><a href="#3-3-1-节点" class="headerlink" title="3.3.1 节点"></a>3.3.1 节点</h3><p>连接各个节点的工作可以使用CLUSTER MEET命令来完成，该命令的格式如下：</p><pre class="line-numbers language-none"><code class="language-none">CLUSTER MEET ＜ip＞ ＜port＞<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一个节点就是一个运行在集群模式下的Redis服务器，Redis服务器在启动时会根据cluster-enabled配置选项是否为yes来决定是否开启服务器的集群模式</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002200823661.png" alt="" style="zoom:50%;" /><p>节点（运行在集群模式下的Redis服务器）会继续使用所有在单机模式中使用的服务器组件，那些只有在集群模式下才会用到的数据，节点将它们保存到了cluster.h&#x2F;clusterNode结构、cluster.h&#x2F;clusterLink结构，以及cluster.h&#x2F;clusterState结构里面</p><h4 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h4><ul><li><p>clusterNode结构保存了一个节点的当前状态，比如节点的创建时间、节点的名字、节点当前的配置纪元、节点的IP地址和端口号</p></li><li><p>每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的clusterNode结构</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">mstime_t</span> ctime<span class="token punctuation">;</span><span class="token comment">//创建节点的时间</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//节点的名字，由40个十六进制字符组成</span>    <span class="token keyword">int</span> flags<span class="token punctuation">;</span><span class="token comment">//节点标识//使用各种不同的标识值记录节点的角色（比如主节点或者从节点），//以及节点目前所处的状态（比如在线或者下线）。</span>    <span class="token class-name">uint64_t</span> configEpoch<span class="token punctuation">;</span><span class="token comment">//节点当前的配置纪元，用于实现故障转移</span>    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>REDIS_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//节点的IP地址</span>    <span class="token keyword">int</span> port<span class="token punctuation">;</span><span class="token comment">//节点的端口号</span>    clusterLink <span class="token operator">*</span>link<span class="token punctuation">;</span><span class="token comment">//保存连接节点所需的有关信息</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>clusterLink结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterLink</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">mstime_t</span> ctime<span class="token punctuation">;</span><span class="token comment">//连接的创建时间</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token comment">// TCP套接字描述符</span>    sds sndbuf<span class="token punctuation">;</span><span class="token comment">//输出缓冲区，保存着等待发送给其他节点的消息（message）。</span>    sds rcvbuf<span class="token punctuation">;</span><span class="token comment">//输入缓冲区，保存着从其他节点接收到的消息。</span>    <span class="token keyword">struct</span> <span class="token class-name">clusterNode</span> <span class="token operator">*</span>node<span class="token punctuation">;</span><span class="token comment">//与这个连接相关联的节点，如果没有的话就为NULL</span><span class="token punctuation">&#125;</span> clusterLink<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>redisClient结构和clusterLink结构的相同和不同之处</strong></p><ul><li>redisClient结构和clusterLink结构都有自己的套接字描述符和输入、输出缓冲区，这两个结构的区别在于，redisClient结构中的套接字和缓冲区是用于连接客户端的，而clusterLink结构中的套接字和缓冲区则是用于连接节点的。</li></ul></blockquote></li><li><p>每个节点都保存着一个clusterState结构，这个结构记录了在当前节点的视角下，集群目前所处的状态，例如集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token punctuation">&#123;</span>    clusterNode <span class="token operator">*</span>myself<span class="token punctuation">;</span><span class="token comment">//指向当前节点的指针</span>    <span class="token class-name">uint64_t</span> currentEpoch<span class="token punctuation">;</span><span class="token comment">//集群当前的配置纪元，用于实现故障转移</span>    <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token comment">//集群当前的状态：是在线还是下线</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment">//集群中至少处理着一个槽的节点的数量</span>    dict <span class="token operator">*</span>nodes<span class="token punctuation">;</span><span class="token comment">//集群节点名单（包括myself节点）//字典的键为节点的名字，字典的值为节点对应的clusterNode结构</span><span class="token punctuation">&#125;</span> clusterState<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="CLUSTER-MEET命令的实现"><a href="#CLUSTER-MEET命令的实现" class="headerlink" title="CLUSTER MEET命令的实现"></a>CLUSTER MEET命令的实现</h4><ul><li>节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li><li>节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条MEET消息（message）</li><li>节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li><li>之后，节点B将向节点A返回一条PONG消息，节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息。</li><li>之后，节点A将向节点B返回一条PING消息。节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231002201946215.png" alt="" style="zoom: 67%;" /><p>之后，节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也与节点B进行握手，最终，经过一段时间之后，节点B会被集群中的所有节点认识。</p><hr><h3 id="3-3-2-槽指派"><a href="#3-3-2-槽指派" class="headerlink" title="3.3.2 槽指派"></a>3.3.2 槽指派</h3><p>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。</p><ul><li><p>当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。</p></li><li><p>通过向节点发送CLUSTER ADDSLOTS命令，我们可以将一个或多个槽指派（assign）给节点负责：</p><pre class="line-numbers language-none"><code class="language-none">CLUSTER ADDSLOTS ＜slot＞ [slot ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>记录节点的槽指派信息</strong></p><ul><li><p>clusterNode结构的slots属性和numslot属性记录了节点负责处理哪些槽</p></li><li><p>slots属性是一个二进制位数组（bit array），这个数组的长度为16384&#x2F;8&#x3D;2048个字节，每个位表示该节点是否负责该槽。</p></li><li><p>numslots属性则记录节点负责处理的槽的数量，也即是slots数组中值为1的二进制位的数量</p><pre class="line-numbers language-none"><code class="language-none">struct clusterNode &#123;    unsigned char slots[16384&#x2F;8];    int numslots;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>传播节点的槽指派信息</strong></p><ul><li>一个节点除了会将自己负责处理的槽记录在clusterNode结构的slots属性和numslots属性之外，它还会将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。</li><li>当节点A通过消息从节点B那里接收到节点B的slots数组时，节点A会在自己的clusterState.nodes字典中查找节点B对应的clusterNode结构，并对结构中的slots数组进行保存或者更新。</li></ul><p><strong>记录集群所有槽的指派信息</strong></p><ul><li><p>clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息</p></li><li><p>每个数组项都是一个指向clusterNode结构的指针：如果为NULL，表示槽i尚未指派给任何节点；</p><pre class="line-numbers language-none"><code class="language-none">typedef struct clusterState &#123;    clusterNode *slots[16384];&#125; clusterState;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>虽然clusterState.slots数组记录了集群中所有槽的指派信息，但使用clusterNode结构的slots数组来记录单个节点的槽指派信息仍然是有必要的：</p><ul><li>因为当程序需要将某个节点的槽指派信息通过消息发送给其他节点时，程序只需要将相应节点的clusterNode.slots数组整个发送出去就可以了。</li><li>如果Redis要将节点A的槽指派信息传播给其他节点时，程序必须先遍历整个clusterState.slots数组，记录节点A负责处理哪些槽，然后才能发送节点A的槽指派信息</li></ul></blockquote></li></ul><h4 id="CLUSTER-ADDSLOTS命令的实现"><a href="#CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="CLUSTER ADDSLOTS命令的实现"></a>CLUSTER ADDSLOTS命令的实现</h4><p>伪代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">CLUSTER_ADDSLOTS</span><span class="token punctuation">(</span><span class="token operator">*</span>all_input_slots<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#遍历所有输入槽，检查它们是否都是未指派槽</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> all_input_slots<span class="token punctuation">:</span>        <span class="token comment">#如果有哪怕一个槽已经被指派给了某个节点</span>        <span class="token comment">#那么向客户端返回错误，并终止命令执行</span>        <span class="token keyword">if</span> clusterState<span class="token punctuation">.</span>slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> NULL<span class="token punctuation">:</span>            reply_error<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>    <span class="token comment">#如果所有输入槽都是未指派槽</span>    <span class="token comment">#那么再次遍历所有输入槽，将这些槽指派给当前节点</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> all_input_slots<span class="token punctuation">:</span>        <span class="token comment">#设置clusterState结构的slots数组</span>        <span class="token comment">#将slots[i]的指针指向代表当前节点的clusterNode结构</span>        clusterState<span class="token punctuation">.</span>slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> clusterState<span class="token punctuation">.</span>myself        <span class="token comment">#访问代表当前节点的clusterNode结构的slots数组</span>        <span class="token comment">#将数组在索引i上的二进制位设置为1</span>        setSlotBit<span class="token punctuation">(</span>clusterState<span class="token punctuation">.</span>myself<span class="token punctuation">.</span>slots<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-3-3-在集群中执行命令"><a href="#3-3-3-在集群中执行命令" class="headerlink" title="3.3.3 在集群中执行命令"></a>3.3.3 在集群中执行命令</h3><p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：</p><ul><li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。</li><li>如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端redirect至正确的节点，并再次发送之前想要执行的命令。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231003143314591.png" alt="" style="zoom:50%;" /><p><strong>计算键属于哪个槽</strong></p><ul><li><p>节点使用以下算法来计算给定键key属于哪个槽，其中CRC16（key）语句用于计算键key的CRC-16校验和</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">slot_number</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> CRC16<span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">16383</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p><strong>MOVED错误</strong></p><ul><li><p>MOVED错误的格式如下，slot为键所在的槽，而ip和port则是负责处理槽slot的节点的IP地址和端口号</p><pre class="line-numbers language-none"><code class="language-none">MOVED ＜slot＞ ＜ip＞:＜port＞<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>集群模式的redis-cli客户端在接收到MOVED错误时，并不会打印出MOVED错误，而是根据MOVED错误自动进行节点转向，并打印出转向信息</p></li></ul><hr><h3 id="3-3-4-重新分片"><a href="#3-3-4-重新分片" class="headerlink" title="3.3.4 重新分片"></a>3.3.4 重新分片</h3><p>重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的键值对也会从源节点被移动到目标节点。</p><ul><li>该操作可以在线进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</li></ul><p><strong>重新分片的实现原理</strong></p><p>由Redis的集群管理软件redis-trib负责执行的，步骤如下：</p><ol><li>redis-trib对目标节点发送CLUSTER SETSLOT＜slot＞IMPORTING＜source_id＞命令，让目标节点准备好从源节点导入（import）属于槽slot的键值对。</li><li>redis-trib对源节点发送CLUSTER SETSLOT＜slot＞MIGRATING＜target_id＞命令，让源节点准备好将属于槽slot的键值对迁移（migrate）至目标节点。</li><li>redis-trib向源节点发送CLUSTER GETKEYSINSLOT＜slot＞＜count＞命令，获得最多count个属于槽slot的键值对的键名（key name）。</li><li>对于步骤3获得的每个键名，redis-trib都向源节点发送一个MIGRATE＜target_ip＞＜target_port＞＜key_name＞0＜timeout＞命令，将被选中的键原子地从源节点迁移至目标节点。</li><li>重复执行步骤3和步骤4，直到源节点保存的所有属于槽slot的键值对都被迁移至目标节点为止。</li><li>redis-trib向集群中的任意一个节点发送CLUSTER SETSLOT＜slot＞NODE＜target_id＞命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽slot已经指派给了目标节点。</li></ol><blockquote><p>如果重新分片涉及多个槽，那么redis-trib将对每个给定的槽分别执行上面给出的步骤。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231003144407027.png" alt="" style="zoom:67%;" /><hr><h3 id="3-3-5-ASK错误"><a href="#3-3-5-ASK错误" class="headerlink" title="3.3.5 ASK错误"></a>3.3.5 ASK错误</h3><p>当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时：</p><ul><li>源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令。</li><li>相反地，则查看键key所属的槽i是否正在进行迁移，如果槽i的确在进行迁移的话，源节点将向客户端返回一个ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令。</li></ul><blockquote><p>和接到MOVED错误时的情况类似，集群模式的redis-cli在接到ASK错误时也不会打印错误，而是自动根据错误提供的IP地址和端口进行转向动作</p></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231003144602276.png" alt="" style="zoom:67%;" /><p><strong>CLUSTER SETSLOT IMPORTING命令的实现</strong></p><ul><li><p>clusterState结构的importing_slots_from数组记录了当前节点正在从其他节点导入的槽：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token punctuation">&#123;</span>    clusterNode <span class="token operator">*</span>importing_slots_from<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> clusterState<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>如果importing_slots_from[i]的值不为NULL，而是指向一个clusterNode结构，那么表示当前节点正在从clusterNode所代表的节点导入槽i</p></li><li><p>该命令可以将目标节点clusterState.importing_slots_from[i]的值设置为source_id所代表节点的clusterNode结构。</p></li></ul><p><strong>CLUSTER SETSLOT MIGRATING命令的实现</strong></p><ul><li><p>clusterState结构的migrating_slots_to数组记录了当前节点正在迁移至其他节点的槽：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">clusterState</span> <span class="token punctuation">&#123;</span>   clusterNode <span class="token operator">*</span>migrating_slots_to<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> clusterState<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>如果migrating_slots_to[i]的值不为NULL，而是指向一个clusterNode结构，那么表示当前节点正在将槽i迁移至clusterNode所代表的节点。</p></li><li><p>改命令可以将源节点clusterState.migrating_slots_to[i]的值设置为target_id所代表节点的clusterNode结构。</p></li></ul><h4 id="ASKING命令"><a href="#ASKING命令" class="headerlink" title="ASKING命令"></a>ASKING命令</h4><ul><li>ASKING命令唯一要做的就是打开发送该命令的客户端的REDIS_ASKING标识</li><li>在一般情况下，如果客户端向节点发送一个关于槽i的命令，而槽i又没有指派给这个节点的话，那么节点将向客户端返回一个MOVED错误；但是，如果节点的clusterState.importing_slots_from[i]显示节点正在导入槽i，并且发送命令的客户端带有REDIS_ASKING标识，那么节点将破例执行这个关于槽i的命令一次</li><li>当客户端接收到ASK错误并转向至正在导入槽的节点时，客户端会先向节点发送一个ASKING命令，然后才重新发送想要执行的命令，这是因为如果客户端不发送ASKING命令，而直接发送想要执行的命令的话，那么客户端发送的命令将被节点拒绝执行，并返回MOVED错误。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231003145851197.png" alt="" style="zoom:50%;" /><blockquote><p>SK错误和MOVED错误的区别</p><ul><li>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点：在客户端收到关于槽i的MOVED错误之后，客户端每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点，因为该节点就是目前负责槽i的节点（永久更改）。</li><li>ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施：在客户端收到关于槽i的ASK错误之后，客户端只会在接下来的一次命令请求中将关于槽i的命令请求发送至ASK错误所指示的节点，但这种转向不会对客户端今后发送关于槽i的命令请求产生任何影响，客户端仍然会将关于槽i的命令请求发送至目前负责处理槽i的节点，除非ASK错误再次出现（只更改一次）。</li></ul></blockquote><hr><h3 id="3-3-6-复制与故障转移"><a href="#3-3-6-复制与故障转移" class="headerlink" title="3.3.6 复制与故障转移"></a>3.3.6 复制与故障转移</h3><h4 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h4><p>以下命令可以让接收命令的节点成为node_id所指定节点的从节点，并开始对主节点进行复制：</p><pre class="line-numbers language-none"><code class="language-none">CLUSTER REPLICATE ＜node_id＞<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实现原理如下：</p><ul><li>接收到该命令的节点首先会在自己的clusterState.nodes字典中找到node_id所对应节点的clusterNode结构，并将自己的clusterState.myself.slaveof指针指向这个结构</li><li>然后节点会修改自己在clusterState.myself.flags中的属性，关闭原本的REDIS_NODE_MASTER标识，打开REDIS_NODE_SLAVE标识，表示这个节点已经由原来的主节点变成了从节点</li><li>节点会调用复制代码，并根据clusterState.myself.slaveof指向的clusterNode结构所保存的IP地址和端口号，对主节点进行复制。</li></ul><p>一个节点成为从节点，并开始复制某个主节点这一信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点。</p><ul><li>集群中的所有节点都会在代表主节点的clusterNode结构的slaves属性和numslaves属性中记录正在复制这个主节点的从节点名单</li></ul><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>通过心跳机制检测是否下线，集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息</p><ul><li>当一个主节点A通过消息得知主节点B认为主节点C进入了疑似下线状态时，主节点A会在自己的clusterState.nodes字典中找到主节点C所对应的clusterNode结构，并将主节点B的下线报告添加到clusterNode结构的fail_reports链表里面</li><li>如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线（FAIL），将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。</li></ul><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，执行步骤：</p><ol><li>复制下线主节点的所有从节点里面，会有一个从节点被选中。</li><li>被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。</li><li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li><li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li><li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li></ol><h4 id="选举新的主节点"><a href="#选举新的主节点" class="headerlink" title="选举新的主节点"></a>选举新的主节点</h4><ol><li>集群的配置纪元是一个自增计数器，它的初始值为0。</li><li>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。</li><li>对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</li><li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</li><li>如果一个主节点具有投票权，并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</li><li>每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。</li><li>如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N&#x2F;2+1张支持票时，这个从节点就会当选为新的主节点。</li><li>如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</li></ol><blockquote><p>该方法和选举Sentinel的方法非常相似，两者都是基于Raft算法的leader election方法来实现的</p></blockquote><hr><h3 id="3-3-7"><a href="#3-3-7" class="headerlink" title="3.3.7"></a>3.3.7</h3><p>发送消息的节点为发送者（sender），接收消息的节点为接收者（receiver）</p><p>节点发送的消息主要有以下五种：</p><ul><li><strong>MEET消息</strong><ul><li>当发送者接到客户端发送的CLUSTER MEET命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。</li></ul></li><li><strong>PING消息</strong><ul><li>集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对这五个节点中最长时间没有发送过PING消息的节点发送PING消息，以此来检测被选中的节点是否在线。</li><li>如果节点A最后一次收到节点B发送的PONG消息的时间，距离当前时间已经超过了节点A的cluster-node-timeout选项设置时长的一半，那么节点A也会向节点B发送PING消息，这可以防止节点A因为长时间没有随机选中节点B作为PING消息的发送对象而导致对节点B的信息更新滞后。</li></ul></li><li><strong>PONG消息</strong><ul><li>当接收者收到发送者发来的MEET消息或者PING消息时，为了向发送者确认这条MEET消息或者PING消息已到达，接收者会向发送者返回一条PONG消息。</li><li>一个节点也可以通过向集群广播自己的PONG消息来让集群中的其他节点立即刷新关于这个节点的认识</li></ul></li><li><strong>FAIL消息</strong><ul><li>当一个主节点A判断另一个主节点B已经进入FAIL状态时，节点A会向集群广播一条关于节点B的FAIL消息，所有收到这条消息的节点都会立即将节点B标记为已下线。</li></ul></li><li><strong>PUBLISH消息</strong><ul><li>当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。</li></ul></li></ul><h4 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h4><p>消息头由cluster.h&#x2F;clusterMsg结构表示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> totlen<span class="token punctuation">;</span><span class="token comment">//消息的长度（包括这个消息头的长度和消息正文的长度）</span>    <span class="token class-name">uint16_t</span> type<span class="token punctuation">;</span><span class="token comment">//消息的类型</span>    <span class="token class-name">uint16_t</span> count<span class="token punctuation">;</span><span class="token comment">//消息正文包含的节点信息数量//只在发送MEET、PING、PONG这三种Gossip协议消息时使用</span>    <span class="token class-name">uint64_t</span> currentEpoch<span class="token punctuation">;</span><span class="token comment">//发送者所处的配置纪元</span>    <span class="token class-name">uint64_t</span> configEpoch<span class="token punctuation">;</span><span class="token comment">//如果发送者是一个主节点，那么这里记录的是发送者的配置纪元//如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的配置纪元</span>    <span class="token keyword">char</span> sender<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//发送者的名字（ID）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> myslots<span class="token punctuation">[</span>REDIS_CLUSTER_SLOTS<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//发送者目前的槽指派信息</span>    <span class="token keyword">char</span> slaveof<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的名字//如果发送者是一个主节点，那么这里记录的是REDIS_NODE_NULL_NAME</span>    <span class="token class-name">uint16_t</span> port<span class="token punctuation">;</span><span class="token comment">//发送者的端口号</span>    <span class="token class-name">uint16_t</span> flags<span class="token punctuation">;</span><span class="token comment">//发送者的标识值</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> state<span class="token punctuation">;</span><span class="token comment">//发送者所处集群的状态</span>    <span class="token keyword">union</span> clusterMsgData data<span class="token punctuation">;</span><span class="token comment">//消息的正文（或者说，内容）</span><span class="token punctuation">&#125;</span> clusterMsg<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>clusterMsg.data属性指向联合cluster.h&#x2F;clusterMsgData:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">union</span> clusterMsgData <span class="token punctuation">&#123;</span>    <span class="token comment">// MEET、PING、PONG消息的正文</span>    <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//每条MEET、PING、PONG消息都包含两个</span>        <span class="token comment">// clusterMsgDataGossip结构</span>        clusterMsgDataGossip gossip<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> ping<span class="token punctuation">;</span>    <span class="token comment">// FAIL消息的正文</span>    <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>        clusterMsgDataFail about<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> fail<span class="token punctuation">;</span>    <span class="token comment">// PUBLISH消息的正文</span>    <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>        clusterMsgDataPublish msg<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> publish<span class="token punctuation">;</span>    <span class="token comment">//其他消息的正文...</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h1><h2 id="4-1-发布与订阅"><a href="#4-1-发布与订阅" class="headerlink" title="4.1 发布与订阅"></a>4.1 发布与订阅</h2><p>通过执行SUBSCRIBE命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者（subscriber）：每当有其他客户端向被订阅的频道发送消息（message）时，频道的所有订阅者都会收到这条消息。</p><p>客户端还可以通过执行PSUBSCRIBE命令订阅一个或多个模式，从而成为这些模式的订阅者：每当有其他客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，它还会被发送给所有与这个频道相匹配的模式的订阅者。</p><hr><h3 id="4-1-1-频道的订阅与退订"><a href="#4-1-1-频道的订阅与退订" class="headerlink" title="4.1.1 频道的订阅与退订"></a>4.1.1 频道的订阅与退订</h3><p>Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    dict <span class="token operator">*</span>pubsub_channels<span class="token punctuation">;</span><span class="token comment">//保存所有频道的订阅关系</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="订阅频道"><a href="#订阅频道" class="headerlink" title="订阅频道"></a>订阅频道</h4><p>执行SUBSCRIBE时，会将客户端与被订阅的频道在pubsub_channels字典中进行关联：</p><ul><li>如果频道已经有其他订阅者，其在pubsub_channels字典中必然有相应的订阅者链表，将客户端添加到订阅者链表的末尾。</li><li>如果频道还未有任何订阅者，在pubsub_channels字典中为频道创建一个键，并将这个键的值设置为空链表，然后再将客户端添加到链表，成为链表的第一个元素。</li></ul><h4 id="退订频道"><a href="#退订频道" class="headerlink" title="退订频道"></a>退订频道</h4><p>当一个客户端退订某个或某些频道的时：</p><ul><li>程序会根据被退订频道的名字，在pubsub_channels字典中找到频道对应的订阅者链表，然后从订阅者链表中删除退订客户端的信息。</li><li>如果删除退订客户端之后，频道的订阅者链表变成了空链表，那么说明这个频道已经没有任何订阅者了，程序将从pubsub_channels字典中删除频道对应的键。</li></ul><hr><h3 id="4-1-2-模式的订阅与退订"><a href="#4-1-2-模式的订阅与退订" class="headerlink" title="4.1.2 模式的订阅与退订"></a>4.1.2 模式的订阅与退订</h3><p>所有模式的订阅关系都保存在服务器状态的pubsub_patterns属性里面，其是一个链表，链表中的每个节点都包含着一个pubsub Pattern结构</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    list <span class="token operator">*</span>pubsub_patterns<span class="token punctuation">;</span><span class="token comment">//保存所有模式订阅关系</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">pubsubPattern</span> <span class="token punctuation">&#123;</span>    redisClient <span class="token operator">*</span>client<span class="token punctuation">;</span><span class="token comment">//订阅模式的客户端</span>    robj <span class="token operator">*</span>pattern<span class="token punctuation">;</span><span class="token comment">//被订阅的模式</span><span class="token punctuation">&#125;</span> pubsubPattern<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h4><p>PSUBSCRIBE命令实现如下：</p><ol><li>新建一个pubsubPattern结构，将结构的pattern属性设置为被订阅的模式，client属性设置为订阅模式的客户端。</li><li>将pubsubPattern结构添加到pubsub_patterns链表的表尾</li></ol><h4 id="退订模式"><a href="#退订模式" class="headerlink" title="退订模式"></a>退订模式</h4><p>在pubsub_patterns链表中查找并删除那些pattern属性为被退订模式，并且client属性为执行退订命令的客户端的pubsubPattern结构</p><hr><h3 id="4-1-3-发送消息"><a href="#4-1-3-发送消息" class="headerlink" title="4.1.3 发送消息"></a>4.1.3 发送消息</h3><p>执行PUBLISH＜channel＞＜message＞命令将消息message发送给频道channel的时候，服务器需要执行以下两个动作：</p><ol><li>将消息message发送给channel频道的所有订阅者。<ul><li>在pubsub_channels字典里找到频道channel的订阅者名单（一个链表），然后将消息发送给名单上的所有客户端</li></ul></li><li>如果有一个或多个模式pattern与频道channel相匹配，那么将消息message发送给pattern模式的订阅者。<ul><li>遍历整个pubsub_patterns链表，查找那些与channel频道相匹配的模式，并将消息发送给订阅了这些模式的客户端。</li></ul></li></ol><hr><h3 id="4-1-4-查看订阅信息"><a href="#4-1-4-查看订阅信息" class="headerlink" title="4.1.4 查看订阅信息"></a>4.1.4 查看订阅信息</h3><p>PUBSUB命令可查看频道或者模式的相关信息</p><ul><li>**PUBSUB CHANNELS[pattern]**：用于返回服务器当前被订阅的频道<ul><li>如果不给定pattern参数，那么命令返回服务器当前被订阅的所有频道。否则，那么返回服务器当前被订阅的频道中那些与pattern模式相匹配的频道。</li><li>通过遍历服务器pubsub_channels字典的所有键，然后记录并返回所有符合条件的频道来实现的</li></ul></li><li>**PUBSUB NUMSUB[channel-1 channel-2…channel-n]**：接受任意多个频道作为输入参数，并返回这些频道的订阅者数量<ul><li>通过在pubsub_channels字典中找到频道对应的订阅者链表，然后返回订阅者链表的长度来实现的</li></ul></li><li><strong>PUBSUB NUMPAT</strong>：用于返回服务器当前被订阅模式的数量<ul><li>通过返回pubsub_patterns链表的长度来实现的</li></ul></li></ul><hr><h2 id="4-2-事务"><a href="#4-2-事务" class="headerlink" title="4.2 事务"></a>4.2 事务</h2><p>Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能</p><h3 id="4-2-1-事务的实现"><a href="#4-2-1-事务的实现" class="headerlink" title="4.2.1 事务的实现"></a>4.2.1 事务的实现</h3><p>事务从开始到结束会经历以下阶段：</p><ol><li><strong>事务开始</strong><ul><li>MULTI命令的执行标志着事务的开始，将执行该命令的客户端从非事务状态切换至事务状态，其通过在客户端状态的flags属性中打开REDIS_MULTI标识来完成的</li></ul></li><li><strong>命令入队</strong><ul><li>当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行</li><li>当一个客户端切换到事务状态之后：<ul><li>如果客户端发送的命令为EXEC、DISCARD、WATCH、MULTI四个命令的其中一个，那么服务器立即执行这个命令。</li><li>否则，服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复。</li></ul></li></ul></li><li><strong>事务执行</strong><ul><li>当客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端</li></ul></li></ol><blockquote><p>每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里面</p><ul><li><p>事务状态包含一个事务队列，以及一个已入队命令的计数器</p></li><li><p>事务队列是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息，包括指向命令实- 现函数的指针、命令的参数，以及参数的数量</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">&#123;</span>    multiState mstate<span class="token punctuation">;</span>    <span class="token comment">/* MULTI/EXEC state */</span> <span class="token comment">//事务状态</span><span class="token punctuation">&#125;</span> redisClient<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">multiState</span> <span class="token punctuation">&#123;</span>    multiCmd <span class="token operator">*</span>commands<span class="token punctuation">;</span><span class="token comment">//事务队列，FIFO顺序</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment">//已入队命令计数</span><span class="token punctuation">&#125;</span> multiState<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">multiCmd</span> <span class="token punctuation">&#123;</span>    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span><span class="token comment">//参数</span>    <span class="token keyword">int</span> argc<span class="token punctuation">;</span><span class="token comment">//参数数量</span>    <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">;</span><span class="token comment">//命令指针</span><span class="token punctuation">&#125;</span> multiCmd<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><hr><h3 id="4-2-2-WATCH命令的实现"><a href="#4-2-2-WATCH命令的实现" class="headerlink" title="4.2.2 WATCH命令的实现"></a>4.2.2 WATCH命令的实现</h3><p>WATCH命令是一个乐观锁（optimistic locking），它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。</p><p><strong>实现原理</strong></p><ul><li><p>每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">&#123;</span>    dict <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span><span class="token comment">//正在被WATCH命令监视的键</span><span class="token punctuation">&#125;</span> redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>所有对数据库进行修改的命令，在执行之后都会调用multi.c&#x2F;touchWatchKey函数对watched_keys字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键</p><ul><li>如果有的话，那么touchWatchKey函数会将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，表示该客户端的事务安全性已经被破坏。</li></ul></li></ul><p><strong>判断事务是否安全</strong></p><p>当收到发来的EXEC命令时：</p><ul><li>如果客户端的REDIS_DIRTY_CAS标识已经被打开，拒绝执行客户端提交的事务</li><li>否则执行客户端提交的这个事务</li></ul><hr><h3 id="4-2-3-事务的ACID性质"><a href="#4-2-3-事务的ACID性质" class="headerlink" title="4.2.3 事务的ACID性质"></a>4.2.3 事务的ACID性质</h3><p>在Redis中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当Redis运行在某种特定的持久化模式下时，事务也具有耐久性（Durability）</p><ul><li><strong>原子性</strong><ul><li>事务队列中的命令要么就全部都执行，要么就一个都不执行，因此具有原子性</li><li><em>Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制（rollback）</em>，即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。</li></ul></li><li><strong>一致性</strong><ul><li>指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据</li><li>通过谨慎的错误检测和简单的设计来保证事务的一致性<ol><li>入队错误：如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，那么Redis将拒绝执行这个事务。</li><li>执行错误：即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令（包括执行命令所产生的结果）不会被出错的命令影响。</li><li>服务器停机：根据服务器所使用的持久化模式，可能有以下情况出现：<ul><li>如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的。</li><li>如果服务器运行在RDB模式下，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的RDB文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。</li><li>如果服务器运行在AOF模式下，因为服务器可以根据现有的AOF文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的AOF文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。</li></ul></li></ol></li></ul></li><li><strong>隔离性</strong><ul><li>使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性的</li></ul></li><li><strong>耐久性</strong><ul><li>Redis事务的耐久性由Redis所使用的持久化模式决定：<ul><li>当服务器在无持久化的内存模式下运作时，事务不具有耐久性</li><li>当服务器在RDB持久化模式下运作时，服务器只会在特定的保存条件被满足时，才会执行BGSAVE命令，对数据库进行保存操作，并且异步执行的BGSAVE不能保证事务数据被第一时间保存到硬盘里面，因此RDB持久化模式下的事务也不具有耐久性。</li><li>当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，程序总会在执行命令之后调用同步（sync）函数，将命令数据真正地保存到硬盘里面，因此这种配置下的事务是具有耐久性的。</li><li>当服务器运行在AOF持久化模式下，并且appendfsync选项的值为everysec时，程序会每秒同步一次命令数据到硬盘。因为停机可能会恰好发生在等待同步的那一秒钟之内，这可能会造成事务数据丢失，所以这种配置下的事务不具有耐久性。</li></ul></li></ul></li></ul><hr><h2 id="4-3-Lua脚本"><a href="#4-3-Lua脚本" class="headerlink" title="4.3 Lua脚本"></a>4.3 Lua脚本</h2><p>通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器端原子地执行多个Redis命令</p><h3 id="4-3-1-创建并修改Lua环境"><a href="#4-3-1-创建并修改Lua环境" class="headerlink" title="4.3.1 创建并修改Lua环境"></a>4.3.1 创建并修改Lua环境</h3><p>创建并修改Lua环境的整个过程由以下步骤组成：</p><ol><li>创建一个基础的Lua环境，之后的所有修改都是针对这个环境进行的。<ul><li>调用Lua的C API函数lua_open，创建一个新的Lua环境</li></ul></li><li>载入多个函数库到Lua环境里面，让Lua脚本可以使用这些函数库来进行数据操作。</li><li>创建全局表格redis，这个表格包含了对Redis进行操作的函数，比如用于在Lua脚本中执行Redis命令的redis.call函数。</li><li>使用Redis自制的随机函数来替换Lua原有的带有副作用的随机函数，从而避免在脚本中引入副作用。</li><li>创建排序辅助函数，Lua环境使用这个辅佐函数来对一部分Redis命令的结果进行排序，从而消除这些命令的不确定性。</li><li>创建redis.pcall函数的错误报告辅助函数，这个函数可以提供更详细的出错信息。</li><li>对Lua环境中的全局环境进行保护，防止用户在执行Lua脚本的过程中，将额外的全局变量添加到Lua环境中。</li><li>将完成修改的Lua环境保存到服务器状态的lua属性中，等待执行服务器传来的Lua脚本。</li></ol><h4 id="Lua环境协作组件"><a href="#Lua环境协作组件" class="headerlink" title="Lua环境协作组件"></a>Lua环境协作组件</h4><p>Redis服务器还创建了两个用于与Lua环境进行协作的组件，它们分别是负责执行Lua脚本中的Redis命令的伪客户端，以及用于保存Lua脚本的lua_scripts字典</p><ul><li><p><strong>伪客户端</strong>：</p><ul><li><p>负责处理Lua脚本中包含的所有Redis命令</p></li><li><p>Lua脚本使用执行一个Redis命令，需要完成以下步骤：</p><ol><li>Lua环境将redis.call函数或者redis.pcall函数想要执行的命令传给伪客户端。</li><li>伪客户端将脚本想要执行的命令传给命令执行器。</li><li>命令执行器执行伪客户端传给它的命令，并将命令的执行结果返回给伪客户端。</li><li>伪客户端接收命令执行器返回的命令结果，并将这个命令结果返回给Lua环境。</li><li>Lua环境在接收到命令结果之后，将该结果返回给redis.call函数或者redis.pcall函数。</li><li>接收到结果的redis.call函数或者redis.pcall函数会将命令结果作为函数返回值返回给脚本中的调用者。</li></ol><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231003172057967.png" alt="" style="zoom: 67%;" /></li></ul></li><li><p><strong>lua_scripts字典</strong>：</p><ul><li>键为某个Lua脚本的SHA1校验和（checksum），而字典的值则是SHA1校验和对应的Lua脚本</li><li>Redis服务器会将所有被EVAL命令执行过的Lua脚本，以及所有被SCRIPT LOAD命令载入过的Lua脚本都保存到lua_scripts字典里面</li><li>lua_scripts字典有两个作用，一个是实现SCRIPT EXISTS命令，另一个是实现脚本复制功能</li></ul></li></ul><hr><h3 id="4-3-2-EVAL命令的实现"><a href="#4-3-2-EVAL命令的实现" class="headerlink" title="4.3.2 EVAL命令的实现"></a>4.3.2 EVAL命令的实现</h3><p>EVAL命令的执行过程可以分为以下三个步骤：</p><ol><li><strong>根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数</strong><ul><li>为传入的脚本定义一个与这个脚本相对应的Lua函数，其中，Lua函数的名字由f_前缀加上脚本的SHA1校验和组成，而函数的body则是脚本本身</li><li>使用函数来保存客户端传入的脚本有以下好处：<ul><li>执行脚本的步骤非常简单，只要调用与脚本相对应的函数即可。</li><li>通过函数的局部性来让Lua环境保持清洁，减少了垃圾回收的工作量，并且避免了使用全局变量。</li><li>如果某个脚本所对应的函数在Lua环境中被定义过至少一次，那么只要记得这个脚本的SHA1校验和，服务器就可以在不知道脚本本身的情况下，直接通过调用Lua函数来执行脚本</li></ul></li></ul></li><li><strong>将客户端给定的脚本保存到lua_scripts字典，等待将来进一步使用</strong></li><li><strong>执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本</strong><ul><li>服务器还需要进行一些设置钩子、传入参数之类的准备动作，才能正式开始执行脚本。整个准备和执行脚本的过程如下：<ul><li>将EVAL命令中传入的键名参数和脚本参数分别保存到KEYS数组和ARGV数组，然后将这两个数组作为全局变量传入到Lua环境里面。</li><li>为Lua环境装载超时处理钩子（hook），这个钩子可以在脚本出现超时运行情况时，让客户端通过SCRIPT KILL命令停止脚本，或者通过SHUTDOWN命令直接关闭服务器。</li><li>执行脚本函数。</li><li>移除之前装载的超时钩子。</li><li>将执行脚本函数所得的结果保存到客户端状态的输出缓冲区里面，等待服务器将结果返回给客户端。</li><li>对Lua环境执行垃圾回收操作。</li></ul></li></ul></li></ol><h4 id="EVALSHA命令的实现"><a href="#EVALSHA命令的实现" class="headerlink" title="EVALSHA命令的实现"></a>EVALSHA命令的实现</h4><ul><li><p><strong>实现原理</strong>：只要脚本对应的函数曾经在Lua环境里面定义过，那么即使不知道脚本的内容本身，客户端也可以根据脚本的SHA1校验和来调用脚本对应的函数，从而达到执行脚本的目的，这就是EVALSHA命令的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">EVALSHA</span><span class="token punctuation">(</span>sha1<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#拼接出函数的名字</span>    <span class="token comment">#例如：f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91</span>    func_name <span class="token operator">=</span> <span class="token string">"f_"</span> <span class="token operator">+</span> sha1    <span class="token comment">#查看这个函数在Lua环境中是否存在</span>    <span class="token keyword">if</span> function_exists_in_lua_env<span class="token punctuation">(</span>func_name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">#如果函数存在，那么执行它</span>        execute_lua_function<span class="token punctuation">(</span>func_name<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token comment">#如果函数不存在，那么返回一个错误</span>        send_script_error<span class="token punctuation">(</span><span class="token string">"SCRIPT NOT FOUND"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="4-3-3-脚本管理命令的实现"><a href="#4-3-3-脚本管理命令的实现" class="headerlink" title="4.3.3 脚本管理命令的实现"></a>4.3.3 脚本管理命令的实现</h3><p>除了EVAL命令和EVALSHA命令之外，Redis中与Lua脚本有关的命令还有</p><ul><li><strong>SCRIPT FLUSH</strong><ul><li>用于清除服务器中所有和Lua脚本有关的信息，这个命令会释放并重建lua_scripts字典，关闭现有的Lua环境并重新创建一个新的Lua环境</li></ul></li><li><strong>SCRIPT EXISTS</strong><ul><li>根据输入的SHA1校验和，检查校验和对应的脚本是否存在于服务器中，其通过检查给定的校验和是否存在于lua_scripts字典来实现的</li></ul></li><li><strong>SCRIPT LOAD</strong><ul><li>命令首先在Lua环境中为脚本创建相对应的函数，然后再将脚本保存到lua_scripts字典里面。</li></ul></li><li><strong>SCRIPT KILL</strong><ul><li>如果超时运行的脚本未执行过任何写入操作，那么客户端可以通过SCRIPT KILL命令来指示服务器停止执行这个脚本，并向执行该脚本的客户端发送一个错误回复。处理完SCRIPT KILL命令之后，服务器可以继续运行<ul><li>如果脚本已经执行过写入操作，那么客户端只能用SHUTDOWN nosave命令来停止服务器，从而防止不合法的数据被写入数据库中。</li></ul></li></ul></li></ul><hr><h3 id="4-3-4-脚本复制"><a href="#4-3-4-脚本复制" class="headerlink" title="4.3.4 脚本复制"></a>4.3.4 脚本复制</h3><p>与其他普通Redis命令一样，当服务器运行在复制模式之下时，具有写性质的脚本命令也会被复制到从服务器，这些命令包括EVAL命令、EVALSHA命令、SCRIPT FLUSH命令，以及SCRIPT LOAD命令</p><ul><li><p><strong>复制EVAL、SCRIPT FLUSH、SCRIPT LOAD</strong>：和复制其他普通Redis命令的方法一样，当主服务器执行完以上三个命令的其中一个时，主服务器会直接将被执行的命令传播给所有从服务器</p></li><li><p><strong>复制EVALSHA命令</strong>：必须确保EVALSHA命令要执行的脚本已经被所有从服务器载入过，否则，将EVALSHA命令转换成一个等价的EVAL命令，然后通过传播EVAL命令来代替EVALSHA命令</p><ul><li><p>判断传播EVALSHA命令是否安全的方法</p><ul><li><p>主服务器使用服务器状态的repl_scriptcache_dict字典记录自己已经将哪些脚本传播给了所有从服务器</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    dict <span class="token operator">*</span>repl_scriptcache_dict<span class="token punctuation">;</span><span class="token comment">//键是Lua脚本的SHA1校验和，而字典的值则全部都是NULL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>当一个校验和出现在repl_scriptcache_dict字典时，说明这个校验和对应的Lua脚本已经传播给了所有从服务器，主服务器可以直接向从服务器传播包含这个SHA1校验和的EVALSHA命令</p></li></ul></li><li><p>清空repl_scriptcache_dict字典</p><ul><li>每当主服务器添加一个新的从服务器时，主服务器都会清空自己的repl_scriptcache_dict字典</li></ul></li><li><p>EVALSHA命令转换成EVAL命令的方法</p><ol><li>根据SHA1校验和sha1，在lua_scripts字典中查找sha1对应的Lua脚本script。</li><li>将原来的EVALSHA命令请求改写成EVAL命令请求，并且将校验和sha1改成脚本script，numkeys、key、arg等参数则保持不变。</li></ol></li><li><p>传播EVALSHA命令的方法</p><ul><li><p>当主服务器成功在本机执行完一个EVALSHA命令之后</p><ul><li>如果EVALSHA命令指定的SHA1校验和存在于repl_scriptcache_dict字典，那么主服务器直接向从服务器传播EVALSHA命令。</li><li>否则，将EVALSHA命令转换成等价的EVAL命令，然后传播这个等价的EVAL命令，并将EVALSHA命令指定的SHA1校验和添加到repl_scriptcache_dict字典里面。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20231003194234830.png" alt="" style="zoom: 50%;" /></li></ul></li></ul></li></ul><hr><h2 id="4-4-排序"><a href="#4-4-排序" class="headerlink" title="4.4 排序"></a>4.4 排序</h2><p>SORT命令可以对列表键、集合键或者有序集合键的值进行排序</p><h4 id="SORT＜key＞命令的实现"><a href="#SORT＜key＞命令的实现" class="headerlink" title="SORT＜key＞命令的实现"></a>SORT＜key＞命令的实现</h4><p>SORT命令的最简单执行形式为：</p><pre class="line-numbers language-none"><code class="language-none">SORT ＜key＞   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实现原理如下：</p><ol><li><p>创建一个和numbers列表长度相同的数组，该数组的每个项都是一个redis.h&#x2F;redisSortObject结构</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_redisSortObject</span> <span class="token punctuation">&#123;</span>    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span><span class="token comment">//被排序键的值</span>    <span class="token keyword">union</span> <span class="token punctuation">&#123;</span><span class="token comment">//权重</span>        <span class="token keyword">double</span> score<span class="token punctuation">;</span><span class="token comment">//排序数字值时使用</span>        robj <span class="token operator">*</span>cmpobj<span class="token punctuation">;</span><span class="token comment">//排序带有BY选项的字符串值时使用</span>    <span class="token punctuation">&#125;</span> u<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> redisSortObject<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>遍历数组，将各个数组项的obj指针分别指向numbers列表的各个项，构成obj指针和列表项之间的一对一关系</p></li><li><p>遍历数组，将各个obj指针所指向的列表项转换成一个double类型的浮点数，并将这个浮点数保存在相应数组项的u.score属性里面</p></li><li><p>根据数组项u.score属性的值，对数组进行数字值排序，排序后的数组项按u.score属性的值从小到大排列</p></li><li><p>遍历数组，将各个数组项的obj指针所指向的列表项作为排序结果返回给客户端</p></li></ol><h4 id="ALPHA选项的实现"><a href="#ALPHA选项的实现" class="headerlink" title="ALPHA选项的实现"></a>ALPHA选项的实现</h4><p>通过使用ALPHA选项，SORT命令可以对包含字符串值的键进行排序：</p><pre class="line-numbers language-none"><code class="language-none">SORT ＜key＞ ALPHA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>详细步骤如下：</p><ol><li>创建一个redisSortObject结构数组，数组的长度等于集合的大小。</li><li>遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素</li><li>根据obj指针所指向的集合元素，对数组进行字符串排序，排序后的数组项按集合元素的字符串值从小到大排列</li><li>遍历数组，依次将数组项的obj指针所指向的元素返回给客户端。</li></ol><h4 id="ASC选项和DESC选项的实现"><a href="#ASC选项和DESC选项的实现" class="headerlink" title="ASC选项和DESC选项的实现"></a>ASC选项和DESC选项的实现</h4><p>默认情况下，SORT命令执行升序排序；使用DESC选项，可以让命令执行降序排序</p><p>升序排序和降序排序都由相同的快速排序算法执行，不同之处在于：</p><ul><li>在执行升序排序时，使用的对比函数产生升序对比结果。</li><li>而在执行降序排序时，使用的对比函数产生降序对比结果。</li></ul><h4 id="BY选项的实现"><a href="#BY选项的实现" class="headerlink" title="BY选项的实现"></a>BY选项的实现</h4><p>默认情况下，SORT命令使用被排序键包含的元素作为排序的权重；通过使用BY选项，SORT命令可以指定某些字符串键，或者某个哈希键所包含的某些域（field）来作为元素的权重，对一个键进行排序。</p><ol><li>创建一个redisSortObject结构数组，数组的长度等于集合的大小。</li><li>遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素</li><li>遍历数组，根据各个数组项的obj指针所指向的集合元素，以及BY选项所给定的模式*-price，查找相应的权重键</li><li>将各个权重键的值转换成一个double类型的浮点数，然后保存在相应数组项的u.score属性里面</li><li>以数组项u.score属性的值为权重，对数组进行排序，得到一个按u.score属性的值从小到大排序的数组</li><li>遍历数组，依次将数组项的obj指针所指向的集合元素返回给客户端。</li></ol><h4 id="带有ALPHA选项的BY选项的实现"><a href="#带有ALPHA选项的BY选项的实现" class="headerlink" title="带有ALPHA选项的BY选项的实现"></a>带有ALPHA选项的BY选项的实现</h4><p>BY选项默认假设权重键保存的值为数字值，如果权重键保存的是字符串值的话，那么就需要在使用BY选项的同时，配合使用ALPHA选项。</p><p>其实现和上述方法大致一样，只是设置权重u.compojb</p><h4 id="LIMIT选项的实现"><a href="#LIMIT选项的实现" class="headerlink" title="LIMIT选项的实现"></a>LIMIT选项的实现</h4><p>通过LIMIT选项，我们可以让SORT命令只返回其中一部分已排序的元素,格式为</p><ul><li>offset参数表示要跳过的已排序元素数量。</li><li>count参数表示跳过给定数量的已排序元素之后，要返回的已排序元素数量</li></ul><pre class="line-numbers language-none"><code class="language-none">LIMIT＜offset＞＜count＞<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其实现原理是在排序完成后，将遍历指针移动到offset上，然后访问count个元素即可</p><h4 id="GET选项的实现"><a href="#GET选项的实现" class="headerlink" title="GET选项的实现"></a>GET选项的实现</h4><p>通过使用GET选项，可以在对键进行排序之后，根据被排序的元素，以及GET选项所指定的模式，查找并返回某些键的值。</p><p>其实现原理是在排序完成后，遍历数组时，根据GET选项所给定的*-name模式，查找相应的键，然后返回。</p><ul><li>一个SORT命令可以带有多个GET选项，所以随着GET选项的增多，命令要执行的查找操作也会增多（依次比较每个模式）</li></ul><h4 id="STORE选项的实现"><a href="#STORE选项的实现" class="headerlink" title="STORE选项的实现"></a>STORE选项的实现</h4><p>默认情况下，SORT命令只向客户端返回排序结果，而不保存排序结果；通过使用STORE选项，可以将排序结果保存在指定的键里面，并在有需要时重用这个排序结果。</p><pre class="line-numbers language-none"><code class="language-none">SORT students ALPHA STORE sorted_students<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>类似操作，先进行排序</li><li>检查sorted_students键是否存在，如果存在的话，那么删除该键。</li><li>设置sorted_students为空白的列表键。</li><li>遍历数组，将排序后的元素依次推入sorted_students列表的末尾，相当于执行命令RPUSH命令</li><li>遍历数组，向客户端返回元素。</li></ul><h4 id="多个选项的执行顺序"><a href="#多个选项的执行顺序" class="headerlink" title="多个选项的执行顺序"></a>多个选项的执行顺序</h4><p>选项的执行顺序是有先后之分的，通常按照执行过程来决定顺序：</p><ol><li>排序：命令会使用ALPHA、ASC或DESC、BY这几个选项，对输入键进行排序，并得到一个排序结果集。</li><li>限制排序结果集的长度：命令会使用LIMIT选项，对排序结果集的长度进行限制，只有LIMIT选项指定的那部分元素会被保留在排序结果集中。</li><li>获取外部键：命令会使用GET选项，根据排序结果集中的元素，以及GET选项指定的模式，查找并获取指定键的值，并用这些值来作为新的排序结果集。</li><li>保存排序结果集：在这一步，命令会使用STORE选项，将排序结果集保存到指定的键上面去。</li><li>向客户端返回排序结果集：在最后这一步，命令遍历排序结果集，并依次向客户端返回排序结果集中的元素。</li></ol><p><strong>后一个步骤必须在前一个步骤完成之后进行</strong></p><p><strong>除了GET选项之外，改变选项的摆放顺序并不会影响SORT命令执行这些选项的顺序。</strong></p><hr><h2 id="4-5-二进制位数组"><a href="#4-5-二进制位数组" class="headerlink" title="4.5 二进制位数组"></a>4.5 二进制位数组</h2><p>Redis使用<strong>字符串对象来表示位数组</strong>，因为字符串对象使用的SDS数据结构是二进制安全的，所以程序可以直接使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组。</p><p>Redis提供了SETBIT、GETBIT、BITCOUNT、BITOP四个命令用于处理二进制位数组</p><ul><li><p><strong>SETBIT</strong></p><ul><li><p>用于为位数组指定偏移量上的二进制位设置值，位数组的偏移量从0开始计数</p><pre class="line-numbers language-none"><code class="language-none">GETBIT ＜bitarray＞ ＜offset＞<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>实现原理</p><ol><li>计算byte&#x3D;offset÷8，byte值记录了offset偏移量指定的二进制位保存在位数组的哪个字节</li><li>计算bit&#x3D;（offset mod 8）+1，bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位。</li><li>根据byte值和bit值，在位数组bitarray中定位offset偏移量指定的二进制位（按位与即可），并返回这个位的值</li></ol></li></ul></li><li><p><strong>GETBIT</strong></p><ul><li><p>用于获取位数组指定偏移量上的二进制位的值</p><pre class="line-numbers language-none"><code class="language-none">SETBIT ＜bitarray＞ ＜offset＞ ＜value＞<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>实现原理：</p><ol><li>计算len&#x3D;offset÷8」+1，len值记录了保存offset偏移量指定的二进制位至少需要多少字节。</li><li>检查bitarray键保存的位数组的长度是否小于len，如果是的话，将SDS的长度扩展为len字节，并将所有新扩展空间的二进制位的值设置为0。</li><li>计算byte&#x3D;offset÷8」，byte值记录了offset偏移量指定的二进制位保存在位数组的哪个字节。</li><li>计算bit&#x3D;（offset mod 8）+1，bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位。</li><li>根据byte值和bit值，在bitarray键保存的位数组中定位offset偏移量指定的二进制位，首先将指定二进制位现在值保存在oldvalue变量，然后将新值value设置为这个二进制位的值。</li><li>向客户端返回oldvalue变量的值。</li></ol></li></ul></li><li><p><strong>BITCOUNT</strong></p><ul><li><p>用于统计位数组里面，值为1的二进制位的数量</p></li><li><p>遍历算法实现：遍历位数组中的每个二进制位，并在遇到值为1的二进制位时，将计数器的值增一。效率非常低</p></li><li><p>查表算法实现：创建一个表，表的键为某种排列的位数组，而表的值则是相应位数组中，值为1的二进制位的数量。例如基于1字节进行创表。</p></li><li><p>variable-precision SWAR算法实现</p><ol><li>步骤1计算出的值i的二进制表示可以按每两个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</li><li>步骤2计算出的值i的二进制表示可以按每四个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</li><li>步骤3计算出的值i的二进制表示可以按每八个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</li><li>步骤4的i*0x01010101语句计算出bitarray的汉明重量并记录在二进制位的最高八位，而＞＞24语句则通过右移运算，将bitarray的汉明重量移动到最低八位，得出的结果就是bitarray的汉明重量。</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> <span class="token function">swar</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//步骤1</span>    i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i ＞＞ <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//步骤2</span>    i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i ＞＞ <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//步骤3</span>    i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i ＞＞ <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//步骤4</span>    i <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x01010101</span><span class="token punctuation">)</span> ＞＞ <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Redis的实现:用到了查表和variable-precisionSWAR两种算法</p><ul><li>如果未处理的二进制位的数量大于等于128位，那么程序使用variable-precision SWAR算法来计算二进制位的汉明重量。</li><li>如果未处理的二进制位的数量小于128位，那么程序使用查表算法来计算二进制位的汉明重量。</li></ul></li></ul><blockquote><p>统计一个位数组中非0二进制位的数量，在数学上被称为“计算汉明重量</p></blockquote></li><li><p><strong>BITOP</strong></p><ul><li>既可以对多个位数组进行按位与、或、异或运算，也可以对给定的位数组进行取反运算</li><li>直接调用C语言提供的位操作来实现</li></ul></li></ul><hr><h2 id="4-6-慢查询日志"><a href="#4-6-慢查询日志" class="headerlink" title="4.6 慢查询日志"></a>4.6 慢查询日志</h2><p>慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。</p><ul><li><p>服务器配置有两个和慢查询日志相关的选项：</p><ol><li><p>slowlog-log-slower-than选项指定执行时间超过多少微秒的命令请求会被记录到日志上。</p></li><li><p>slowlog-max-len选项指定服务器最多保存多少条慢查询日志。</p></li></ol></li><li><p>服务器使用先进先出的方式保存多条慢查询日志，超过容量时则先弹出队头日志</p></li></ul><h4 id="慢查询记录的保存"><a href="#慢查询记录的保存" class="headerlink" title="慢查询记录的保存"></a>慢查询记录的保存</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> slowlog_entry_id<span class="token punctuation">;</span><span class="token comment">//下一条慢查询日志的ID</span>    list <span class="token operator">*</span>slowlog<span class="token punctuation">;</span><span class="token comment">//保存了所有慢查询日志的链表</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> slowlog_log_slower_than<span class="token punctuation">;</span><span class="token comment">//服务器配置slowlog-log-slower-than选项的值</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> slowlog_max_len<span class="token punctuation">;</span><span class="token comment">//服务器配置slowlog-max-len选项的值</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>slowlog链表保存了服务器中的所有慢查询日志，链表中的每个节点都保存了一个slowlogEntry结构:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">slowlogEntry</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span><span class="token comment">//唯一标识符</span>    <span class="token class-name">time_t</span> time<span class="token punctuation">;</span><span class="token comment">//命令执行时的时间，格式为UNIX时间戳</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> duration<span class="token punctuation">;</span><span class="token comment">//执行命令消耗的时间，以微秒为单位</span>    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span><span class="token comment">//命令与命令参数</span>    <span class="token keyword">int</span> argc<span class="token punctuation">;</span><span class="token comment">//命令与命令参数的数量</span><span class="token punctuation">&#125;</span> slowlogEntry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="添加新日志"><a href="#添加新日志" class="headerlink" title="添加新日志"></a>添加新日志</h4><p>在每次执行命令的之前和之后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长，服务器会将这个时长作为参数之一传给slowlogPushEntryIfNeeded函数，其负责检查是否需要为这次执行的命令创建慢查询日志。该函数作用有两个：</p><ol><li>检查是否超过设定时间，超过则为命令创建一个新的日志，并将新日志添加到slowlog链表的表头。</li><li>检查慢查询日志的长度是否超过设置的长度，如果是的话，那么将多出来的日志从slowlog链表中删除掉。</li></ol><hr><h2 id="4-7-监视器"><a href="#4-7-监视器" class="headerlink" title="4.7 监视器"></a>4.7 监视器</h2><p>通过执行MONITOR命令，客户端可以将自己变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息</p><ul><li>每当一个客户端向服务器发送一条命令请求时，服务器除了会处理这条命令请求之外，还会将关于这条命令请求的信息发送给所有监视器</li></ul><h4 id="成为监视器"><a href="#成为监视器" class="headerlink" title="成为监视器"></a>成为监视器</h4><p>实现原理伪代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">MONITOR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    client<span class="token punctuation">.</span>flags <span class="token operator">|</span><span class="token operator">=</span> REDIS_MONITOR<span class="token comment">#打开客户端的监视器标志</span>    server<span class="token punctuation">.</span>monitors<span class="token punctuation">.</span>append<span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token comment">#将客户端添加到服务器状态的monitors链表的末尾</span>    send_reply<span class="token punctuation">(</span><span class="token string">"OK"</span><span class="token punctuation">)</span><span class="token comment">#向客户端返回OK</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="向监视器发送命令信息"><a href="#向监视器发送命令信息" class="headerlink" title="向监视器发送命令信息"></a>向监视器发送命令信息</h4><ul><li><p>服务器在每次处理命令请求之前，都会调用replicationFeedMonitors函数，由这个函数将被处理的命令请求的相关信息发送给各个监视器。</p></li><li><p>eplicationFeedMonitors函数的伪代码定义如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">replicationFeedMonitors</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> monitors<span class="token punctuation">,</span> dbid<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> argc<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#根据执行命令的客户端、当前数据库的号码、命令参数、命令参数个数等参数</span>    <span class="token comment">#创建要发送给各个监视器的信息</span>    msg <span class="token operator">=</span> create_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> dbid<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> argc<span class="token punctuation">)</span>    <span class="token keyword">for</span> monitor <span class="token keyword">in</span> monitors<span class="token punctuation">:</span><span class="token comment">#遍历所有监视器</span>        send_message<span class="token punctuation">(</span>monitor<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token comment">#将信息发送给监视器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 阅读书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式的艺术-笔记</title>
      <link href="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
      <url>/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>学习《设计模式的艺术》笔记</p><hr><hr><h1 id="第一部分-基础知识"><a href="#第一部分-基础知识" class="headerlink" title="第一部分 基础知识"></a>第一部分 基础知识</h1><p><strong>软件模式</strong>是指在软件开发过程中某些可重现问题的有效解决方法，其基础结构主要由四部分构成，包括问题描述（待解决的问题是什么）、前提条件（在何种环境或约束条件下使用）、解法（如何解决）和效果（有哪些优缺点）</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903143337565.png" alt="" style="zoom:50%;" /><p><strong>设计模式</strong>（Design Pattern）是一套被反复使用的、多数人知晓的、经过分类编目的代码设计经验的总结，使用设计模式是为了可以重用代码，让代码更容易被他人理解并且提高代码的可靠性。</p><p><strong>设计模式优点</strong>：</p><ul><li>设计模式是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案可以避免做一些重复性的工作，有助于提高设计和开发效率。</li><li>设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间进行沟通和交流，使得设计方案更加通俗易懂。</li><li>大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得开发人员可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免经常做一些重复的设计、编写一些重复的代码</li><li>合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统</li></ul><h2 id="1-1-UML基础"><a href="#1-1-UML基础" class="headerlink" title="1.1 UML基础"></a>1.1 UML基础</h2><h3 id="UML简介"><a href="#UML简介" class="headerlink" title="UML简介"></a>UML简介</h3><p><strong>UML特性</strong>：</p><ul><li>融合了多种优秀的面向对象建模方法以及多种得到认可的软件工程方法，消除了因方法林立且相互独立而带来的种种不便</li><li>是一种通用的可视化建模（Modeling）语言，通过一些标准的图形符号和文字来对系统进行建模</li><li>是一种语言（Language），也就意味着它有属于自己的标准表达规则</li></ul><p>UML主要包括以下部分：</p><ol><li>视图（View）：UML视图用于从不同的角度来表示待建模系统。<ul><li>包括用户视图、结构视图、行为视图、实现视图和环境视图。</li><li>用户视图以用户的观点表示系统的目标，它是所有视图的核心，用于描述系统的需求；结构视图表示系统的静态行为，描述系统的静态元素，如包、类与对象，以及它们之间的关系；行为视图表示系统的动态行为，描述系统的组成元素（如对象）在系统运行时的交互关系；实现视图表示系统中逻辑元素的分布，描述系统中物理文件以及它们之间的关系；环境视图表示系统中物理元素的分布，描述系统中硬件设备以及它们之间的关系。</li></ul></li><li>图（Diagram）：UML图是描述UML视图内容的图形。<ul><li>提供了13种图，分别是用例图、类图、对象图、包图、组合结构图、状态图、活动图、顺序图（、通信图、定时图、交互概览图、组件图和部署图</li></ul></li><li>模型元素（Model Element）：指UML图中所使用的一些概念，如关联关系、依赖关系、泛化关系等。</li><li>通用机制（General Mechanism）：为模型元素提供额外的注释、信息和语义，允许用户对UML进行扩展，如定义新的建模元素、扩展原有元素的语义、添加新的特殊信息来扩展模型元素的规则说明等</li></ol><hr><h3 id="类与类的UML图示"><a href="#类与类的UML图示" class="headerlink" title="类与类的UML图示"></a>类与类的UML图示</h3><p><strong>类图</strong>（Class Diagram）是用出现在系统中的不同类来描述系统的静态结构，主要用来描述不同的类以及它们之间的关系。一般由三部分组成：</p><ol><li>类名：每个类都必须有一个名字，类名是一个字符串。</li><li>类的属性（Attributes）：属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性。<ul><li>表示方法：<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903144751996.png" alt="" style="zoom:50%;" /></li><li>可见性：public、private和protected，分别用符号+、-和＃表示</li></ul></li><li>类的操作（Operations）：操作是类的任意一个实例对象都可以使用的行为，是类的成员方法<ul><li>表示方法：<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903144941570.png" alt="" style="zoom:50%;" /></li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903145023139.png" alt="" style="zoom:67%;" /><hr><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a><strong>关联关系</strong></h4><p>用于表示一类对象与另一类对象之间有联系。用实线连接有关联关系的对象所对应的类，通常将一个类的对象作为另一个类的成员变量。</p><ul><li><strong>双向关联</strong>：默认情况下，关联是双向的。实现无箭头。<ul><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903145534238.png" alt="" style="zoom: 50%;" /></li></ul></li><li><strong>单向关联</strong>：在UML中单向关联用带箭头的实线表示<ul><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903145629656.png" alt="" style="zoom:50%;" /></li></ul></li><li><strong>自关联</strong>：可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。<ul><li>例如，一个节点类（Node）的成员又是节点Node类型的对象</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903145716030.png" alt="" style="zoom:50%;" /></li></ul></li><li><strong>多重性关联</strong>：又称为重数性关联关系，表示两个关联对象在数量上的对应关系。对象之间的多重性可以直接在关联直线上用一个数字或一个数字范围表示。<ul><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903145918222.png" alt="" style="zoom:50%;" /></li><li>例如，一个界面（Form）可以拥有零个或多个按钮（Button），但是一个按钮只能属于一个界面</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903145946367.png" alt="" style="zoom:50%;" /></li></ul></li><li><strong>聚合关系</strong>：表示整体与部分的关系。成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。用带空心菱形的直线表示。<ul><li>在代码实现聚合关系时，成员对象通常作为构造方法、Setter方法或业务方法的参数注入整体对象中</li><li>相比于几种关联，多了构造注入等方法，但都是定义一个变量</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903150123496.png" alt="" style="zoom:50%;" /></li></ul></li><li><strong>组合关系</strong>：也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期。一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。组合关系用带实心菱形的直线表示。<ul><li>例如，人的头与嘴巴，嘴巴是头的组成部分之一，而且如果头没了，嘴巴也就没了，因此头和嘴巴是组合关系</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903150526971.png" alt="" style="zoom:50%;" /></li></ul></li></ul><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><ul><li>依赖关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。</li><li><strong>依赖关系体现在某个类的方法使用另一个类的对象作为参数</strong></li><li>依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。</li><li>依赖关系通常通过3种方式来实现：<ol><li>将一个类的对象作为另一个类中方法的参数</li><li>在一个类的方法中将另一个类的对象作为其局部变量</li><li>一个类的方法中调用另一个类的静态方法</li></ol></li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903150950831.png" alt="" style="zoom:50%;" /></li></ul><h4 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h4><ul><li>也称继承关系，用于描述父类与子类之间的关系。用带空心三角形的直线来表示。</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903151112717.png" alt="" style="zoom: 33%;" /></li></ul><h4 id="接口与实现关系"><a href="#接口与实现关系" class="headerlink" title="接口与实现关系"></a>接口与实现关系</h4><ul><li>接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现（Realization）关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。</li><li>类与接口之间的实现关系用带空心三角形的虚线来表示</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903151257815.png" alt="" style="zoom: 33%;" /></li></ul><h2 id="1-2-面向对象设计原则概述"><a href="#1-2-面向对象设计原则概述" class="headerlink" title="1.2 面向对象设计原则概述"></a>1.2 面向对象设计原则概述</h2><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903151356604.png" alt="" style="zoom:50%;" /><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><ul><li>一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</li><li>将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中；如果多个职责总是同时发生改变，则可将它们封装在同一类中。</li></ul><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><ul><li>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</li><li>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。</li></ul><h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><ul><li>所有引用基类（父类）的地方必须能透明地使用其子类的对象。</li><li>里氏代换原则是实现开闭原则的重要方式之一。由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</li><li>在运用里氏代换原则时，应该将父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法。程序运行时，子类实例替换父类实例，可以很方便地扩展系统的功能，无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</li></ul><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><ul><li>抽象不应该依赖于细节，细节应该依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</li><li>要求在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</li></ul><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><ul><li>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</li><li>每个接口应该承担一种相对独立的角色。这里的“接口”有两种不同的含义：<ul><li>一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象</li><li>另一种是指某种语言具体的“接口”定义，有严格的定义和结构</li></ul></li></ul><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><ul><li>尽量使用对象组合，而不是继承来达到复用的目的。原因如下：<ul><li>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用。如果基类发生改变，那么子类的实现也不得不发生改变。</li><li>由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用。</li></ul></li><li>如果两个类之间是“Has-A”的关系，应使用组合或聚合；如果是“Is-A”关系，可使用继承。<ul><li>“Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的“一种”；而“Has-A”则不同，它表示某一个角色具有某一项责任。</li></ul></li></ul><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><ul><li>一个软件实体应当尽可能少地与其他实体发生相互作用</li><li>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易。</li><li>迪米特法则还有几种定义形式：不要和“陌生人”说话，只与你的直接朋友通信等对于一个对象，其“朋友”包括以下几类：<ol><li>当前对象本身（this）。</li><li>以参数形式传入到当前对象方法中的对象。</li><li>当前对象的成员对象。</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。</li><li>当前对象所创建的对象。</li></ol></li></ul><h1 id="第2部分-创建的艺术——创建型模式"><a href="#第2部分-创建的艺术——创建型模式" class="headerlink" title="第2部分　创建的艺术——创建型模式"></a>第2部分　创建的艺术——创建型模式</h1><p><strong>创建型模式</strong>将对象的创建和使用分离，在使用对象时无须关心对象的创建细节，从而降低系统的耦合度，让设计方案更易于修改和扩展。</p><ul><li>每个创建型模式都通过采用不同的解决方案来回答3个问题：创建什么（What），由谁创建（Who）和何时创建（When）。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903154751903.png" alt="" style="zoom: 67%;" /><h2 id="2-1-单例模式——确保对象的唯一性"><a href="#2-1-单例模式——确保对象的唯一性" class="headerlink" title="2.1 单例模式——确保对象的唯一性"></a>2.1 单例模式——确保对象的唯一性</h2><p><strong>单例模式</strong>：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p><p><strong>单例模式的动机</strong>：确保对象的唯一性，避免资源浪费或对象状态的唯一性</p><p>单例模式实现步骤：</p><ol><li>禁止类的外部直接创建对象</li><li>在类中定义一个静态类型的私有成员变量</li><li>增加一个公有的静态方法提供对私有变量的访问</li></ol><p><strong>单例模式实现方法</strong>：</p><ol><li>饿汉式单例<ul><li>直接定义好静态示例的初始值</li><li>当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。</li><li>优缺点：<ul><li>优点：无须考虑多线程访问问题，调用速度和反应时间更优</li><li>缺点：无论系统在运行时是否需要使用该单例对象都会进行加载，导致资源浪费</li></ul></li></ul></li><li>懒汉式单例<ul><li>在第一次调用时进行实例化，通常使用互斥来避免创建多个实例</li><li>优缺点：<ul><li>优点：在第一次使用时创建，无须一直占用系统资源，实现了延迟加载</li><li>缺点：需要处理多线程同时访问问题，资源初始化很有可能耗费大量时间</li></ul></li><li>双重检查锁定：第一次判断时不进行互斥（减少竟态消耗），再临界区再判断一次（避免重复进入临界区导致创建多个实例）</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903162045948.png" alt="" style="zoom:50%;" /></li></ul></li><li>IoDH (Initialization on Demand Holder)<ul><li>在单例类中增加一个静态（static）内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance（）方法返回给外部使用<ul><li>由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton。第一次调用getInstance（）时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。</li><li>java支持，C++不支持</li></ul></li><li>结合了懒汉模式和饿汉模式优点，既可以实现延迟加载，又可以保证线程安全，不影响系统性能</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903162822393.png" alt="" style="zoom:50%;" /></li></ul></li></ol><blockquote><p><strong>单例模式优总结：</strong></p><ul><li>优点：<ul><li>提供了对唯一实例的受控访问，所以它可以严格控制客户怎样以及何时访问它。</li><li>可以节约系统资源。</li><li>允许可变数目的实例。基于单例模式，开发人员可以进行扩展，使用与控制单例对象相似的方法来获得指定个数的实例对象，既节省系统资源，又解决了由于单例对象共享过多有损性能的问题。</li></ul></li><li>缺点：<ul><li>单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>职责过重，在一定程度上违背了单一职责原则。因为单例类既提供了业务方法，又提供了创建对象的方法（工厂方法），将对象的创建和对象本身的功能耦合在一起。</li><li>对于提供gc的语言，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化</li></ul></li><li>适用场景：<ul><li>系统只需要一个实例对象。例如，系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点。除了该公共访问点，不能通过其他途径访问该实例。</li></ul></li></ul></blockquote><h2 id="2-2-简单工厂模式——集中式工厂的实现"><a href="#2-2-简单工厂模式——集中式工厂的实现" class="headerlink" title="2.2 简单工厂模式——集中式工厂的实现"></a>2.2 简单工厂模式——集中式工厂的实现</h2><p><strong>简单工厂模式</strong>：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p><ul><li>因为在简单工厂模式中用于创建实例的方法是静态方法，因此简单工厂模式又被称为静态工厂方法模式，它属于类创建型模式。</li><li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903171409955.png" alt="" style="zoom:50%;" /><p>简单工厂模式结构图中包含以下3个角色：</p><ul><li>Factory（工厂角色）：即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。在工厂类中提供了静态的工厂方法factoryMethod（），它的返回类型为抽象产品类型Product。</li><li>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法。抽象产品的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</li><li>eProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法</li></ul><p><strong>简单工厂模式的简化</strong></p><ul><li>有时候，为了简化简单工厂模式，可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903171634243.png" alt="" style="zoom:50%;" /></li></ul><blockquote><p><strong>简单工厂模式总结</strong></p><ul><li>优点<ul><li>实现了对象创建和使用的分离。工厂类可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可。</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul></li><li>缺点：<ul><li>工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响</li><li>使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</li><li>系统扩展困难。一旦添加新产品就不得不修改工厂逻辑，不利于系统的扩展和维护。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ul></li><li>适用场景<ul><li>工厂类负责创建的对象比较少。由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</li></ul></li></ul></blockquote><h2 id="2-3-工厂方法模式——多态工厂的实现"><a href="#2-3-工厂方法模式——多态工厂的实现" class="headerlink" title="2.3 工厂方法模式——多态工厂的实现"></a>2.3 工厂方法模式——多态工厂的实现</h2><p>简单工厂模式如何实现增加新产品而不影响已有代码？工厂方法模式为此应运而生</p><p><strong>工厂方法模式</strong>：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。其又简称为工厂模式或虚拟构造器模式或多态工厂模式。</p><ul><li>提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。</li><li>在抽象工厂中声明了工厂方法但并未实现工厂方法，具体产品对象的创建由其子类负责。客户端针对抽象工厂编程，可在运行时再指定具体工厂类。具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品</li><li>具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。</li><li>可以通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230903205956666.png" alt="" style="zoom: 33%;" /></li></ul><p>工厂方法模式结构图中包含以下4个角色</p><ul><li>Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</li><li>ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</li><li>Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</li><li>ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</li></ul><blockquote><p>与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色。抽象工厂可以是接口，也可以是抽象类或者具体类</p></blockquote><blockquote><p><strong>为啥不直接通过反射机制来生成产品对象。在定义产品对象时使用抽象类型，同样可以确保系统的灵活性和可扩展性？</strong></p><ul><li>基于职责分离来说不可行，因为工厂模式就是将创建的逻辑、初始化等独立出来。</li></ul></blockquote><p><strong>工厂方法的隐藏</strong>：在工厂类中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法。</p><blockquote><p><strong>工厂方法模式总结</strong></p><ul><li>优点<ul><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。</li><li>加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以</li></ul></li><li>缺点：<ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</li></ul></li><li>适用场景<ul><li>客户端不知道其所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</li><li>抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li></ul></li></ul></blockquote><h2 id="2-4-抽象工厂模式——产品族的创建"><a href="#2-4-抽象工厂模式——产品族的创建" class="headerlink" title="2.4 抽象工厂模式——产品族的创建"></a>2.4 抽象工厂模式——产品族的创建</h2><blockquote><p>工厂模式每新建一个产品，都需要建立一个与之对应的工厂，会导致工厂数据剧增。那如果几类产品具有相同的性质，例如同一套颜色皮肤下的按键、文本框等，那就可以将这几类产品划分为一个产品族，而具体工厂类则基于产品族来创建。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230904111939905.png" alt="" style="zoom: 33%;" /></blockquote><p><strong>抽象工厂模式</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</p><ul><li>工厂模式只有一个创建接口，而抽象工厂模式则是多个依赖的接口</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230904112826197.png" alt="" style="zoom:50%;" /><p>抽象工厂模式结构图中包含以下4个角色：</p><ul><li>AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每个方法对应一种产品。</li><li>ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每种产品都位于某个产品等级结构中。</li><li>AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li><li>ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现在抽象产品接口中声明的业务方法。</li></ul><blockquote><p><strong>抽象工厂模式是否符合开闭原则？</strong></p><ul><li>从增加新的产品等级结构来看不符合，需要改动源代码</li><li>增加新的产品族来看符合，因为已经定义了抽象接口</li></ul><p><strong>抽象工厂模式总结</strong></p><ul><li>优点<ul><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的产品族很方便，无须修改已有系统，符合开闭原则。</li></ul></li><li>缺点<ul><li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则。</li></ul></li><li>适用场景<ul><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节</li><li>系统中有多于一个的产品族，而每次只使用其中某一个产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li><li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束。</li><li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li></ul></li></ul></blockquote><h2 id="2-5-原型模式——对象的克隆"><a href="#2-5-原型模式——对象的克隆" class="headerlink" title="2.5 原型模式——对象的克隆"></a>2.5 原型模式——对象的克隆</h2><p><strong>原型模式</strong>：使用原型实例指定创建对象的种类，并且通过克隆这些原型创建新的对象。原型模式是一种对象创建型模式。</p><ul><li>工作原理：将一个原型对象传给要发动创建的对象，这个要发动创建的对象通过请求原型对象克隆自己来实现创建过程。</li><li>通用实现方法：在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回</li><li>注意克隆时存在深拷贝和浅拷贝之分</li></ul><p><strong>原型管理器</strong>（Prototype Manager）：是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得</p><ul><li>其实现使用一个哈希表记录名字与对应的实例对象（new一个），获取时则使用名字获取对象，然后调用其clone方法</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230904114427867.png" alt="" style="zoom:50%;" /><blockquote><p><strong>原型模式总结</strong></p><ul><li>优点：<ul><li>当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</li><li>性较好。由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少具体原型类对原有系统都没有任何影响。</li><li>原型模式提供了简化的创建结构，无须专门的工厂类来创建产品。</li><li>可以使用深克隆的方式保存对象的状态。使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用，例如恢复到某一历史状态，可辅助实现撤销操作。</li></ul></li><li>缺点：<ul><li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部。当对已有的类进行改造时，需要修改源代码，违背了开闭原则。</li><li>在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</li></ul></li><li>适用场景：<ul><li>创建新对象成本较大（例如初始化需要占用较长的时间，占用太多的CPU资源或网络资源）。新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</li><li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</li><li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态。通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li></ul></li></ul></blockquote><h2 id="2-6-建造者模式——复杂对象的组装与创建"><a href="#2-6-建造者模式——复杂对象的组装与创建" class="headerlink" title="2.6 建造者模式——复杂对象的组装与创建"></a>2.6 建造者模式——复杂对象的组装与创建</h2><p><strong>建造者模式</strong>（Builder Pattern）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</p><ul><li>将客户端与包含多个组成部分（或部件）的复杂对象的创建过程分离。客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需的建造者类型即可</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230904115359021.png" alt="" style="zoom:50%;" /><p><strong>建造者模式结构中包含以下4个角色</strong>：</p><ul><li>Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口。在该接口中一般声明两类方法：一类方法是buildPartX（），用于创建复杂对象的各个部件；另一类方法是getResult（），用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</li><li>ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确其所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</li><li>Product（产品角色）：它是被构建的复杂对象，包含多个组成部件。具体建造者创建该产品的内部表示并定义其装配过程。</li><li>Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序。指挥者与抽象建造者之间存在关联关系，可以在其construct（）建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</li></ul><p><strong>省略Director</strong>：为了简化系统结构，可以将Director和抽象建造者Builder进行合并，在Builder中提供逐步构建复杂产品对象的construct（）方法。由于Builder类通常为抽象类，因此可以将construct（）方法定义为静态（static）方法。</p><p><strong>钩子方法的引入</strong>：增加一类称之为钩子方法（Hook Method）的特殊方法来控制是否调用某个buildPartX（）方法</p><ul><li>钩子方法的返回类型通常为boolean类型，方法名一般为is×××（）。钩子方法定义在抽象建造者类中。例如，可以在游戏角色的抽象建造者类ActorBuilder中定义一个方法isBareheaded（），用于判断某个角色是否为“光头（Bareheaded）”</li></ul><blockquote><p><strong>建造者模式总结</strong></p><ul><li>优点<ul><li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每个具体建造者都相对独立，而与其他具体建造者无关。因此，可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合开闭原则。</li><li>可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li></ul></li><li>缺点<ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似。如果产品之间的差异性很大，例如很多组成部分都不相同，就不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部结构复杂且多变，可能会需要定义很多具体建造者类来实现这种变化，这就导致系统变得很庞大，增加系统的理解难度和运行成本。</li></ul></li><li>适用场景<ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中通过引入指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ul></li></ul></blockquote><h1 id="第3部分-组合的艺术——结构型模式"><a href="#第3部分-组合的艺术——结构型模式" class="headerlink" title="第3部分　组合的艺术——结构型模式"></a>第3部分　组合的艺术——结构型模式</h1><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230904120027083.png" alt="" style="zoom:67%;" /><h2 id="3-1-适配器模式——不兼容结构的协调"><a href="#3-1-适配器模式——不兼容结构的协调" class="headerlink" title="3.1 适配器模式——不兼容结构的协调"></a>3.1 适配器模式——不兼容结构的协调</h2><p><strong>适配器模式</strong>（Adapter Pattern）：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器（Wrapper）。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><ul><li>在适配器模式定义中所提及的接口是指广义的接口，它可以表示一个方法或者一组方法的集合</li><li>根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器模式和类适配器模式两种。<ul><li>在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230904120355910.png" alt="" style="zoom:50%;" /><p><strong>对象适配器模式结构图中包含以下3个角色</strong></p><ul><li>Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</li><li>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。适配器类是适配器模式的核心，在对象适配器模式中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</li><li>Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配。适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li></ul><blockquote><p><strong>在对象适配器模式中，一个适配器能否适配多个适配者？</strong></p><ul><li>个人认为可以，定义多个适配者的对象即可</li></ul></blockquote><p><strong>类适配器模式</strong>：其适配器和适配者之间的关系是继承关系</p><ul><li>由于Java、C＃等语言不支持多重类继承，因此类适配器模式的使用受到很多限制。例如，如果目标抽象类Target不是接口，而是一个类，就无法使用类适配器模式。此外，如果适配者Adaptee为最终（Final）类，也无法使用类适配器模式。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230904120733109.png" alt="" style="zoom:50%;" /><p><strong>双向适配器模式</strong></p><ul><li>在对象适配器模式的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230904192323935.png" alt="" style="zoom:50%;" /><p><strong>缺省适配器模式</strong>（Default Adapter Pattern）：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求。它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式</p><ul><li>ServiceInterface（适配者接口）：它是一个接口，通常在该接口中声明了大量的方法。</li><li>AbstractServiceClass（缺省适配器类）：它是缺省适配器模式的核心类，使用空方法的形式实现了在ServiceInterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。</li><li>ConcreteServiceClass（具体业务类）：它是缺省适配器类的子类，在没有引入适配器之前，它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无须使用的方法也不得不提供空实现。在有了缺省适配器模式之后，可以直接继承该适配器类，根据需要有选择性地覆盖在适配器类中定义的方法。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230904193040538.png" alt="" style="zoom:33%;" /><blockquote><p><strong>适配器模式总结</strong></p><ul><li>优点<ul><li>将目标类和适配者类解耦。通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li><li>增加了类的透明性和复用性。将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者类的复用性，同一个适配者类可以在多个不同的系统中复用。</li><li>灵活性和扩展性都非常好。通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合开闭原则。</li></ul></li><li>缺点<ul><li>对于Java、C＃等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者。</li><li>适配者类不能为最终类，例如在Java中不能为final类，C＃中不能为sealed类。</li><li>在Java、C＃等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</li></ul></li><li>适用场景<ul><li>系统需要使用一些现有的类，而这些类的接口（例如方法名）不符合系统的需要，甚至没有这些类的源代码。</li><li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作。</li></ul></li></ul></blockquote><h2 id="3-2-处理多维度变化——桥接模式"><a href="#3-2-处理多维度变化——桥接模式" class="headerlink" title="3.2 处理多维度变化——桥接模式"></a>3.2 处理多维度变化——桥接模式</h2><p><strong>桥接模式</strong>（Bridge Pattern）：将抽象部分与其实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口（Interface）模式。</p><ul><li>如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合单一职责原则。</li><li>与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230907163211009.png" alt="" style="zoom:50%;" /><p><strong>桥接模式结构图中包含以下4个角色：</strong></p><ul><li>Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象。抽象类与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。</li><li>RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类。扩充抽象类实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。</li><li>Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同。一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多、更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。</li><li>ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现。在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。</li></ul><p><strong>适配器模式与桥接模式的联用</strong></p><ul><li>桥接模式和适配器模式用于设计的不同阶段。桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象类和实现类两个角色，使它们可以分别进行变化；</li><li>而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及大量第三方应用接口的情况。</li><li>示例如下：<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230907163535953.png" alt="" style="zoom: 33%;" /></li></ul><blockquote><p><strong>桥接模式总结</strong></p><ul><li>优点<ul><li>分离抽象接口及其实现部分，使得抽象和实现可以沿着各自的维度来变化（即抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任意组合子类，从而获得多维度组合对象）。</li><li>在很多情况下，桥接模式可以取代多层继承方案。多层继承方案违背了单一职责原则，复用性较差，且类的个数非常多。桥接模式是比多层继承方案更好的解决方法，它极大地减少了子类的个数。</li><li>桥接模式提高了系统的可扩展性。在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合开闭原则。</li></ul></li><li>缺点<ul><li>桥接模式的使用会增加系统的理解与设计难度，要求开发者一开始就针对抽象层进行设计与编程。</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。</li></ul></li><li>适用场景<ul><li>如果一个系统需要在抽象类和具体类之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li><li>抽象部分和实现部分可以以继承的方式独立扩展而互不影响，在程序运行时可以动态地将一个抽象类子类的对象和一个实现类子类的对象进行组合，即系统需要对抽象类角色和实现类角色进行动态耦合。</li><li>一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。</li><li>对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li></ul></li></ul></blockquote><h2 id="3-3-组合模式——树形结构的处理"><a href="#3-3-组合模式——树形结构的处理" class="headerlink" title="3.3 组合模式——树形结构的处理"></a>3.3 组合模式——树形结构的处理</h2><p><strong>组合模式</strong>（Composite Pattern）：组合多个对象形成树形结构以表示具有“部分—整体”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，又可以称为“部分—整体”（Part-Whole）模式，它是一种对象结构型模式。</p><ul><li>组合模式通过定义一个共有的抽象父类，使得对所有子类对象的使用具有一致性</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230907164123740.png" alt="" style="zoom:50%;" /><p><strong>组合模式结构图中包含以下3个角色</strong>：</p><ul><li>Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法。</li><li>Leaf（叶子构件）：它在组合模式结构中表示叶子节点对象。叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过捕获异常等方式进行处理。</li><li>Composite（容器构件）：它在组合模式结构中表示容器节点对象。容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点。它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。</li></ul><p><strong>透明组合模式与安全组合模式</strong></p><ul><li>透明组合模式中，抽象构件Component中声明了所有用于管理成员对象的方法，这样做的好处是确保所有的构件类都有相同的接口。<ul><li>缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。</li></ul></li><li>安全组合模式中，在抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法。<ul><li>缺点是不够透明。因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</li></ul></li></ul><blockquote><p><strong>组合模式总结</strong></p><ul><li>优点<ul><li>可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次。让客户端忽略层次的差异，方便对整个层次结构进行控制。</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li><li>在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合开闭原则。</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案。通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li></ul></li><li>缺点<ul><li>在增加新构件时很难对容器中的构件类型进行限制。</li></ul></li><li>适用场景<ul><li>在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致性地对待它们。</li><li>在一个使用面向对象语言开发的系统中需要处理一个树形结构。</li><li>在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，将来需要增加一些新的类型。</li></ul></li></ul></blockquote><h2 id="3-4-装饰模式——扩展系统功能"><a href="#3-4-装饰模式——扩展系统功能" class="headerlink" title="3.4 装饰模式——扩展系统功能"></a>3.4 装饰模式——扩展系统功能</h2><p><strong>装饰模式</strong>（Decorator Pattern）：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</p><ul><li>在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。</li><li>具体构件类和装饰类都实现了相同的抽象构件接口，因此装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230907164930720.png" alt="" style="zoom: 67%;" /><p><strong>装饰模式结构图中包含以下4个角色</strong></p><ul><li>Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法。它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</li><li>ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</li><li>Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它<strong>维护一个指向抽象构件对象的引用</strong>，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</li><li>ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</li></ul><blockquote><p><strong>装饰模式和桥接模式的相同之处和不同之处</strong></p><ul><li>相同：两个模式都是为了解决子类过多问题，都具有两个维度，装饰模式中具体构件类与具体装饰类可以独立变化</li><li>不同<ul><li>桥接模式对象自身有沿着多个维度变化的趋势 , 本身不稳定;</li><li>装饰者模式对象自身非常稳定, 只是为了增加新功能&#x2F;增强原功能。</li></ul></li></ul></blockquote><p><strong>透明装饰模式与半透明装饰模式</strong></p><ul><li><p>透明装饰模式中，要求客户端<strong>完全针对抽象编程</strong>。装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Component</span> c，c1<span class="token punctuation">;</span>       <span class="token comment">//使用抽象构件类型定义对象</span>c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecorator</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>为了能够调用到新增方法，不得不用具体装饰类型来定义装饰之后的对象，而具体构件类型还是可以使用抽象构件类型来定义，这种装饰模式即为半透明装饰模式。</p><ul><li>也就是说，对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的。</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230907165811730.png" alt="" style="zoom:50%;" /></li></ul></li></ul><p><strong>装饰模式注意事项</strong></p><ul><li>尽量保持装饰类的接口与被装饰类的接口相同，即应该尽量使用透明装饰模式。</li><li>尽量保持具体构件类是一个“轻”类，即不要把太多的行为放在具体构件类中，可以通过装饰类对其进行扩展。</li><li>如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类。</li></ul><blockquote><p><strong>装饰模式总结</strong></p><ul><li>优点<ul><li>对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。</li><li>可以通过一种动态的方式来扩展一个对象的功能。通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。</li><li>可以对一个对象进行多次装饰。通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合开闭原则。</li></ul></li><li>缺点<ul><li>使用装饰模式进行系统设计时将产生很多小对象。这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同。</li><li>排错困难。对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul></li><li>适用场景<ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：<ul><li>第1类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长</li><li>第2类是因为类已定义为不能被继承。</li></ul></li></ul></li></ul></blockquote><h2 id="3-5-外观模式——提供统一入口"><a href="#3-5-外观模式——提供统一入口" class="headerlink" title="3.5 外观模式——提供统一入口"></a>3.5 外观模式——提供统一入口</h2><p><strong>外观模式</strong>（Facade Pattern）：外部与一个子系统的通信通过一个统一的外观角色进行，为子系统中的一组接口提供一个一致的入口。外观模式定义了一个高层接口，这个接口使得子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</p><ul><li>引入外观模式之后，增加新的子系统或者移除子系统都非常方便，客户端类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。从这一点来说，外观模式在一定程度上并不符合开闭原则，</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230907192826649.png"></p><p><strong>外观模式结构图中包含以下两个角色</strong>：</p><ul><li>Facade（外观角色）：在客户端可以调用这个角色的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任。在正常情况下，它将所有从客户端发来的请求委派到相应的子系统中去，传递给相应的子系统对象处理。</li><li>SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色。每个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。每个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求。子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</li></ul><p><strong>抽象外观类的引入</strong></p><ul><li>引入抽象外观类之后，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类。由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的。</li></ul><p><strong>外观角色设计补充说明</strong></p><ul><li>可以通过单例模式来设计外观类，从而确保系统中只有唯一一个访问子系统的入口，并降低对系统资源的消耗。</li><li>在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向客户端提供相应的业务功能。</li><li>试图通过外观类为子系统增加新行为的做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新行为。新行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。</li></ul><blockquote><p><strong>外观模式总结</strong></p><ul><li>优点<ul><li>对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目并使得子系统使用起来更加容易。</li><li>实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。</li><li>一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li><li>只是提供了一个访问子系统的统一入口，并不影响客户端直接使用子系统类。</li></ul></li><li>缺点<ul><li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，这违背了开闭原则。</li></ul></li><li>适用场景<ul><li>当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。</li><li>客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。</li><li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul></li></ul></blockquote><h2 id="3-6-享元模式——实现对象的复用"><a href="#3-6-享元模式——实现对象的复用" class="headerlink" title="3.6 享元模式——实现对象的复用"></a>3.6 享元模式——实现对象的复用</h2><p><strong>享元模式</strong>（Flyweight Pattern）：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。</p><ul><li>由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，是一种对象结构型模式。</li><li>享元模式以共享的方式高效地支持大量细粒度对象的重用。享元对象能做到共享的关键是区分了内部状态和外部状态。<ul><li>内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享</li><li>外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候，再传入享元对象内部。</li></ul></li></ul><p>享元模式结构较为复杂，一般结合工厂模式一起使用，结构图如图所示：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230907193658920.png" alt="" style="zoom:50%;" /><p><strong>享元模式结构图中包含以下4个角色</strong>：</p><ul><li>Flyweight（抽象享元类）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li>ConcreteFlyweight（具体享元类）：它实现了抽象享元类，其实例称为享元对象。在具体享元类中为内部状态提供了存储空间。通常，可以结合单例模式来设计具体享元类，为每个具体享元类提供唯一的享元对象。</li><li>UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类。当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li><li>FlyweightFactory（享元工厂类）：用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中。享元池一般设计为一个存储“键值对”的集合，结合工厂模式进行设计。当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例，或者创建一个新的实例并返回新创建的实例，同时将其存储在享元池中。</li></ul><p><strong>单纯享元模式和复合享元模式</strong></p><ul><li>在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类</li><li>将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以包括单纯享元对象，而后者则可以共享。</li></ul><blockquote><p><strong>享元模式总结</strong></p><ul><li>优点<ul><li>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</li></ul></li><li>缺点<ul><li>享元模式需要分离出内部状态和外部状态，从而使得系统变得复杂，这使得程序的逻辑复杂化。</li><li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。</li></ul></li><li>适用场景<ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源。因此，在需要多次重复使用同一享元对象时才值得使用享元模式。</li></ul></li></ul></blockquote><h2 id="3-7-代理模式——对象的间接访问"><a href="#3-7-代理模式——对象的间接访问" class="headerlink" title="3.7 代理模式——对象的间接访问"></a>3.7 代理模式——对象的间接访问</h2><p><strong>代理模式</strong>（Proxy Pattern）：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式是一种对象结构型模式。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230907194314099.png" alt="" style="zoom:50%;" /><p><strong>代理模式结构图中包含以下3个角色</strong>：</p><ul><li>Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，使得在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</li><li>Proxy（代理主题角色）：代理主题角色内部包含了对真实主题的引用，从而可以在任何时候操作真实主题对象。在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题。代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。</li><li>RealSubject（真实主题角色）：在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</li></ul><blockquote><p><strong>代理模式和装饰模式的区别</strong></p><ul><li>代理模式主要是给真实主题类增加一些全新的职责，例如权限控制、缓冲处理、智能引用、远程访问等，这些职责与原有职责不属于同一个问题域。</li><li>装饰模式是通过装饰类为具体构件类增加一些相关的职责，是对原有职责的扩展，这些职责属于同一问题域。</li><li>代理模式和装饰模式的目的也不相同，前者是控制对对象的访问，而后者是为对象动态地增加功能。</li></ul></blockquote><p><strong>常用的几种代理模式</strong></p><ul><li>远程代理（Remote Proxy）：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中。</li><li>虚拟代理（Virtual Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。在以下两种情况下可以考虑使用虚拟代理：<ul><li>由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象。</li><li>当一个对象的加载十分耗费系统资源的时候，也非常适合使用虚拟代理。虚拟代理可以让那些占用大量内存或处理起来非常复杂的对象推迟到使用它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象，再通过代理对象来引用真实对象。</li></ul></li><li>保护代理（Protect Proxy）：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li>缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li>智能引用代理（Smart Reference Proxy）：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。</li></ul><blockquote><p><strong>代理模式总结</strong></p><ul><li>优点<ul><li>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度，满足迪米特法则。</li><li>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。</li><li>远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。</li><li>虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。</li><li>保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。</li></ul></li><li>缺点<ul><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂，例如远程代理。</li></ul></li><li>适用场景<ul><li>当客户端对象需要访问远程主机中的对象时，可以使用远程代理。</li><li>当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时，可以使用虚拟代理。</li><li>当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时，可以使用保护代理。</li><li>当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时，可以使用缓冲代理。</li><li>当需要为一个对象的访问（引用）提供一些额外的操作时，可以使用智能引用代理。</li></ul></li></ul></blockquote><h1 id="第4部分-交互的艺术——行为型模式"><a href="#第4部分-交互的艺术——行为型模式" class="headerlink" title="第4部分　交互的艺术——行为型模式"></a>第4部分　交互的艺术——行为型模式</h1><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230907210409197.png" alt="" style="zoom:80%;" /><h2 id="4-1-职责链模式——请求的链式处理"><a href="#4-1-职责链模式——请求的链式处理" class="headerlink" title="4.1 职责链模式——请求的链式处理"></a>4.1 职责链模式——请求的链式处理</h2><p><strong>职责链模式</strong>（Chain of Responsibility Pattern）：避免将请求发送者与接收者耦合在一起，让多个对象都有机会接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。</p><ul><li>职责链模式结构的核心在于引入了一个抽象处理者</li><li>在职责链模式里，很多对象由每个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求为止。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230907210539162.png" alt="" style="zoom:50%;" /><p><strong>职责链模式结构图中包含以下两个角色</strong>：</p><ul><li>Handler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类。由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（结构图中的successor），作为其对下家的引用。通过该引用，处理者可以连成一条链。</li><li>ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求。在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者。在具体处理者中可以访问链中下一个对象，以便请求的转发。</li></ul><p><strong>纯与不纯的职责链模式</strong></p><ul><li>纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家。不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。且不能出现某个请求未被任何一个处理者对象处理的情况。</li><li>不纯的职责链模式中，允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。</li></ul><blockquote><p><strong>职责链模式总结</strong></p><ul><li>优点<ul><li>职责链模式使得一个对象无须知道是其他哪一个对象处理其请求。对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构。由客户端负责链的创建，降低了系统的耦合度。</li><li>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。</li><li>在给对象分派职责时，职责链可以提供更多的灵活性，可以通过在运行时对链进行动态的增加或修改来增加或改变处理一个请求的职责。</li><li>在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合开闭原则的。</li></ul></li><li>缺点<ul><li>由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理。一个请求也可能因职责链没有被正确配置而得不到处理。</li><li>对于比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</li><li>如果建链不当，可能会造成循环调用，将导致系统陷入死循环。</li></ul></li><li>适用场景<ul><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定。客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li><li>可动态指定一组对象处理请求。客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。</li></ul></li></ul></blockquote><h2 id="4-2-命令模式——请求发送者与接收者解耦"><a href="#4-2-命令模式——请求发送者与接收者解耦" class="headerlink" title="4.2 命令模式——请求发送者与接收者解耦"></a>4.2 命令模式——请求发送者与接收者解耦</h2><p><strong>命令模式</strong>（Command Pattern）：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作（Action）模式或事务（Transaction）模式。</p><ul><li>命令模式的核心在于引入了命令类，请求发送者只需指定一个命令对象，再通过命令对象来调用请求接收者的处理方法</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230907211357760.png" alt="" style="zoom:50%;" /><p><strong>命令模式结构图中包含以下4个角色</strong></p><ul><li>Command（抽象命令类）：是一个抽象类或接口，在其中声明了用于执行请求的execute（）等方法，通过这些方法可以调用请求接收者的相关操作。</li><li>ConcreteCommand（具体命令类）：是抽象命令类的子类，实现了在抽象命令类中声明的方法。它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute（）方法时，将调用接收者对象的相关操作。</li><li>Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute（）方法，从而实现间接调用请求接收者的相关操作。</li><li>Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li></ul><p><strong>命令队列的实现</strong></p><ul><li>当一个请求发送者发送一个请求时，不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理。此时，可以通过命令队列来实现。</li><li>实现：增加一个CommandQueue类。CommandQueue类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者</li></ul><p><strong>宏命令</strong>（Macro Command）：又称为组合命令，它是组合模式和命令模式联用的产物。宏命令是一个具体命令类，它拥有一个集合属性，在该集合中包含了对其他命令对象的引用。</p><ul><li>通常宏命令不直接与请求接收者交互，而是通过它的成员来调用接收者的方法。当调用宏命令的execute（）方法时，将递归调用它所包含的每个成员命令的execute（）方法。</li></ul><blockquote><p><strong>命令模式总结</strong></p><ul><li>优点<ul><li>降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者。同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。</li><li>新的命令可以很容易地加入系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码甚至客户类代码，满足开闭原则的要求。</li><li>可以比较容易地设计一个命令队列或宏命令（组合命令）。</li><li>为请求的撤销（Undo）和恢复（Redo）操作提供了一种设计和实现方案。</li></ul></li><li>缺点：使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。</li><li>适用场景<ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期。换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。</li><li>系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作。</li><li>系统需要将一组操作组合在一起形成宏命令。</li></ul></li></ul></blockquote><h2 id="4-3-解释器模式——自定义语言的实现"><a href="#4-3-解释器模式——自定义语言的实现" class="headerlink" title="4.3 解释器模式——自定义语言的实现"></a>4.3 解释器模式——自定义语言的实现</h2><h2 id="4-4-迭代器模式——遍历聚合对象中的元素"><a href="#4-4-迭代器模式——遍历聚合对象中的元素" class="headerlink" title="4.4 迭代器模式——遍历聚合对象中的元素"></a>4.4 迭代器模式——遍历聚合对象中的元素</h2><p><strong>迭代器模式</strong>（Iterator Pattern）：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标（Cursor）。迭代器模式是一种对象行为型模式。</p><ul><li>聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230908174040830.png" alt="" style="zoom:50%;" /><p><strong>迭代器模式结构图中包含以下4个角色</strong>：</p><ul><li>Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法。<ul><li>例如，用于获取第一个元素的first（）方法，用于访问下一个元素的next（）方法，用于判断是否还有下一个元素的hasNext（）方法，用于获取当前元素的currentItem（）方法等。在具体迭代器中将实现这些方法。</li></ul></li><li>ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置。在具体实现时，游标通常是一个表示位置的非负整数。</li><li>Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator（）方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。</li><li>ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的createIterator（）方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。</li></ul><p><strong>使用内部类实现迭代器</strong></p><ul><li>在具体迭代器中需要维持一个对具体聚合对象的引用，该关联关系的目的是访问存储在聚合对象中的数据，以便迭代器能够对这些数据进行遍历操作。</li><li>除了使用关联关系外，为了能够让迭代器可以访问到聚合对象中的数据，还可以将迭代器类设计为聚合类的内部类。</li></ul><blockquote><p><strong>迭代器模式总结</strong></p><ul><li>优点<ul><li>支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足开闭原则的要求。</li></ul></li><li>缺点<ul><li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li><li>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展。<ul><li>例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。</li></ul></li></ul></li><li>适用场景<ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。</li><li>需要为一个聚合对象提供多种遍历方式。</li><li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。</li></ul></li></ul></blockquote><h2 id="4-5-中介者模式——协调多个对象之间的交互"><a href="#4-5-中介者模式——协调多个对象之间的交互" class="headerlink" title="4.5 中介者模式——协调多个对象之间的交互"></a>4.5 中介者模式——协调多个对象之间的交互</h2><p><strong>中介者模式</strong>（Mediator Pattern）：用一个中介对象（中介者）来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</p><ul><li>中介模式可以将对象之间多对多的复杂关系就转化为相对简单的一对多关系</li><li>通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构</li><li>该模式将各对象之间的交互模式隐藏在中介者中，会使得中介者交互逻辑变得复杂</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230908202521445.png" alt="" style="zoom:50%;" /><p><strong>中介者模式结构图中包含以下4个角色</strong>：</p><ul><li>Mediator（抽象中介者）：定义一个接口用于与各同事对象之间进行通信。<ul><li>中介者中会存在一个集合用于存储所有同事对象，若要调用其他同事方法则先通过该集合获取对象再调用其方法</li></ul></li><li>ConcreteMediator（具体中介者）：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，维持了对各个同事对象的引用。</li><li>Colleague（抽象同事类）：它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时维持了一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信。</li><li>ConcreteColleague（具体同事类）：它是抽象同事类的子类。每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信。在具体同事类中实现了在抽象同事类中声明的抽象方法。</li></ul><p><strong>中介者类职责</strong>：</p><ul><li>中转作用（结构性）。通过中介者提供的中转作用，各个同事对象就不再需要显式地引用其他同事。当需要和其他同事进行通信时，可通过中介者来实现间接调用。该中转作用属于中介者在结构上的支持。</li><li>协调作用（行为性）。中介者可以更进一步地对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做。中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</li></ul><blockquote><p><strong>中介者模式总结</strong></p><ul><li>优点<ul><li>中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互。一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星形结构。</li><li>中介者模式可将各同事对象解耦。中介者有利于各同事之间的松耦合，可以独立地改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合开闭原则。</li><li>可以减少大量同事子类生成。中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需要生成新的中介者子类即可，这使得各个同事类可以被重用，无须对同事类进行扩展。</li></ul></li><li>缺点：在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护</li><li>适用场景<ul><li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li><li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类。</li></ul></li></ul></blockquote><h2 id="4-6-备忘录模式——撤销功能的实现"><a href="#4-6-备忘录模式——撤销功能的实现" class="headerlink" title="4.6 备忘录模式——撤销功能的实现"></a>4.6 备忘录模式——撤销功能的实现</h2><p><strong>备忘录模式</strong>（Memento Pattern）：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p><ul><li>用一个类保存状态，一个类用于状态的保存和获取，进行职责分离</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230908204822137.png" alt="" style="zoom:50%;" /><p><strong>备忘录模式结构图中包含以下3个角色</strong></p><ul><li>Originator（原发器）：它是一个普通类，可以创建一个备忘录，并存储其当前内部状态，也可以使用备忘录来恢复其内部状态。一般将需要保存内部状态的类设计为原发器。</li><li>Memento（备忘录）：存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用，且不允许其他对象来修改备忘录。</li><li>Caretaker（负责人）：负责人又称为管理者，他负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，他只负责存储对象，而不能修改对象，也无须知道对象的实现细节。</li></ul><p><strong>实现多次撤销</strong></p><ul><li>在负责人类中定义一个集合来存储多个备忘录。每个备忘录负责保存一个历史状态，在撤销时可以对备忘录集合进行逆向遍历，回到一个指定的历史状态，而且还可以对备忘录集合进行正向遍历，实现重做（Redo）或恢复操作，即取消撤销，让对象状态得到恢复。</li></ul><blockquote><p><strong>备忘录模式总结</strong></p><ul><li>优点<ul><li>提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤。当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。</li><li>备忘录实现了对信息的封装。一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。</li></ul></li><li>缺点：资源消耗过大。如果需要保存的原发器类的成员变量太多，就不可避免地需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。</li><li>适用场景<ul><li>保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时就能够恢复到先前的状态，实现撤销操作。</li><li>防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。</li></ul></li></ul></blockquote><h2 id="4-7-观察者模式——对象间的联动"><a href="#4-7-观察者模式——对象间的联动" class="headerlink" title="4.7 观察者模式——对象间的联动"></a>4.7 观察者模式——对象间的联动</h2><p><strong>观察者模式</strong>（Observer Pattern）：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。</p><ul><li>又称发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。</li><li>在被观察目标中存储所有观察对象，当时间发生则通知所有对象</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230909150522440.png" alt="" style="zoom:67%;" /><p><strong>观察者模式结构图中包含以下4个角色</strong>：</p><ul><li>Subject（目标）：又称为主题，指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时定义了通知方法notify（）。目标类可以是接口，也可以是抽象类或具体类。</li><li>ConcreteSubject（具体目标）：具体目标是目标类的子类，通常包含有经常发生改变的数据。当它的状态发生改变时，向其各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有）。如果无须扩展目标类，则具体目标类可以省略。</li><li>Observer（观察者）：观察者将对观察目标的改变做出反应。观察者一般定义为接口，该接口声明了更新数据的方法update（），因此又称为抽象观察者。</li><li>ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。<ul><li>它实现了在抽象观察者Observer中声明的update（）方法。通常在实现时，可以调用具体目标类的attach（）方法将自己添加到目标类的集合中或通过detach（）方法将自己从目标类的集合中删除。</li></ul></li></ul><blockquote><p>MVC也应用了观察者模式。</p><p>模型层提供的数据是视图层所观察的对象。如果模型层的数据发生改变，视图层发生相应改变。</p></blockquote><blockquote><p><strong>观察者模式总结</strong></p><ul><li>优点<ul><li>观察者模式可以实现表示层和数据逻辑层的分离。它定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。</li><li>观察者模式支持广播通信。观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。</li><li>观察者模式满足开闭原则的要求，增加新的具体观察者无须修改原有系统代码。在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。</li></ul></li><li>缺点<ul><li>如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul></li><li>适用场景<ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……可以使用观察者模式创建一种链式触发机制。</li></ul></li></ul></blockquote><h2 id="4-8-状态模式——对象状态及其转换"><a href="#4-8-状态模式——对象状态及其转换" class="headerlink" title="4.8 状态模式——对象状态及其转换"></a>4.8 状态模式——对象状态及其转换</h2><p><strong>状态模式</strong>（State Pattern）：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象（Objects for States），状态模式是一种对象行为型模式。</p><ul><li>用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。</li><li>状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230909151312839.png"></p><p><strong>状态模式结构图中包含以下3个角色</strong></p><ul><li>Context（环境类）：环境类又称为上下文类，它是拥有多种状态的对象。由于环境类的状态存在多样性且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类。在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象。</li><li>State（抽象状态类）：它用于定义一个接口以封装与环境类的一个特定状态相关的行为。在抽象状态类中声明各种不同状态对应的方法，而在其子类中实现这些方法。由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中。</li><li>ConcreteState（具体状态类）：它是抽象状态类的子类，每个子类实现一个与环境类的一个状态相关的行为。每个具体状态类对应环境类的一个具体状态，不同的具体状态类其行为有所不同。</li></ul><p>在状态模式的使用过程中，一个对象的状态之间还可以进行相互转换。<strong>通常有以下两种实现状态转换的方式</strong>：</p><ol><li>统一由环境类来负责状态之间的转换。此时，环境类还充当了状态管理器（State Manager）角色。在环境类的业务方法中通过对某些属性值的判断实现状态转换，还可以提供一个专门的方法用于实现属性判断和状态转换。</li><li>由具体状态类来负责状态之间的转换。可以在具体状态类的业务方法中判断环境类的某些属性值再根据情况为环境类设置新的状态对象，实现状态转换。同样，也可以提供一个专门的方法来负责属性值的判断和状态转换。此时，状态类与环境类之间将存在依赖或关联关系，因为状态类需要访问环境类中的属性值。</li></ol><p><strong>共享状态</strong>：如果希望在系统中实现多个环境对象共享一个或多个状态对象，那么需要将这些状态对象定义为环境类的静态成员对象。</p><blockquote><p><strong>状态模式总结</strong></p><ul><li>优点<ul><li>封装了状态的转换规则。在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，对状态转换代码进行集中管理，而不是分散在一个个业务方法中。</li><li>将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块。状态模式可以避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li></ul></li><li>缺点<ul><li>状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。</li><li>状态模式的程序结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。</li><li>状态模式对开闭原则的支持并不太好。增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li></ul></li><li>适用场景<ul><li>对象的行为依赖于它的状态（例如某些属性值），状态的改变将导致行为的变化。</li><li>在代码中包含大量与对象状态有关的条件语句。这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。</li></ul></li></ul></blockquote><h2 id="4-9-策略模式——算法的封装与切换"><a href="#4-9-策略模式——算法的封装与切换" class="headerlink" title="4.9 策略模式——算法的封装与切换"></a>4.9 策略模式——算法的封装与切换</h2><p><strong>策略模式</strong>（Strategy Pattern）：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。</p><ul><li>将算法的定义与使用分开，也就是将算法的行为和环境分开。将算法的定义放在专门的策略类中，每个策略类封装了一种实现算法。</li><li>使用算法的环境类针对抽象策略类进行编程，符合依赖倒转原则。在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230909152203473.png" alt="" style="zoom:50%;" /><p><strong>策略模式结构图中包含以下3个角色</strong></p><ul><li>Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。</li><li>Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类。它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。</li><li>ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法。在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。</li></ul><blockquote><p><strong>策略模式总结</strong></p><ul><li>优点</li><li><ul><li>提供了对开闭原则的完美支持。用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复代码。</li><li>策略模式提供了一种可以替换继承关系的办法。<ul><li>如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合单一职责原则。决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换。</li></ul></li><li>使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起</li><li>策略模式提供了一种算法的复用机制。由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。</li></ul></li><li>缺点<ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</li><li>策略模式将造成系统产生很多具体策略类。任何细小的变化都将导致系统要增加一个新的具体策略类。</li><li>无法同时在客户端使用多个策略类。也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。</li></ul></li><li>适用场景<ul><li>一个系统需要动态地在几种算法中选择一种。可以将这些算法封装到一个个的具体算法类中，而这些具体算法类都是一个抽象算法类的子类。</li><li>一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。</li><li>不希望客户端知道复杂的、与算法相关的数据结构。在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。</li></ul></li></ul></blockquote><h2 id="8-10-模板方法模式——定义算法的框架"><a href="#8-10-模板方法模式——定义算法的框架" class="headerlink" title="8.10 模板方法模式——定义算法的框架"></a>8.10 模板方法模式——定义算法的框架</h2><p><strong>模板方法模式</strong>（Template Method Pattern）：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法模式是一种类行为型模式。</p><ul><li>在抽象类中定义执行步骤，形成方法模板，而继承该类时可以重写小步骤的方法，但不能重写整体步骤逻辑。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230909152955434.png" alt="" style="zoom:67%;" /><p><strong>模板方法模式结构图中包含以下两个角色</strong></p><ul><li>AbstractClass（抽象类）：定义了一系列基本操作，这些基本操作可以是具体的，也可以是抽象的。每个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，实现了一个模板方法，用于定义一个算法的框架。模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。</li><li>ConcreteClass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。</li></ul><p><strong>模板方法</strong>：模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。不能修改。</p><p><strong>基本方法</strong>：</p><ul><li>抽象方法：一个抽象方法由抽象类声明，由其具体子类实现。</li><li>具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</li><li>钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现。相当于预留了一个判断接口。</li></ul><blockquote><p><strong>模板方法模式总结</strong></p><ul><li>优点<ul><li>模板方法模式在父类中形式化地定义一个算法，而由它的子类来实现细节的处理。在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。</li><li>模板方法模式是一种代码复用技术，它在类库设计中尤为重要。它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为。它鼓励恰当使用继承来实现代码复用。</li><li>模板方法模式可实现一种反向控制结构。通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。</li><li>在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。</li></ul></li><li>缺点：需要为每一个基本方法的不同实现提供一个子类。如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象。此时，可结合桥接模式来进行设计。</li><li>适用场景<ul><li>对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即一次性地实现一个算法的不变部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li></ul></li></ul></blockquote><h2 id="4-11-访问者模式——操作复杂对象结构"><a href="#4-11-访问者模式——操作复杂对象结构" class="headerlink" title="4.11 访问者模式——操作复杂对象结构"></a>4.11 访问者模式——操作复杂对象结构</h2><p><strong>访问者模式</strong>（Visitor Pattern）：提供一个作用于某对象结构中的各元素的操作表示，它使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。</p><ul><li>访问者模式包括两个层次结构：一个是访问者层次结构，提供了抽象访问者和具体访问者；另一个是元素层次结构，提供了抽象元素和具体元素。</li><li>相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同访问方式访问。在访问者模式中，增加新的访问者无须修改原有系统，系统具有较好的可扩展性。</li><li>抽象访问者为每一种类型的元素对象都提供一个访问方法，而具体访问者可以实现这些访问方法。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230909154540918.png" alt="" style="zoom:50%;" /><p><strong>访问者模式结构图中包含以下5个角色</strong></p><ul><li>Visitor（抽象访问者）：抽象访问者为对象结构中每个具体元素类ConcreteElement声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型。具体访问者需要实现这些操作方法，提供对这些元素的访问操作。</li><li>ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每个操作用于访问对象结构中一种类型的元素。</li><li>Element（抽象元素）：抽象元素一般是抽象类或者接口，它定义一个accept（）方法，该方法通常以一个抽象访问者作为参数。</li><li>ConcreteElement（具体元素）：具体元素实现了accept（）方法，在accept（）方法中调用访问者的访问方法以便完成对一个元素的操作。</li><li>ObjectStructure（对象结构）：对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，例如一个List对象或一个Set对象。</li></ul><blockquote><p><strong>访问者模式总结</strong></p><ul><li>优点<ul><li>增加新的访问操作很方便。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合开闭原则。</li><li>将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。</li><li>让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。</li></ul></li><li>缺点<ul><li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了开闭原则的要求。</li><li>破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问。</li></ul></li><li>适用场景<ul><li>一个对象结构包含多种类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而且需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。访问者模式将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离。</li><li>对象结构中元素对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</li></ul></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>440. 字典序的第K小数字</title>
      <link href="/2023/08/22/leetcode/other/leetcode-440-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97-difficult/"/>
      <url>/2023/08/22/leetcode/other/leetcode-440-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="440-字典序的第K小数字"><a href="#440-字典序的第K小数字" class="headerlink" title="440. 字典序的第K小数字"></a><a href="https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字</a></h1><p>FIrst：百度提前批面试遇到过类似的题，今天做pdd往年真题才发现这是一道经典笔试题。</p><hr><p><strong>方法1</strong>：<strong>字典序</strong></p><p>对于每个数，如果能计算出以其为前缀的数量count，那么就如果k大于count就说明答案不在当前数字为前缀的数中，如果小于等于则说明在当前前缀中，此时可以将k减一，并将p乘以10（因为后面数字后面添0是下一个数字），利用上述原理同样计算。</p><p>计算某前缀数量方法：假设前缀为pre，那么可以通过比较next&#x3D;pre+1为前缀来获得，通过在每一层加上next与pre之间差值即可，每往下一层，都将两者乘10</p><ul><li>时间复杂度：O(2logn)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    long long getCount(long long p,long long n)&#123;        long long next&#x3D;p+1,res&#x3D;0;        while(p&lt;&#x3D;n)&#123;            res+&#x3D;min(n+1,next)-p;            p*&#x3D;10;            next*&#x3D;10;        &#125;        return res;    &#125;public:    int findKthNumber(int n, int k) &#123;        long long  p&#x3D;1;        while(k&gt;1)&#123;            int count&#x3D;getCount(p,n);            if(count&lt;k)&#123;                k-&#x3D;count;                ++p;            &#125;else&#123;                --k;                p*&#x3D;10;            &#125;        &#125;        return p;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>深度搜索</strong></p><ul><li>时间复杂度：O(log^2^num)</li><li>空间复杂度：O(lognum)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-字典序 </tag>
            
            <tag> Alg-第k数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>668. 乘法表中第k小的数</title>
      <link href="/2023/08/22/leetcode/other/leetcode-668-%E4%B9%98%E6%B3%95%E8%A1%A8%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0-difficult/"/>
      <url>/2023/08/22/leetcode/other/leetcode-668-%E4%B9%98%E6%B3%95%E8%A1%A8%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="668-乘法表中第k小的数"><a href="#668-乘法表中第k小的数" class="headerlink" title="668. 乘法表中第k小的数"></a><a href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/">668. 乘法表中第k小的数</a></h1><p>FIrst：拼多多往年笔试题遇到类似的题，用优先队列通过部分用例</p><hr><p><strong>方法1</strong>：<strong>二分查找</strong></p><p>要知道一个数x为第几小的数，那么可以计算有多少个数比其小或等于，可以遍历每一行来计算比小于等于x的数，而计算第i行的个数可以通过x&#x2F;i 来快速获得。另外可以使用x&#x2F;n来计算完全一整行满足条件的行数，因此x&#x2F;n*n就是其个数。</p><ul><li>时间复杂度：O(2logn)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findKthNumber(int m, int n, int k) &#123;        long long left&#x3D;1,right&#x3D;m*n;        while(left&lt;right)&#123;            int mid&#x3D;left+(right-left)&#x2F;2;            int count&#x3D;mid&#x2F;n*n;            for(int i&#x3D;mid&#x2F;n+1;i&lt;&#x3D;m;++i)&#123;                count+&#x3D;min(mid&#x2F;i,n);            &#125;            if(count&gt;&#x3D;k)&#123;                right&#x3D;mid;            &#125;else&#123;                left&#x3D;mid+1;            &#125;        &#125;        return left;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-第k数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拼多多2020校招部分编程题合集</title>
      <link href="/2023/08/22/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E6%8B%BC%E5%A4%9A%E5%A4%9A2020%E6%A0%A1%E6%8B%9B%E9%83%A8%E5%88%86%E7%BC%96%E7%A8%8B%E9%A2%98%E5%90%88%E9%9B%86/"/>
      <url>/2023/08/22/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E6%8B%BC%E5%A4%9A%E5%A4%9A2020%E6%A0%A1%E6%8B%9B%E9%83%A8%E5%88%86%E7%BC%96%E7%A8%8B%E9%A2%98%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="拼多多2020校招部分编程题合集"><a href="#拼多多2020校招部分编程题合集" class="headerlink" title="拼多多2020校招部分编程题合集"></a><a href="https://www.nowcoder.com/exam/test/72490686/detail?pid=23354036&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=732&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">拼多多2020校招部分编程题合集</a></h1><p>1+0+0.3+1+0.8，第二题没看懂题意</p><hr><p><strong>1</strong>：<strong>多多的魔术盒子</strong></p><blockquote><p>多多鸡有N个魔术盒子（编号1～N），其中编号为i的盒子里有i个球。<br>多多鸡让皮皮虾每次选择一个数字X（1 &lt;&#x3D; X &lt;&#x3D; N），多多鸡就会把球数量大于等于X个的盒子里的球减少X个。<br>通过观察，皮皮虾已经掌握了其中的奥秘，并且发现只要通过一定的操作顺序，可以用最少的次数将所有盒子里的球变没。</p><p>那么请问聪明的你，是否已经知道了应该如何操作呢？</p></blockquote><p>每次取中间大小的数值进行减少即可，相当于求logn的值</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">deal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        n<span class="token operator">/=</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token operator">++</span>ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    cin<span class="token operator">>></span>T<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>T<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n<span class="token punctuation">;</span>        cin<span class="token operator">>></span>n<span class="token punctuation">;</span>        <span class="token function">deal</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>2</strong>：<strong>多多的排列函数</strong></p><blockquote><p>没看懂题意，解释如下：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230822163306906.png" alt="image-20230822163306906" style="zoom:50%;" /></blockquote><p>根据题意，只有当依次递减或递增时，结果才会最小，因此只有当n%4为1或2时，结果为1，其余为0</p><p>而求最大值可以看成是一直n-1个数的最小值，那么再添加一个n则为最大值。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">deal</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token operator">&amp;</span>dp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>dp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">4</span><span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">%</span><span class="token number">4</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">abs</span><span class="token punctuation">(</span>i<span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    cin<span class="token operator">>></span>T<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">deal</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>T<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n<span class="token punctuation">;</span>        cin<span class="token operator">>></span>n<span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>3</strong>：<strong>多多的电子字典</strong></p><blockquote><p>多多鸡打算造一本自己的电子字典，里面的所有单词都只由a和b组成。<br>每个单词的组成里a的数量不能超过N个且b的数量不能超过M个。<br>多多鸡的幸运数字是K，它打算把所有满足条件的单词里的字典序第K小的单词找出来，作为字典的封面。</p></blockquote><p>最开始自己做的时候使用的深搜来做，但效率较低。</p><p>此题是一个字典序问题，有点类似leetcode440；</p><p>使用二维数组dp[i] [j]表示i个a和j个b能表示多少个单词数。需要注意dp为 unsigned long long，否则超出范围。</p><p>由于一个位置要么为a要么为b，那么当i个a字符和j个b字符时，如果固定首位为a，那么有dp[i-1] [j]种，固定b则有dp[i] [j-1]种，因此dp[i] [j] &#x3D;dp[i-1] [j] +dp [i] [j-1]+2;</p><p>和lc440思想类似，如果dp[n-1] [m]+1大于等于k，那么说明首位为a，–k, –n; 否则首位为b, k-&#x3D;dp[n-1] [m] +2（多了一个1是因为本身占1），不断类似操作得到最终答案</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>string path<span class="token punctuation">,</span>ans<span class="token punctuation">;</span><span class="token keyword">bool</span> success<span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span><span class="token comment">// void DFS(long long k,long long n,long long m)&#123;</span>    <span class="token comment">//     if(success) return;</span><span class="token comment">//     if(k==count)&#123;</span><span class="token comment">//         ans=path;</span><span class="token comment">//         success=true;</span><span class="token comment">//         return;</span><span class="token comment">//     &#125;</span><span class="token comment">//     for(int i=0;i&lt;=1;++i)&#123;</span><span class="token comment">//         if(i==0&amp;&amp;n==0) continue;</span><span class="token comment">//         if(i==1&amp;&amp;m==0) continue;</span><span class="token comment">//         path+='a'+i;</span><span class="token comment">//         ++count;</span><span class="token comment">//         // cout&lt;&lt;path&lt;&lt;" "&lt;&lt;count&lt;&lt;" "&lt;&lt;n&lt;&lt;" "&lt;&lt;m&lt;&lt;endl;</span><span class="token comment">//         DFS(k,n-(i==0),m-(i==1));</span><span class="token comment">//         path.pop_back();</span><span class="token comment">//     &#125;</span><span class="token comment">// &#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n <span class="token operator">>></span> m <span class="token operator">>></span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        <span class="token comment">// path="";</span>        <span class="token comment">// ans="";</span>        <span class="token comment">// success=false;</span>        <span class="token comment">// DFS(k,n,m);</span>        <span class="token comment">// cout&lt;&lt;ans&lt;&lt;endl;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>j<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        string ans<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">>=</span>k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    ans<span class="token operator">+=</span><span class="token char">'a'</span><span class="token punctuation">;</span>                    <span class="token operator">--</span>k<span class="token punctuation">;</span>                    <span class="token operator">--</span>n<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    ans<span class="token operator">+=</span><span class="token char">'b'</span><span class="token punctuation">;</span>                    k<span class="token operator">-=</span>dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>                    <span class="token operator">--</span>m<span class="token punctuation">;</span>                                    <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans<span class="token operator">+=</span><span class="token char">'b'</span><span class="token punctuation">;</span>                <span class="token operator">--</span>k<span class="token punctuation">;</span>                <span class="token operator">--</span>m<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>m<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans<span class="token operator">+=</span><span class="token char">'a'</span><span class="token punctuation">;</span>                <span class="token operator">--</span>k<span class="token punctuation">;</span>                <span class="token operator">--</span>n<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>4</strong>：<strong>骰子期望</strong></p><blockquote><pre class="line-numbers language-none"><code class="language-none">扔n个骰子，第i个骰子有可能投掷出Xi种等概率的不同的结果，数字从1到Xi。所有骰子的结果的最大值将作为最终结果。求最终结果的期望<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>求每个数字能出现的次数，例如数字5能出现的次数等于所有骰子min(5, nums[i])的乘积减去所有1、2、3、4出现的次数。然后求概率即可。注意，使用printf会出现内存溢出等问题，使用的c++限制小数位数进行输出。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iomanip></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxN<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cin<span class="token operator">>></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            maxN<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>maxN<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">double</span><span class="token operator">></span> <span class="token function">counts</span><span class="token punctuation">(</span>maxN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">double</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>maxN<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">long</span> <span class="token keyword">double</span> cur<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                cur<span class="token operator">*=</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            cur<span class="token operator">-=</span>sum<span class="token punctuation">;</span>            counts<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>cur<span class="token punctuation">;</span>            sum<span class="token operator">+=</span>cur<span class="token punctuation">;</span>            <span class="token comment">// cout&lt;&lt;cur&lt;&lt;endl;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">long</span> <span class="token keyword">double</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>maxN<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token operator">+=</span>i<span class="token operator">*</span><span class="token punctuation">(</span>counts<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">/</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token function">setiosflags</span><span class="token punctuation">(</span>ios<span class="token double-colon punctuation">::</span>fixed<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token function">setprecision</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token comment">// printf("%.2lf\n",ans);</span>        <span class="token comment">// cout&lt;&lt;ans&lt;&lt;endl;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>5</strong>：<strong>二维表第k大数</strong></p><blockquote><p>在一块长为n，宽为m的场地上，有n✖️m个1✖️1的单元格。每个单元格上的数字就是按照从1到n和1到m中的数的乘积。给出一个查询的值k，求出按照这个方式列举的的数中第k大的值v。</p></blockquote><p>开始使用的优先队列来求，但内存爆了。</p><p>和leetcode668类似，只是一个求第k大，一个求第k小，可以转换为求第n*m-k+1小的数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n <span class="token operator">>></span> m <span class="token operator">>></span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        <span class="token comment">//优先队列</span>        <span class="token comment">// if(n>m) swap(n,m);</span>        <span class="token comment">// priority_queue&lt;long long,vector&lt;long long>,greater&lt;long long>> que;</span>        <span class="token comment">// int len=sqrt(4*k)+1;</span>        <span class="token comment">// int ie=max(m-len,0);</span>        <span class="token comment">// int je=max(n-len,0);</span>        <span class="token comment">// for(int i=m;i>=ie;--i)&#123;</span>        <span class="token comment">//     for(int j=n;j>=je;--j)&#123;</span>        <span class="token comment">//         que.push((long long)i*j);</span>        <span class="token comment">//         if(que.size()>k) que.pop();</span>        <span class="token comment">//     &#125;</span>        <span class="token comment">// &#125;</span>        <span class="token comment">// cout&lt;&lt;que.top()&lt;&lt;endl;</span>        <span class="token comment">//lc668</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> left<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>n<span class="token operator">*</span>m<span class="token punctuation">;</span>        k<span class="token operator">=</span>right<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> count<span class="token operator">=</span>mid<span class="token operator">/</span>n<span class="token operator">*</span>n<span class="token punctuation">;</span><span class="token comment">// mid/n表示都小于等于mid的行数量，再乘以n表示总个数</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>mid<span class="token operator">/</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                count<span class="token operator">+=</span><span class="token function">min</span><span class="token punctuation">(</span>mid<span class="token operator">/</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">>=</span>k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                right<span class="token operator">=</span>mid<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span>left<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试真题 </tag>
            
            <tag> 拼多多 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯2020校园招聘-后台</title>
      <link href="/2023/08/18/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E8%85%BE%E8%AE%AF2020%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98-%E5%90%8E%E5%8F%B0/"/>
      <url>/2023/08/18/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E8%85%BE%E8%AE%AF2020%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98-%E5%90%8E%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="腾讯2020校园招聘-后台"><a href="#腾讯2020校园招聘-后台" class="headerlink" title="腾讯2020校园招聘-后台"></a><a href="https://www.nowcoder.com/exam/test/72289058/detail?pid=21283868&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=138&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">腾讯2020校园招聘-后台</a></h1><p>过了2道题，挺难</p><hr><p><strong>1</strong>：<strong>压缩算法</strong></p><blockquote><p>小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字符串中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为<a href="m%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%941%3C=m%3C=100">m|S</a>，例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符串，你能帮助他进行解压缩么？ </p></blockquote><p>不断压入栈，需要注意细节即可。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">/**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param str string字符串      * @return string字符串     */</span>    string <span class="token function">compress</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// write code here</span>        string ans<span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st1<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st2<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'['</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token operator">++</span>i<span class="token punctuation">;</span>                <span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token char">'|'</span><span class="token punctuation">)</span> <span class="token operator">++</span>j<span class="token punctuation">;</span>                st1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">=</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                                st2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token char">'['</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">']'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                string tmp<span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>st2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token char">'['</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    tmp<span class="token operator">+=</span>st2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    st2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                st2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">reverse</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>tmp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> num<span class="token operator">=</span>st1<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>num<span class="token punctuation">;</span><span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>tmp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        st2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                                    <span class="token punctuation">&#125;</span>                <span class="token operator">++</span>i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                st2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                  <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token operator">+=</span>st2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ans<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>2</strong>：<strong>逛街</strong></p><blockquote><p>小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。</p><p>小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住）</p></blockquote><p>使用两个单调递减栈分别从左边和右边进行遍历，不断弹出比当前元素小的栈中元素（因为会被遮挡），栈中的元素个数就是所能看到的楼数。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">/**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param heights int整型vector      * @return int整型vector     */</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findBuilding</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> heights<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// write code here</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> left<span class="token punctuation">,</span>right<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ans</span><span class="token punctuation">(</span>heights<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>heights<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span><span class="token operator">+</span>left<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>left<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>left<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                left<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            left<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>heights<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>right<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>right<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>heights<span class="token punctuation">[</span>right<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                right<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            right<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>3</strong>：<strong>逆序对</strong></p><blockquote><p>作为程序员的小Q，他的数列和其他人的不太一样，他有2^n2<em>n</em>个数。</p><p>老板问了小Q一共 m次，每次给出一个整数q_i (1 &lt;&#x3D; i &lt;&#x3D; m)<em>q**i</em>(1&lt;&#x3D;<em>i</em>&lt;&#x3D;<em>m</em>), 要求小Q把这些数每2^{q_i}2<em>q**i</em>分为一组，然后把每组进行翻转，小Q想知道每次操作后整个序列中的逆序对个数是多少呢？</p></blockquote><p><a href="https://blog.csdn.net/qq_43517189/article/details/105313349">参考</a></p><p>可以使用归并排序找到所有的逆序对，其时间复杂度为nlogn，但仍会超时，利用归并招逆序对个数<a href="https://www.nowcoder.com/questionTerminal/96bd6684e04a44eb80e6a68efc0ec6c5">见此</a>。可以注意到每次翻转只会造成归并时每一层的逆序对数和顺序对数对调，因此记录归并时每一层的逆序对和顺序对个数。代码改了很久还是不能全过。。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stack></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> s1<span class="token punctuation">,</span> <span class="token keyword">int</span> e1<span class="token punctuation">,</span> <span class="token keyword">int</span> s2<span class="token punctuation">,</span> <span class="token keyword">int</span> e2<span class="token punctuation">,</span>           vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span><span class="token operator">&amp;</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// cout&lt;&lt;s1&lt;&lt;" "&lt;&lt;e1&lt;&lt;" "&lt;&lt;s2&lt;&lt;' '&lt;&lt;e2&lt;&lt;endl;      </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e2 <span class="token operator">-</span> s1 <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> s1<span class="token punctuation">,</span> e <span class="token operator">=</span> e2<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">tmp</span><span class="token punctuation">(</span>e2 <span class="token operator">-</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> neg <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> posi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>s1 <span class="token operator">&lt;=</span> e1 <span class="token operator">&amp;&amp;</span> s2 <span class="token operator">&lt;=</span> e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>s1<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            neg <span class="token operator">+=</span> e1 <span class="token operator">-</span> s1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            tmp<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>s2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            posi <span class="token operator">+=</span> e2 <span class="token operator">-</span> s2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            tmp<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>s1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    count<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> neg<span class="token punctuation">;</span>    count<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> posi<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>s1 <span class="token operator">&lt;=</span> e1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tmp<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>s1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>s2 <span class="token operator">&lt;=</span> e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tmp<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>s2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> e<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">>></span> layers<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">calLayerCount</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span> count<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">+=</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token operator">+</span> len<span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                  count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        layers<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        n <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cin <span class="token operator">>></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> m<span class="token punctuation">;</span>        cin <span class="token operator">>></span> m<span class="token punctuation">;</span>        <span class="token keyword">int</span> ques<span class="token punctuation">;</span>        <span class="token function">calLayerCount</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cin <span class="token operator">>></span> ques<span class="token punctuation">;</span>            <span class="token keyword">long</span> <span class="token keyword">long</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ques<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>layers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> layers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> layers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ans <span class="token operator">+=</span> layers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>4</strong>：<strong>假期</strong></p><blockquote><p>由于业绩优秀，公司给小Q放了 n 天的假，身为工作狂的小Q打算在在假期中工作、锻炼或者休息。他有个奇怪的习惯：不会连续两天工作或锻炼。只有当公司营业时，小Q才能去工作，只有当健身房营业时，小Q才能去健身，小Q一天只能干一件事。给出假期中公司，健身房的营业情况，求小Q最少需要休息几天。</p></blockquote><p>动态规划。</p><p>使用dp[i] [0] 记录第i天去工作最大的不休息天数，dp[i] [1]表示第i天去锻炼最大的不休息次数。</p><p>如果第i-1天不营业，那么第i天能否工作就与前一天 无关，即d[i] [0]&#x3D;dp[i-1] [0] +nums1[i]。如果前一天营业，那么就等于前一天。最后，应与dp[i-1] [1] +nums1[i]比较，取最大值。 dp[i] [1]同理。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nums1</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">nums2</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cin <span class="token operator">>></span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cin <span class="token operator">>></span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//或者简化</span>            <span class="token comment">// dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + nums1[i]);</span>            <span class="token comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + nums2[i]);</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">-</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>5</strong>：<strong>视野争夺</strong></p><blockquote><p>小Q在进行一场竞技游戏,这场游戏的胜负关键就在于能否能争夺一条长度为L的河道,即可以看作是[0,L]的一条数轴。</p><p>这款竞技游戏当中有n个可以提供视野的道具−真视守卫,第i个真视守卫能够覆盖区间[xi,yi]。现在小Q想知道至少用几个真视守卫就可以覆盖整段河道。 </p></blockquote><p>贪心。</p><p>先排序，不断找以当前区间为起点，所能到达的最大范围。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>l<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n <span class="token operator">>></span> l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span> cin<span class="token operator">>></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">||</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// for(auto tmp:nums) cout&lt;&lt;tmp[0]&lt;&lt;" "&lt;&lt;tmp[1]&lt;&lt;endl;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>curRight<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>curLeft<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> lastRight<span class="token operator">=</span>curRight<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>lastRight<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                curRight<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>curRight<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token operator">++</span>ans<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curRight<span class="token operator">>=</span>l<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试真题 </tag>
            
            <tag> 腾讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL练习笔记</title>
      <link href="/2023/08/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/SQL%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/SQL%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="合并两个表"><a href="#合并两个表" class="headerlink" title="合并两个表"></a>合并两个表</h3><p>按不同要求分别查询，将分别查询结果进行合并，如果去重使用union，如果不去重使用union all</p><p>例如<a href="https://www.nowcoder.com/practice/979b1a5a16d44afaba5191b22152f64a?tpId=199&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/oj?page=1&tab=SQL%25E7%25AF%2587&topicId=199">SQL25 查找山东大学或者性别为男生的信息</a></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span>    device_id<span class="token punctuation">,</span>    gender<span class="token punctuation">,</span>    age<span class="token punctuation">,</span>    gpa<span class="token keyword">from</span>    user_profile<span class="token keyword">where</span>    university <span class="token operator">=</span> <span class="token string">'山东大学'</span><span class="token keyword">union</span> <span class="token keyword">all</span><span class="token keyword">select</span>    device_id<span class="token punctuation">,</span>    gender<span class="token punctuation">,</span>    age<span class="token punctuation">,</span>    gpa<span class="token keyword">from</span>    user_profile<span class="token keyword">where</span>    gender <span class="token operator">=</span> <span class="token string">'male'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CASE函数"><a href="#CASE函数" class="headerlink" title="CASE函数"></a>CASE函数</h3><p>分为：简单CASE函数和搜索CASE函数</p><p>例题<a href="https://www.nowcoder.com/practice/30f9f470390a4a8a8dd3b8e1f8c7a9fa?tpId=199&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/oj?page=1&tab=SQL%25E7%25AF%2587&topicId=199"><strong>SQL26</strong> <strong>计算25岁以上和以下的用户数量</strong></a></p><p><strong>简单 CASE函数</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CASE</span> 测试表达式<span class="token keyword">WHEN</span> 简单表达式<span class="token number">1</span> <span class="token keyword">THEN</span> 结果表达式<span class="token number">1</span><span class="token keyword">WHEN</span> 简单表达式<span class="token number">2</span> <span class="token keyword">THEN</span> 结果表达式<span class="token number">2</span> …<span class="token keyword">WHEN</span> 简单表达式n <span class="token keyword">THEN</span> 结果表达式n<span class="token punctuation">[</span> <span class="token keyword">ELSE</span> 结果表达式n<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">]</span><span class="token keyword">END</span>例如<span class="token keyword">SELECT</span> 班号 <span class="token punctuation">,</span>班名<span class="token punctuation">,</span><span class="token keyword">CASE</span> 系号<span class="token keyword">WHEN</span> <span class="token number">1</span> <span class="token keyword">THEN</span> <span class="token string">'软件工程系'</span><span class="token keyword">WHEN</span> <span class="token number">2</span> <span class="token keyword">THEN</span> <span class="token string">'计算机系'</span><span class="token keyword">WHEN</span> <span class="token number">3</span> <span class="token keyword">THEN</span> <span class="token string">'物联网系'</span><span class="token keyword">END</span> <span class="token keyword">AS</span> 系号<span class="token punctuation">,</span>班主任号<span class="token keyword">FROM</span> 班级表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>搜索CASE函数</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CASE</span><span class="token keyword">WHEN</span> 布尔表达式<span class="token number">1</span> <span class="token keyword">THEN</span> 结果表达式<span class="token number">1</span><span class="token keyword">WHEN</span> 布尔表达式<span class="token number">2</span> <span class="token keyword">THEN</span> 结果表达式<span class="token number">2</span> …<span class="token keyword">WHEN</span> 布尔表达式n <span class="token keyword">THEN</span> 结果表达式n<span class="token punctuation">[</span> <span class="token keyword">ELSE</span> 结果表达式n<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">]</span><span class="token keyword">END</span>例如<span class="token keyword">SELECT</span> 班号 <span class="token punctuation">,</span>班名<span class="token punctuation">,</span><span class="token keyword">CASE</span><span class="token keyword">WHEN</span> 系号<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">THEN</span> <span class="token string">'软件工程系'</span><span class="token keyword">WHEN</span> 系号<span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">THEN</span> <span class="token string">'计算机系'</span><span class="token keyword">WHEN</span> 系号<span class="token operator">=</span><span class="token number">3</span> <span class="token keyword">THEN</span> <span class="token string">'物联网系'</span><span class="token keyword">END</span> <span class="token keyword">AS</span> 系号<span class="token punctuation">,</span>班主任号<span class="token keyword">FROM</span> 班级表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>**DAYOFWEEK(date)**：返回日期date的星期索引(1&#x3D;星期天，2&#x3D;星期一, ……7&#x3D;星期六)</p><p>DAYOFMONTH(date)：返回date的月份中日期，在1到31范围内。</p><p>DAYOFYEAR(date)：返回date在一年中的日数, 在1到366范围内。</p><p>**MONTH(date)**：返回date的月份，范围1到12</p><p>DAYNAME(date)：返回date的星期名字。</p><p>MONTHNAME(date)：返回date的月份名字。</p><p>QUARTER(date)：返回date一年中的季度，范围1到4。</p><p>**YEAR(date)**：返回date的年份，范围在1000到9999。</p><p>**DAY(date)**：返回date的日，范围在1到31。</p><p>[例题](**SQL28** **计算用户8月每天的练题数量**)</p><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#切割</span>substring_index<span class="token punctuation">(</span>列名<span class="token punctuation">,</span> <span class="token string">'切割标志'</span><span class="token punctuation">,</span> 位置数（负号：从后面开始）<span class="token punctuation">)</span>substring_index<span class="token punctuation">(</span>blog_url<span class="token punctuation">,</span><span class="token string">'/'</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">as</span> user_name <span class="token comment">#注意可以嵌套使用来多次切割</span><span class="token comment">#删除</span>trim<span class="token punctuation">(</span><span class="token string">'被删除字符串'</span> <span class="token keyword">from</span> 列名<span class="token punctuation">)</span>trim<span class="token punctuation">(</span><span class="token string">'http:/url/'</span> <span class="token keyword">from</span> blog_url<span class="token punctuation">)</span> <span class="token keyword">as</span> user_name<span class="token comment">#截取</span>substr<span class="token punctuation">(</span>列名<span class="token punctuation">,</span> start_point<span class="token punctuation">,</span> length<span class="token operator">*</span>可选参数<span class="token operator">*</span><span class="token punctuation">)</span>substr<span class="token punctuation">(</span>blog_url<span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span>length<span class="token punctuation">(</span>blog_url<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">as</span> user_nam<span class="token comment">#替换</span><span class="token keyword">replace</span><span class="token punctuation">(</span>string<span class="token punctuation">,</span> <span class="token string">'被替换部分'</span><span class="token punctuation">,</span><span class="token string">'替换后的结果'</span><span class="token punctuation">)</span><span class="token keyword">replace</span><span class="token punctuation">(</span>blog_url<span class="token punctuation">,</span><span class="token string">'http:/url/'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token keyword">as</span> user_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快手2019年秋季校园招聘笔试试题--工程A试卷</title>
      <link href="/2023/08/10/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E5%BF%AB%E6%89%8B2019%E5%B9%B4%E6%98%A5%E5%AD%A3%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E8%AF%95%E9%A2%98--%E5%B7%A5%E7%A8%8BA%E8%AF%95%E5%8D%B7/"/>
      <url>/2023/08/10/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E5%BF%AB%E6%89%8B2019%E5%B9%B4%E6%98%A5%E5%AD%A3%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E8%AF%95%E9%A2%98--%E5%B7%A5%E7%A8%8BA%E8%AF%95%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="快手2019年秋季校园招聘笔试试题–工程A试卷"><a href="#快手2019年秋季校园招聘笔试试题–工程A试卷" class="headerlink" title="快手2019年秋季校园招聘笔试试题–工程A试卷"></a><a href="https://www.nowcoder.com/exam/test/72009173/detail?pid=13547115&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=1&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">快手2019年秋季校园招聘笔试试题–工程A试卷</a></h1><p>算法题挺难的，只过了一道。。学到了最大m子段和类型的动态规划解法</p><hr><p><strong>1</strong>：<strong>a&#x2F;b</strong></p><blockquote><p>求 a&#x2F;b 的小数表现形式。如果 a 可以整除 b 则不需要小数点。如果是有限小数，则可以直接输出。如果是无限循环小数，则需要把小数循环的部分用”()”括起来。</p></blockquote><p>做的时候不知道如何快速判断循环，如果将出现的所有数都放入map中，那么即使再次出现相同数，但也不一定循环，且效率很低。看了一个解析才知道使用余数判断是否循环，余数再次出现则一定循环。</p><p>先输出a&#x2F;b，令余数cur&#x3D;a%b，如果cur等于0，则结束。否则不断循环求解小数点后的数，且将cur插入到map中，如果cur重复出现，则说明出现了循环。注意map中记录的是cur和其出现的位置，因为括号只包括循环部分。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">%</span> b <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token char">'.'</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> cur <span class="token operator">=</span> a <span class="token operator">%</span> b<span class="token punctuation">;</span>            string ans<span class="token punctuation">;</span>            <span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> appear<span class="token punctuation">;</span>            appear<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                cur <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>                ans <span class="token operator">+=</span> <span class="token char">'0'</span> <span class="token operator">+</span> cur <span class="token operator">/</span> b<span class="token punctuation">;</span>                cur <span class="token operator">%=</span> b<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>appear<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    flag<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> pos<span class="token operator">=</span>appear<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span>                    cout<span class="token operator">&lt;&lt;</span>ans<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>pos<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token char">'('</span><span class="token operator">&lt;&lt;</span>ans<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>pos<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token char">')'</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                appear<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">=</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>2</strong>：<strong>善变的同伴</strong></p><blockquote><p>又到了吃午饭的时间，你和你的同伴刚刚研发出了最新的GSS-483型自动打饭机器人，现在你们正在对机器人进行功能测试。</p><p>为了简化问题，我们假设午饭一共有N个菜，对于第i个菜，你和你的同伴对其定义了一个好吃程度（或难吃程度，如果是负数的话……）A[i]，</p><p>由于一些技（经）术（费）限制，机器人一次只能接受一个指令：两个数L, R——表示机器人将会去打第L~R一共R-L+1个菜。</p><p>本着不浪费的原则，你们决定机器人打上来的菜，含着泪也要都吃完，于是你们希望机器人打的菜的好吃程度之和最大</p><p>然而，你善变的同伴希望对机器人进行多次测试（实际上可能是为了多吃到好吃的菜），他想知道机器人打M次菜能达到的最大的好吃程度之和</p><p>当然，打过一次的菜是不能再打的，而且你也可以对机器人输入-1, -1，表示一个菜也不打</p></blockquote><p>开始想的是用贪心，不断求当前最大的子段，但会有个问题是：一个字段可以拆分出多个子段使得其和更大，因此决定应该用动态规划来做，但还是没想到咋做。</p><p>这题可以简化为寻找最大m子段和，可<a href="https://blog.csdn.net/winter2121/article/details/72848482">参考</a></p><p>使用二维数组记录状态，dp[i] [j]表示前 j 项所构成 i 子段的最大和，且必须包含着第j项，即以第j项结尾</p><p>dp[i] [j]递推有两种状态：</p><ul><li>dp[ i ] [ j ] &#x3D; dp[ i ] [ j-1 ] + a[ j ] ，即把第j项融合到第 j-1 项的子段中，子段数没变</li><li>dp[ i ] [ j ] &#x3D; dp[ i-1 ] [ t ] + a[ j ]，（i-1&lt;&#x3D; t &lt; j ），把第 j 项作为单独的一个子段，然后找一下i-1个子段时，最大的和，然后加上a[ j ]</li></ul><p>因此dp[i] [j]&#x3D;max(dp[ i ] [ j-1 ], dp[ i-1 ] [ t ] )，可以使用一个变量在内层循环中记录当前最大的t，以减少一个遍历。由于可以不选，因此皆初始化为0（如果必须要选，则除第0行外，其余皆初始化为负无穷）</p><p>由递推公式知从左到右，从上到下遍历。</p><p>由于可以少选或不选，因此使用一个ans最大值。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">deal</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>nums<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> pre<span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>pre<span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pre<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// for(int t=i-1;t&lt;j;++t)&#123;</span>            <span class="token comment">//     dp[i][j]=max(dp[i][j],dp[i-1][t]+nums[j-1]);</span>            <span class="token comment">// &#125;</span>            ans<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cin<span class="token operator">>></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token function">deal</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>n<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>3</strong>：<strong>最小代价爬楼梯</strong></p><blockquote><p>你需要爬上一个 n 层的楼梯，在爬楼梯过程中， 每阶楼梯需花费非负代价，第i阶楼梯花费代价表示为 cost[i] ， 一旦你付出了代价，你可以在该阶基础上往上爬一阶或两阶。</p><p>你可以从第 0 阶或者 第 1 阶开始，请找到到达顶层的最小的代价是多少。</p><p>n 和 cost[i] 皆为整数</p></blockquote><p>打卡题，使用动态规划即可。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">deal</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string str<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">','</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token operator">++</span>j<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">deal</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试真题 </tag>
            
            <tag> 快手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度2020校招C++PHP研发工程师笔试卷第三批</title>
      <link href="/2023/08/10/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E7%99%BE%E5%BA%A62020%E6%A0%A1%E6%8B%9BC++PHP%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E5%8D%B7%E7%AC%AC%E4%B8%89%E6%89%B9/"/>
      <url>/2023/08/10/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E7%99%BE%E5%BA%A62020%E6%A0%A1%E6%8B%9BC++PHP%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E5%8D%B7%E7%AC%AC%E4%B8%89%E6%89%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="百度2020校招C-PHP研发工程师笔试卷第三批"><a href="#百度2020校招C-PHP研发工程师笔试卷第三批" class="headerlink" title="百度2020校招C++PHP研发工程师笔试卷第三批"></a><a href="https://www.nowcoder.com/exam/test/71942646/detail?pid=30544864&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=139&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">百度2020校招C++PHP研发工程师笔试卷第三批</a></h1><p>比较难，就过了一道，第三道题没看懂，不知道那个最小距离的最大值啥意思，看不懂示例咋求出来的，解析也没有清楚地。</p><hr><p><strong>1</strong>：<strong>最小公倍数与最大公约数</strong></p><blockquote><p>度度熊请你找出两个数\mathit a,b<em>a</em>,<em>b</em>，满足1 \leq a,b \leq n1≤<em>a</em>,<em>b</em>≤<em>n</em>且\mathit lcm(a,b)-gcd(a,b)<em>l<strong>c</strong>m</em>(<em>a</em>,<em>b</em>)−<em>g<strong>c</strong>d</em>(<em>a</em>,<em>b</em>)尽量大。输出最大的\mathit lcm(a,b)-gcd(a,b)<em>l<strong>c</strong>m</em>(<em>a</em>,<em>b</em>)−<em>g<strong>c</strong>d</em>(<em>a</em>,<em>b</em>).<br>其中\mathit lcm(a,b)<em>l<strong>c</strong>m</em>(<em>a</em>,<em>b</em>)表示\mathit a<em>a</em>和\mathit b<em>b</em>的最小公倍数，\mathit gcd(a,b)<em>g<strong>c</strong>d</em>(<em>a</em>,<em>b</em>)表示\mathit a<em>a</em>和\mathit b<em>b</em>的最大公约数。</p></blockquote><p>开始使用的暴力法，不出所料过不了。后来发现只要两个值只差一那么其最大公约数便是1，而最小公倍数&#x3D;a*b&#x2F;最大公约数，因此相差为1的两个值才能产生更大的结果。其实可以直接输出n * (n-1)-1</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;climits></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">deal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> ans<span class="token operator">=</span>LONG_LONG_MIN<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// long long t=gcd(i,i-1);</span>        <span class="token comment">// ans=max(ans,i*(i-1)/t-t);</span>        ans<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        <span class="token function">deal</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>2</strong>：<strong>石子游戏</strong></p><blockquote><p>今天，度度熊和牛妹在玩取石子的游戏，开始的时候有\mathit n<em>n</em>堆石头，第\mathit i<em>i</em>堆有{a_i}<em>a**i</em>个石头，两个人轮流动作，度度熊先走，在每个回合，玩家选择一个非空堆，并从堆中移除一块石头。如果一个玩家在轮到他之前所有的石碓都是空的，或者如果在移动石头之后，存在两个堆包含相同数量的石头（可能为都为\text 00），那么他就会输。假设两人都在游戏时选择最佳方式，度度熊和牛妹谁会赢？如果度度熊获胜，输出“man”，如果牛妹获胜，输出“woman”（输出不包含双引号）。</p></blockquote><p>不擅长做这种题目，总结不出来规律。</p><p>参考的一个解析如下：首先把先手必败的情况给判掉：0的数目大于等于2时，相同数字对数大于1，出现了x,x+1,x+1这种情况，总和为0，这几种情况先手必败。其他情况，可以想到游戏结束的上一个状态一定是0, 1, 2, 3…n - 1这种，谁到了这个状态谁必败，而且因为判掉了先手必败的几个情况（保证了相同数字不大于2且总和不为0），所以一定能出现这种状态。那么只要将数目总和减去最后形成的这个等差数列，就可以知道谁可以领到这个等差数列状态，就可以知道谁必胜了</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    cin<span class="token operator">>></span>T<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>T<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n<span class="token punctuation">;</span>        cin<span class="token operator">>></span>n<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>zeros<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> mmap<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cin<span class="token operator">>></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> zeros<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//计算0的个数</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mmap<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//计算相同值的对数</span>            <span class="token operator">++</span>mmap<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            sum<span class="token operator">+=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//先手必输</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">3</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">==</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"woman"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//先手必输</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>cnt<span class="token operator">></span><span class="token number">1</span><span class="token operator">||</span>zeros<span class="token operator">>=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"woman"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//输的上一个状态必为等差为1的等差数列，因此计算减去等差数列的和</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum<span class="token operator">+=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"woman"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"man"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>3</strong>：<strong>穿越银河</strong></p><blockquote><p>在浩瀚深邃的星空中，有若干个可以被视为质点的星球，以及坐着飞船想要探索宇宙奥秘的度度熊。</p><p>我们假定银河是一个n \times m<em>n</em>×<em>m</em>的区域，顶点在\text (0,0)(0,0)和(\mathit n,m)(<em>n</em>,<em>m</em>)，度度熊从最左边任意一点进入，打算穿越这片区域并从右边任意一点离开。</p><p>在银河中分布着\mathit k<em>k</em>个星球，每个星球以及银河的上下两个边缘都有引力，处于安全考虑，度度熊要离他们越远越好。<br>试求度度熊穿越银河的路径上，距离所有星球以及上下边界的最小距离的最大值可以为多少？</p></blockquote><p>题没看懂，解析也无，实例也不知道咋求出来的。。。。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试真题 </tag>
            
            <tag> 百度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大m子段和问题</title>
      <link href="/2023/08/10/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E5%A4%A7m%E5%AD%90%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/10/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E5%A4%A7m%E5%AD%90%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="最大m子段和问题"><a href="#最大m子段和问题" class="headerlink" title="最大m子段和问题"></a><a href="https://www.nowcoder.com/exam/test/72009173/detail?pid=13547115&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=1&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">最大m子段和问题</a></h1><p>做快手2019年秋季A题时，才发现没做过这类问题，记录下。</p><p><a href="https://blog.csdn.net/winter2121/article/details/72848482">参考</a></p><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>给定由n个整数（可能为负）组成的序列a1、a2、a3…,an,  以及一个正整数m，要求确定序列的m个不相交子段，使这m个子段的总和最大！</p><p>特别注意：有些题目可能不存在负数答案，给出的序列全是负数，那么不管m是多少，答案是0。此时选择的子段是0个，不足m个，但符合题意。。。也可能有些题目要求，必须选够m个子段。区别在dp数组的初始化。前者要求dp初始为0，后者要求第0行为0，其余为负无穷</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>动态规划</strong></p><p>使用二维数组记录状态，dp[i] [j]表示前 j 项所构成 i 子段的最大和，且必须包含着第j项，即以第j项结尾</p><p>dp[i] [j]递推有两种状态：</p><ul><li>dp[ i ] [ j ] &#x3D; dp[ i ] [ j-1 ] + a[ j ] ，即把第j项融合到第 j-1 项的子段中，子段数没变</li><li>dp[ i ] [ j ] &#x3D; dp[ i-1 ] [ t ] + a[ j ]，（i-1&lt;&#x3D; t &lt; j ），把第 j 项作为单独的一个子段，然后找一下i-1个子段时，最大的和，然后加上a[ j ]</li></ul><p>因此dp[i] [j]&#x3D;max(dp[ i ] [ j-1 ], dp[ i-1 ] [ t ] )，可以使用一个变量在内层循环中记录当前最大的t，以减少一个遍历。</p><p>如果可以不选，皆初始化为0（如果必须要选，则除第0行外，其余皆初始化为负无穷）</p><p>由递推公式知从左到右，从上到下遍历。</p><ul><li><p>时间复杂度：O(n^2^) </p></li><li><p>空间复杂度：O(n^2^)</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//此代码是快手那题的代码</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">deal</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>nums<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> pre<span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>pre<span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pre<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// for(int t=i-1;t&lt;j;++t)&#123;</span>            <span class="token comment">//     dp[i][j]=max(dp[i][j],dp[i-1][t]+nums[j-1]);</span>            <span class="token comment">// &#125;</span>            ans<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cin<span class="token operator">>></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token function">deal</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>n<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>对于S中的每个字符都向左右进行扩展，然后得到最大扩展回文子串。注意，每个字符串只需要两种扩展，第一种是以当前字符为中心，第二种是以当前字符和左边字符进行扩展。</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">getLongRes</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>left<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>right<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token operator">--</span>left<span class="token punctuation">;</span>                <span class="token operator">++</span>right<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">++</span>left<span class="token punctuation">;</span>        <span class="token operator">--</span>right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ansl<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>ansr<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> left<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token function">getLongRes</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">></span>ansr<span class="token operator">-</span>ansl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ansr<span class="token operator">=</span>right<span class="token punctuation">;</span>                ansl<span class="token operator">=</span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            left<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>right<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">getLongRes</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">></span>ansr<span class="token operator">-</span>ansl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ansr<span class="token operator">=</span>right<span class="token punctuation">;</span>                ansl<span class="token operator">=</span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>ansl<span class="token punctuation">,</span>ansr<span class="token operator">-</span>ansl<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2：Manacher算法</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度2020校招C++PHP研发工程师笔试卷第二批</title>
      <link href="/2023/08/09/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E7%99%BE%E5%BA%A62020%E6%A0%A1%E6%8B%9BC++PHP%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E5%8D%B7%E7%AC%AC%E4%BA%8C%E6%89%B9/"/>
      <url>/2023/08/09/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E7%99%BE%E5%BA%A62020%E6%A0%A1%E6%8B%9BC++PHP%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E5%8D%B7%E7%AC%AC%E4%BA%8C%E6%89%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="百度2020校招C-PHP研发工程师笔试卷第二批"><a href="#百度2020校招C-PHP研发工程师笔试卷第二批" class="headerlink" title="百度2020校招C++PHP研发工程师笔试卷第二批"></a><a href="https://www.nowcoder.com/exam/test/71884987/detail?pid=30544845&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=139&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">百度2020校招C++PHP研发工程师笔试卷第二批</a></h1><p>算法题不难，ak。总得分16，排名6%</p><hr><p><strong>1</strong>：<strong>最小值</strong></p><blockquote><p>牛牛给度度熊出了一个数学题，牛牛给定数字\mathit n,m,k<em>n</em>,<em>m</em>,<em>k</em>，希望度度熊能找到一组<strong>非负整数</strong>\mathit a,b<em>a</em>,<em>b</em>满足(n-a)(m-b) \leq k(<em>n</em>−<em>a</em>)(<em>m</em>−<em>b</em>)≤<em>k</em>且\mathit a+b<em>a</em>+<em>b</em>尽量小。</p><p>度度熊把这个问题交给了你，希望你能帮他解决。</p></blockquote><p>使用的暴力法，交换nm使得n&lt;m，将a从0开始遍历到n，如果求得b小于0，则退出遍历。</p><p>这其实是一道数学题，看解析有一个推导，经推导后a+b最小值为n - k&#x2F;m，推导如下：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230809114311026.png" alt="image-20230809114311026" style="zoom: 67%;" /><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;climits></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span>  n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n <span class="token operator">>></span> m <span class="token operator">>></span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> ans <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> a <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> b <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>2</strong>：<strong>度度熊的工作</strong></p><blockquote><p>老板给度度熊分配了\mathit n<em>n</em>个工作，第\mathit i<em>i</em>个工作需要耗费a_i<em>a**i</em>单位时间，每个工作必须老板给定的限制时间b_i<em>b**i</em>前完成。<br>度度熊从\text 00时刻开始工作，在同一时间度度熊手上只能做一件工作，度度熊想知道他是否能把所有工作都完成呢？</p></blockquote><p>贪心算法。</p><p>先按完成时间从小到大进行排序，然后从小开始遍历，如果当前任务消耗时间+当前已用时间cur大于截止时间则说明不能完成。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">deal</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token operator">&amp;</span>nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cur<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"No"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cur<span class="token operator">+=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"Yes"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    cin<span class="token operator">>></span>T<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>T<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token operator">--</span>T<span class="token punctuation">;</span>        <span class="token keyword">int</span> n<span class="token punctuation">;</span>        cin<span class="token operator">>></span>n<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cin<span class="token operator">>></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>></span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">deal</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>3</strong>：<strong>树上游戏</strong></p><blockquote><p>牛牛和牛妹在做游戏，在他们面前的桌子上有一棵树，初始\text 11号点是黑点，\mathit n<em>n</em>号点是白点，其他都是空点，两人轮流操作，牛牛可以选择一个黑点并把该黑点周围的某个空点染成黑色，牛妹可以选择一个白点并把该白点周围的某个空点染成白色，直到有一方不能涂了，另一方获胜。</p></blockquote><p>感觉就是模拟。</p><p>先使用一个二维数据记录每个节点连接哪些节点，一维数组flag记录当前节点的状态。使用两个set分别记录niuniu和niumei所能选择的下一个节点。</p><p>每次niuniu从niuset中选择一个节点，如果不能选则niumei赢，如果能选则将更改flags中该节点状态，且将该节点的连接节点插入到niuset中。同理niumei也如此操作，直到有人赢即可。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    cin<span class="token operator">>></span>T<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>T<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token operator">--</span>T<span class="token punctuation">;</span>        <span class="token keyword">int</span> n<span class="token punctuation">;</span>        cin<span class="token operator">>></span>n<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">trees</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>            cin<span class="token operator">>></span>a<span class="token operator">>></span>b<span class="token punctuation">;</span>            trees<span class="token punctuation">[</span>a<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>b<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            trees<span class="token punctuation">[</span>b<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">flags</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flags<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        flags<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> niu<span class="token punctuation">,</span>mei<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>trees<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            niu<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>trees<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>trees<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            mei<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>trees<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> zeroPoint<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span>win<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>zeroPoint<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> ch1<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>ch2<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">:</span>niu<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>flags<span class="token punctuation">[</span>it<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    flags<span class="token punctuation">[</span>it<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                    ch1<span class="token operator">=</span>it<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ch1<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                win<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>trees<span class="token punctuation">[</span>ch1<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>flags<span class="token punctuation">[</span>trees<span class="token punctuation">[</span>ch1<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        niu<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>trees<span class="token punctuation">[</span>ch1<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">:</span>mei<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>flags<span class="token punctuation">[</span>it<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    flags<span class="token punctuation">[</span>it<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>                    ch2<span class="token operator">=</span>it<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ch2<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                win<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>trees<span class="token punctuation">[</span>ch2<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>flags<span class="token punctuation">[</span>trees<span class="token punctuation">[</span>ch2<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        mei<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>trees<span class="token punctuation">[</span>ch2<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>win<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"niuniu"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>win<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"niumei"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"None"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试真题 </tag>
            
            <tag> 百度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快手2019年春季校园招聘笔试试题--工程A试卷</title>
      <link href="/2023/08/08/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E5%BF%AB%E6%89%8B2019%E5%B9%B4%E7%A7%8B%E5%AD%A3%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E8%AF%95%E9%A2%98--%E5%B7%A5%E7%A8%8BA%E8%AF%95%E5%8D%B7/"/>
      <url>/2023/08/08/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E5%BF%AB%E6%89%8B2019%E5%B9%B4%E7%A7%8B%E5%AD%A3%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E8%AF%95%E9%A2%98--%E5%B7%A5%E7%A8%8BA%E8%AF%95%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="快手2019年春季校园招聘笔试试题–工程A试卷"><a href="#快手2019年春季校园招聘笔试试题–工程A试卷" class="headerlink" title="快手2019年春季校园招聘笔试试题–工程A试卷"></a><a href="https://www.nowcoder.com/exam/test/71834291/detail?pid=16369402&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=898&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">快手2019年春季校园招聘笔试试题–工程A试卷</a></h1><p>算法题较简单，ak</p><hr><p><strong>1</strong>：<strong>二进制中有多少个1</strong></p><blockquote><p>把一个 32-bit 整型转成二进制，其中包含多少个 1 ，比如 5 的二进制表达是 101 ，其中包含 2 个 1</p></blockquote><p>不断移位比较即可</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">deal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> comp<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    ans<span class="token operator">+=</span>n<span class="token operator">&amp;</span>comp<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">32</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//可改为while(n)</span>        n<span class="token operator">>>=</span><span class="token number">1</span><span class="token punctuation">;</span>        ans<span class="token operator">+=</span>n<span class="token operator">&amp;</span>comp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        <span class="token function">deal</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>2</strong>：<strong>机器人移动范围</strong></p><blockquote><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 0,0 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。 例如，当 k 为 18 时，机器人能够进入方格（35,37），因为 3+5+3+7 &#x3D; 18 。但是，它不能进入方格（35,38），因为 3+5+3+8 &#x3D; 19 。请问该机器人能够达到多少个格子？</p></blockquote><p>使用深度搜索遍历能到达的格子，使用一个二维数组flags记录到了哪些格子。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token operator">&amp;</span>flags<span class="token punctuation">,</span><span class="token keyword">int</span> m<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>i<span class="token operator">&lt;</span>m<span class="token operator">&amp;&amp;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ti<span class="token operator">=</span>i<span class="token punctuation">,</span>tj<span class="token operator">=</span>j<span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>ti<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        sum<span class="token operator">+=</span>ti<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>        ti<span class="token operator">/=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tj<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        sum<span class="token operator">+=</span>tj<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>        tj<span class="token operator">/=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">></span>k<span class="token operator">||</span>flags<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token operator">++</span>ans<span class="token punctuation">;</span>    flags<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span>m<span class="token punctuation">,</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span>m<span class="token punctuation">,</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span>m<span class="token punctuation">,</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span>m<span class="token punctuation">,</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">deal</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">flags</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span>m<span class="token punctuation">,</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> m<span class="token punctuation">,</span>n<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> m <span class="token operator">>></span> n <span class="token operator">>></span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        <span class="token function">deal</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>3</strong>：<strong>判断一棵满二叉树是否为二叉搜索树</strong></p><blockquote><p>给定一棵满二叉树，判定该树是否为二叉搜索树，是的话打印True，不是的话打印False</p></blockquote><p>使用中序遍历得到数组，然后对其进行排序，比较排序后的数组和未排序前是否有差别即可判断结果。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>trees<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>nums<span class="token punctuation">,</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>idx<span class="token operator">>=</span>trees<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>trees<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>trees<span class="token punctuation">,</span>nums<span class="token punctuation">,</span>idx<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>trees<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>trees<span class="token punctuation">,</span>nums<span class="token punctuation">,</span>idx<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string str<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">trees</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">','</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                string substr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>substr <span class="token operator">==</span> <span class="token string">"None"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    trees<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    trees<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>substr<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                i <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token operator">++</span>j<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        string substr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>substr <span class="token operator">==</span> <span class="token string">"None"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            trees<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            trees<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>substr<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>        <span class="token function">traverse</span><span class="token punctuation">(</span>trees<span class="token punctuation">,</span>nums<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sort_nums<span class="token operator">=</span>nums<span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>sort_nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sort_nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sort_nums<span class="token operator">==</span>nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"True"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"False"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span class="token comment">//method2 直接中序遍历来做，以下是leetcode-98代码</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    TreeNode <span class="token operator">*</span>pre<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">midOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> left<span class="token operator">=</span><span class="token function">midOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token operator">&amp;&amp;</span>root<span class="token operator">-></span>val<span class="token operator">&lt;=</span>pre<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        pre<span class="token operator">=</span>root<span class="token punctuation">;</span>        <span class="token keyword">bool</span> right<span class="token operator">=</span><span class="token function">midOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> left<span class="token operator">&amp;&amp;</span>right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        pre<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">midOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试真题 </tag>
            
            <tag> 快手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度2020校招C++PHP研发工程师笔试卷第一批</title>
      <link href="/2023/08/08/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E7%99%BE%E5%BA%A62020%E6%A0%A1%E6%8B%9BC++PHP%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E5%8D%B7%E7%AC%AC%E4%B8%80%E6%89%B9/"/>
      <url>/2023/08/08/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E7%99%BE%E5%BA%A62020%E6%A0%A1%E6%8B%9BC++PHP%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E5%8D%B7%E7%AC%AC%E4%B8%80%E6%89%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="百度2020校招C-PHP研发工程师笔试卷第一批-https-www-nowcoder-com-exam-test-71846697-detail-pid-30544826-amp-examPageSource-Company-amp-testCallback-https-3A-2F-2Fwww-nowcoder-com-2Fexam-2Fcompany-3FcurrentTab-3Drecommand-26jobId-3D100-26selectStatus-3D0-26tagIds-3D139-amp-testclass-E8-BD-AF-E4-BB-B6-E5-BC-80-E5-8F-91"><a href="#百度2020校招C-PHP研发工程师笔试卷第一批-https-www-nowcoder-com-exam-test-71846697-detail-pid-30544826-amp-examPageSource-Company-amp-testCallback-https-3A-2F-2Fwww-nowcoder-com-2Fexam-2Fcompany-3FcurrentTab-3Drecommand-26jobId-3D100-26selectStatus-3D0-26tagIds-3D139-amp-testclass-E8-BD-AF-E4-BB-B6-E5-BC-80-E5-8F-91" class="headerlink" title="[百度2020校招C++PHP研发工程师笔试卷第一批](https://www.nowcoder.com/exam/test/71846697/detail?pid=30544826&amp;examPageSource=Company&amp;testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26selectStatus%3D0%26tagIds%3D139&amp;testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"></a>[百度2020校招C++PHP研发工程师笔试卷第一批](<a href="https://www.nowcoder.com/exam/test/71846697/detail?pid=30544826&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=139&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">https://www.nowcoder.com/exam/test/71846697/detail?pid=30544826&amp;examPageSource=Company&amp;testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26selectStatus%3D0%26tagIds%3D139&amp;testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91</a></h1><p>做到算法题才发现以前做过这试卷，算法题过了两道，第二道没过</p><hr><p><strong>1</strong>：<strong>小度买果汁</strong></p><blockquote><p>小度和同事们一起去春游，天气炎热，小度自告奋勇去给大家买果汁。</p><p>员工一共有n名（包括小度）, 果汁一共有k种，第i位员工每个人都有自己最喜欢的一种果汁a_i<em>a**i</em>。</p><p>小度到达果汁商店的时候，被告知商店正在举行促销活动，全场果汁买一送一（购买一瓶i型果汁，再赠送一瓶i型果汁）。</p><p>小度想让所有人（包括小度）都拿到他们最喜欢的果汁，需要购买多少瓶呢？</p></blockquote><p>统计每种果汁需要多少瓶，每种果汁瓶数先加1再除2，将所有结果相加即可</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n <span class="token operator">>></span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">data</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> a<span class="token punctuation">;</span>            cin <span class="token operator">>></span> a<span class="token punctuation">;</span>            data<span class="token punctuation">[</span>a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            ans <span class="token operator">+=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>2</strong>：<strong>发工资</strong></p><blockquote><p>小度新聘请了一名员工牛牛, 每个月小度需要给牛牛至少发放m元工资(给牛牛发放的工资可以等于m元或者大于m元, 不能低于m)。<br>小度有一些钞票资金, 一共有n种不同的面额, 对于面额为x_i<em>x**i</em>的钞票, 小度有y_i<em>y**i</em>张, 并且每一个钞票面额都能整除所有比它大的面额, 并且每一张钞票不能找零。<br>小度想知道这部分资金最多能牛牛发放多少个月的工资?</p></blockquote><p>贪心算法。</p><p>先将所有面额大于等于工资的计算（只能发一次工资），然后剩下的都是单个面额不足以发一次工资。使用剩下的面额尝试能否凑齐一次工资，首先使用大的面额来凑（此时不要求能凑满，尽量凑满），如果剩余钱仍大于0，则依次使用小面额进行凑（此时要么将当前面额钱用完，要么凑齐），最后判断是否能凑齐一次工资。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cin <span class="token operator">>></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//先用完面额大于工资的钱</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>=</span>m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans<span class="token operator">+=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> need<span class="token punctuation">,</span> rest <span class="token operator">=</span> m<span class="token punctuation">;</span>            <span class="token comment">//依次使用大面额凑，尽量凑满，但不能超过</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                need <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rest <span class="token operator">/</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                rest <span class="token operator">-=</span> need <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-=</span> need<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rest <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rest <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//依次使用小面额凑，要么凑满，要么用完</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                    need <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>rest <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//为了凑满当前剩余值</span>                    rest <span class="token operator">-=</span> need <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-=</span> need<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rest <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rest <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token operator">++</span>ans<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>3</strong>：<strong>摆火柴</strong></p><blockquote><p>牛牛给了小度n根火柴和m种数字(m只能是1到9)，小度只能摆这m种数字，小度想知道能摆出来最大的数的多少。</p></blockquote><p>动态规划。</p><p>使用一维dp来记录，dp[i]表示i根火柴能摆的最大数字，由于数可能很大，使用string记录。</p><p>由于需要将火柴用完，因此当i-cost[nums[i]]]等于0或i-cost[nums[i]]]大于0但dp[i-cost[nums[i]]]]必须不为0，才能进行更新，dp[dp[i] &#x3D; str_max(dp [i],dp[i-cost[nums[i]]]+to_string(nums[i]));</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>string <span class="token function">str_max</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> b<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> b<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> cost <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nums</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cin <span class="token operator">>></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> t <span class="token operator">=</span> cost<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;=</span> i <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> t <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> t <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> t<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">str_max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> t<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">to_string</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试真题 </tag>
            
            <tag> 百度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快手2020校园招聘秋招笔试--工程A试卷</title>
      <link href="/2023/08/07/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E5%BF%AB%E6%89%8B2020%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95--%E5%B7%A5%E7%A8%8BA%E8%AF%95%E5%8D%B7/"/>
      <url>/2023/08/07/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E5%BF%AB%E6%89%8B2020%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95--%E5%B7%A5%E7%A8%8BA%E8%AF%95%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="快手2020校园招聘秋招笔试–工程A试卷"><a href="#快手2020校园招聘秋招笔试–工程A试卷" class="headerlink" title="快手2020校园招聘秋招笔试–工程A试卷"></a><a href="https://www.nowcoder.com/exam/test/71803393/detail?pid=22088856&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=898&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">快手2020校园招聘秋招笔试–工程A试卷</a></h1><p>过了2道题</p><hr><p><strong>1</strong>：<strong>“好序列”的个数</strong></p><blockquote><p>现在你面前有一棵n个节点的树（全连通无环图）。树上的边只有2种颜色，红色或者黑色。现在还给你一个整数k，考虑下面这个k个节点的序列[a1, a2, …, ak]。</p><p>[a1, a2, …, ak]如果是”好序列“当且仅当满足下面的条件：</p><p>\1. 我们要走一条从a1开始到ak结束的路径。</p><p>\2. 从a1开始，到a2走一条a1到a2的最短路。然后从a2开始，继续走一条到a3的最短路，以此类推，最终到a(k-1)和ak。</p><p>\3. 走的路径中<strong>至少包含一条</strong>黑色的边。</p></blockquote><p>做的时候知道是用全红边去减，但不知道咋算个数。先用深度搜索所有只以红边构成的子图的变数a，每个子图可以构成a^k个，因此使用总的个数减去所有子图构成的个数即可。（不知道为啥，使用快速幂求始终有问题）</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_set></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> lines<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    flags<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">:</span> lines<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        lines<span class="token punctuation">[</span>it<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>        ret <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>lines<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> it<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// long long fpow(int t,int k)&#123;</span><span class="token comment">//     if(k==1) return t;</span><span class="token comment">//     long long ans=1,a=t;</span><span class="token comment">//     if(k%2==1) ans=t;</span><span class="token comment">//     while(k)&#123;</span><span class="token comment">//         if(k==1)&#123;</span><span class="token comment">//             break;</span><span class="token comment">//         &#125;</span><span class="token comment">//         a=a*a%mod;</span><span class="token comment">//         k>>=1;</span><span class="token comment">//     &#125;</span><span class="token comment">//     ans=ans*a%mod;</span><span class="token comment">//     return ans;</span><span class="token comment">// &#125;</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">fpow</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ans <span class="token operator">=</span> ans <span class="token operator">*</span> t <span class="token operator">%</span> mod<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n <span class="token operator">>></span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span>unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">lines</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>            cin <span class="token operator">>></span> a <span class="token operator">>></span> b <span class="token operator">>></span> c<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                lines<span class="token punctuation">[</span>a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>b <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                lines<span class="token punctuation">[</span>b <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">flags</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flags<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">long</span> <span class="token keyword">long</span> t <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>lines<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                ans <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">+</span> <span class="token function">fpow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>                <span class="token comment">// cout&lt;&lt;t&lt;&lt;" "&lt;&lt;ans&lt;&lt;endl;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        ans <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">fpow</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">+</span> mod <span class="token operator">-</span> ans<span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>2</strong>：<strong>计算累计平方和</strong></p><blockquote><p>给定一个32位int型正整数，我们定义如下操作，取其十进制各位数字的平方和，并不断重复这个操作。如果某次操作完成后得到的结果是1，则返回true；否则继续执行，直到证明永远不会得到结果为1，返回false</p></blockquote><p>三位数以上的数生成的平方和会小于其原值，因此如果是一直循环，那么一定会有重复值，当遍历到重复值就返回false</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">deal</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> mset<span class="token punctuation">;</span>    mset<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> t <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            t <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>            sum <span class="token operator">+=</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"true"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mset<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"false"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        mset<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        t <span class="token operator">=</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> t<span class="token punctuation">;</span>        cin <span class="token operator">>></span> t<span class="token punctuation">;</span>        <span class="token function">deal</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>3</strong>：<strong>版本升级判定</strong></p><blockquote><p>给定两个版本号，只有在版本号更高的时候，才可以升级。「.」号作为分割符使用，版本号中只有数和.号。</p></blockquote><p>将每个版号都假设为3位，不足的补0，依次比较即可</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void str2num(string&amp; str, vector&lt;int&gt;&amp; num) &#123;    int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;    while (j &lt; str.size()) &#123;        if (str[j] &#x3D;&#x3D; &#39;.&#39;) &#123;            num[k] &#x3D; atoi(str.substr(i, j - i).c_str());            ++k;            i &#x3D; j + 1;        &#125;        ++j;    &#125;    num[k] &#x3D; atoi(str.substr(i, j - i).c_str());&#125;bool compare(vector&lt;int&gt;&amp; num1, vector&lt;int&gt;&amp; num2) &#123;    for (int i &#x3D; 0; i &lt; num1.size(); ++i) &#123;        if (num2[i] &gt; num1[i]) return true;        else if (num2[i] &lt; num1[i]) return false;    &#125;    return false;&#125;int main() &#123;    int n;    cin &gt;&gt; n;    for (int i &#x3D; 0; i &lt; n; ++i) &#123;        string str1, str2;        cin &gt;&gt; str1 &gt;&gt; str2;        vector&lt;int&gt; num1(3, 0), num2(3, 0);        str2num(str1, num1);        str2num(str2, num2);        if (compare(num1, num2)) &#123;            cout &lt;&lt; &quot;true&quot; &lt;&lt; endl;        &#125; else &#123;            cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;        &#125;    &#125;&#125;&#x2F;&#x2F; 64 位输出请用 printf(&quot;%lld&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>4</strong>：<strong>合并内容流</strong></p><blockquote><p>合并两个内容流，实现隔4个插入1个，如果合并完还有剩下，则加内容流尾部</p></blockquote><p>不断遍历插入即可，只是注意空格</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string str1<span class="token punctuation">,</span> str2<span class="token punctuation">;</span>    <span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>    string ans<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> str1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> str2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            ans <span class="token operator">+=</span> str1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            ans <span class="token operator">+=</span> <span class="token char">' '</span><span class="token punctuation">;</span>            <span class="token operator">++</span>t<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ans <span class="token operator">+=</span> str2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                ans <span class="token operator">+=</span> <span class="token char">' '</span><span class="token punctuation">;</span>                j <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">++</span>i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> str1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>        ans <span class="token operator">+=</span> str1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> str1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> str2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token operator">++</span>j<span class="token punctuation">;</span>        ans <span class="token operator">+=</span> str2<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> str2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试真题 </tag>
            
            <tag> 快手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快手2020校园招聘秋招笔试--工程B试卷</title>
      <link href="/2023/08/07/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E5%BF%AB%E6%89%8B2020%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95--%E5%B7%A5%E7%A8%8BB%E8%AF%95%E5%8D%B7/"/>
      <url>/2023/08/07/leetcode/%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/%E5%BF%AB%E6%89%8B2020%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95--%E5%B7%A5%E7%A8%8BB%E8%AF%95%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="快手2020校园招聘秋招笔试–工程B试卷"><a href="#快手2020校园招聘秋招笔试–工程B试卷" class="headerlink" title="快手2020校园招聘秋招笔试–工程B试卷"></a><a href="https://www.nowcoder.com/exam/test/71800855/detail?pid=22088872&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=898&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">快手2020校园招聘秋招笔试–工程B试卷</a></h1><p>选择挺难，DNA算法难度不大，过了三道题，第二道过了部分用例，后来本想用暴力做的，但感觉时间复杂度太高就放弃了</p><hr><p><strong>1</strong>：<strong>集合划分问题</strong></p><blockquote><p>给定一个数组，每个元素范围是0~K（K &lt; 整数最大值2^32），将该数组分成两部分，使得 |S1- S2|最小，其中S1和S2分别是数组两部分的元素之和。</p></blockquote><p>使用动态规划来做，先求总和sum，使用goal&#x3D;sum&#x2F;2作为背包容量，求容量在goal情况下能选取多大的值，最后使用sum减即可。</p><ul><li>时间复杂度：O(n^2) </li><li>空间复杂度：O(n^2)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int deal(vector&lt;int&gt;&amp; nums) &#123;    long long sum &#x3D; 0;    for (auto a : nums) sum +&#x3D; a;    sort(nums.begin(), nums.end());    int goal &#x3D; sum &#x2F; 2;    vector&lt;int&gt; dp(goal + 1, 0);    for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;        for (int j &#x3D; goal; j &gt;&#x3D; nums[i]; --j) &#123;            dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);        &#125;    &#125;    return abs(sum - 2 * dp[goal]);&#125;int main() &#123;    int n;    while (cin &gt;&gt; n) &#123; &#x2F;&#x2F; 注意 while 处理多个 case        vector&lt;int&gt; nums(n);        for (int i &#x3D; 0; i &lt; n; ++i) cin &gt;&gt; nums[i];        cout &lt;&lt; deal(nums) &lt;&lt; endl;    &#125;&#125;&#x2F;&#x2F; 64 位输出请用 printf(&quot;%lld&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>2</strong>：<strong>最长等差数列问题</strong></p><blockquote><p>给定一个未排序数组,找出其中最长的等差数列(无需保证数字顺序)。</p></blockquote><p>没啥好办法，解析里面也没看见，最后使用的暴力。先排序，遍历每两个数之间的差值，然后按此差值进行增长，找到最长的等差。但需要注意，可能会出现都是1的这种用例，因此需要对差值为0的直接从哈希表中找到当前数有多少个。</p><ul><li>时间复杂度：O(n^3) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">deal</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mmap<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token operator">++</span>mmap<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> dif <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dif<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dif <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                cur <span class="token operator">=</span> mmap<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>mmap<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token operator">++</span>cur<span class="token punctuation">;</span>                        a <span class="token operator">+=</span> dif<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cin <span class="token operator">>></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token function">deal</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>3</strong>：<strong>字母组合</strong></p><blockquote><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合，按照字典序升序排序,如果有重复的结果需要去重</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母</p></blockquote><p>使用回溯即可，leetcode上有一样的题目。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;string&gt; ans;string path;void traverse(vector&lt;string&gt;&amp; data, string&amp; num, int idx) &#123;    if (idx &#x3D;&#x3D; num.size()) &#123;        ans.push_back(path);        return;    &#125;    int pos &#x3D; num[idx] - &#39;2&#39;;    for (int i &#x3D; 0; i &lt; data[pos].size(); ++i) &#123;        path.push_back(data[pos][i]);        traverse(data, num, idx + 1);        path.pop_back();    &#125;&#125;int main() &#123;    vector&lt;string&gt; data &#x3D; &#123;&#123;&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;&#125;;    int n;    while (cin &gt;&gt; n) &#123; &#x2F;&#x2F; 注意 while 处理多个 case        ans.clear();        string num &#x3D; to_string(n);        traverse(data, num, 0);        cout &lt;&lt; &#39;[&#39;;        for (int i &#x3D; 0; i &lt; ans.size(); ++i) &#123;            if (i &lt; ans.size() - 1)                cout &lt;&lt; ans[i] &lt;&lt; &quot;, &quot;;            else                cout &lt;&lt; ans[i] &lt;&lt; &#39;]&#39;;        &#125;    &#125;&#125;&#x2F;&#x2F; 64 位输出请用 printf(&quot;%lld&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>4</strong>：<strong>验证IP地址</strong></p><blockquote><p>编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址</p></blockquote><p>对ipv4和ipv6分别进行判定，先将整个ip按‘.’或‘：’进行分割，然后对分割后的每个值按规则进行判定即可。</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">split</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> ip<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> ip<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ip<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            strs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ip<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">++</span>j<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    strs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ip<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">isIpv4</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> ip<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> strs<span class="token punctuation">;</span>    <span class="token function">split</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token char">'.'</span><span class="token punctuation">,</span> strs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>strs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'0'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> <span class="token number">255</span> <span class="token operator">||</span> t <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">isIpv6</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> ip<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> strs<span class="token punctuation">;</span>    <span class="token function">split</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token char">':'</span><span class="token punctuation">,</span> strs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>strs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">8</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">""</span> <span class="token operator">||</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token char">'a'</span> <span class="token operator">&amp;&amp;</span>                    strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'z'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token char">'A'</span> <span class="token operator">&amp;&amp;</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'Z'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string str<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isIpv4</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"IPv4"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isIpv6</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"IPv6"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Neither"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试真题 </tag>
            
            <tag> 快手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>填数游戏</title>
      <link href="/2023/08/02/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BE%8E%E5%9B%A2-%E5%A1%AB%E6%95%B0%E6%B8%B8%E6%88%8F-middle/"/>
      <url>/2023/08/02/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BE%8E%E5%9B%A2-%E5%A1%AB%E6%95%B0%E6%B8%B8%E6%88%8F-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="填数游戏"><a href="#填数游戏" class="headerlink" title="填数游戏"></a><a href="https://www.nowcoder.com/exam/test/71612908/detail?pid=28665320&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=179&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">填数游戏</a></h1><p>First：用深度遍历只过了部分用例，超时。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230802160436554.png" alt="image-20230802160436554"></p><ul><li>时间复杂度：O(nk) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">deal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>k<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">%=</span><span class="token number">998244353</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">%=</span><span class="token number">998244353</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">%=</span><span class="token number">998244353</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> d<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> n <span class="token operator">>></span> k <span class="token operator">>></span> d<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意 while 处理多个 case</span>        <span class="token function">deal</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>k<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 64 位输出请用 printf("%lld")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神秘的苹果树</title>
      <link href="/2023/07/27/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E7%A5%9E%E7%A7%98%E7%9A%84%E8%8B%B9%E6%9E%9C%E6%A0%91-middle/"/>
      <url>/2023/07/27/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E7%A5%9E%E7%A7%98%E7%9A%84%E8%8B%B9%E6%9E%9C%E6%A0%91-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="神秘的苹果树"><a href="#神秘的苹果树" class="headerlink" title="神秘的苹果树"></a><a href="https://www.nowcoder.com/exam/test/71421550/detail?pid=28665338&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=179&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">神秘的苹果树</a></h1><p>First：牛客上美团2021第9场第4题，建数那里折腾很久</p><hr><p><strong>方法1</strong>：<strong>深度遍历</strong></p><p>麻烦点在于建立树，因为边的两个点不知道是谁是父节点：使用一个邻接表先构建无向图，然后深度遍历，找到构建树。</p><p>对树的每个节点使用一个哈希表记录子树的所有颜色，进行深度遍历时加上所有子树的颜色值即可。</p><p>注意哈希表的key值不是从小到大遍历的。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;climits&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;void traverse(unordered_map&lt;int,vector&lt;int&gt;&gt; &amp;mmap,int idx,vector&lt;unordered_map&lt;int,int&gt;&gt; &amp;colorSum,vector&lt;int&gt; &amp;colors)&#123;    colorSum[idx-1][colors[idx-1]]++;    auto it&#x3D;mmap.find(idx);    if(it!&#x3D;mmap.end())&#123;        for(int i&#x3D;0;i&lt;it-&gt;second.size();++i)&#123;            traverse(mmap,it-&gt;second[i],colorSum,colors);            for(auto &amp;kv:colorSum[it-&gt;second[i]-1])&#123;                colorSum[idx-1][kv.first]+&#x3D;kv.second;            &#125;        &#125;    &#125;&#125;void createTree(vector&lt;vector&lt;int&gt;&gt; &amp;lines,unordered_map&lt;int,vector&lt;int&gt;&gt; &amp;mmap,int idx)&#123;    int n&#x3D;lines.size();    for(int i&#x3D;0;i&lt;n;++i)&#123;        if(lines[idx][i]&#x3D;&#x3D;1)&#123;            lines[i][idx]&#x3D;0;            mmap[idx+1].push_back(i+1);            createTree(lines,mmap,i);                    &#125;    &#125;&#125;int main() &#123;    int n;    cin&gt;&gt;n;    vector&lt;vector&lt;int&gt;&gt; lines(n,vector&lt;int&gt;(n,0));    for(int i&#x3D;0;i&lt;n-1;++i)&#123;        int a,b;        cin&gt;&gt;a&gt;&gt;b;        lines[a-1][b-1]&#x3D;1;        lines[b-1][a-1]&#x3D;1;    &#125;    unordered_map&lt;int,vector&lt;int&gt;&gt; mmap;    createTree(lines,mmap,0);    vector&lt;int&gt; colors(n,0);    int maxColor&#x3D;0;    for(int i&#x3D;0;i&lt;n;++i)&#123;        cin&gt;&gt;colors[i];        maxColor&#x3D;max(maxColor,colors[i]);    &#125;    vector&lt;unordered_map&lt;int,int&gt;&gt; colorSum(n);    traverse(mmap,1,colorSum,colors);    int q;    cin&gt;&gt;q;    for(int i&#x3D;0;i&lt;q;++i)&#123;        int t,ans&#x3D;0,cur&#x3D;0;        cin&gt;&gt;t;        for(auto &amp;kv:colorSum[t-1])&#123;            if(kv.second&gt;cur||(kv.second&#x3D;&#x3D;cur&amp;&amp;kv.first&lt;ans))&#123;                ans&#x3D;kv.first;                cur&#x3D;kv.second;            &#125;         &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;&#x2F;&#x2F; 64 位输出请用 printf(&quot;%lld&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形数组最大和</title>
      <link href="/2023/07/27/leetcode/%E6%95%B0%E7%BB%84/%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C-middle/"/>
      <url>/2023/07/27/leetcode/%E6%95%B0%E7%BB%84/%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="环形数组最大和"><a href="#环形数组最大和" class="headerlink" title="环形数组最大和"></a><a href="https://www.nowcoder.com/exam/test/71421550/detail?pid=28665338&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=179&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">环形数组最大和</a></h1><p>FIrst：牛客上美团2021第9场题</p><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>题目要求环形数组的连续子数组的最大和，我们先不要去管数组是环形的情况，利用动态规划求解连续子数组的最大和以及最小和。 </p><p>  (1) 不考虑环形得到的最大值：题中允许寿司首尾相连的环形数组情况，因此常规求得的连续子数组的最大和就是我们排除这种情况之外的所有情况中的最大和。 </p><p>  (2) 只考虑环形得到的最大值：而对于首尾相连的情况，我们可以这样考虑，如果常规求得的连续子数组的和达到了最小，那么总和减去这个最小值就等于首尾相连情况的最大值了。 </p><p>  因此最大的美味值就是(1)和(2)两种情况中大的那个。 </p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;right)&#123;            while(nums[left]&#x3D;&#x3D;0&amp;&amp;left&lt;right) ++left;            while(nums[right]!&#x3D;0&amp;&amp;left&lt;right) --right;            if(left&lt;right)&#123;                int t&#x3D;nums[left];                nums[left]&#x3D;nums[right];                nums[right]&#x3D;t;            &#125;        &#125;        left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;nums.size()&amp;&amp;nums[left]&#x3D;&#x3D;0) ++left;        while(left&lt;right)&#123;            while(nums[left]&#x3D;&#x3D;1&amp;&amp;left&lt;right) ++left;            while(nums[right]&#x3D;&#x3D;2&amp;&amp;left&lt;right) --right;            if(left&lt;right)&#123;                int t&#x3D;nums[left];                nums[left]&#x3D;nums[right];                nums[right]&#x3D;t;            &#125;                    &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>三指针</strong></p><p>一次遍历。先使用两个指针p1 p2分别指向已排好的0和1尾部，使用一个指针从头到尾进行遍历，如果nums[i]&#x3D;1，则将其与nums[p2]进行交换，并p2+1；当nums[i]&#x3D;0时，此时将其与nums[p1]进行交换，但如果已经有1排好序，即p2&gt;p1，此时将会把1交换到nums[i]，因此还需要将nums[i]和nums[p2]交换，最后p1和p2都加1.</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int p1&#x3D;0,p2&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(nums[i]&#x3D;&#x3D;0)&#123;                swap(nums[i],nums[p1]);                                                if(p1&lt;p2)&#123;                    swap(nums[i],nums[p2]);                                    &#125;                      ++p2;                ++p1;                      &#125;else if(nums[i]&#x3D;&#x3D;1)&#123;                swap(nums[i],nums[p2]);                ++p2;            &#125;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
            <tag> Alg-环形数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前序和中序（重复）重建二叉树</title>
      <link href="/2023/07/26/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/other-%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%EF%BC%88%E9%87%8D%E5%A4%8D%EF%BC%89%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-difficult/"/>
      <url>/2023/07/26/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/other-%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%EF%BC%88%E9%87%8D%E5%A4%8D%EF%BC%89%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="前序和中序（重复）重建二叉树"><a href="#前序和中序（重复）重建二叉树" class="headerlink" title="前序和中序（重复）重建二叉树"></a><a href="https://www.nowcoder.com/exam/test/71374931/detail?pid=43184608&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">前序和中序（重复）重建二叉树</a></h1><p>First：腾讯音乐娱乐集团2023校园招聘技术类岗位编程题之一，没做出来，开始想的是使用回溯来做，但有个问题是构建树的时候必须返回之后才能设定左右子树，而判定回溯一次完成将路径push到结果中时，此时树的左右子节点没有设定完成，还有个问题是不好知道什么时候回溯完成。</p><hr><p><strong>方法1</strong>：<strong>递归</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;** * struct TreeNode &#123; *int val; *struct TreeNode *left; *struct TreeNode *right; *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * &#125;; *&#x2F;#include &lt;cstddef&gt;#include &lt;numeric&gt;class Solution &#123;public:    &#x2F;**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param preOrder int整型vector      * @param inOrder int整型vector      * @return TreeNode类vector     *&#x2F;    vector&lt;TreeNode*&gt; createTree(vector&lt;int&gt;&amp; preOrder,int pl,int pr, vector&lt;int&gt;&amp; inOrder,int il,int ir)&#123;        vector&lt;TreeNode*&gt; res;        if(pl&gt;pr)&#123;            res.push_back(nullptr);            return res;        &#125;        for(int i&#x3D;il;i&lt;&#x3D;ir;++i)&#123;            if(inOrder[i]&#x3D;&#x3D;preOrder[pl])&#123;                int len&#x3D;i-il;                auto lres&#x3D;createTree(preOrder,pl+1,pl+len,inOrder,il,i-1);                auto rres&#x3D;createTree(preOrder,pl+len+1,pr,inOrder,i+1,ir);                for(auto la:lres)&#123;                    for(auto ra:rres)&#123;                        auto *root&#x3D;new TreeNode(preOrder[pl]);                        root-&gt;left&#x3D;la;                        root-&gt;right&#x3D;ra;                        res.push_back(root);                    &#125;                &#125;            &#125;        &#125;        return res;            &#125;    vector&lt;TreeNode*&gt; getBinaryTrees(vector&lt;int&gt;&amp; preOrder, vector&lt;int&gt;&amp; inOrder) &#123;        &#x2F;&#x2F; write code here        return createTree(preOrder,0,preOrder.size()-1,inOrder,0,inOrder.size()-1);            &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>回溯</strong></p><p>代码未完成，记录下。</p><p>使用了一个哈希表来记录一个值的所有位置，每次使用回溯来遍历，使用一个nodeNum来记录当前path有多少个节点了，当nodeNum到达一定数目就push到节点中（感觉代码中nodeNum减的时候有问题）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * struct TreeNode &#123; *int val; *struct TreeNode *left; *struct TreeNode *right; *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * &#125;; */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstddef></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric></span></span><span class="token keyword">struct</span> <span class="token class-name">VF</span><span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> values<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> flags<span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span>VF <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>values<span class="token operator">==</span>a<span class="token punctuation">.</span>values<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">hash</span><span class="token operator">&lt;</span>VF<span class="token operator">></span><span class="token punctuation">&#123;</span>    size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>VF <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token function">accumulate</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>values<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>values<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>VF<span class="token operator">></span> mmap<span class="token punctuation">;</span>    TreeNode <span class="token operator">*</span>path<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> ans<span class="token punctuation">;</span>    <span class="token keyword">int</span> nodeNum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">/**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param preOrder int整型vector      * @param inOrder int整型vector      * @return TreeNode类vector     */</span>    TreeNode<span class="token operator">*</span> <span class="token function">copyTree</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> root<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>a<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                root<span class="token operator">-></span>left<span class="token operator">=</span><span class="token function">copyTree</span><span class="token punctuation">(</span>a<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-></span>right<span class="token operator">=</span><span class="token function">copyTree</span><span class="token punctuation">(</span>a<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    TreeNode<span class="token operator">*</span> <span class="token function">createTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preOrder<span class="token punctuation">,</span><span class="token keyword">int</span> pl<span class="token punctuation">,</span><span class="token keyword">int</span> pr<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inOrder<span class="token punctuation">,</span><span class="token keyword">int</span> il<span class="token punctuation">,</span><span class="token keyword">int</span> ir<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pl<span class="token operator">></span>pr<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> <span class="token operator">*</span>root<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">[</span>pl<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>nodeNum<span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>root<span class="token operator">-></span>val<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nodeNum<span class="token operator">==</span>preOrder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        TreeNode<span class="token operator">*</span> cur<span class="token operator">=</span><span class="token function">copyTree</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span>root<span class="token operator">-></span>val<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pr<span class="token operator">-</span>pl<span class="token operator">==</span>preOrder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> path<span class="token operator">=</span>root<span class="token punctuation">;</span>        <span class="token keyword">auto</span> it<span class="token operator">=</span>mmap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">[</span>pl<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>it<span class="token operator">-></span>second<span class="token punctuation">.</span>values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>it<span class="token operator">-></span>second<span class="token punctuation">.</span>flags<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                it<span class="token operator">-></span>second<span class="token punctuation">.</span>flags<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> pos<span class="token operator">=</span>it<span class="token operator">-></span>second<span class="token punctuation">.</span>values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> len<span class="token operator">=</span>pos<span class="token operator">-</span>il<span class="token punctuation">;</span>                                root<span class="token operator">-></span>left<span class="token operator">=</span><span class="token function">createTree</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span>pl<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>pl<span class="token operator">+</span>len<span class="token punctuation">,</span>inOrder<span class="token punctuation">,</span>il<span class="token punctuation">,</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                root<span class="token operator">-></span>right<span class="token operator">=</span><span class="token function">createTree</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span>pl<span class="token operator">+</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>pr<span class="token punctuation">,</span>inOrder<span class="token punctuation">,</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>ir<span class="token punctuation">)</span><span class="token punctuation">;</span>                it<span class="token operator">-></span>second<span class="token punctuation">.</span>flags<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token operator">--</span>nodeNum<span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> <span class="token function">getBinaryTrees</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preOrder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inOrder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// write code here</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>inOrder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">auto</span> it<span class="token operator">=</span>mmap<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>inOrder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>it<span class="token operator">==</span>mmap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                mmap<span class="token punctuation">[</span>inOrder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>i<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                mmap<span class="token punctuation">[</span>inOrder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>values<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                mmap<span class="token punctuation">[</span>inOrder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>flags<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">createTree</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>preOrder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>inOrder<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>inOrder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2781. 最长合法子字符串的长度</title>
      <link href="/2023/07/17/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-2781-%E6%9C%80%E9%95%BF%E5%90%88%E6%B3%95%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6-difficult/"/>
      <url>/2023/07/17/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-2781-%E6%9C%80%E9%95%BF%E5%90%88%E6%B3%95%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="2781-最长合法子字符串的长度"><a href="#2781-最长合法子字符串的长度" class="headerlink" title="2781. 最长合法子字符串的长度"></a><a href="https://leetcode.cn/problems/length-of-the-longest-valid-substring/description/">2781. 最长合法子字符串的长度</a></h1><p>First：周赛题，开始想用dp做，感觉始终有点问题</p><hr><p><strong>方法1</strong>：<strong>哈希表+双指针</strong></p><p>由于forbidden字符长度最大为10，可以使用暴力法</p><p>先使用哈希表存储所有的forbidden字符，使用left和right来表示当前合法字符区间。不断移动right指针，每次移动后需要判断以right为末尾的字符是否存在forbidden字符（最多只会判断10次），如果存在则更新left，最大区间长度即为答案</p><ul><li>时间复杂度：O() </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int longestValidSubstring(string word, vector&lt;string&gt;&amp; forbidden) &#123;        unordered_set&lt;string&gt; mset(forbidden.begin(),forbidden.end());        int left&#x3D;0,ans&#x3D;0;        for(int right&#x3D;0;right&lt;word.size();++right)&#123;            for(int i&#x3D;right;i&gt;&#x3D;left&amp;&amp;i&gt;right-10;--i)&#123;                if(mset.count(word.substr(i,right-i+1)))&#123;                    left&#x3D;i+1;                    break;                &#125;            &#125;            ans&#x3D;max(ans,right-left+1);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>AC自动机</strong></p><p>无视长度10的限制，参考<a href="https://leetcode.cn/problems/length-of-the-longest-valid-substring/solutions/2345818/aczi-dong-ji-onjie-fa-wu-shi-chang-du-10-47dy/">https://leetcode.cn/problems/length-of-the-longest-valid-substring/solutions/2345818/aczi-dong-ji-onjie-fa-wu-shi-chang-du-10-47dy/</a></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2779. 数组的最大美丽值</title>
      <link href="/2023/07/17/leetcode/%E6%95%B0%E7%BB%84/leetcode-2779-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%BE%8E%E4%B8%BD%E5%80%BC-middle/"/>
      <url>/2023/07/17/leetcode/%E6%95%B0%E7%BB%84/leetcode-2779-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%BE%8E%E4%B8%BD%E5%80%BC-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="2779-数组的最大美丽值"><a href="#2779-数组的最大美丽值" class="headerlink" title="2779. 数组的最大美丽值"></a><a href="https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/description/">2779. 数组的最大美丽值</a></h1><p>FIrst：周赛题，做着有点迷惑，用排序再找左右边界不知道为啥出错了，有点搞</p><hr><p><strong>方法1</strong>：<strong>双指针</strong></p><p>先对数组进行排序，使用指针left和right来指向一个区间，如果nums[right]-nums[left]大于2*k则移动右指针，否则移动左指针。</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maximumBeauty(vector&lt;int&gt;&amp; nums, int k) &#123;        sort(nums.begin(),nums.end());        int ans&#x3D;1;        int left&#x3D;0,right&#x3D;0;        for(;right&lt;nums.size();++right)&#123;            while(nums[right]-nums[left]&gt;2*k)&#123;                ++left;            &#125;            ans&#x3D;max(ans,right-left+1);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>差分</strong></p><p>使用一个差分数组dif记录增减，依次遍历nums，将dif[nums[i]-k]+&#x3D;1、dif[nums[i]+k+1]-&#x3D;1。最后只需要对差分数组求<strong>前缀和</strong>，<strong>得到的即为每个元素的出现频率</strong>。记录频率最大值作为答案即可。时间复杂度：O(n)</p><blockquote><p>求范围类的题都可以尝试下差分</p></blockquote><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maximumBeauty(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; dif(100001,0);        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            int x&#x3D;nums[i];            int l&#x3D;max(x-k,0);            int r&#x3D;min(x+k+1,100000);            dif[l]+&#x3D;1;            dif[r]-&#x3D;1;        &#125;        int ans&#x3D;0,cur&#x3D;0;        for(int i&#x3D;0;i&lt;dif.size();++i)&#123;            cur+&#x3D;dif[i];            ans&#x3D;max(ans,cur);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型</title>
      <link href="/2023/07/11/c++/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/07/11/c++/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>深度探索C++对象模型，阅读笔记</p><hr><hr><h1 id="第1章-关于对象"><a href="#第1章-关于对象" class="headerlink" title="第1章 关于对象"></a>第1章 关于对象</h1><p>每一个non-inline member func tion 只会诞生一个函数实例。至于每一个“拥有零个或一个定义”的inline function则会在其每一个使用者（模块）身上产生一个函数实例</p><p>C++在布局以及存取时间上主要的额外负担是由virtual引起的，包括：</p><ul><li>virtual function 机制 用以支持一个有效率的“执行期绑定”（runtime binding）。</li><li>virtual base class 用以实现“多次出现在继承体系中的 base class，有一个单一而被共享的实例”。</li></ul><h2 id="1-1-C-对象模式"><a href="#1-1-C-对象模式" class="headerlink" title="1.1 C++对象模式"></a>1.1 C++对象模式</h2><p>在C++中，有两种class data members：static和nonstatic，以及三种class member functions：static、nonstatic和virtual。</p><p><strong>C++对象模型</strong></p><ul><li>Nonstatic data members被配置于每一个class object之内，static data members则被存放在个别的class object之外。</li><li>Static和nonstatic function members也被放在个别的class object之外。</li><li>Virtual functions则以两个步骤支持之：<ol><li>每一个 class产生出一堆指向 virtual functions 的指针，放在virtual table（vtbl）之中</li><li>每一个 class object 被添加了一个指针 vptr，指向相对应的 vtable。vptr 的设置由编译器 全权负责，程序员无需关心。。每一个 class所关联的 type_info object（用以支持 runtime type identification，RTTI）也经由 virtual table被指出来，通常放在表格的第一个 slot</li></ol></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230716151546131.png" alt="" style="zoom:67%;" /><p><strong>引入继承后的对象模型成本</strong>： </p><ul><li>如果是普通的继承，父对象被直接包含在子对象里面，这样对父对象的存取也是直接进行的， 没有额外的成本； </li><li>如果是虚拟继承，则父对象会由一个指针被指出来，这样的话对父对象的存取就添加了一层 间接性，必须经由一个指针来访问，添加了一次间接的额外成本。</li></ul><h2 id="1-2-关键词所带来的差异"><a href="#1-2-关键词所带来的差异" class="headerlink" title="1.2 关键词所带来的差异"></a>1.2 关键词所带来的差异</h2><p><strong>C++优先判断一个语句为声明</strong>：当语言无法区分一个语句是声明还是表达式时，就需用用一个 超越语言范围的规则 —— C++优先判断为声明。</p><p><strong>struct 和 class 关键字的意义</strong>： </p><ul><li>它们之间在语言层面并无本质的区别，更多的是概念和编程思想上的区别。</li><li>struct 用来表现那些只有数据的集合体 POD（Plain OI’ Data）、而 class 则希望表达的 是 ADT（abstract data type）的思想；</li><li>由于这 2 个关键字在本质是无区别，所以 class 并没有必须要引入，但是引入它的确非常令 人满意，因为这个语言所引入的不止是这个关键字，还有它所支持的封装和继承的哲学；</li></ul><p><strong>C++只保证处于同一个 access section 的数据，一定会以声明的次序出现在内存布局当中</strong></p><p><strong>组合（composition），而非继承，才是把 C 和C++结合在一起的唯一可行方法</strong></p><ul><li>只有使用组合时，才能够保证与 C 拥有相同的内存布局，使用继承时的内存布局是不受 C++ Standard 所保证的（很多编译器也可行，但是标准未定义！）。</li></ul><h2 id="1-3-对象的差异"><a href="#1-3-对象的差异" class="headerlink" title="1.3 对象的差异"></a>1.3 对象的差异</h2><p><strong>C++支持三种形式的编译风格</strong>（或称典范 paradigm）： </p><ul><li>面向过程的风格：就像 C 一样，一条语句接一条语句的执行或者函数跳转； </li><li>基于对象的风格（object-based）（或称 ADT）： 仅仅使用了 class 的封装，很多人都是 在用基于对象的风格却误以为自己在使用面向对象的风格； </li><li>面向对象的风格（object-oriented）： 使用了 class 的封装和多态的编程思维（多态才是 真正的面向对象的特征）。 </li><li>纯粹以一种 paradigm 写程序，有助于整体行为的良好稳固。</li></ul><blockquote><p>只有通过pointer或reference来调用函数，才会表现出多态。直接使用object则会在编译器就决定使用当前对象的函数进行调用。</p></blockquote><p>还有一种能引起多态的写法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">(</span><span class="token operator">*</span>point<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">vf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//当 point 指向派生类时也能引发多态，已实验验证。等价于 point->vf();</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>一个 reference 通常是以一个指针来实现的，所以 point 和 reference 并没有本质的区别。</strong></p><p><strong>一个对象的内存布局大小</strong>（通常由 3 部分组成）： </p><ul><li>其 nonstatic data member 的总和大小； </li><li>任何由于位对齐所需要的填补上去的空间； </li><li>加上了为了支持 virtual 机制而引起的额外负担。</li></ul><p><strong>指针的类型</strong>： </p><ul><li>对于内存来说，不同类型的指针并没有什么不同。它们都内是占用一个 word 的大小，包含 一个数字，这个数字代表内存中的一个地址； </li><li>感觉上，指针的类型是编译器的概念，对于硬件来说，并没有什么指针类型的概念； </li><li>转型操作也只是一种编译器的指令，它改变的内是编译器对被指内存的解释方式而已！</li></ul><p><strong>多态只能由指针或引用 来实现，根本原因在于</strong>： </p><ul><li>指针和引用（通常以指针来实现）的大小是固定的（一个 word），而对象的大小却是可变 的。其类的指针和引用可以指向（或引用）子类，但是基类的对象永远也只能是基类，没有变化则不可能引发多态。 </li><li>一个 point 或 reference 绝不会引发任何” “ 与类型有关的内存委托操作 ，在指针类型转换时 会受到的改变的只有它们所指向内存的解释方式而已。（例如指针绝不会引发 slice，因为它 们大小相同）</li></ul><blockquote><p>一个object-based（OB）设计可能比一个对等的OO设计速度更快而且空间更紧凑。速度快是因为所有的函数调用操作都在编译时期解析完成，对象建构起来时不需要设置 virtual机制；空间紧凑则是因为每一个class object 不需要负担传统上为了支持virtual机制而需要的额外负荷。不过，OB设计比较没有弹性。</p></blockquote><h1 id="第2章-构造函数语意学"><a href="#第2章-构造函数语意学" class="headerlink" title="第2章 构造函数语意学"></a>第2章 构造函数语意学</h1><blockquote><p>trivial：没有用的                nontrivial：有用的                      </p><p>memberwise：对每一个member施以……               bitwise：对每一个bit施以……</p></blockquote><h2 id="2-1-Default-Constructor的构造操作"><a href="#2-1-Default-Constructor的构造操作" class="headerlink" title="2.1 Default Constructor的构造操作"></a>2.1 Default Constructor的构造操作</h2><p>C++中对于默认构造函数的解释是：<strong>默认的构造函数会在需要的时候被编译器产生出来</strong>。 </p><ul><li>谁需要？是程序的需要还是编译器的需要？如果是程序的需要，那是程 序员的责任；</li><li>只有在是编译器的需要时，默认构造函数才会被编译器产生出来，而且被产生出来 的默认构造函数只会执行编译器所需要的行动，而且这个产生操作只有在默认构造函数真正被调 用时才会进行合成。</li></ul><p><strong>区分 trivial 和 notrivial构造函数</strong>： </p><ul><li>只有编译器需要的时候（为什么会需要？后面讲的很清楚），合成操作才是 notrivial 的， 这样的函数才会被真正的合成出来； </li><li>如果编译器不需要，而程序员又没有提供，这时的默认构造函数就是 trivial 的。虽然它在概 念上存在，但是编译器实际上根本不会去合成出来，因为他不做任何有意义的事情，所以当 然可以忽略它不去合成。trivial 的函数只存在于概念上，实际上不存在这个函数。</li></ul><p><strong>变量的初始化：只有全局变量和静态变量才会保证初始化</strong>，其中静态变量可以视为全局变量 的一种，因它静态变量也是保存在全局变量的存储空间上的。</p><ul><li>Golbal objects 的内存保证会在程序激活的时候被清 0；Local objects 配置于程序的堆栈中， Heap objects 配置于自由空间中，都不一定会被清为 0,它们的内容将是内存上次被使用后的痕 迹！</li></ul><p>类声明头文件可以被许多源文件所包含，如何避免合成默认构造函数、拷贝构造函数、析构函数、 赋值拷贝操作符（4 大成员函数）时不引起函数的重定义？</p><ul><li>解决方法是以 inline 的方式完成，如果函数太复杂不适合 inline，就会合成一个 explicit noninline static 实体（Static 函数独立于编译单元）。</li></ul><p>如果 class A 内含一个或以上的 member objects，那么 A 的 constructor 必须调用每一个 member class 的默认构造函数。 具体方法是： </p><ul><li>编译器会扩张 constructors ，在其中安插代码使得在 user code 被调用之前先调 用 member objects 的默认构造函数（当然如果需要调用基类的默认构造函数，则放在基类的 默认构造函数调用之后：基类构造函数 -&gt; 成员构造函数 -&gt;user code）</li><li>C++要求以“member objects 在 class 中的声明次序”来调用各个 construtors。这就是声明 的次序决定了初始化次序（构造函数初始化列表一直要求以声明顺序来初始化）的根本原因！</li></ul><p><strong>virtual相关class</strong></p><ul><li>带有 virtual functions 的类的默认构造函数毫无疑问是 notrivial 的，需要编译器安插额外的 成员 vptr 并在构造函数中正确的设置好 vptr，这是编译器的重要职责之一。 </li><li>带有 virtual base class 的类的默认构造函数同样也毫无疑问的 notrivial，编译器需要正确设 置相关的信息以使得这些虚基类的信息能够在执行时准备妥当，这些设置取决于编译实现虚基类 的手法。</li></ul><p><strong>编译器有 4 种情况会使得编译器真正的为 class 生成 nontrivial 的默认构造函数</strong>，这个 nontrivial 的默认构造函数只满足编译器的需要（调用 member objects 或 base class 的默 认构造函数、初始化 virtual function 或 virutal base class 机制）。其它情况时，类在概念 上拥有默认构造函数，但是实际上根本不会被产生出来（即前面的区分 trivial 和 notrivial）。</p><p><strong>C++新手常见的 2 个误区</strong>： </p><ol><li>ERROR: 如果 class 没有定义 default constructor 就会被合成一个； <ul><li>首先定义了其它的 constructor 就不会合成默认构造函数，再次即使没有定义任何构造函数 也不一定会合成 default constructor，可能仅仅是概念上有，但实际上不合成出来。</li></ul></li><li>ERROR: 编译器合成出来的默认构造函数会明确设定每一个 data member 的默认值； <ul><li>明显不会，区分了 Global objects, Stack objects, Heap objects 就非常明白了只有在 Global 上的 objects 会被清 0，其它的情况都不会保证被清 0。</li></ul></li></ol><blockquote><p>在合成的 default constructor 中，只有 base class subobjects 和 member clas s objects会被初始化。所有其他的nonstatic data member（如整数、整数指针、整数数组等等）都不会被初始化。</p></blockquote><h2 id="2-2-Copy-Constructor的构造操作"><a href="#2-2-Copy-Constructor的构造操作" class="headerlink" title="2.2 Copy Constructor的构造操作"></a>2.2 Copy Constructor的构造操作</h2><p>有三种情况，会以一个object的内容作为另一个class object的初值：</p><ul><li>对一个object做显式的初始化操作，即直接&#x3D;赋值</li><li>object被当做参数交给某个函数时</li><li>当函数传回一个class object时</li></ul><h3 id="Default-Memberwise-Initialization"><a href="#Default-Memberwise-Initialization" class="headerlink" title="Default Memberwise Initialization"></a><strong>Default Memberwise Initialization</strong></h3><ul><li><p>当class object 以“相同 class 的另一个 object”作为初值，其内部是以所谓的 default memberwise initialization手法完成的：</p></li><li><p>即把每一个内建的或派生的data member（例如一个指针或一个数组）的值，从某个object拷贝一份到另一个object身上。不过它不会拷贝其中的 member class object，而是以递归的方式施行memberwise initialization。</p></li></ul><p><strong>C++S tandard 把copy constructor 区分为 trivial 和nontrivial 两种。只有 nontrivial 的实例才会被合成于程序之中。决定一个 copy constructor 是否为 trivial 的标准在于 class 是否展现出所谓的“bitwise copy semantics”</strong></p><p>一个class不展现出“bitwise copy semantics”的4种情况：</p><ol><li><p>当class内含一个member object 而后者的class声明有一个copy constructor时（不论是被 class设计者显式地声明或是被编译器合成）。</p></li><li><p>当 class继承自一个 base class而后者存在一个 copy constructor时（不论是被显式声明或是被合成而得）。</p></li><li><p>当 class声明了一个或多个 virtual functions时。</p></li><li><p>当 class派生自一个继承串链，其中有一个或多个 virtual base classes时。</p><blockquote><p>由于带虚函数类会多一个虚函数表和虚函数指针，因此对于拷贝构造需要正确对虚函数指针进行赋值</p><ul><li>同一个类的对象，即使继承带虚函数，可以直接靠“bitwise copy semantics”完成拷贝构造。</li><li>但是对于派生类给基类赋值，则需要重新设置虚函数指针，因此需要生成一个构造函数</li></ul></blockquote><blockquote><p>一个class object 如果以另一个object作为初值，而后者有一个virtual base class subobject，那么也会使“bitwise copy semantics”失效。</p><ul><li>例如A是基类，B继承A，C继承B；如果B的对象给C的对象进行赋值，那么就需要合成一个拷贝构造函数，安插一些代码以设定virtual base class pointer&#x2F;offset 的初值，对每一个members执行必要的memberwise初始化操作，以及执行其他的内存相关工作</li><li>简单说还是上述那套规则，继承的类中不能有虚函数。</li></ul></blockquote></li></ol><p><strong>不要随意提供 copy constructor</strong>， 对于满足 bitwise copy semantics 的类来说，编译器自 动生成的拷贝构造函数自动地使用了位拷贝（这是效率最高的），如果你自己随意提供 copy constructor 就会压抑掉编译器的这个行为，画蛇添足还影响了效率。</p><h2 id="2-3-程序转化语意学"><a href="#2-3-程序转化语意学" class="headerlink" title="2.3 程序转化语意学"></a>2.3 程序转化语意学</h2><p>编译器通常会对代码进行转化，其操作可能和直观的并不同</p><p><strong>显式的初始化操作</strong></p><ul><li><p>例如以一个X的示例x0来初始化值，其并没有直接调用拷贝构造函数，可能会被转化。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711113449177.png" alt="" style="zoom:50%;" /></li><li><p>其转化有两个阶段：重写每一个变量定义，其中的初始化操作会被剥除；class的 copy constructor调用操作会被安插进去。会被转换成如下结果：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711113758369.png" alt="" style="zoom:50%;" /></li></ul><p><strong>参数的初始化</strong></p><ul><li>当函数参数是一个非引用或指针类型的变量时，如果传入参数，有的编译器会先构建一个临时对象，在调用拷贝构造，然后重写函数调用操作（为了避免再赋值，将原来的参数类型改为引用）</li><li>另一种实现方法是以“拷贝建构”（copy construct）的方式把实际参数直接建构在其应该的位置上，此位置视函数活动范围的不同，记录于程序堆栈中。在函数返回之前，destructor会被执行。</li></ul><p><strong>返回值的初始化</strong></p><ul><li><p>首先加上一个额外参数，类型是 class object的一个 reference。这个参数将用来放置被“拷贝建构（copy constructed）”而得的返回值。</p></li><li><p>在 return指令之前安插一个 copy constructor调用操作，以便将欲传回之object的内容当做上述新增参数的初值。</p></li><li><p>以下函数将被转换，且其调用处也会被相应转换</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711114732784.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711114744038.png" alt="" style="zoom:50%;" /></li></ul><p><strong>在使用者层面做优化</strong></p><ul><li>对一些通过定义变量进行操作再返回的函数，可以通过定义一个新的构造函数来避免一次拷贝</li></ul><p><strong>在编译器层面做优化</strong></p><ul><li>Named Return Value（NRV）：将需返回的局部变量修改为在参数列表中定义引用，从而减少拷贝</li></ul><h2 id="2-4-成员列表初始化"><a href="#2-4-成员列表初始化" class="headerlink" title="2.4 成员列表初始化"></a>2.4 成员列表初始化</h2><p>编译器会一一操作initialization list，以适当顺序在constructor之内安插初始化操作，并且在任何explicit user code之前。</p><ul><li>成员初始化顺序是由声明顺序决定，而不是初始化列表排列顺序决定。</li></ul><p>以下情况必须使用member initialization list：</p><ol><li>当初始化一个reference member时；</li><li>当初始化一个 const member时；</li><li>当调用一个 base class的 constructor，而它拥有一组参数时；</li><li>当调用一个 member class的 constructor，而它拥有一组参数时。</li></ol><p>如果不适用列表初始化，而在构造函数中初始化，那么编译器会</p><ul><li><p>先使用默认构造函数生成一个对象，且用初始化值生成一个临时对象</p></li><li><p>然后以赋值方式将临时对象拷贝给想要初始化的对象，最后再讲临时对象销毁。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711155120575.png" alt="" style="zoom:50%;" /></li></ul><h1 id="第3章-Data语意学"><a href="#第3章-Data语意学" class="headerlink" title="第3章 Data语意学"></a>第3章 Data语意学</h1><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711160518505.png" alt="" style="zoom:67%;" /><p>如上定义，X大小为1，Y、Z对象大小为4，A大小为8</p><ul><li>X对象虽然无数据，为了使得这一class的两个objects得以在内存中配置独一无二的地址，编译器会安插一个char</li><li>YZ大小受三个因素影响：<ul><li>语言本身所造成的额外负担：虚函数指针需要占4个字节</li><li>编译器对于特殊情况所提供的优化处理：有的编译器不会优化X所占的一个字节，有的会优化</li><li>Alignment的限制：为了更有效的存储，数据存储需要对齐</li></ul></li><li>A的大小由两个虚函数指针构成，X的一个占位字节会被优化</li></ul><p>C++对象模型把数据直接存放在每一个class object 之中。对于继承而来的nonstatic data members （不管是virtual还是nonvirtual）也是如此。不过并没有强制定义其间的排列顺序。</p><p>静态成员变量被放置在程序的一个global data segment 中，不会影响个别的class object的大小。在程序之中，不管该class被产生出多少个objects，静态成员变量永远只存在一份实例</p><h2 id="3-1-Data-Member的绑定"><a href="#3-1-Data-Member的绑定" class="headerlink" title="3.1 Data Member的绑定"></a>3.1 Data Member的绑定</h2><p><strong>应尽量将class成员变量定义在函数出现之前，即把变量定义在class起始处</strong></p><p>如下图所示，两个函数的length都会被判断为int，只有当length成员定义出现后，才会认为length是float类型</p><ul><li><p>注意，只有函数参数才会出现这种情况，函数内部不会（因为函数内部对类型进行分析是在整个class声明出现之后才进行）。</p></li><li><p>在下图中，如果打印val类型，经测试会输出int</p></li><li><p>远古时期如果定义一个全局变量和成员变量同名，那么成员变量没出现之前，class中的函数会使用全局变量。但这种情况已经得到修正。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711162911644.png" alt="" style="zoom:50%;" /><p><strong>对 member functions 本身的分析会直到整个 class 的声明都出现了才开始（函数参数会一出现就进行分析）</strong>。所以 class 的 member functions 可以引用声明在后面的成员，C 语言就做不到。</p><h2 id="3-2-Data-Member的布局"><a href="#3-2-Data-Member的布局" class="headerlink" title="3.2 Data Member的布局"></a>3.2 Data Member的布局</h2><p>非静态成员在class object中的排列顺序将和其被声明的顺序一样，任何中间介入的静态都不会被放进对象布局之中。</p><ul><li>在同一个access section（也就是private、public、protected等区段）中，members的排列只需符合“较晚出现的members在class object 中有较高的地址”这一条件即可，即各个members并不一定得连续排列。例如可能中间进行对齐。</li><li>C++Standard也允许编译器将多个access sections之中的data members自由排列，不必在乎它们出现在class声明中的顺序。但目前所有编译器都是依照声明的顺序进行排列，且例如多个private不会带来损耗，其会将所有private连成一个。</li></ul><h2 id="3-3-Data-Member的存取"><a href="#3-3-Data-Member的存取" class="headerlink" title="3.3 Data Member的存取"></a>3.3 Data Member的存取</h2><p>成员变量存取成本几何？对象存取变量和指针存取变量是否有差异？</p><p><strong>当变量是静态成员变量</strong></p><ul><li>每次取静态成员变量，会被内部转化为对该唯一extern实例的直接参考操作，不会有任何空间上或执行时间上的额外负担</li><li>通过指针或对象存取变量执行的指令完全相同，也是唯一完全相同的情况</li><li>即使该静态成员变量是由虚拟派生出来的，也是直接存取</li><li>静态成员变量是放在data segment中，因此需要对其进行重新命名以避免命名冲突</li></ul><p><strong>当变量非静态成员变量</strong></p><ul><li>欲对一个非静态成员变量进行存取操作，编译器需要把class object的起始地址加上data member的偏移位置</li><li>每个成员的偏移在编译即可获知，因此存取一个非静态成员，其效率和存取一个C struct member或一个nonderived class的member是一样的。</li><li><em>如果待存取成员是由virtual base class继承而来，使用对象和指针访问就存在巨大差异</em><ul><li>使用指针访问时无法确定该指针指向哪种类型，也就不知道偏移位置，所以这个存取操作必须延迟至执行期，经由一个额外的间接导引，才能够解决。</li><li>但如果使用对象进行存取，其偏移位置在编译时期就固定了，因此在编译时就知道存取哪个位置</li></ul></li></ul><h2 id="3-4-“继承”与Data-Member"><a href="#3-4-“继承”与Data-Member" class="headerlink" title="3.4 “继承”与Data Member"></a>3.4 “继承”与Data Member</h2><p>假设将一个类的成员变量分裂成三层结构，其通过继承得到，继承后的内存布局不会和直接在一个类中声明变量一样。</p><ul><li><p>例如如下将Concrete类分裂</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711194303670.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230717163719889.png" alt="" style="zoom:50%;" /></li><li><p>分裂后的concrete3对象会占据16字节，而原来的concrete只需要8个字节，其原因是不会将bit2和bit3成员变量填充到concrete1的填充上。内存布局如下图所示。</p><ul><li>不填充原因：如果填充了，那么当使用concrete1对象给concrete2对象进行复制操作时，bit2变量就会被指定一个数值，而这是不被期望的。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711194546570.png" alt="" style="zoom:50%;" /></li></ul><p><strong>C++ Standard 保证：“出现在派生类中的 base class subobject 有其完整原样性！”</strong> </p><ul><li>子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节 也是父类的一部分，也是不可分割的。</li></ul><h3 id="加上多态"><a href="#加上多态" class="headerlink" title="加上多态"></a><strong>加上多态</strong></h3><ul><li>使用虚函数会给类带来空间和存取时间上的额外负担：<ul><li>导入一个virtual table，用来存放它所声明的每一个virtual functions 的地址。这个table 的元素个数一般而言是被声明的virtual functions的个数，再加上一个或两个 slots（用以支持 runtime type identification）。</li><li>在每一个class object中导入一个vptr，提供执行期的链接，使每一个object能够找到相应的 virtual table。</li><li>加强 constructor，使它能够为 vptr 设定初值，让它指向 class 所对应的virtual table。</li><li>加强 destructor，使它能够抹消“指向 class之相关 virtual table”的 vptr。</li></ul></li><li>在早期vptr通常放在尾端，这保留了C的兼容性，允许在C程序代码中也能使用。后来是把vptr放在首段，是的不需要计算vptr的偏移，代价就是丧失了C语言兼容性。</li></ul><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a><strong>多重继承</strong></h3><ul><li>把一个派生类指定给一个基类，在实现上会按照基类在派生类中的内存布局加上偏移进行赋值</li><li>c++标准并未规定各基类的布局</li><li>多重继承中，可能会有多个 vptr 指针，视其继承体系而定：<strong>派生类中 vptr 的数目最等于所有基 类的 vptr 数目的总和</strong>。</li></ul><h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a><strong>虚拟继承</strong></h3><ul><li><p>iostream是最常见的虚拟继承例子，实现虚拟继承要找到一个足够有效的方法，将istream和ostream各自维护的一个ios subobject，折叠成为一个由iostream维护的单一 ios subobject，并且还可以保存 base class 和 derived class 的指针之间的多态指定操作</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711200602246.png" alt="" style="zoom:50%;" /></li><li><p><em>一般的实现方法</em>：Class 如果内含一个或多个 virtual base class subobjects，例如istream将被分割为两部分：一个不变区域和一个共享区域。不变区域中的数据，不管后继如何衍化，总是拥有固定的offset（从object的开头算起），所以这一部分数据可以被直接存取。至于共享区域，所表现的就是virtual base class subobject。这一部分的数据，其位置会因为每次的派生操作而有变化，所以它们只可以被间接存取。各家编译器实现技术之间的差异就在于间接存取的方法不同，以下两种主流策略：</p><ol><li><strong>一种做法是直接使用一个指针指向虚基类</strong>。先安排好derived class的不变部分，然后再建立其共享部分。在每一个derived class object中安插一些指针，每个指针指向一个virtual base class，以此存取共享部分。<ul><li>缺点：每一个对象必须针对其每一个 virtual base class 背负一个额外的指针；由于虚拟继承串链的加长，导致间接存取层次的增加。</li><li>缺点解决方法：通过设置一个virtual base class table或在virtual function table中放置virtual base class的offset（而不是地址）;第二个问题通过将不断嵌套的虚拟基类指针拷贝到派生类中，从而得到固定时间存取。</li></ul></li><li><strong>另一种做法是在 vtable 中放置 virtual base class 的 offset</strong><ul><li>这种方式好处在于： vptr 是已经存在的成本，而 vtable 是 class 的所有 objects 所共享的成本。对于每一个 class object 没有引入任何的额外成本，仅仅在 vtable 多 存储了一个 slot 布局，而前一种方式却对每一个 object 都引了两个指针的巨大成本。</li></ul></li></ol></li><li><p>这两种虚基类方式都是把虚基类放在内存中模型中的最后面，然后借由一层间接性（指针或 offset）来 访问。</p></li><li><p>一个使用指针指向虚基类的例子内存布局如下：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711202559012.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711202609004.png" alt="" style="zoom:67%;" /></li></ul><h2 id="3-5-对象成员的效率"><a href="#3-5-对象成员的效率" class="headerlink" title="3.5 对象成员的效率"></a>3.5 对象成员的效率</h2><p>在简单的类封装测试中，如果把优化打开，封装不会带来执行期的效率成本</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711203410103.png" alt="" style="zoom:50%;" /><p>单一继承应该不会影响效率，因为 members 被连续存储于 derived class object中，并且其offset在编译时期就已知了。而虚拟继承则通过会通过一个间接层访问，因此带来效率下降。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711203637859.png" alt="" style="zoom: 50%;" /><h2 id="3-6-指向Data-Members的指针"><a href="#3-6-指向Data-Members的指针" class="headerlink" title="3.6 指向Data Members的指针"></a>3.6 指向Data Members的指针</h2><p>取某个成员变量的地址会得到其在class中的偏移，但是结果会比真实结果多1，原因下面解释。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711203842598.png" alt="" style="zoom: 80%;" /><p>而以下则是取一个“绑定于真正class object身上的data member”的地址，将会得到该member在内存中的真正地址</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711204825218.png" alt="" style="zoom:80%;" /><p><strong>如何区分一个“没有指向任何data me mber”的指针，和一个指向“第一个data member”的指针？</strong></p><ul><li>考虑这样的例子：</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711204608316.png" alt="" style="zoom:50%;" /><ul><li>为了区分p1和p2，每一个真正的member offset值都被加上1。因此，在真正使用该值以指出一个 member 之前，先减掉1。</li></ul><h1 id="第4章-Function语意学"><a href="#第4章-Function语意学" class="headerlink" title="第4章 Function语意学"></a>第4章 Function语意学</h1><p>当调用虚函数、普通函数、静态函数时，通过对象调用和通过指针调用可能会有不同。</p><h2 id="4-1-Member-的各种调用方式"><a href="#4-1-Member-的各种调用方式" class="headerlink" title="4.1 Member 的各种调用方式"></a>4.1 Member 的各种调用方式</h2><p><strong>非静态成员函数</strong></p><ul><li>其调用开销和非成员函数一样</li><li>编译器会将每个成员函数转换为非成员函数，过程如下：<ol><li>改写函数参数列表，添加一个相应类的this指针</li><li>将每一个对 nonstatic data member 的存取操作改为经由 this指针来存取</li><li>将 member function重新写成一个外部函数。将函数名称经过“mangling”处理（将类名编译进去）</li><li>将该函数调用处进行转换，由obj.fun形式改成func(obj)形式</li></ol></li></ul><blockquote><p><strong>名称的特殊处理</strong></p><ul><li>member的名称前面会被加上class名称，形成独一无二的命名（避免派生时出现同名变量）</li><li>member functions 可以被重载化，所以将参数类型添加到函数名中</li></ul></blockquote><p><strong>虚拟成员函数</strong></p><ul><li><p>如果normalize（）是一个virtual member function，那么以下的调用会被如下转化：</p><ul><li>vptr表示由编译器产生的指针，指向 virtual table。1是 virtual table slot的索引值，关联到 normalize（）函数。 第二个 ptr表示 this指针。</li><li>事实上，vptr 的名称会被加上 mangled，因为对于一个复杂的派生体系，可能会有多个 vptr</li><li>但使用对象进行调用时，由于已经确定调用哪个类的函数，因此没必要再使用虚函数表来间接访问</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711221328144.png" alt="" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711221334457.png" alt="" style="zoom:67%;" /></li></ul><p><strong>静态成员函数</strong></p><ul><li><p>如果normalize（）是一个static member function，以下两个调用操作，将被转换为一般的nonmember函数调用</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711221753421.png" alt="" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711221759273.png" alt="" style="zoom:67%;" /></li><li><p>静态成员函数的主要特性就是它没有this指针，以下的次要特性统统根源于其主要特性：</p><ul><li>它不能够直接存取其 class中的 nonstatic members。</li><li>它不能够被声明为 const、volatile或 virtual。</li><li>它不需要经由 class object 才被调用——虽然大部分时候它是这样被调用的！</li></ul></li></ul><h2 id="4-2-Virtual-Member-Functions（虚拟成员函数）"><a href="#4-2-Virtual-Member-Functions（虚拟成员函数）" class="headerlink" title="4.2 Virtual Member Functions（虚拟成员函数）"></a>4.2 Virtual Member Functions（虚拟成员函数）</h2><p>这节主要是将虚函数表的必要以及作用</p><p>多态时，使用指针调用函数，无法知道指向的是哪个函数，需要额外信息才能正确调用相应函数。因此，在每个具有虚函数的类前添加一个虚函数表指针，其指向的虚函数表存储的是函数地址。</p><ul><li><p>每一个virtual table内含其对应之class object 中所有active virtual functions函数实例的地址，包括：</p><ol><li><p>这一 class 所定义的函数实例。它会改写一个可能存在的base class virtual function函数实例。</p></li><li><p>继承自 base class 的函数实例。这是在 derived class 决定不改写 virtual function时才会出现的情况。</p></li><li><p>一个 pure_virtual_called（）函数实例，它既可以扮演 pure virtual function的空间保卫者角色，也可以当做执行期异常处理函数。</p></li></ol></li><li><p>每一个virtual function都被指派一个固定的索引值，这个索引在整个继承体系中保持与特定的virtual function的关系。</p></li><li><p>虚函数表编号0的位置存储的是对应类的信息（type_info，RTTI）</p></li><li><p>因此，对于指针调用函数可以被转化如下，vptr表示编译器所安插的指针，指向virtual table；4表示z（）被指派的slot编号</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712103348842.png" alt="" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712103402268.png" alt="" style="zoom:80%;" /></li></ul><h3 id="多重继承下的-Virtual-Functions"><a href="#多重继承下的-Virtual-Functions" class="headerlink" title="多重继承下的 Virtual Functions"></a><strong>多重继承下的 Virtual Functions</strong></h3><p>单继承下对于基类指针指向派生类时，无需移动指针。而多继承下，第二个基类及之后的指针指向的派生类时，无论是调用虚函数，还是delete对象（其实也是虚函数）都需要移动指针（加上或减去一个offset）</p><ul><li>比如对于简单的 delete 操作： deleta base2;由于 base2 可能没有指向对象的起始地址，这样简单的删除操作会引发灾难，所以需要对 base2 做执行期 的调整才能正确的 delete 对象。</li></ul><p>上述移动offset需要记录，使用了一种名叫thunk的技术，一个示例如下（其实就是预置了一个offset）。虚函数表中存储的既可以是虚函数地址，也可以存储一个thunk地址。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712112033531.png" alt="" style="zoom:67%;" /><p>可能是通过派生类（或第一个base class）指针调用，也可能是通过第二个base class指针调用，同一函数在virtual table中可能需要多笔对应的slots，因此多重继承下会有多个虚函数表。</p><ul><li><p>在多重继承之下，一个derived class内含n-1个额外的virtual tables，n表示其上一层base classes的个数（因此，单一继承将不会有额外的virtual tables）</p></li><li><p>一个示例如下，注意第一个虚拟表中多了一个mumble函数（derived类中只重写了析构函数和clone函数）</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712112503789.png" alt="" style="zoom:67%;" /></li></ul><blockquote><p>多个vptr不是放置一起的，应该是放置在各subclass首部或末尾</p></blockquote><h3 id="虚拟继承下的-Virtual-Functions"><a href="#虚拟继承下的-Virtual-Functions" class="headerlink" title="虚拟继承下的 Virtual Functions"></a><strong>虚拟继承下的 Virtual Functions</strong></h3><ul><li><p>在虚拟继承下，即使只继承一个class，也会存在两个虚函数表，也需要调整this指针位置</p></li><li><p>下面内存布局应该就是虚继承下的基于offset指向基类的布局（另一种是基于指针指向基类）</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712113201347.png" alt="" style="zoom:80%;" /></li></ul><blockquote><p>Lippman 建议：<strong>不要在一个 virtual base class 中声明 nonstatic data members</strong>。如果一 定要这么做，那么你会距离复杂的深渊愈来愈近，终不可拔。</p></blockquote><h2 id="4-3-函数的效能"><a href="#4-3-函数的效能" class="headerlink" title="4.3 函数的效能"></a>4.3 函数的效能</h2><h2 id="4-4-指向Member-Function的指针Pointer-to-Member-Functions"><a href="#4-4-指向Member-Function的指针Pointer-to-Member-Functions" class="headerlink" title="4.4 指向Member Function的指针Pointer-to-Member Functions"></a>4.4 指向Member Function的指针Pointer-to-Member Functions</h2><p>取一个nonstatic member function的地址，如果该函数是nonvirtual，得到的结果是它在内存中真正的地址。但是仍然需要this指针才能调用该函数。</p><h3 id="支持“指向-Virtual-Member-Functions”的指针"><a href="#支持“指向-Virtual-Member-Functions”的指针" class="headerlink" title="支持“指向 Virtual Member Functions”的指针"></a><strong>支持“指向 Virtual Member Functions”的指针</strong></h3><ul><li><p><strong>对一个 virtual member function 取其地址，所能获得的只是一个 vtable 中的索引值。</strong></p></li><li><p>对于虚函数取地址得到的指针，也可以通过调用执行该函数，其在编译时期会被转化</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712161836240.png" alt="" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712161843601.png" alt="" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712162225187.png" alt="" style="zoom: 67%;" /></li><li><p>对一个virtual function取地址，其地址在编译时期是未知的，所能知道的仅是在virtual table中的索引值。因此，对一个virtual member function取其地址，所能获得的只是一个索引值。</p></li><li><p>那么编译器如何知道该指针到底是索引值还是一个地址？</p><ul><li><p>cfront中通过判断其大小，如果小于等于128，则视为索引值，否则视为地址</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712162021772.png" alt="" style="zoom:50%;" /></li></ul></li></ul><h3 id="在多重继承之下，指向-Member-Functions的指针"><a href="#在多重继承之下，指向-Member-Functions的指针" class="headerlink" title="在多重继承之下，指向 Member Functions的指针"></a><strong>在多重继承之下，指向 Member Functions的指针</strong></h3><ul><li><p>设置了一个单独结构体来存储信息，但这会使得每个指针调用开销变大，微软使用了一个vcall thunk来解决</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712163152150.png" alt="" style="zoom:67%;" /></li></ul><h3 id="“指向-Member-Functions之指针”的效率"><a href="#“指向-Member-Functions之指针”的效率" class="headerlink" title="“指向 Member Functions之指针”的效率"></a><strong>“指向 Member Functions之指针”的效率</strong></h3><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712163331440.png" alt="" style="zoom:50%;" /><h2 id="4-5-Inline-Functions"><a href="#4-5-Inline-Functions" class="headerlink" title="4.5 Inline Functions"></a>4.5 Inline Functions</h2><p>处理一个inline函数，有两个阶段：</p><ol><li>分析函数定义，以决定函数的“intrinsic inline ability”。如果函数因其复杂度，或因其建构问题，被判断不可成为inline，它会被转为一个<em>static函数</em></li><li>真正的 inline函数扩展操作是在调用的那一点上。这会带来参数的求值操作（evaluation）以及临时性对象的管理。</li></ol><h3 id="形式参数（Formal-Arguments）"><a href="#形式参数（Formal-Arguments）" class="headerlink" title="形式参数（Formal Arguments）"></a><strong>形式参数（Formal Arguments）</strong></h3><ul><li><p>在inline扩展期间，每一个形式参数都会被对应的实际参数取代。</p><ul><li>如果实际参数是一个常量表达式，可以在替换之前先完成其求值操作，然后就可以把常量直接“绑”上去。</li><li>如果既不是个常量表达式，也不是个带有副作用的表达式，那么就直接代换之。</li><li>如果是一个会带来副作用的实际参数（例如函数），通常都需要引入临时性对象。</li></ul></li><li><p>inline 函数扩展时的实际参数取代形式参数的过程，会聪明地引入临时变量来避免重复求值。</p></li><li><p>例子如下：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712164704158.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712164711655.png" alt="" style="zoom:50%;" /><img src="C:\Users\MyPC\AppData\Roaming\Typora\typora-user-images\image-20230712164742328.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712164751816.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712164812153.png" alt="" style="zoom:50%;" /></li></ul><h3 id="局部变量（Local-Variables）"><a href="#局部变量（Local-Variables）" class="headerlink" title="局部变量（Local Variables）"></a><strong>局部变量（Local Variables）</strong></h3><ul><li><p>inline函数中的每一个局部变量都必须被放在函数调用的一个封闭区段中，拥有一个独一无二的名称</p></li><li><p>如果inline函数在同一位置被扩展多次，则每次扩展都需要自己的一组局部变量。如果inline函数不同地方被扩展多次，那么只需一组局部变量，就可以重复使用（这里翻译有点迷）</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712165142950.png" alt="" style="zoom:50%;" /></li></ul><blockquote><p>inline 中再调用 inline 函数，可能使得表面上一个看起来很平凡的 inline 却因连锁的复杂性而 没有办法扩展开来。</p></blockquote><h1 id="第5章-构造、析构、拷贝语意学"><a href="#第5章-构造、析构、拷贝语意学" class="headerlink" title="第5章 构造、析构、拷贝语意学"></a>第5章 构造、析构、拷贝语意学</h1><p><strong>C++隐式生成的 4 大成员函数，在不是真正需要的情况下都不要自己去声明</strong>。 </p><ul><li>因为如果是 trivial 的，这些函数不会被真正的合成出来（只存在于概念上），当然也就没有调 用的成本了，去提供一个 trivial 的成员反而是不符合效率的。</li></ul><h2 id="5-1-“无继承”情况下的对象构造"><a href="#5-1-“无继承”情况下的对象构造" class="headerlink" title="5.1 “无继承”情况下的对象构造"></a>5.1 “无继承”情况下的对象构造</h2><h3 id="纯虚函数的存在"><a href="#纯虚函数的存在" class="headerlink" title="纯虚函数的存在"></a><strong>纯虚函数的存在</strong></h3><ul><li>纯虚函数也可以被实现和调用。纯虚函数不能在类的声明中提供实现，只能在类声明的外部来提供默认的实现；</li><li>基类的纯虚函数的默认实现必须由派生类显式的要求调用；</li><li>派生类不会自动继承这个纯虚函数的定义，如果派生类未实现纯虚函数，那么其依然是一个抽 象类型； </li><li>这种 pure virtual 函数还提供实现的方案比较好的应用场景为：基类提供了一个默认的实现， 但是不希望自动的继承给派生类使用，除非派生类明确的要求。</li><li>还需要注意这个纯虚函数为析构函数的情况。C++语言保证继承体系中的每一个 class object 的 destructors 都会被调用。所以<strong>编译器一定会扩展派生类的析构函数去显式地调 用基类的析构函数</strong>。 </li><li>另外一个重要的应用场景：有些情况下会把析构函数声明为纯虚。这时，必须为纯虚析构函 数提供一个默认的实现。否则，派生类的析构函数由于编译器的扩展而显式的调用基类的析 构函数时会找不到定义。同时编译器也无法为已经声明为纯虚的析构函数生成一个默认的实 现。</li></ul><h3 id="虚函数中的-const-哲学："><a href="#虚函数中的-const-哲学：" class="headerlink" title="虚函数中的 const 哲学："></a><strong>虚函数中的 const 哲学</strong>：</h3><p><strong>一个虚函数该不该被定义为 const 呢？</strong></p><ul><li>一个虚函数在基类中不需要修改 data member 并不意味着派生类改写它时一定不会修改 data member</li></ul><p>观念上，编译器会为每一个类产生 4 个函数： dafault constructor, destructor, copy constructor, copy assignment operator。 但是，切记这仅仅是观念上的，<strong>trivial 的函数不会被真正的产生出来</strong>。</p><p>理论上：A *pa1 &#x3D; new A; 和 A *pa2 &#x3D; new A(); 之间是有差别的，前一个应该不会调用默认构造函数而后一个会。但是在 GCC 和 VS2010 的实验中发现，这 2 个写法是完全没有区别的， 默认的构造函数都被调用了。</p><p><strong>对于可以视为 POD 的 class（ 没有声明构造函数、没有 virtual 机制等等），就可以使用 POD 结构特有的 initialization list 进行初始化。</strong></p><p><strong>引入 virtual function 会给对象的构造、拷贝和析构等过程带来的负担</strong>如下： </p><ul><li>constructor 必须被安插一些代码以便将 vptr 正确的初始化，这些代码需要被安插在任何 base class constructors 的调用之后，但必须在任何 user code 的代码之前； </li><li>合成 copy constructor 和 copy assignment operator，因为它们不再是 trivial 的了， 它们必须安插代码以正确的设置 vptr；</li></ul><p><strong>C++S tandard要求编译器尽量延迟nontrivial members 的实际合成操作，直到真正遇到其使用场合为止。</strong></p><p>当需要以传值方式（by value）传回一个local class object，那么提供一个copy constructor就比较合理——甚至即使default memberwise语意已经足够。它的出现会触发NRV优化。</p><h2 id="5-2-继承体系下的对象构造"><a href="#5-2-继承体系下的对象构造" class="headerlink" title="5.2 继承体系下的对象构造"></a>5.2 继承体系下的对象构造</h2><p><strong>编译器扩充每一个constructor的操作</strong>如下：</p><ol><li>记录在 member initialization list中的 data members初始化操作会被放进constructor的函数本体，并以members的声明顺序为顺序。</li><li>如果有一个 member并没有出现在 member initialization list之中，但它有一个 default constructor，那么该 default constructor必须被调用。</li><li>在那之前，如果 class object 有vptr，必须被设定初值，指向适当的virtual table。</li><li>在那之前，所有上一层的 base class constructors必须被调用，以 base class的声明顺序为顺序。使用 member initialization list 或者调用默认构造函数，同时如果 base class 是多重继承下的非第 1 基类，还需要调整 this 指针（需要调用this指针进行构造，因此需要调整到相应位置）；</li><li>在那之前，所有的 virtual base class constructors 必须被调用，从左到右，从深到浅。class中的每一个virtual base class subobject的偏移位置（offset）必须在执行期可被存取， 并同时设置好 virtual base class 所需要使用的各种机制；<ul><li>“virtual base class constructors的被调用”有着明确的定义：只有当一个完整的 class object 被定义出来（例如origin）时，它才会被调用；如果object只是某个完整object的subobject，它就不会被调用</li></ul></li><li>即处理顺序为：virtual base classes → base class → vptr → member</li></ol><p>赋值运算符中切记要记得进行自我检查。</p><p><strong>虚拟继承时，共享基类必须由最底层的 class 负责初始化操作</strong>： 这是虚拟继承时非常重要的一点，共享基类的初始化操作必须由最底层的类来负责，中层层次的类调用这个共享基类初始化的操作会被编译器所压抑掉。</p><ul><li>其通过对中层层次类的构造安插一个额外的参数__most_derived 来解决的。</li></ul><h3 id="vptr初始化语意学"><a href="#vptr初始化语意学" class="headerlink" title="vptr初始化语意学"></a>vptr初始化语意学</h3><p>在一个 class的constructor（和destructor）中，经由构造中的对象来调用一个virtual function，其函数实例应该是在此class中有作用的那个</p><ul><li>即使是派生类调用基类的构造有使用虚函数，也还是会调用基类相应的函数，因为此时派生类对象并未构造完成，其成员可能并未初始化</li><li>为了达到上述目的，先不更改当前对象虚指针的指向，当虚基类构造完成后再进行更改。因此，vptr的初始化操作处理时机为：<em>在 base class constructors调用操作之后，但是在程序员供应的代码或是“member initialization list中所列的 members初始化操作”之前。</em>（<strong>这是构造函数中没有多态性的根本原因！</strong>）</li></ul><p><strong>constructor的执行算法</strong>如下：</p><ol><li>在 derived class constructor中，“所有 virtual base classes”及“上一层base class”的constructors会被调用。</li><li>上述完成之后，对象的 vptr（s）被初始化，指向相关的 virtual table（s）。</li><li>如果有member initialization list的话，将在constructor体内扩展开来。这必须在vptr被设定之后才做，以免有一个virtual member function被调用。</li><li>最后，执行程序员所提供的代码。</li></ol><blockquote><p><strong>在class的constructor的member initialization list中调用该class的一个虚拟函数，安全吗？</strong></p><ul><li>将此函数施行于其class’s da ta me mber的初始化行动中，总是安全的。这是因为，vptr保证能够在member initialization list 被扩展之前，由编译器正确设定好。但是在语意上这可能是不安全的，因为函数本身可能还得依赖未被设立初值的members。</li></ul><p><strong>在一个class的虚基类的构造函数中传递该class的虚拟函数安全吗</strong></p><ul><li>不安全，此时vptr未被设定好，会指向错误的class</li></ul><p><strong>一个很容易犯的错误</strong>：使用了派生类的成员方法去初始化基类，注意在这个时候派生类还没有开始构造，调用它的成员 方法的行为当然是未定义的</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>， <span class="token function">valueA</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> valueA<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">int</span> valueA<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="5-3-对象复制语意学"><a href="#5-3-对象复制语意学" class="headerlink" title="5.3 对象复制语意学"></a>5.3 对象复制语意学</h2><p>如果class拥有bitwise copy语意，所以implicit copy assignment operator被视为毫无用处，也根本不会被合成出来。</p><blockquote><p>一个class对于默认的copy assignment operator，在以下情况，不会表现出bitwise copy语意：</p><ol><li>当class内含一个member object，而其class有一个copy assignment operator时。</li><li>当一个 class的 base class有一个 copy assignment operator时。</li><li>当一个 class声明了任何 virtual functions （一定不要拷贝右端 class object的 vptr地址，因为它可能是一个 derived class object）时。</li><li>当 class 继承自一个 virtual base class （不论此 base class 有没有 copy operator）时。</li></ol><p>不表示bitwise copy semantics则是nontrivial</p></blockquote><p><strong>注意，应尽可能提供一个 copy constructor，为的是把 name return value （NRV）优化打开。copy constructor的出现并不意味着也一定要提供一个copy assignment operator。</strong></p><p><strong>C++语言中的虚继承时 copy assignment operator 弱点</strong>： </p><ul><li>C++ 标准没有规定在虚继承时 copy assignment operator 中是否会多次调用共享基类的 copy assignment operator。这样就有可能造成共享基类被赋值多次，造成一些错误，所以 程序员应该在使用了 virtual base class 时小心检验 copy assignment operator 里的代码 （以确保这样的多次赋值没有问题或者查看编译器是否已经提供了解决方案）。<ul><li>这是因为没有类似member initialization list的东西member assignment list，来抑制上一层base class的copy operators被调用</li></ul></li><li>因此，尽可能不要允许一个 virtual base class 的拷贝操作，甚至根本不在要任何 virtual base class 中声明数据。</li></ul><h2 id="5-4-对象的效能"><a href="#5-4-对象的效能" class="headerlink" title="5.4 对象的效能"></a>5.4 对象的效能</h2><p>在一般的单继承或多继承中（非虚继承），如果表现出bitwise copy语义，那么继承不会给复制带来性能损耗。</p><p>当使用虚拟继承，由于不在具有bitwise copy语意，合成型的inline copy constructor和copy assignment operator于是被产生出来，并被派上用场，这导致效率成本上的一个重大增加（时间加了3倍，还只是一层虚拟继承）。</p><p>即使不使用任何继承，只是增加一个虚函数，同样导致合成型的inline copy constructor和copy assignment operator于是被产生出来，会增加40%～50%消耗。</p><h2 id="5-5-析构语意学"><a href="#5-5-析构语意学" class="headerlink" title="5.5 析构语意学"></a>5.5 析构语意学</h2><p>如果class没有定义destructor，那么只有在class内含的member object （或class自己的base class）拥有destructor的情况下，编译器才会自动合成出一个来。否则，destructor被视为不需要，也就不需被合成（当然更不需要被调用）</p><blockquote><p>构造函数（显式或隐式）必须存在是因为无法判断一个class是否被初始化，而delete一个对象却不一定需要将其数据清除，因此，也就不一定需要一个destructor（甚至根本不被合成）</p></blockquote><p><strong>析构函数的执行顺序</strong>（ 这里侯捷认为的顺序是错误的，而 Lippman 的才是正确的）：</p><ol><li>如果 object 内带有 vptr，那么首先重设相关的 vtable； </li><li>destructor 函数本身现在会被执行， 也就是说 vptr 会在程序员的代码执行之前被重设； </li><li>以声明顺序的相反顺序调用 members 的析构函数； </li><li>如果有任何直接的（上一层）nonvirtual base classed 拥有 destructor，那么会以其声 明顺序的相反顺序被调用； </li><li>如果有任何 virtual base classes 拥有 destructor，而当前讨论的这个 class 是最尾端的， 那么它们会以其原来的构造顺序的相反顺序被调用</li></ol><blockquote><p>由于析构函数中的重设 vptr 会在任何代码之前被执行，这样就保证了在析构函数中也不具有多 态性，从而不会调用子类的函数。因为此时派生类已经不完整了，派生类中的成员已经不存在了，而 派生类的函数有可能需要使用这些成员。</p></blockquote><p><strong>构造函数和析构函数中都不具有多态性</strong>：这并不是语言的弱点，而是正确的语意所要求的（因 为那个时候的对象不完整）。</p><h1 id="第6章-执行期语意学"><a href="#第6章-执行期语意学" class="headerlink" title="第6章 执行期语意学"></a>第6章 执行期语意学</h1><h2 id="6-1-对象的构造和析构"><a href="#6-1-对象的构造和析构" class="headerlink" title="6.1 对象的构造和析构"></a>6.1 对象的构造和析构</h2><p>一般而言会把object尽可能放置在使用它的那个程序区段附近，这么做可以节省非必要的对象产生操作和摧毁操作。</p><ul><li>因为如果都在开始处定义变量，那么在使用该变量前，如果中间代码有return之类操作，那么又会销毁该变量，造成不必要的消耗。</li></ul><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><ul><li>C++保证：全局变量会在第一次用到之前构造好，在 main()结束之前析构掉</li><li>C++程序中所有的 Global object 都放置在程序的 data segment 中并清 0（有指定初始值则不清零），但是它的 constructor 在程序激活时才会被调用。</li><li>Lippman 建议不要使用那些需要使用静态初始化的 global object （ Google C++编程规范也 是如此建议的）。</li><li>因为，如果exception handling 被支持，那些objects将不能够被放置于try区段之内，任何的 throw 操作将必然触发 exception handling library默认的terminate（）函数。</li></ul><h3 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h3><p>现在的 C++ Standard 已经强制要求局部静态对象在第一次被使用时才被构造出来。 而且在程序结束时会被以构造的相反次序被摧毁。</p><p>局部静态对象的构造和析构会多设置一个静态指针来保护（初始化为0）：</p><ul><li>当需要构造时，如果指针为0，则调用构造函数，并将指针指向对象地址，不为0则不调用构造函数</li><li>而在析构时，同样也会判断该指针决定是否调用析构函数</li></ul><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><p>对象的数组初始化和析构都是通过编译器安插一个vec_new函数调用的代码来实现的：</p><ul><li>vec_new之所以传进了析构函数的指针，是为了在构造函数抛出异常时，把已经构造好的对象给析构掉</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Point knots<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">vec_new</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> <span class="token comment">// address of start of array</span> size_t elem_size<span class="token punctuation">,</span> <span class="token comment">// size of each class object</span> <span class="token keyword">int</span> elem_count<span class="token punctuation">,</span> <span class="token comment">// number of elements in array</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>constructor<span class="token punctuation">)</span><span class="token punctuation">(</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">//构造函数的指针</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//析构函数的指针</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">vec_delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> <span class="token comment">// address of start of array</span> size_t elem_size<span class="token punctuation">,</span> <span class="token comment">// size of each class object</span> <span class="token keyword">int</span> elem_count<span class="token punctuation">,</span> <span class="token comment">// number of elements in array</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果knots提供一个或多个初值给数组，那么对于提供初值的元素会调用相应构造函数初始化，而未提供的元素则仍然通过vec_new初始化，只需要将array地址增加，元素个数减小即可。</p><h3 id="Default-Constructors和数组"><a href="#Default-Constructors和数组" class="headerlink" title="Default Constructors和数组"></a>Default Constructors和数组</h3><p>由于经由一个指针来启动 constructor，将无法（不被允许）存取default argument values。因此</p><ul><li>对于那些声明了默认参数从而实际上拥有无参构造函数的类，编译器会产生一个绝对无参的构造函数，再从这个构造函数里调用这个默认参数的构造函数。</li><li>这样，编译器实际上违反了语言的 规定，拥有了 2 个没有参数的构造函数，但是这样的特例只能由编译器自己来违反</li></ul><h2 id="6-2-new-和delete运算符"><a href="#6-2-new-和delete运算符" class="headerlink" title="6.2 new 和delete运算符"></a>6.2 new 和delete运算符</h2><p><strong>new运算符</strong>由两个步骤完成的：</p><ul><li>通过适当的 new运算符（__new)函数实例，配置所需的内存</li><li>将配置得来的对象设立初值（或调用构造）</li></ul><p><strong>delete运算符</strong>同理，但会判断指针是否为空：</p><ul><li>调用析构函数</li><li>释放内存（使用__delete函数）</li></ul><p><strong>一般的 library 对 new 运算符的实现</strong>如下，有两个精妙之处：</p><ul><li>new 操作符至少会返回 1 个字节的内存（语言要求每一次对 new 的调用都必须传回一个独一无二的指针，即使写出new T[0]这样的代码）</li><li>允许用户提供_new_handler ，会给内存分配不足时以补救的机会。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token operator">*</span>last_alloc<span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>last_alloc <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_new_handler<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>_new_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">return</span> last_alloc<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然 C++ Standard 并没有规定，但是实际上的 new 运算符都是以 C malloc()完成；同样 delete 运算符也都是以 C free()完成的。</p><h3 id="针对数组的-new语意"><a href="#针对数组的-new语意" class="headerlink" title="针对数组的 new语意"></a>针对数组的 new语意</h3><p>当使用new申请对象数组时，如果要分配的数组的类型并没有定义默认构造函数，那么不会调用vec_new函数进行初始化。只有在定义了默认构造函数时，vec_new 才需要被调用起来。</p><p><strong>delete 和 delete []</strong></p><ul><li>寻找数组维度给 delete 运算符带来了效率上的影响，所以出现了这个妥协。只有在 []出现时，编 译器才会去寻找数组的维度，否则它就假设只有一个 object 需要被删除</li><li>delete 数组时，只有第 1 个元素会被删除；</li><li>delete [] 单个对象时，1 个元素都不会被删除，没有任何析构函数被调用。</li></ul><blockquote><p>数组的大小会被编译器记录在某个地方，所以编译器能够直接查询出来某个数组的大小。</p></blockquote><p><strong>数组和多态行为的天生不兼容性：</strong></p><ul><li>永远不要把数组和多态扯到一起，他们天生是不兼容的。当你对一个指向派生类的基类指针进行 delete [] pbase; 操作时，它是不会有正确的语意的。</li><li>这是由于 delete []实际上会使用 vec_delete()类似的函数调用代替，而在 vec_delete()的参 数中已经传递了元素的大小，在 vec_delete 中的迭代删除时，会在删除一个指针之后将指针向 后移动 item_size 个位置，如果 DerivedClass 的 size 比 BaseClass 要大的话（通常都是如 此），指针就已经指向了一个未知的区域了（如果 Derived 与 Base 大小相同，那碰巧不会发生 错误，delete []可以正确的执行）。</li><li>如果一定要基类指针指向派生类数组然后进行删除，那么只能通过遍历该数组，逐个删除内存。</li></ul><blockquote><p>vec_new实现原型如下，其每次调用构造函数后，会将指针移动size大小然后再调用构造函数，而vec_delete实现也类似，因此会造成与多态的兼容问题。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230714123205506.png" alt="" style="zoom:67%;" /></blockquote><h3 id="Placement-Operator-new的语意"><a href="#Placement-Operator-new的语意" class="headerlink" title="Placement Operator new的语意"></a>Placement Operator new的语意</h3><p>有一个预先定义好的重载的new运算符，称为placement operator new。它需要二个参数，第一个为大小，第二个为void*。调用方式如下：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230714151527383.png" alt="" style="zoom:67%;" /><ul><li><p>arena是一个指针，指向一个内存区块</p></li><li><p>Point2w是需要放置在arena的类型</p></li><li><p>其内部操作会被解释为：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230714151742649.png" alt="" style="zoom:67%;" /></li></ul><p>如果placement operator在原已存在的一个object上构造新的object，而该既存的object有个destructor，这个destructor并不会被调用。</p><ul><li>可以使用delete，其会调用析构函数，但同时也会释放内存空间。因此，应该显式地调用destructor并保留存储空间以便再使用。</li><li>在原已存在的一个object上构造新的object，会将新object构造于原已存在的object之上</li></ul><p><strong>placement operator new 并不支持多态</strong>，因为 Derived Class 往往比 Base Class 要大，已经存在的类型为 Base 内存并不一定能够容纳 Derived 类型的对象。</p><blockquote><p>一个晦涩隐暗的问题：以下代码是安全的，大部分编译器调用base::f()，因为 b 是 一个对象而不是指针或者引用不具有多态性。如果将b改成指针就会调用Derived::f()</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230714152234533.png" alt="" style="zoom:67%;" /></blockquote><h2 id="6-3-临时性对象"><a href="#6-3-临时性对象" class="headerlink" title="6.3 临时性对象"></a>6.3 临时性对象</h2><p>C++ Standard 允许编译器对临时性对象的产生有完全的自由度</p><p><strong>临时对象的摧毁时机</strong>： 摧毁临时对象应该在产生它的 完整的表达式的最后一个步骤。</p><ul><li>切记是完整的表达式，比如一连串的逗号或一堆的括号，只有在完整的表达式最后才能保证这个 临时对象在后面不会再被引用到。</li></ul><p>临时性对象的生命规则有两个例外：</p><ul><li>第一个例外发生在表达式产生的临时对象被用来初始化一个object时：<ul><li>临时对象应该存留到object的初始化操作完成为止</li></ul></li><li>第二个例外是“当一个临时性对象被一个 reference绑定”时：<ul><li>如果一个临时性对象被绑定于一个 reference，对象将残留，直到被初始化之reference 的生命结束，或直到临时对象的生命范畴（scope）结束——视哪一种情况先到达而定。</li></ul></li></ul><p><em><strong>总结</strong>：临时性对象的确在一些场合、一定程度上影响了 C++的效率。但是这些影响完全可以通 过良好的编码和编译器的积极优化而解决掉临时性对象带来的问题（至少在很大的程度上），所 以对临时性对象的影响不能大意但也不必太放在心上。</em></p><h1 id="第7章-站在对象模型的尖端"><a href="#第7章-站在对象模型的尖端" class="headerlink" title="第7章 站在对象模型的尖端"></a>第7章 站在对象模型的尖端</h1><h2 id="7-1-Template"><a href="#7-1-Template" class="headerlink" title="7.1 Template"></a>7.1 Template</h2><h3 id="Template的“实例化”行为"><a href="#Template的“实例化”行为" class="headerlink" title="Template的“实例化”行为"></a>Template的“实例化”行为</h3><p>编译器在看到一个模板的声明时会做出什么反映呢？实际上编译器没有任何反映！编译器的反映只有在真正具现化时才会发生。</p><ul><li>明白了这个，就明白了为什么在模板内部有明显的语法错误，编译器也不会报错，除非你要具现化出这个模板的一具实体时编译器才会发出抱怨。</li></ul><p>实例化规则：</p><ul><li>即使定义的变量与模板类别无关，每次实例化时也会被产生出来，并且访问此变量同样需要加模版类别进行访问</li><li>同上，与类别无关的静态成员变量，每次实例都会产生出来</li><li><strong>声明一个模板类型的指针是不会引起模板的具现化操作的，因为仅仅声明指针不需要知道 class 的实际内存布局。</strong></li><li>而声明一个模板类型的引用会引起模板的具现化操作</li><li>只有在某个 member function 真正被使用时，它才会被真正的具现化出来，这样的延迟具现化 至少有 2 个好处： <ul><li>空间和时间上的效率；</li><li>如果使用的类型并不完全支持所有的函数，但是只需要不去用那些不支持函数，这样的部分 具现化就能得以通过编译。</li></ul></li></ul><blockquote><p>int 和 long 在大多数的机器上都是相同的，但是目前的所有编译器都会具现化 2 个实体。</p></blockquote><h3 id="Template的错误报告"><a href="#Template的错误报告" class="headerlink" title="Template的错误报告"></a>Template的错误报告</h3><p>涉及 Template 时的错误检查太弱了，template 中那些与语法无关的错误，程序员可能认为十 分明显，编译器却放它通过了，只有在特定的实体被具现化时，编译器才发出抱怨，这是目前实现技术上的一个大问题（二阶段查找的必然结果）。</p><h3 id="Template中的名称决议法"><a href="#Template中的名称决议法" class="headerlink" title="Template中的名称决议法"></a>Template中的名称决议法</h3><blockquote><p>Template 中的名称决议方式：scope of the template definition（定义模板的地方） 和 scope of the template instantiation（具现出模板实体的地方）。</p></blockquote><p>template在定义处和实例化处如果有相同函数名该怎么调用？</p><ul><li>Template 中，对于一个 nonmember name 的决议结果是根据这个 name 的使用是否与“用以具现出该 template 的参数类型 有关而决定的。<ul><li>例如决议使用哪个函数，则判断此函数使用的变量是否与实例化类相关。</li></ul></li><li>情况 1：如果其使用互不相关，那就在scope of template declaration 中来决议 name； </li><li>情况 2：如果其使用互有关系，那就在scope of template instantiation中来决议 name；<ul><li>而如果在此scope中有重载函数，那么会优先调用参数类别与实例化类别相同的函数，如果都不同那么就不知道调用哪个</li></ul></li><li>注意！只要决定了在哪个scope中决议name，那么即使搜索不到也不会去另一个scope中决议</li></ul><blockquote><p>这种决议方式可以理解为：非依赖示例类别的就在模板定义处查找，而依赖的则在实例化处超找</p><p>这种决议方式好处：给予了一个调用者可以进行自定义的机会。 模板的使用者往往可以在使用时，根据具体的调用类型来提供一个更好的函数给模板</p></blockquote><p>示例如下：</p><ul><li>如果调用invariant函数，那么其内部会调用scope of the template definition中的foo函数，因为val与实例化类别无关</li><li>而如果调用type_dependent函数，那么其内部会调用scope of the template instantiation中的foo函数，因为member与实例化类别相关</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// scope of the template definition</span><span class="token keyword">extern</span> <span class="token keyword">double</span> <span class="token function">foo</span> <span class="token punctuation">(</span> <span class="token keyword">double</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">type</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">ScopeRules</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token function">invariant</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//情况 1</span> _member <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span> _val <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> type <span class="token function">type_dependent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//情况 2</span> <span class="token keyword">return</span> <span class="token function">foo</span><span class="token punctuation">(</span> _member <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token keyword">int</span> _val<span class="token punctuation">;</span> type _member<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//scope of the template instantiation</span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>ScopeRules<span class="token operator">&lt;</span> <span class="token keyword">int</span> <span class="token operator">></span> sr0<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Member-Function的实例化行为"><a href="#Member-Function的实例化行为" class="headerlink" title="Member Function的实例化行为"></a>Member Function的实例化行为</h3><p>Member Function实例化时，编译器设计者必须回答的三个主要问题：</p><ol><li>编译器如何找出函数的定义？<ul><li>一种方法是像头文件一样包含模板定义文件</li><li>另一种方法是基于文件命名规则，在Point.h文件中发现的函数声明，其template program text一定要放置于文件Point.C或Point.cpp中</li></ul></li><li>编译器如何能够只实例化程序中用到的 member functions？<ul><li>解决办法之一就是，根本忽略这项要求，把一个已经实例化的 class 的所有member functions 都产生出来</li><li>另一种策略就是模拟链接操作，检测看看哪一个函数真正需要，然后只为它（们）产生实例</li></ul></li><li>编译器如何阻止 member definitions在多个.o文件中都被实例化呢？<ul><li>解决办法之一就是产生多个实例，然后从链接器中提供支持，只留下其中一个实例</li><li>另一个办法就是由使用者来导引“模拟链接阶段”的实例化策略，决定哪些实例（instances）才是所需求的</li></ul></li></ol><p><strong>一种具现化的策略</strong>：先不具现任何的 member function，链接器会登记缺少哪些函数的定义， 然后再重新调用编译器把登记在册的缺乏的定义重写编译出来，最后在把这些缺乏的定义和以前 的链接结果链接起来形成最后的可执行文件或者库。</p><p><strong>如果 vtable 被具现出来，那么每一个 virtual function 也都必须被具现</strong>。 </p><ul><li>这就是为什么 C++ Standard 中有如下的描述： 如果一个 “ 虚函数被具现出来，其具现点紧跟 在其 class 的具现点之后 。（ ” 也就是说，virtual function 是一口气被具现出来的）</li></ul><h2 id="7-2-异常处理"><a href="#7-2-异常处理" class="headerlink" title="7.2 异常处理"></a>7.2 异常处理</h2><blockquote><p>一般而言，exception handling 机制需要与编译器所产生的数据结构以及执行期的一个 exception library 紧密合作而实现。</p><p>如果要支持异常处理，那么在程序大小和执行速度之间，编译器必须有所抉择：</p><ul><li>为了维护执行速度，编译器可以在编译时期建立起用于支持的数据结构。这会使程序的大小发生膨胀，但编译器可以几乎忽略这些结构，直到有个 exception被抛出来。</li><li>为了维护程序大小，编译器可以在执行期建立起用于支持的数据结构。这会影响程序的执行速度，但意味着编译器只有在必要的时候才建立那些数据结构（并且可以抛弃之）。</li></ul></blockquote><p><strong>exception 处理过程</strong>：</p><ul><li>当一个exception 被抛出去时，控制权会从函数调用中被释放出来，并寻找一个吻合的catch子句。如果都没有吻合者，那么默认的处理例程terminate（）会被调用。</li><li>当控制权被放弃后，堆栈中的每一个函数调用也就被弹出（popped up）。这个动作称为unwinding the stack。在每一个函数被推离堆栈之前，函数的local class objects的destructor会被调用（这意味着会析构栈上的变量而不会析构堆上变量）。</li></ul><p><strong>当一个exception发生时，编译系统必须完成以下事情</strong>：</p><ol><li>检验发生 throw操作的函数。</li><li>决定 throw操作是否发生在 try区段中。</li><li>若是，编译系统必须把 exception type拿来和每一个 catch子句进行比较。</li><li>如果比较后吻合，流程控制应该交到 catch子句手中。</li><li>如果 throw的发生并不在 try区段中，或没有一个 catch子句吻合，那么系统必须（a）摧毁所有 active local objects，（b）从堆栈中将目前的函数“unwind”掉，（c）进行到程序堆栈的下一个函数中去，然后重复上述步骤 2～5。</li></ol><p>对于每一个被丢出的 exception，编译器必须产生一个类型描述器，对 exception 类型进行编 码。如果那是一个 derived type，则编码内容还必须包括其所有 base class 的类型信息。</p><p><strong>当一个实际对象在程序执行时被抛出，会发生什么事？</strong></p><ul><li>当一个 exception 被丢出时， exception object 会被产生出来并通常放置在相同形式的 exception 数据堆栈中。从 throw 端传染给 catch 子句的是 exception object 的地址、类型 描述器（或是一个函数指针，该函数会返回该 exception type 有关的类型描述器对象），以及 有可能还有的 exception object 的析构函数的地址（如果有的话）</li></ul><p><strong>以值类型抛出异常，以引用类型进行捕获</strong>：</p><ul><li>被抛出的异常类型，一定会被先复制一份，真正被抛出的实际上是这份复制器（引用类型是全局变量，也会被复制一份）； </li><li>即使是以值类型来进行捕获异常也可以捕获该值类型和其派生类的异常，但是在 catch 语句中会 引发切割。</li></ul><p>C++ 对异常机制所付出的代价大概为：空间 10% 、时间 5%</p><h2 id="7-3-执行期类型识别（RTTI）"><a href="#7-3-执行期类型识别（RTTI）" class="headerlink" title="7.3 执行期类型识别（RTTI）"></a>7.3 执行期类型识别（RTTI）</h2><p>由于具备多态性质的 class 都已经含有一个 vptr 指向 vtable 了，C++把类型信息放在 vtable 的第 1 个 slot 中（一个 type_info 的指针指向一个表示当前类型的 type_info 对象），从而几 乎没有付出代价的支持了 RTTI。</p><ul><li>由于 RTTI 所需要的信息放在 vtable 中，自然的：只有含有 vptr 的类才支持 RTTI</li></ul><p><strong>dynamic_cast运算符</strong></p><ul><li><p>dynamic_cast运算符可以在执行期决定真正的类型：</p><ul><li>如果downcast是安全的（也就是说，如果base type pointer指向一个derived class object），这个运算符会传回被适当转换过的指针。</li><li>如果downcast不是安全的，这个运算符会传回0。</li></ul></li><li><p>dynamic_cast是通过比较需转换指针指向的对象对应的类型描述器与需转换的类型是否相同，来保证安全性。</p></li><li><p>取得指针指向对象的对应类型描述器操作如下：</p><ul><li>type_info是C++Standard所定义的类型描述器的class名称，该class中放置着待索求的类型信息</li><li>virtual table 的第一个 slot 内含 type_info object 的地址；此type_info object与pt所指的class type有关</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230716144814752.png" alt="" style="zoom:67%;" /></li></ul><p><strong>在 dynamic_cast 中使用指针和引用的区别在于当转型失败时</strong>：</p><ul><li>指针版本会返回 0，使用者需要进行检查； </li><li>引用的版本会抛出一个 bad_cast exception（因为没有空引用）</li></ul><h3 id="Typeid运算符"><a href="#Typeid运算符" class="headerlink" title="Typeid运算符"></a>Typeid运算符</h3><ul><li><p>typeid运算符返回对象的type_info，其传回一个const reference，类型为type_info。</p></li><li><p>type_info 类型的 copy 构造函数和 operator&#x3D;操作符都被声明为私有，禁止了赋值和拷贝操作。 而且只提供了一个受保护的带有一个 const char *参数的构造函数，因为不能直接得到 type_info 对象，只能通过 typeid()运算符来得到这类对象。</p></li><li><p>可以使用typeid运算符先判断引用的类型，从而使得dynamic_cast引用时不抛出异常</p></li><li><p>RTTI 只适用于多态类型（RTTI 信息存于 vtable 的原因），事实上 type_info object 也适用 于非多态类型。</p><ul><li>typeid()使用于非多态类型时的差异在于，这时候的 type_info object 是<strong>静态</strong> 取得的（编译器直接给扩展了），而非像多态类型一样在执行期通过 vtable 动态取得。</li></ul></li></ul><h2 id="7-4-效率有了，弹性呢？"><a href="#7-4-效率有了，弹性呢？" class="headerlink" title="7.4 效率有了，弹性呢？"></a>7.4 效率有了，弹性呢？</h2><p>class的大小及其每一个直接（或继承而来）的members的偏移位置（offset）都在编译时期就已经固定（虚拟继承的members除外）。这虽然带来了效率，却在二进制层面（binary level）阻碍了弹性。如果 object 布局改变，应用程序就必须重新编译。</p><p>当一个shared library 被加载时，它在内存中的位置由runtime linker 决定。然而，在C++对象模型中，当一个动态的shared library支持一个class object，其中含有virtual functions（被放在shared memory中）时，想要经由这个shared object附着并调用一个virtual function”的第二个或更后继的进程，就会导致错误（没看太懂）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2768. 黑格子的数目</title>
      <link href="/2023/07/10/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-2768-%E9%BB%91%E6%A0%BC%E5%AD%90%E7%9A%84%E6%95%B0%E7%9B%AE-middle/"/>
      <url>/2023/07/10/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-2768-%E9%BB%91%E6%A0%BC%E5%AD%90%E7%9A%84%E6%95%B0%E7%9B%AE-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="2768-黑格子的数目"><a href="#2768-黑格子的数目" class="headerlink" title="2768. 黑格子的数目"></a><a href="https://leetcode.cn/problems/number-of-black-blocks/description/">2768. 黑格子的数目</a></h1><p>First：双周赛题，没参加。开始使用暴力遍历法，无法通过，打算用哈希表遍历每个存在的黑色格子，但也需要考虑其对其他格子的作用。</p><hr><p><strong>方法1</strong>：<strong>哈希表</strong></p><p>每个黑色格子会对四个子矩阵产生影响，每遍历一个黑色格子都分别对四个格子对应左上角的值加1，最后统计所有数目即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">namespace std&#123;    template&lt;&gt;    struct hash&lt;pair&lt;int,int&gt;&gt;&#123;        size_t operator ()(const pair&lt;int,int&gt; a) const&#123;            return a.first+a.second;        &#125;    &#125;;&#125;class Solution &#123;public:    vector&lt;long long&gt; countBlackBlocks(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;        unordered_map&lt;pair&lt;int,int&gt;,int&gt; map;        for(auto &amp;t:coordinates)&#123;            ++map[&#123;t[0],t[1]&#125;];            ++map[&#123;t[0]-1,t[1]&#125;];            ++map[&#123;t[0],t[1]-1&#125;];            ++map[&#123;t[0]-1,t[1]-1&#125;];        &#125;        vector&lt;long long&gt; ans(5,0);        for(auto &amp;kv:map)&#123;            int x&#x3D;kv.first.first,y&#x3D;kv.first.second;            if(x&lt;m-1&amp;&amp;x&gt;&#x3D;0&amp;&amp;y&lt;n-1&amp;&amp;y&gt;&#x3D;0)&#123;                ++ans[kv.second];            &#125;        &#125;        ans[0]&#x3D;(long long)(m-1)*(n-1);        for(int i&#x3D;1;i&lt;5;++i)&#123;            ans[0]-&#x3D;ans[i];        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6912. 构造最长非递减子数组</title>
      <link href="/2023/07/09/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-6912-%E6%9E%84%E9%80%A0%E6%9C%80%E9%95%BF%E9%9D%9E%E9%80%92%E5%87%8F%E5%AD%90%E6%95%B0%E7%BB%84-middle/"/>
      <url>/2023/07/09/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-6912-%E6%9E%84%E9%80%A0%E6%9C%80%E9%95%BF%E9%9D%9E%E9%80%92%E5%87%8F%E5%AD%90%E6%95%B0%E7%BB%84-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="6912-构造最长非递减子数组"><a href="#6912-构造最长非递减子数组" class="headerlink" title="6912. 构造最长非递减子数组"></a><a href="https://leetcode.cn/problems/longest-non-decreasing-subarray-from-two-arrays/description/">6912. 构造最长非递减子数组</a></h1><p>First：周赛题，有点迷糊没做出来，总想到的是记录前一个选的哪个数，就完全没咋用到动态规划。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp记录状态，dp[i] [0]表示以nums1[i] 结尾的最长非递减子数组长度，dp[i] [1]表示以nums2[i]结尾的最长非递减子数组长度。</p><p>只要比前面一个数大，则可以更新dp，递推见code</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxNonDecreasingLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int ans&#x3D;1;        int n&#x3D;nums1.size();        vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(2,1));        int a&#x3D;1,b&#x3D;1;        for(int i&#x3D;1;i&lt;n;++i)&#123;            if(nums1[i]&gt;&#x3D;nums1[i-1]) dp[i][0]&#x3D;max(dp[i][0],dp[i-1][0]+1);            if(nums1[i]&gt;&#x3D;nums2[i-1]) dp[i][0]&#x3D;max(dp[i][0],dp[i-1][1]+1);            if(nums2[i]&gt;&#x3D;nums1[i-1]) dp[i][1]&#x3D;max(dp[i][1],dp[i-1][0]+1);            if(nums2[i]&gt;&#x3D;nums2[i-1]) dp[i][1]&#x3D;max(dp[i][1],dp[i-1][1]+1);            ans&#x3D;max(ans,max(dp[i][0],dp[i][1]));        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6919. 使数组中的所有元素都等于零</title>
      <link href="/2023/07/09/leetcode/%E6%95%B0%E7%BB%84/leetcode-6919-%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E9%83%BD%E7%AD%89%E4%BA%8E%E9%9B%B6-middle/"/>
      <url>/2023/07/09/leetcode/%E6%95%B0%E7%BB%84/leetcode-6919-%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E9%83%BD%E7%AD%89%E4%BA%8E%E9%9B%B6-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="6919-使数组中的所有元素都等于零"><a href="#6919-使数组中的所有元素都等于零" class="headerlink" title="6919. 使数组中的所有元素都等于零"></a><a href="https://leetcode.cn/problems/apply-operations-to-make-all-array-elements-equal-to-zero/">6919. 使数组中的所有元素都等于零</a></h1><p>FIrst：周赛题，用暴力法在最后两个测试用例无法通过，当时隐约想到应该记录该减去的数，但没想到差分。</p><hr><p><strong>方法1</strong>：<strong>差分数组</strong></p><p>使用一个数组a记录在每个位置应该加上或减去多少，当遍历到位置i时,nums[i]&#x3D;nums[i]+a[i]：</p><ul><li>如果nums[i]大于0，那么应当减去更多的数，即a[i]-&#x3D;nums，且a[i+k]+&#x3D;nums[i]，此时如果i+k-1&gt;&#x3D;nums.size()，则说明数组不够长，应该返回false</li><li>如果nums[i]小于0，则返回false</li></ul><p>每次遍历之后需要更新下一个位置，a[i+1]+&#x3D;a[i]</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool checkArray(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; a(nums.size()+1,0);        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            nums[i]+&#x3D;a[i];            if(nums[i]&gt;0)&#123;                a[i]-&#x3D;nums[i];                  if(i+k-1&gt;&#x3D;nums.size())                    return false;                              a[i+k]+&#x3D;nums[i];                            &#125;else if(nums[i]&lt;0)&#123;                return false;            &#125;            a[i+1]+&#x3D;a[i];        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>三指针</strong></p><p>一次遍历。先使用两个指针p1 p2分别指向已排好的0和1尾部，使用一个指针从头到尾进行遍历，如果nums[i]&#x3D;1，则将其与nums[p2]进行交换，并p2+1；当nums[i]&#x3D;0时，此时将其与nums[p1]进行交换，但如果已经有1排好序，即p2&gt;p1，此时将会把1交换到nums[i]，因此还需要将nums[i]和nums[p2]交换，最后p1和p2都加1.</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int p1&#x3D;0,p2&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(nums[i]&#x3D;&#x3D;0)&#123;                swap(nums[i],nums[p1]);                                                if(p1&lt;p2)&#123;                    swap(nums[i],nums[p2]);                                    &#125;                      ++p2;                ++p1;                      &#125;else if(nums[i]&#x3D;&#x3D;1)&#123;                swap(nums[i],nums[p2]);                ++p2;            &#125;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
            <tag> Alg-差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1372. 二叉树中的最长交错路径</title>
      <link href="/2023/07/06/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-1372-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E4%BA%A4%E9%94%99%E8%B7%AF%E5%BE%84-middle/"/>
      <url>/2023/07/06/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-1372-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E4%BA%A4%E9%94%99%E8%B7%AF%E5%BE%84-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="1372-二叉树中的最长交错路径"><a href="#1372-二叉树中的最长交错路径" class="headerlink" title="1372. 二叉树中的最长交错路径"></a><a href="https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/description/">1372. 二叉树中的最长交错路径</a></h1><p>First：递归挺简单，只是需要记录下状态即可</p><hr><p><strong>方法1</strong>：<strong>深度遍历</strong></p><p>对于每个节点，都使用两个变量分别记录其左边到此节点的路径长度和右边到此节点的路径长度，找出最大值即为结果。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    int ans&#x3D;0;    void traverse(TreeNode* root,int ln,int rn)&#123;        if(root&#x3D;&#x3D;nullptr) return;        ans&#x3D;max(ans,max(ln,rn));        traverse(root-&gt;left,0,ln+1);        traverse(root-&gt;right,rn+1,0);    &#125;public:    int longestZigZag(TreeNode* root) &#123;        traverse(root,0,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2763. 所有子数组中不平衡数字之和</title>
      <link href="/2023/07/05/leetcode/%E6%95%B0%E7%BB%84/leetcode-2763-%E6%89%80%E6%9C%89%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%8D%E5%B9%B3%E8%A1%A1%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C-middle/"/>
      <url>/2023/07/05/leetcode/%E6%95%B0%E7%BB%84/leetcode-2763-%E6%89%80%E6%9C%89%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%8D%E5%B9%B3%E8%A1%A1%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="2763-所有子数组中不平衡数字之和"><a href="#2763-所有子数组中不平衡数字之和" class="headerlink" title="2763. 所有子数组中不平衡数字之和"></a><a href="https://leetcode.cn/problems/sum-of-imbalance-numbers-of-all-subarrays/description/">2763. 所有子数组中不平衡数字之和</a></h1><p>FIrst：周赛题，没做出来。贡献法还是有点疑惑，每个子数组产生的平衡数总和不知道为啥那样计算，推导出来？</p><hr><p><strong>方法1</strong>：<strong>枚举</strong></p><p>依次枚举所有数组，先列举数组左端点i，再依次从i+1枚举右端点j：</p><ul><li><p>如果nums[j]之前出现过，那个子数组排序后会和另一个相同值相邻，平衡数不变。</p></li><li><p>如果nums[j]未出现过，则查看nums[j]+1和nums[j]-1是否出现过：</p><ul><li>都出现，平衡树减1</li><li>都未出现，加1</li><li>出现一个，不变</li></ul></li><li><p>时间复杂度：O(n^2)</p></li><li><p>空间复杂度：O(1)</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int sumImbalanceNumbers(vector&lt;int&gt;&amp; nums) &#123;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            vector&lt;int&gt; flag(nums.size()+2,0);            flag[nums[i]]&#x3D;1;            int cur&#x3D;0;            for(int j&#x3D;i+1;j&lt;nums.size();++j)&#123;                if(!flag[nums[j]])&#123;                    if(flag[nums[j]+1]&amp;&amp;flag[nums[j]-1]) cur--;                    else if(!flag[nums[j]+1]&amp;&amp;!flag[nums[j]-1]) cur++;                    &#x2F;&#x2F; cur+&#x3D;1-flag[nums[j]+1]-flag[nums[j]-1];                    flag[nums[j]]&#x3D;1;                &#125;                ans+&#x3D;cur;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>贡献法</strong></p><p>每个数 vv<em>v</em> 产生贡献的子数组，是 v+1v+1<em>v</em>+1 没有出现的范围。另外相同的数字出现时，我们假设只有第一个数字有贡献，因此：</p><ul><li><p>找到每个数 v ，之前最近一个 v+1出现的下标 pi</p><p>找到每个数 v，之后最近一个 v或 v+1出现的下标 si</p></li></ul><p>可以采用哈希表在 O(N)时间内分别完成前后缀的迭代处理，然后即可计算出每个数产生贡献的子数组数量为： (i−pi)×(si−i)</p><p>注意每个子数组的最大的数其实是不应该产生贡献的，但上述过程多余计算了，因此要剔除。显然每个子数组最大的数只有一个，所以总数上剔除 N(N+1)2</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int sumImbalanceNumbers(vector&lt;int&gt;&amp; nums) &#123;        int n&#x3D;nums.size();        vector&lt;int&gt; pre(n,-1),next(n,n);        unordered_map&lt;int,int&gt; pre_map,next_map;        for(int i&#x3D;0;i&lt;n;++i)&#123;            int v&#x3D;nums[i];            pre_map[v]&#x3D;i;            auto it&#x3D;pre_map.find(v+1);            if(it!&#x3D;pre_map.end())&#123;                pre[i]&#x3D;it-&gt;second;            &#125;        &#125;        for(int i&#x3D;n-1;i&gt;&#x3D;0;--i)&#123;                 int v&#x3D;nums[i];                   auto it1&#x3D;next_map.find(v+1);            if(it1!&#x3D;next_map.end())&#123;                next[i]&#x3D;it1-&gt;second;            &#125;            auto it2&#x3D;next_map.find(v);            if(it2!&#x3D;next_map.end())&#123;                next[i]&#x3D;min(next[i],it2-&gt;second);            &#125;            next_map[v]&#x3D;i;        &#125;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;n;++i)&#123;            ans+&#x3D;(i-pre[i])*(next[i]-i);        &#125;        ans-&#x3D;n*(n+1)&#x2F;2;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2762. 不间断子数组</title>
      <link href="/2023/07/03/leetcode/%E6%95%B0%E7%BB%84/leetcode-2762-%E4%B8%8D%E9%97%B4%E6%96%AD%E5%AD%90%E6%95%B0%E7%BB%84-middle/"/>
      <url>/2023/07/03/leetcode/%E6%95%B0%E7%BB%84/leetcode-2762-%E4%B8%8D%E9%97%B4%E6%96%AD%E5%AD%90%E6%95%B0%E7%BB%84-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="2762-不间断子数组"><a href="#2762-不间断子数组" class="headerlink" title="2762. 不间断子数组"></a><a href="https://leetcode.cn/problems/continuous-subarrays/description/">2762. 不间断子数组</a></h1><p>FIrst：周赛题，没做出来，没想到怎么合适表示一个区间最大值和最小值。看了解析，才想起map的begin和rbegin就分别指向最小值和最大值</p><hr><p><strong>方法1</strong>：<strong>滑动窗口</strong></p><p>将一个滑动窗口中的所有数值添加到map中，map的begin即为最小值，map的rbegin即为最大值。依次遍历，将当前值插入到map中，如果最大差值大于2，则将左指针右移，且将map中相应计数减1，直到最大差值小于等于2为止。每次加上当前窗口大小即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    long long continuousSubarrays(vector&lt;int&gt;&amp; nums) &#123;        long long ans&#x3D;0;        map&lt;int,int&gt; map;        int left&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            ++map[nums[i]];            while(map.rbegin()-&gt;first-map.begin()-&gt;first&gt;2)&#123;                --map[nums[left]];                if(map[nums[left]]&#x3D;&#x3D;0)&#123;                    map.erase(nums[left]);                &#125;                ++left;            &#125;            ans+&#x3D;i-left+1;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
            <tag> Alg-滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2751. 机器人碰撞</title>
      <link href="/2023/06/29/leetcode/%E6%95%B0%E7%BB%84/leetcode-2751-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%A2%B0%E6%92%9E-difficult/"/>
      <url>/2023/06/29/leetcode/%E6%95%B0%E7%BB%84/leetcode-2751-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%A2%B0%E6%92%9E-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="2751-机器人碰撞"><a href="#2751-机器人碰撞" class="headerlink" title="2751. 机器人碰撞"></a><a href="https://leetcode.cn/problems/robot-collisions/">2751. 机器人碰撞</a></h1><p>FIrst：周赛题，当时不知道咋想的，用的是把每个往左边跑的机器人分配一个存储其左边所有往右边跑的机器人队列，十分繁琐，而且还没做出来</p><hr><p><strong>方法1</strong>：<strong>栈模拟</strong></p><p>先将机器人按位置进行排序，按位置就行遍历，如果当前机器人是R，则将其用栈存储起来，而如果是L，则将其不断与栈顶元素进行比较：健康度大于栈顶则移除栈顶继续比较栈顶元素，直至当前机器人健康度为0。</p><p>最后将healths中不为0的元素添加到结果中即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; survivedRobotsHealths(vector&lt;int&gt;&amp; positions, vector&lt;int&gt;&amp; healths, string directions) &#123;        vector&lt;int&gt; id(positions.size(),0);        iota(id.begin(),id.end(),0);        sort(id.begin(),id.end(),[&amp;positions](int i,int j)&#123;            return positions[i]&lt;positions[j];        &#125;);        stack&lt;int&gt; rightMove;        for(int i&#x3D;0;i&lt;id.size();++i)&#123;            if(directions[id[i]]&#x3D;&#x3D;&#39;L&#39;)&#123;                while((!rightMove.empty())&amp;&amp;healths[id[i]]&gt;0)&#123;                    int t&#x3D;rightMove.top();                    if(healths[id[t]]&lt;healths[id[i]])&#123;                        rightMove.pop();                        --healths[id[i]];                        healths[id[t]]&#x3D;0;                                            &#125;else if(healths[id[t]]&gt;healths[id[i]])&#123;                        --healths[id[t]];                        healths[id[i]]&#x3D;0;                    &#125;else&#123;                        rightMove.pop();                        healths[id[i]]&#x3D;0;                        healths[id[t]]&#x3D;0;                       &#125;                    &#125;            &#125;else&#123;                rightMove.push(i);            &#125;        &#125;        vector&lt;int&gt; ans;        for(int i&#x3D;0;i&lt;healths.size();++i)&#123;            if(healths[i]&gt;0)&#123;                ans.push_back(healths[i]);            &#125;        &#125;        return ans;            &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144</title>
      <link href="/2023/06/28/%E9%A1%B9%E7%9B%AE/CS144/"/>
      <url>/2023/06/28/%E9%A1%B9%E7%9B%AE/CS144/</url>
      
        <content type="html"><![CDATA[<p>cs144官网地址：<a href="https://cs144.github.io/">https://cs144.github.io/</a></p><p>整体难度不大，花了三四天，没看视频直接做的，有点面对测试用例编程的样子，但做了后对TCP细节有了更详细的了解</p><p>各lab所做功能如下图所示</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230626195904323.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230628150828498.png" alt="" style="zoom: 50%;" /><h1 id="Lab0-networking-warmup"><a href="#Lab0-networking-warmup" class="headerlink" title="Lab0 networking warmup"></a>Lab0 networking warmup</h1><p>此lab主要是调用提供的接口来模仿telnet发送信息并接受回答，实现webget.cc中的get_URL函数。以及在内存中实现一个字节流，因此字节流是可靠的，其使用的接口会在后来被使用。相比TCP，只是底层字节通道不同，而接口是通用的。</p><p>get_URL函数：向服务端发起连接，并发送信息获取回答。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">get_URL</span><span class="token punctuation">(</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> host<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> path <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// cerr &lt;&lt; "Function called: get_URL(" &lt;&lt; host &lt;&lt; ", " &lt;&lt; path &lt;&lt; ")\n";</span>  <span class="token comment">// cerr &lt;&lt; "Warning: get_URL() has not been implemented yet.\n";</span>  clog <span class="token operator">&lt;&lt;</span> <span class="token string">"Function called: get_URL("</span> <span class="token operator">&lt;&lt;</span> host <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> path <span class="token operator">&lt;&lt;</span> <span class="token string">")\n"</span><span class="token punctuation">;</span>  Address <span class="token function">server</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  TCPSocket sk<span class="token punctuation">;</span>  sk<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>  string get_info<span class="token operator">=</span><span class="token string">"GET "</span><span class="token operator">+</span>path<span class="token operator">+</span><span class="token string">" HTTP/1.1\r\n"</span><span class="token operator">+</span><span class="token string">"Host:"</span><span class="token operator">+</span>host<span class="token operator">+</span><span class="token string">"\r\n"</span><span class="token operator">+</span><span class="token string">"Connection:close\r\n\r\n"</span><span class="token punctuation">;</span>  <span class="token comment">// cout&lt;&lt;get_info&lt;&lt;endl;</span>  sk<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>get_info<span class="token punctuation">)</span><span class="token punctuation">;</span>  string response<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>sk<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       sk<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>       std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> response<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>  sk<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span>SHUT_WR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字节流实现如下，为了简单，直接使用了一个deque作为缓冲区，但效率不太行。</p><p><strong><em>ByteStream</em>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ByteStream</span><span class="token punctuation">&#123;</span><span class="token keyword">protected</span><span class="token operator">:</span>  <span class="token keyword">uint64_t</span> capacity_<span class="token punctuation">;</span> <span class="token comment">// 缓冲区容量限制</span>  <span class="token comment">// Please add any additional state to the ByteStream here, and not to the Writer and Reader interfaces.</span>  std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> buffer_<span class="token punctuation">;</span> <span class="token comment">// 缓冲区</span>  <span class="token keyword">bool</span> close_<span class="token punctuation">;</span>              <span class="token comment">// 关闭标志</span>  <span class="token keyword">bool</span> err_<span class="token punctuation">;</span>                <span class="token comment">// 错误标志</span>  <span class="token keyword">uint64_t</span> totalPushBytes_<span class="token punctuation">;</span> <span class="token comment">// 总共放入字节数</span>  <span class="token keyword">uint64_t</span> totalPopBytes_<span class="token punctuation">;</span>  <span class="token comment">// 总共弹出字节数</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>ByteStream</em>成员函数</strong></p><ul><li>push函数：取data长度和当前可push长度的最小值即可，并记录到totalPushBytes_中</li><li>pop函数：取需弹出的len长度和现有buffer容量最小值，弹出即可，并记录到totalPopBytes_中</li><li>其余函数皆是简单的标志容量设置或返回标志容量</li></ul><h1 id="Lab1-stitching-substrings-into-a-byte-stream"><a href="#Lab1-stitching-substrings-into-a-byte-stream" class="headerlink" title="Lab1 stitching substrings into a byte stream"></a>Lab1 stitching substrings into a byte stream</h1><p>此lab是将收到的许多字符串归整为一个字符串，期间可能需要等到前面尚未收到的字符串。</p><p><strong>设计思路</strong>：</p><ul><li>使用一个红黑树map来记录尚未被归整的字符串开始位置和结束位置（因为前面还有未收到的字符串所以无法归整）</li><li>每次收到一个字符串，就将其插入，并向前和向后进行查询是否有相连的字符串，如果有则合并，最后合并的字符串如果开始位置等于首个未整理好的字符位置，则视为此段之前无未收到字符串。</li><li>此方法在字符串较大时，效率较高，不用去扫描哪些位置收到数据，但如果字符串较小时则效率较低。</li></ul><p><strong><em>Reassembler</em>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Reassembler</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">uint64_t</span> unassem_index_<span class="token punctuation">;</span>           <span class="token comment">// 未整理好的窗口位置</span>  <span class="token keyword">uint64_t</span> unaccept_index_<span class="token punctuation">;</span>          <span class="token comment">// 不能接收的窗口位置</span>  std<span class="token double-colon punctuation">::</span>string buffers_<span class="token punctuation">;</span>              <span class="token comment">//</span>  std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token punctuation">,</span> <span class="token keyword">uint64_t</span><span class="token operator">></span> map_<span class="token punctuation">;</span> <span class="token comment">// 存储的是尚未被整理的字符串的开始序列号和结束序列号</span>  <span class="token keyword">bool</span> is_last_flag_<span class="token punctuation">;</span>                <span class="token comment">// 是否为最后一个字符串</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>Reassembler</em>成员函数</strong></p><ul><li>insert函数：将收到的字符串进行插入，如设计思路中所说，需要现合并已有字符串。每次都会将收到字符串插入到buffer中（因为会收到重复的），只有当合并后的字符串满足要求才会移动指针。</li><li>bytes_pending函数：记录当前有多少字符串还未归整，直接遍历map，将所有长度相加即可。</li></ul><p><strong>注意点</strong></p><ul><li>带有关闭标志的字符串可能会最后收到，但此时并不一定能关闭，且可能收到空字符串却拥有关闭标志的信息</li><li>收到的字符串可能会超出当前窗口或是确认以前的字符串，此时应该丢弃</li><li>收到的字符串可能一部分已经被确认，而剩余部分尚未确认，因为插入map时需注意首位</li><li>合并字符串后并不一定能全部push，因为reciever大小有限，因此需要将不能push的部分重新插入到map中</li><li>每次函数末尾都需要判断是否应当关闭输出</li></ul><h1 id="Lab2-the-TCP-receiver"><a href="#Lab2-the-TCP-receiver" class="headerlink" title="Lab2 the TCP receiver"></a>Lab2 the TCP receiver</h1><p>此lab主要实现接受底层传来的字节流，并处理回绕问题。</p><p>为处理IP报文的回绕问题，此实验在内部使用64bit字节序（几乎不可能发生回绕），通过抽象一个<em>Wrap32</em>来解决其与32bit字节序互转问题，使得整体逻辑更加简单清晰。</p><p>因而在整个实验中，共有三种序号：</p><ul><li>绝对字节序和流序号的区别为是否包括SYN&#x2F;FIN标志</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230628153046354.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230628153138023.png"></p><p><strong><em>Wrap32</em>成员函数</strong></p><ul><li><p>wrap函数：用于将64位序号转为32位序号，其通过对比初始字节序来进行转化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Wrap32 <span class="token class-name">Wrap32</span><span class="token double-colon punctuation">::</span><span class="token function">wrap</span><span class="token punctuation">(</span> <span class="token keyword">uint64_t</span> n<span class="token punctuation">,</span> Wrap32 zero_point <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> Wrap32 <span class="token punctuation">&#123;</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span> n <span class="token punctuation">)</span> <span class="token operator">+</span> zero_point<span class="token punctuation">.</span>raw_value_ <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 直接利用溢出来计算</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>unwrap函数：通过对比最近接受到的一个64位字节序checkpoint，从而将其转成64位，注意转成的数应当离checkpoint最近</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">uint64_t</span> <span class="token class-name">Wrap32</span><span class="token double-colon punctuation">::</span><span class="token function">unwrap</span><span class="token punctuation">(</span> Wrap32 zero_point<span class="token punctuation">,</span> <span class="token keyword">uint64_t</span> checkpoint <span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 参考：https://www.cnblogs.com/kangyupl/p/stanford_cs144_labs.html</span>  <span class="token comment">// 计算当前值到checkpoint对应的wrap32值的距离，</span>  <span class="token comment">// 还没搞懂为啥反着走ret会小于0，后面待调试</span>  <span class="token comment">// 这两个值相减，如果最高位是0，那么此值一定更接近checkpoint，是到checkpoint的最近步数</span>  <span class="token comment">// 但如果最高位是1，那么应该加上uint32_len（此时min_step为负数）此值才是到checkpoint的最小步数；而如果</span>  <span class="token keyword">int32_t</span> min_step <span class="token operator">=</span> raw_value_ <span class="token operator">-</span> <span class="token function">wrap</span><span class="token punctuation">(</span> checkpoint<span class="token punctuation">,</span> zero_point <span class="token punctuation">)</span><span class="token punctuation">.</span>raw_value_<span class="token punctuation">;</span>  <span class="token comment">// 将步数加到checkpoint上</span>  <span class="token comment">// int32_t转uint64时会将左边第一位复制到其左边第1~32位上。</span>  <span class="token comment">// 上面两值相减，如果最高位为0，此时会正常相加；而如果最高位为1，转换时在其高32为都会为1，那么ret最高位必定为1，也就必为负数(不一定为1，还是没弄明白咋回事)</span>  <span class="token keyword">int64_t</span> ret <span class="token operator">=</span> checkpoint <span class="token operator">+</span> min_step<span class="token punctuation">;</span>  <span class="token comment">// 如果反着走的话要加2^32</span>  <span class="token comment">// 如果为ret为负，则说明在高位多加了32位1，再加2^32则可以通过溢出来减去</span>  <span class="token keyword">return</span> ret <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span> ret <span class="token punctuation">)</span> <span class="token operator">:</span> ret <span class="token operator">+</span> <span class="token punctuation">(</span> <span class="token number">1ul</span> <span class="token operator">&lt;&lt;</span> <span class="token number">32</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong><em>TCPReceiver</em>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TCPReceiver</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>  Wrap32 zero_point_<span class="token punctuation">;</span>    <span class="token comment">// 初始sequence number</span>  <span class="token keyword">uint64_t</span> check_point_<span class="token punctuation">;</span> <span class="token comment">// 下一个待发送的stream index，初始为UINT64_MAX代表SYN未收到过</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>TCPReceiver</em>成员函数</strong></p><ul><li>receive函数：处理接受到的报文段，需要注意一些特别情况，在注意点阐述。<ul><li>SYN可能会被多次发送，且可能和数据或FIN一起发送，当和数据或FIN一起发送时，需要注意送入到reassembler中的数据长度，以及check_pint应该加上多少</li><li>当FIN和数据一起发送的时候，需要处理check_point大小</li><li>需要注意处理从未收到过SYN而收到数据或FIN的情况，此时check_point不应当增加</li></ul></li><li>send函数：需要向发送方发回当前确认号和当前窗口大小，窗口大小最大为65535, 需要注意此确认号应当包括SYN和FIN，为sequence number。</li></ul><h1 id="Lab3-the-TCP-sender"><a href="#Lab3-the-TCP-sender" class="headerlink" title="Lab3 the TCP sender"></a>Lab3 the TCP sender</h1><p>此lab算是难度最大的，需要注意的细节特别多。其需要实现TCP的发送，包括重传等。整体关于发送和接收的还好处理，重传部分是整个lab最关键部分。</p><p><strong>重传规则</strong>：</p><ul><li>重传无需监控每个报文（耗费资源），每次只需要监控一个报文即可。</li><li>当一个定时器被关闭时，如果还有等待确认的报文段，则需要重新打开定时器</li><li>当一个定时器超时，只需要重传序号最小的报文</li><li>当接收方发来的窗口大小大于0时，如果定时器超时则会执行指数避退，而窗口为0则不执行指数避退，使用原来的超时时间。注意此窗口大小和发送方的窗口大小不同，发送方的窗口大小最小为1。</li></ul><p><strong>设计</strong>：</p><ul><li>使用一个deque存储等待发送的报文段（其实应当使用queue），使用一个deque存储已经发送但等待确认的报文（使用双向是因为超时重传报文应该置为首部，避免遍历所有来找到最小序号报文）</li><li>需要标记SYN和FIN是否已经发送</li></ul><p><strong><em>TCPSender</em>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TCPSender</span><span class="token punctuation">&#123;</span>  Wrap32 isn_<span class="token punctuation">;</span>              <span class="token comment">// 初始序列号</span>  <span class="token keyword">uint64_t</span> initial_RTO_ms_<span class="token punctuation">;</span> <span class="token comment">// 初始超时时间</span>  <span class="token keyword">uint64_t</span> unack_idx_<span class="token punctuation">;</span>      <span class="token comment">// 尚未收到确认的第一个stream index，注意这不是absolute sequence number</span>  <span class="token keyword">uint64_t</span> next_send_idx_<span class="token punctuation">;</span>  <span class="token comment">// 下一个待发送的stream index</span>  <span class="token keyword">uint16_t</span> win_size_<span class="token punctuation">;</span>       <span class="token comment">// 真实的发送窗口大小，最小为1，初始为1</span>  <span class="token keyword">uint16_t</span>    recv_win_size_<span class="token punctuation">;</span> <span class="token comment">// 从接收方接受到的发送窗口大小，最小为0，初始为1，主要用于RTO是否翻倍判断:大于0，则不翻倍，否则翻倍</span>  std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span>TCPSenderMessage<span class="token operator">></span> messages_out_<span class="token punctuation">;</span>         <span class="token comment">// 等待发送的报文段</span>  std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span>TCPSenderMessage<span class="token operator">></span> messages_outstanding_<span class="token punctuation">;</span> <span class="token comment">// 已经发送但等待确认的报文</span>  size_t timer_<span class="token punctuation">;</span>                                      <span class="token comment">// 当前定时器时间</span>  <span class="token keyword">bool</span> timer_runing_<span class="token punctuation">;</span>                                 <span class="token comment">// 当前定时器是否在运行</span>  <span class="token keyword">uint64_t</span> outstanding_count_<span class="token punctuation">;</span> <span class="token comment">// 当前待确认的sequence number数量，注意不是stream index，因此包括SYN和FIN</span>  <span class="token keyword">bool</span> is_SYN_<span class="token punctuation">;</span>                <span class="token comment">// 是否成功发送SYN初始报文</span>  <span class="token keyword">bool</span> is_SYN_sending_<span class="token punctuation">;</span> <span class="token comment">// SYN是否正在发送中，此时会占据一个窗口大小</span>  <span class="token keyword">bool</span> is_FIN_<span class="token punctuation">;</span>         <span class="token comment">// 是否成功发送FIN报文</span>  <span class="token keyword">uint16_t</span> retrans_times_<span class="token punctuation">;</span> <span class="token comment">// 当前重传次数，主要用于指数避退和当前连接是否在重传过多后进行关闭</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>TCPSender</em>成员函数</strong></p><ul><li>maybe_send函数：弹出需要发送的报文。<ul><li>从messages_out_中弹出报文，并将其插入到messages_outstanding ，如果是重传报文则插入队首，否则插入队尾。</li><li>没有开启定时器则应当开启。</li></ul></li><li>push函数：插入需要发送的报文。<ul><li>如果SYN尚未发送，则先添加一个SYN报文，此时也需要检查输出流是否已关闭，若已经关闭则应当和SYN同时发出FIN。然后不断冲输出流中取出需要发送的数据形成报文添加到messages_out中。</li><li>第一次发送SYN时需要检查应当置FIN。</li><li>发送SYN也需要占用窗口大小，可以设置一个标志记录SYN正在发送</li><li>outstanding_count_需要在添加进messages_out时就开始计数，在messages_out弹出时计数测试会不通过（其实这有点怪异）</li><li>在每次发送数据时，需要判断FIN是否应当一起发送，且如果可发送大小无法装下FIN，那么FIN应当单独发送</li><li>在每次函数末尾处，都需要判断FIN是否需要发送</li><li>send_empty_message函数发送的空消息序号应当加上is_FIN标志</li></ul></li><li>receive函数：需要处理接受方发送的消息，包括更新已确认号和窗口大小。<ul><li>即使此窗口大小为0，发送窗口大小最小为1。需要拒绝收到的确认号小于当前确认号或大于待发送序号，这里特别需要注意三种index的处理。</li><li>如果收到的确认号不足以确认整个报文，那么对整个报文都不进行确认（确认部分测试反而无法通过）。</li><li>最后如果定时器未开启则开启。</li></ul></li><li>tick函数：管理定时器<ul><li>如果待确认报文队列为空，则不做处理</li><li>如果定时器未运行，则开启定时器</li><li>如果定时器超时则将序号最小报文重新发送，并且此时需要通过窗口大小来判断是否需要执行指数避退。</li></ul></li></ul><h1 id="Lab4-the-network-interface"><a href="#Lab4-the-network-interface" class="headerlink" title="Lab4 the network interface"></a>Lab4 <strong>the network interface</strong></h1><p>此lab较简单，容易实现。</p><p>此lab主要实现一个介于网络层到以太链路层的中间操作，其目的是将IP数据报打包成以太帧进行发送，打包过程中需要查询以太网地址，因而需要实现ARP协议请求及回复等处理。</p><p>此lab通过实现网络接口层，最后通过调用Linux提供的TAP接口，将以太帧发送出去，即文档提到的<strong>TCP-in-IP-in-Ethernet</strong>方式。</p><p><strong><em>NetworkInterface</em>类成员</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">NetworkInterface</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>  EthernetAddress ethernet_address_<span class="token punctuation">;</span> <span class="token comment">// 主机以太网地址</span>  Address ip_address_<span class="token punctuation">;</span> <span class="token comment">// 主机IP地址</span>  <span class="token comment">//添加成员</span>  std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>Address<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>EthernetAddress<span class="token punctuation">,</span> size_t<span class="token operator">>></span>    ip2eth_map_<span class="token punctuation">;</span> <span class="token comment">// IP:(eth,time_to_expired), 记录IP到以太网的映射及当前还有多久过期</span>  std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>Address<span class="token punctuation">,</span> size_t<span class="token operator">></span> arp_req_sending_<span class="token punctuation">;</span> <span class="token comment">// 记录当前正在请求的arp及请求过去时间</span>  std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>EthernetFrame<span class="token operator">></span> eth_frame_out_<span class="token punctuation">;</span>             <span class="token comment">// 需要从以太网接口输出的帧</span>  std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>InternetDatagram<span class="token punctuation">,</span> Address<span class="token operator">>></span> datagram_out_<span class="token punctuation">;</span> <span class="token comment">// 待处理的数据报，例如因等待arp请求而等待的数据报</span><span class="token punctuation">&#125;</span><span class="token comment">// Address哈希值</span><span class="token keyword">namespace</span> std <span class="token punctuation">&#123;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">hash</span><span class="token operator">&lt;</span>Address<span class="token operator">></span><span class="token punctuation">&#123;</span>  size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Address<span class="token operator">&amp;</span> addr <span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> hash<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span> addr<span class="token punctuation">.</span><span class="token function">ip</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>NetworkInterface</em>类函数</strong></p><ul><li>send_datagram：发送数据报，若能得到以太网地址则直接发送，否则发送ARP请求，一定时间内不发送重复地址的ARP请求<ul><li>逻辑如上，lab中已经提供了序列化类用以将IP消息或ARP消息序列化</li></ul></li><li>recv_frame：接受到以太网帧应该进行的处理，包括处理IP消息，ARP请求、回复消息，以及对等待ARP回复的数据报进行发送<ul><li>需要注意的是，如果为ARP request消息，需要对比其目的IP地址是否为本机IP，如果合法需要将此条记录加入映射中；在收到ARP reply消息时，需要将等待ARP消息的数据报进行发送。</li></ul></li><li>tick：主要是对arp记录过期的处理，及重复ARP请求记录的处理<ul><li>删除过期的ARP请求，将超时的正在发送的arp请求删除，以便可以再发送相同地址的的arp请求</li></ul></li><li>maybe_send：不断从以太帧队列eth_frame_out_拿出队头元素即可。</li></ul><p><strong>注意点</strong></p><ul><li>ARP请求消息需对比本机IP地址，且需要添加此条映射</li><li>arp_req_sending_中的时间记录的是已经过去时间， ip2eth_map记录的是还剩多久过期</li><li>填充以太帧数据部分直接将IP消息或ARP消息调用serialize方法即可</li></ul><h1 id="Lab5"><a href="#Lab5" class="headerlink" title="Lab5"></a>Lab5</h1><p>此lab实现路由管理，包括插入路由信息以及将数据报转发到对应窗口。</p><p>数据报在转发时，其目的IP地址不会变，而下一条IP地址会通过查询路由表得到，当下一跳地址为空时，则下一跳为终点。而发送以太帧的目的地址则是通过查询下一跳地址得到。</p><p><strong>设计</strong>：</p><ul><li>为了处理路由表更新情况，使用了一个哈希表进行存储路由信息（测试用例中没有更新路由信息，直接使用一个vector即可），key值为route_prefix和prefix_length，value则为剩下数据</li></ul><p><strong><em>Router</em>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Router</span><span class="token punctuation">&#123;</span>  <span class="token comment">// The router's collection of network interfaces</span>  std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>AsyncNetworkInterface<span class="token operator">></span> interfaces_ <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 以太网接口</span>  std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>SubNetAddr<span class="token punctuation">,</span> SubNetInfo<span class="token operator">></span> route_map_<span class="token punctuation">;</span> <span class="token comment">// 路由表</span><span class="token punctuation">&#125;</span><span class="token keyword">struct</span> <span class="token class-name">SubNetAddr</span><span class="token punctuation">&#123;</span>  <span class="token keyword">uint32_t</span> route_prefix<span class="token punctuation">;</span>  <span class="token keyword">uint8_t</span> prefix_length<span class="token punctuation">;</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span> <span class="token keyword">const</span> SubNetAddr<span class="token operator">&amp;</span> other <span class="token punctuation">)</span> <span class="token keyword">const</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>route_prefix <span class="token operator">==</span> other<span class="token punctuation">.</span>route_prefix <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token operator">-></span>prefix_length <span class="token operator">==</span> other<span class="token punctuation">.</span>prefix_length<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">SubNetInfo</span><span class="token punctuation">&#123;</span>  std<span class="token double-colon punctuation">::</span>optional<span class="token operator">&lt;</span>Address<span class="token operator">></span> next_hop<span class="token punctuation">;</span>  size_t interface_num<span class="token punctuation">;</span>  <span class="token function">SubNetInfo</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>optional<span class="token operator">&lt;</span>Address<span class="token operator">></span> next_hop1<span class="token punctuation">,</span> size_t interface_num1 <span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">next_hop</span><span class="token punctuation">(</span> next_hop1 <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">interface_num</span><span class="token punctuation">(</span> interface_num1 <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>Router</em>成员函数</strong></p><ul><li>add_route函数：将路由信息添加到map中即可</li><li>route函数：遍历所有接口，如果接口有数据报待处理则处理，没有则遍历下一个接口，注意此函数不能一直循环（最开始看到这函数不知道咋用。。而且还写成了一直循环。。）<ul><li>当数据报的ttl小于等于1时，则直接进行丢弃</li><li>从路由表中找最佳匹配（直接通过比对当前地址和路由地址的前缀是否相同即可，可通过移位操作，相同则匹配），找到最长匹配即可。没找到匹配则需丢弃。</li><li>注意如果找最佳匹配时使用移位操作，则需要特别判断前缀长度为0情况，此时移32位会发生错误。</li><li>如果路由信息中无下一跳地址，则应当使用数据报中的目的地址作为下一跳地址</li><li>特别注意！！发送前应当重新计算校验和。</li></ul></li></ul><p>出现问题：</p><ul><li>payload: bad IPv4 datagram。即数据报解析失败，最开始以为是没数据之类原因，调了一个多小时，后来在网上看见才知道应该重新计算校验和。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2749. 得到整数零需要执行的最少操作数</title>
      <link href="/2023/06/28/leetcode/%E6%95%B0%E7%BB%84/leetcode-2749-%E5%BE%97%E5%88%B0%E6%95%B4%E6%95%B0%E9%9B%B6%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0-middle/"/>
      <url>/2023/06/28/leetcode/%E6%95%B0%E7%BB%84/leetcode-2749-%E5%BE%97%E5%88%B0%E6%95%B4%E6%95%B0%E9%9B%B6%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="2749-得到整数零需要执行的最少操作数"><a href="#2749-得到整数零需要执行的最少操作数" class="headerlink" title="2749. 得到整数零需要执行的最少操作数"></a><a href="https://leetcode.cn/problems/minimum-operations-to-make-the-integer-zero/description/">2749. 得到整数零需要执行的最少操作数</a></h1><p>FIrst：周赛题，但没做出来</p><hr><p><strong>方法1</strong>：<strong>枚举</strong></p><p>num1减去k次（num2+2^i)等于0，那么num1-k*num2&#x3D;k *2^i（i可不一样），令x&#x3D;num1-k *num2.</p><p>如果x&lt;0，必不可能存在k使得等式成立，因为2^i必大于0</p><p>如果x&lt;k，同理无解</p><p>如果x二进制中1的个数大于k，也无法拆成k个2^i之和，无解（因为 2 ^i的二进制结果中只会有一个1，那么相加之后最多只能有k个1）</p><p>否则分解方案一定存在，返回k。（因为2^i可以拆成两个2 ^(i-1)之和，可以不断拆分凑成k个）</p><p>采用双指针分别遍历两次，第一次先将0调换到数组前部分，第二次再将1调换到数组中部。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int makeTheIntegerZero(int num1, int num2) &#123;        for(long long k&#x3D;1;k&lt;&#x3D;num1-k*num2;++k)&#123;            if(k&gt;&#x3D;__builtin_popcountll(num1-num2*k))                 return k;        &#125;        return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
            <tag> Alg-最少操作数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试问题</title>
      <link href="/2023/06/20/c++/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
      <url>/2023/06/20/c++/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>深度探索C++对象模型，阅读笔记</p><h1 id="迭代器失效情况"><a href="#迭代器失效情况" class="headerlink" title="迭代器失效情况"></a>迭代器失效情况</h1><p>参考<a href="https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers">1</a>、<a href="https://www.cnblogs.com/zhchoutai/p/8449786.html">2</a></p><p><strong>失效情况：</strong></p><ul><li><code>erase()</code><ul><li>当序列容器调用<code>erase()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效。<ul><li>C++03: deque在头尾删除，只会使得被删除迭代器和引用无效。而在其他位置删除会使得所有迭代器和引用都失效。c++11中有一点改变，见参考2.<ul><li>因为在其他位置删除或插入会移动之后或之后的元素，从而使得所有迭代器和引用失效。</li></ul></li></ul></li><li>当关联容器调用<code>erase()</code>方法后，只会使当前迭代器失效，不会造成其他迭代器失效</li></ul></li><li><code>insert()</code><ul><li>当序列容器调用<code>insert()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效。<ul><li>C++11: deque在头尾插入，可能会使得所有迭代器无效但引用不受影响（因为map可能重新分配空间）。而在其他位置插入会使得所有迭代器和引用都失效。</li></ul></li><li>当关联容器调用<code>insert()</code>方法后，，不会造成其他迭代器失效</li></ul></li><li>如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/qgST0.png" alt="qgST0"></p><h1 id="容器间的对比"><a href="#容器间的对比" class="headerlink" title="容器间的对比"></a>容器间的对比</h1><p><strong>vector 插入删除操作和list有什么区别</strong></p><ul><li>vector插入删除操作需要进行元素的移动，如果vector所存储的对象很大或者构造函数比较复杂，则开销较大，如果是简单的小数据效率优于list </li><li>list插入删除操作需要遍历当前数据，但在首部插入效率很高</li></ul><p><strong>什么情况下用list,什么情况下用vector</strong></p><ul><li>当数据对象简单，对象数量变化不大，需要频繁的随机访问时，用vector</li><li>当数据对象复杂，对象的数量频繁变化，频繁的进行插入和删除操作时，用list</li></ul><p><strong>deque和vector的区别</strong></p><ul><li>vector是单向开口的连续区间，deque是双向开口的连续区间（可以在头尾两端进行插入和删除操作）</li><li>deque提供随机访问迭代器，但是迭代器比vector复杂很多</li><li>deque没有提供空间保留功能，也就是没有capacity这个概念，而vector提供了空间保留功能。即vector有capacity和reserve函数，deque 和 list一样，没有这两个函数。</li></ul><p><strong>vector，list，deque对比</strong></p><ul><li>vector数据在内存中连续排列，所以随机存取元素的速度最快。但是在除尾部以外的位置删除或者添加元素的时候速度很慢</li><li>list数据是链式存储，不能随机存取。其优势在于在任意位置添加和删除元素</li><li>deque通过链接若干片连续的数据实现的，均衡了以上两容器的特点</li></ul><p><strong>hash_map和map的区别？什么时候用map,什么时候用hash_map</strong></p><ul><li>构造函数：hash_map需要hash function以及等于函数，map需要比较函数</li><li>存储结构：hash_map以hashtable为底层，map以红黑树为底层</li><li>查找速度：总体来说，hash_map查找速度比map快，而且查找速度基本和数据量的大小无关，属于常数级别；map的查找速度是(logn)级别。并不一定常数级别就比（logn）小，hash_map的hash function也会耗时</li><li>二者如何选择：如果考虑效率，特别是元素达到一定的数量级时，用hash_map；如果考虑内存，或者元素比较少时，用map</li></ul><p><strong>hashtable,hash_set,hash_map的区别</strong></p><ul><li>hash_set以hashtable为底层，不具有排序功能，能快速查找，其键值就是实值</li><li>hash_map以hashtable为底层，不具有自动排序功能，能快速查找，每一个元素同时拥有键值和实值</li></ul><p><strong>map和set的区别</strong></p><ul><li>相同点：map和set都是c++的关联容器，底层都是红黑树实现的</li><li>元素： map的元素是key-value（键值—实值）对，关键字起到索引的作用，值表示与索引相关联的数据；set的元素是键值，没有实值</li><li>迭代器：map的迭代器既不是const也不是mutable，map允许修改value实值，不允许修改key键值；set的迭代器是const的，不允许修改键值。其原因在于map和set是根据关键字来保证其有序性的，如果允许修改键值，那么首先要删除该键，调节平衡，然后再插入修改后的键值，调节平衡，这样一来破坏了map和set的结构，导致iterator失效。</li><li>下标操作：map支持下标操作，用关键字作为下标访问关键字对应的值，如果关键字不存在，他会自动将该关键字插入；set不支持下标操作</li></ul><h1 id="map和set的相关问题"><a href="#map和set的相关问题" class="headerlink" title="map和set的相关问题"></a>map和set的相关问题</h1><p>为什么map和set插入和删除效率比其他容器高？</p><ul><li>不需要内存的拷贝和移动</li></ul><p>为什么map和set每次insert后，以前保存的迭代器不会失效？</p><ul><li>因为插入操作只是节点的指针的交换，节点并没有改变，节点的内存没有改变，指向内存的指针也不会改变。（红黑树迭代器只是一个指向节点的指针，插入和删除不会改变节点内存，只可能改变节点的父子节点）</li></ul><p>当数据元素增多时（从10000增加到20000）,map和set的查找速度会怎样？</p><ul><li>二者的底层是基于红黑树来实现的，查找的时间复杂度为logn,数据量从10000增加到20000，查找的次数从log10000 &#x3D; 14 增加到 log20000 &#x3D; 15，只是增加了1次</li></ul><p>为什么map和set不能像vector一样有个reserve函数来预分配数据</p><ul><li>map和set内部存储的已经不是元素本身了，而是包含元素的一个节点。他们内部使用的配置器不是在声明的时候传入的alloc而是转换后的alloc。</li><li>个人认为应该是不需要做预分配，因为每插入一个节点直接申请内存即可，插入节点也不会影响原有迭代器</li></ul>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>407. 接雨水 II</title>
      <link href="/2023/06/20/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-407-%E6%8E%A5%E9%9B%A8%E6%B0%B4II-diffcult/"/>
      <url>/2023/06/20/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-407-%E6%8E%A5%E9%9B%A8%E6%B0%B4II-diffcult/</url>
      
        <content type="html"><![CDATA[<h1 id="407-接雨水-II"><a href="#407-接雨水-II" class="headerlink" title="407. 接雨水 II"></a><a href="https://leetcode.cn/problems/trapping-rain-water-ii/description/">407. 接雨水 II</a></h1><p>First：没做出来，和2D接雨水的按列求思路有点类似，但和单调栈差异巨大，因为单调栈只能处理2d的</p><hr><p><strong>方法1</strong>：<strong>最小堆</strong></p><p>在2d接雨水中，使用了左右两个最高墙，而此题就需要维护一个圈（不能只是简单上下左右四个方向）。</p><p>首先将最外围的柱子添加进最小堆中，然后弹出一个最小高度值，由于此柱子高度最低，水只可能往这流出，然后判断此柱子上下左右四个柱子，若已经遍历过则跳过，将其插入到最小堆中，其高度值应该为弹出柱子和当前柱子的最大值（相当于更新了围墙），若能装水则加到结果上。</p><p>使用一个vision数组来记录是否已经遍历</p><p>总结：水只可能从围墙的最低处流出，因此遍历最低处周围的柱子，并更新围墙。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    struct Node&#123;        int x_,y_,h_;        Node(int x,int y,int h):x_(x),y_(y),h_(h)&#123;&#125;        bool operator &lt; (const Node &amp;a) const&#123;            return h_&gt;a.h_;        &#125;    &#125;;public:    int trapRainWater(vector&lt;vector&lt;int&gt;&gt;&amp; heightMap) &#123;        if(heightMap.size()&lt;&#x3D;1) return 0;        int m&#x3D;heightMap.size(),n&#x3D;heightMap[0].size();        vector&lt;vector&lt;int&gt;&gt; vision(m,vector&lt;int&gt;(n,0));        priority_queue&lt;Node&gt; pq;        for(int i&#x3D;0;i&lt;m;++i)&#123;            for(int j&#x3D;0;j&lt;n;++j)&#123;                if(i&#x3D;&#x3D;0||i&#x3D;&#x3D;m-1||j&#x3D;&#x3D;0||j&#x3D;&#x3D;n-1)&#123;                    pq.push(&#123;i,j,heightMap[i][j]&#125;);                &#125;            &#125;        &#125;        int ans&#x3D;0;        while(!pq.empty())&#123;            Node t&#x3D;pq.top();            pq.pop();            auto func&#x3D;[&amp;](int x,int y)&#123;                if(x&gt;0&amp;&amp;x&lt;m-1&amp;&amp;y&gt;0&amp;&amp;y&lt;n-1&amp;&amp;vision[x][y]&#x3D;&#x3D;0)&#123;                    pq.push(&#123;x,y,max(t.h_,heightMap[x][y])&#125;);                    if(t.h_-heightMap[x][y]&gt;0) ans+&#x3D;t.h_-heightMap[x][y];                    vision[x][y]&#x3D;1;                &#125;            &#125;;            func(t.x_-1,t.y_);            func(t.x_+1,t.y_);            func(t.x_,t.y_-1);            func(t.x_,t.y_+1);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. 寻找两个正序数组的中位数</title>
      <link href="/2023/06/12/leetcode/%E6%95%B0%E7%BB%84/leetcode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-diffcult/"/>
      <url>/2023/06/12/leetcode/%E6%95%B0%E7%BB%84/leetcode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-diffcult/</url>
      
        <content type="html"><![CDATA[<h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">4. 寻找两个正序数组的中位数</a></h1><p>First：没做出来</p><hr><p><strong>方法1</strong>：<strong>二分查找</strong></p><p>参考<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/258842/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">1</a></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230612153408529.png" alt="image-20230612153408529"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230612153557096.png" alt="image-20230612153557096"></p><ul><li>时间复杂度：O(log(m+n))</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int getKthElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2,int k)&#123;        int m&#x3D;nums1.size(),n&#x3D;nums2.size();        int index1&#x3D;0,index2&#x3D;0;        while(1)&#123;            if(index1&#x3D;&#x3D;m)&#123;                return nums2[index2+k-1];            &#125;            if(index2&#x3D;&#x3D;n)&#123;                return nums1[index1+k-1];            &#125;            if(k&#x3D;&#x3D;1)&#123;                return min(nums1[index1],nums2[index2]);            &#125;            int newindex1&#x3D;min(index1+k&#x2F;2-1,m-1);            int newindex2&#x3D;min(index2+k&#x2F;2-1,n-1);            if(nums1[newindex1]&lt;&#x3D;nums2[newindex2])&#123;                k-&#x3D;newindex1-index1+1;                index1&#x3D;newindex1+1;                            &#125;else&#123;                k-&#x3D;newindex2-index2+1;                index2&#x3D;newindex2+1;            &#125;        &#125;    &#125;    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        double ans&#x3D;0;        int size&#x3D;nums1.size()+nums2.size();        if(size%2&#x3D;&#x3D;1)&#123;            ans&#x3D;getKthElement(nums1,nums2,(size+1)&#x2F;2);        &#125;else&#123;            int pre&#x3D;getKthElement(nums1,nums2,size&#x2F;2);            int last&#x3D;getKthElement(nums1,nums2,size&#x2F;2+1);            ans&#x3D;(pre+last)&#x2F;2.0;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP详解，卷1：协议阅读笔记</title>
      <link href="/2023/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71-%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.52im.net/topic-tcpipvol1.html"><em>TCP&#x2F;IP详解，卷1：协议</em> </a>阅读笔记</p><h1 id="第1章-概-述"><a href="#第1章-概-述" class="headerlink" title="第1章 概 述"></a>第1章 概 述</h1><p><strong>基础知识</strong>：</p><ul><li>传输层协议TCP和UDP采用16 bit的端口号来识别应用程序，而知名的程序端口已被固定分配。</li><li>底层向上传送数据时，每层协议都要去检查报文首部中的协议标识，以确定接收数据的上层协议，这个过程称作分用<ul><li>例如IP协议中首部有个8bit的数字，表示上层协议名字，6表示TCP协议</li></ul></li><li>RFC(Request For Comment) 中TCP&#x2F;IP协议族每一层的稳健性原则：<strong>自由地接收，保守地发送</strong></li><li>网络层和运输层之间的区别：网络层（IP）提供点到点的服务，而运输层（TCP和UDP）提供端到端的服务。这也是为什么将网络层和运输层划分开的原因。</li></ul><p><strong>FTP发送消息示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230609202737930.png"></p><p>本书要讨论的协议</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230609113755572.png"></p><p><strong>几类IP地址</strong>（注意比较，网络号的规则是逐渐加一个字节）：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230609202849943.png"></p><h1 id="第2章-链路层"><a href="#第2章-链路层" class="headerlink" title="第2章 链路层"></a>第2章 链路层</h1><p>链路层主要有三个目的：、</p><ul><li>（1）为IP模块发送和接收IP数据报；</li><li>（2）为ARP模块发送ARP请求和接收ARP应答；</li><li>（3）为RARP发送RARP请求和接收RARP应答</li></ul><h2 id="2-1-以太网和IEEE-802封装"><a href="#2-1-以太网和IEEE-802封装" class="headerlink" title="2.1 以太网和IEEE 802封装"></a>2.1 以太网和IEEE 802封装</h2><p>以太网和IEEE802帧格式稍有不同：</p><ul><li>在802中，长度字段是指它后续数据的字节长度，但不包括CRC检验码，类型字段则由后续的子网接入协议的首部给出。以太网的类型字段定义了后续数据的类型。</li><li>802.3规定数据部分必须至少为38字节，而对于以太网，则要求最少要有46字节。为了保证这一点，必须在不足的空间插入填充（pad）字节。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620103016456.png"></p><h2 id="2-2-SLIP：串行线路IP"><a href="#2-2-SLIP：串行线路IP" class="headerlink" title="2.2 SLIP：串行线路IP"></a>2.2 SLIP：串行线路IP</h2><p><strong>SLIP协议帧格式</strong>：</p><ul><li>IP数据报以一个称作END（0xc0）的特殊字符结束。同时，为了防止数据报到来之前的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个END字符（如果有线路噪声，那么END字符将结束这份错误的报文。这样当前的报文得以正确地传输，而前一个错误报文交给上层后，会发现其内容毫无意义而被丢弃）。</li><li>如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它。0xdb这个特殊字符被称作SLIP的ESC字符，但是它的值与ASCII码的ESC字符（0x1b）不同。</li><li>如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620104831921.png"></li></ul><p><strong>SLIP缺陷</strong>：</p><ul><li>每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。</li><li>数据帧中没有类型字段（类似于以太网中的类型字段）。如果一条串行线路用于SLIP，那么它不能同时使用其他协议。</li><li>SLIP没有在数据帧中加上检验和，只能通过上层协议来发现错误。因此IP首部和TCP首部及其数据始终都有检验和，UDP首部及其数据的检验和却是可选的。</li></ul><p><strong>压缩SLIP（SCLIP）</strong></p><ul><li>SLIP线路上有许多小的TCP分组进行交换，为了传送1个字节的数据需要20个字节的IP首部和20个字节的TCP首部，总数超过40个字节，整体效率很低</li><li>CSLIP一般能把上面的40个字节压缩到3或5个字节。它能在CSLIP的每一端维持多达16个TCP连接，并且知道其中每个连接的首部中的某些字段一般不会发生变化。</li></ul><h2 id="2-3-PPP：点对点协议"><a href="#2-3-PPP：点对点协议" class="headerlink" title="2.3 PPP：点对点协议"></a>2.3 PPP：点对点协议</h2><p>PPP，点对点协议修改了SLIP协议中的所有缺陷。PPP包括以下三个部分：</p><ol><li>在串行链路上封装IP数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式，还支持面向比特的同步链接。</li><li>建立、配置及测试数据链路的链路控制协议（LCP：Link Control Protocol）。它允许通信双方进行协商，以确定不同的选项。</li><li>针对不同网络层协议的网络控制协议（NCP：Network Control Protocol）体系。IP NCP允许双方商定是否对报文首部进行压缩，类似于CSLIP。</li></ol><p><strong>PPP帧格式</strong></p><ul><li><p>每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。</p></li><li><p>当遇到字符0x7e时，需连续传送两个字符：0x7d和0x5e，以实现标志字符的转义。当遇到转义字符0x7d时，需连续传送两个字符：0x7d和0x5d，以实现转义字符的转义。</p></li><li><p>利用链路控制协议，大多数的产品通过协商可以省略标志符和地址字段，并且把协议字段由2个字节减少到1个字节。PPP只增加了3个额外的字节：1个字节留给协议字段，另2个给CRC字段使用。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620113229094.png"></p></li></ul><p><strong>PPP优点</strong></p><ul><li>(1)PPP支持在单根串行线路上运行多种协议，不只是IP协议；</li><li>(2)每一帧都有循环冗余检验；</li><li>(3)通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；</li><li>(4)与CSLIP类似，对TCP和IP报文首部进行压缩；</li><li>(5)链路控制协议可以对多个数据链路选项进行设置。</li></ul><h2 id="2-4-环回接口"><a href="#2-4-环回接口" class="headerlink" title="2.4 环回接口"></a>2.4 环回接口</h2><p>大多数的产品都支持环回接口（Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过TCP&#x2F;IP进行通信。A类网络号127就是为环回接口预留的。根据惯例，大多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。</p><p>大多实现照样完成传输层和网络层的所有过程，只是当IP数据报离开网络层时把它返回给自己。</p><ul><li>传给环回地址（一般是127.0.0.1）的任何数据均作为IP输入。</li><li>传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是因为广播传送和多播传送的定义包含主机本身。</li><li>任何传给该主机IP地址的数据均送到环回接口。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620113700866.png"></p><h2 id="2-5-最大传输单元MTU"><a href="#2-5-最大传输单元MTU" class="headerlink" title="2.5 最大传输单元MTU"></a>2.5 最大传输单元MTU</h2><p>以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特性称作MTU ,最大传输单元。</p><p>如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大,那么IP层就需要进行分片（fragmentation），把数据报分成若干片，这样每一片都小于MTU。</p><p>点到点的链路层（如SLIP和PPP）的<strong>MTU并非指的是网络媒体的物理特性，而是一个逻辑限制</strong>，目的是为交互使用提供足够快的响应时间。</p><p><strong>路径MTU</strong>：两台通信主机路径中的最小MTU</p><h1 id="第3章-IP-网际协议"><a href="#第3章-IP-网际协议" class="headerlink" title="第3章 IP:网际协议"></a>第3章 IP:网际协议</h1><h2 id="3-1-IP首部"><a href="#3-1-IP首部" class="headerlink" title="3.1 IP首部"></a>3.1 <strong>IP首部</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230611190424255.png"></p><p>网络数据传输采用<strong>大端字节序</strong>，也称网络字节序（即先传输左边的高位）。IP首部各字段作用：</p><ul><li>首部长度：指首部占32 bit字（4字节）的数目。其是一个4比特字段，因此首部最长为60个字节。</li><li>服务类型（TOS）字段：包括一个3bit的优先权子字段（现已被忽略），4bit的TOS子字段和1bit未用位但必须置0。<ul><li>4bit的TO S分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4bit中只能置其中1bit。均为0则为一般服务。</li></ul></li><li>总长度字段：指整个IP数据报的长度，以字节为单位。利用首部长度字段，可以知道IP数据报中数据内容的起始位置和长度。<ul><li>以太网有最小帧长限制，需要对数据进行填充，因此必须有总长度字段才能知道IP数据包的内容。</li></ul></li><li>标识字段：唯一地标识主机发送的每一份数据报，每发送一份报文它的值就会加1。</li><li>片偏移：用于分片和重组</li><li>TTL：数据报可以经过的最多路由器数，每经过一个路由器此值减1</li><li>首部检验和：根据IP首部计算的检验和码（不包括数据，因为ICMP、TCP等均含有同时覆盖首部和数据的检验和码）<ul><li>检验和生成：把检验和字段置为0，对首部中每个16 bit进行二进制反码求和</li><li>检验和校验：校验也是对首部中每个16 bit进行二进制反码求和（包括检验字段），因此结果应该全为1.</li></ul></li><li>选项字段：可选时间戳等，是一个变长字段。一直都是以32 bit作为界限，在必要的时候插入值为0的填充字节</li></ul><h2 id="3-2-IP路由选择"><a href="#3-2-IP路由选择" class="headerlink" title="3.2 IP路由选择"></a>3.2 IP路由选择</h2><p>当IP层从TCP等或一个网络接口收到数据报并进行发送时，会先搜索路由表（每一份数据报都搜索）。</p><p>如果从网口收到数据，则检查目的IP地址是否为本机的IP地址之一或者IP广播地址，是则送到指定协议模块处理，不是则根据主机设定进行转发或丢弃（主机可以设定是否进行路由功能）</p><p>路由表中的每一项都包含以下信息：</p><ul><li>目的IP地址：一个主机地址或网络地址，由一个标志字段决定</li><li>下一站（或下一跳）路由器的IP地址，或者有直接连接的网络IP地址</li><li>标志：一个指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口</li><li>数据报的传输指定一个网络接口</li></ul><p>P路由选择是逐跳地进行的，IP并不知道到达任何目的的完整路径。IP路由选择规则：</p><ul><li>先寻找能与目的IP地址完全匹配的表目，若没找到则寻找能与目的网络号相匹配的表目，还是没找到则寻找标为“默认（default）”的表目。</li></ul><h2 id="3-3-子网掩码"><a href="#3-3-子网掩码" class="headerlink" title="3.3 子网掩码"></a>3.3 子网掩码</h2><p><strong>子网好处</strong>：可以将主机数巨大的地址空间划分为多个子网；由于划分子网对外界是透明的，因此相比将其分为C类地址，可以显著减少路由条目</p><p>子网掩码是一个32 bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230612155526100.png"></p><blockquote><p>0表示所有的比特位全为0；-1表示所有的比特位全为1；netid、subnetid和hostid分别表示不为全0或全1的对应字段。子网号栏为空表示该地址没有进行子网划分。</p></blockquote><h1 id="第4章-ARP-地址解析协议"><a href="#第4章-ARP-地址解析协议" class="headerlink" title="第4章 ARP:地址解析协议"></a>第4章 ARP:地址解析协议</h1><p>在链路层进行数据传输需要有硬件地址（一个48 bit的值），ARP为IP地址到对应的硬件地址之间提供动态映射。</p><p><strong>ARP高速缓存</strong>：每个主机上都有一个ARP高速缓存，存放了最近IP地址到硬件地址之间的映射记录，每一项的生存时间一般为20分钟。</p><p><strong>ARP请求或应答格式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230612161939294.png"></p><p>字段说明：</p><ul><li>以太网的源地址和目的地址：目的地址为全1，表示广播帧</li><li>帧类型：表示后面数据的类型，ARP该值为0x0806</li><li>硬件类型：表示硬件地址的类型，值为1即表示以太网地址</li><li>协议类型：表示要映射的协议地址类型，值为0x0800即表示IP地址</li><li>硬件地址长度和协议地址长度：分别指出硬件地址和协议地址的长度，以字节为单位。当为ARP时，值分别为6和4。</li><li>操作：四种操作类型，ARP请求（1）、ARP应答（2）、RARP请求（3）和RARP应答（4）</li><li>最后四个字段分别为发送接收端IP地址和以太网地址，注意这里硬件地址有所重复。</li></ul><p>ARP请求：除目的端硬件地址外的所有其他的字段都有填充值。</p><p>ARP接受：当系统收到一份目的端为本机的ARP请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为2，最后把它发送回去。（注意是处理请求部分，这里逻辑感觉有点不清楚，难道目的两个地址不进行更改？）</p><blockquote><p>如果查询的主机已关机或不存在，那么ARP会不断重传报文，如果超过时间限制则结束，而此时上层协议也会因超时等原因传输失败</p></blockquote><p><strong>ARP代理</strong>：如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求</p><ul><li>这样可以欺骗发起ARP请求的发送端，使它误以为路由器就是目的主机，而事实上目的主机是在路由器的“另一边”。路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。</li></ul><p><strong>免费ARP</strong>：指主机发送ARP查找自己的IP地址。通常发生在系统引导期间进行接口配置的时候。其作用如下：</p><ul><li>可以通过其来确定另一个主机是否设置了相同的IP地址。</li><li>如果发送免费ARP的主机正好改变了硬件地址，那么就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。</li></ul><h1 id="第5章-RARP-逆地址解析协议"><a href="#第5章-RARP-逆地址解析协议" class="headerlink" title="第5章 RARP:逆地址解析协议"></a>第5章 RARP:逆地址解析协议</h1><blockquote><p>具有本地磁盘的系统引导时，一般是从磁盘上的配置文件中读取IP地址。但是无盘机，如X终端或无盘工作站，则需要采用其他方法来获得IP地址。（为啥不用DHCP获取？引导镜像需要发送TFTP请求进行读取，可能DHCP较复杂）</p></blockquote><p><strong>RARP的分组格式</strong>：与ARP分组基本一致。主要差别是RARP请求或应答的帧类型代码为0x8035，且RARP请求的操作代码为3，应答操作代码为4。</p><ul><li>RARP请求以广播方式传送，而RARP应答一般是单播传送的（RAP应答也是单播）。</li><li>同样，RARP也会超时重发</li></ul><p>RARP服务器的复杂性在于</p><ul><li>由于需要提供硬件地址到IP地址的映射，而此映射一般在磁盘文件中。由于内核一般不读取和分析磁盘文件，因此RARP服务器的功能就由用户进程来提供</li><li>由于发送和接收这些数据帧与系统有关，因此RARP服务器的实现是与系统捆绑在一起的。</li></ul><h1 id="第11章-UDP-用户数据报协议"><a href="#第11章-UDP-用户数据报协议" class="headerlink" title="第11章 UDP:用户数据报协议"></a>第11章 UDP:用户数据报协议</h1><h2 id="11-1-UDP首部"><a href="#11-1-UDP首部" class="headerlink" title="11.1 UDP首部"></a>11.1 UDP首部</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230613151945659.png"></p><ul><li><p>端口号：表示发送和接收进程</p></li><li><p>UDP长度：指的是UDP首部和UDP数据的字节长度，最小值为8字节，因此可以发送一个0字节报文。且此字段是冗余的，可以通过IP长度字段求得此字段</p></li><li><p>UDP校验和：覆盖UDP首部和UDP数据。计算方法和IP首部校验相同，只是由于该算法是将16bit相加，不足处补0。</p><ul><li>且计算时还存在一个12字节长的伪首部，用于检查数据是否已经到达了正确的目的地<ul><li>比如IP头部的目的ip地址在传输过程中被错误的改变了，这个分组就会到达错误ip地址的主机。</li><li>比如IP头部的协议号被错误的改变了（本来是TCP，现在却错改成UDP），这个分组就会到达UDP协议栈，但实际上这个分组不应该被UDP处理。</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230613152618515.png" style="zoom:50%;" /></li></ul><h2 id="11-2-IP分片"><a href="#11-2-IP分片" class="headerlink" title="11.2 IP分片"></a>11.2 IP分片</h2><p>物理网络层一般要限制每次发送数据帧的最大长度，当IP数据报长度超过其MTU时，就会进行分片（发生在原始发送端或中间路由器）</p><p>当分片到达目的地才进行重新组装（是<strong>在下一站就进行重装</strong>，而不是最终目的地），重新组装由目的端的IP层来完成。</p><p>分片过程：</p><ul><li>每份IP数据报都有唯一标识，分片时会复制到分片中。</li><li>标志字段用其中一个比特来表示“更多的片”，除最后一片外该值都要置1</li><li>片偏移字段指的是该片偏移原始数据报开始处的位置（以8字节为单位）。当数据报被分片后，每个片的总长度值要改为该片的长度值。</li><li>标志字段中有一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片</li><li>注意，除最后一片外,其他片中的数据长度均要求为8字节的整数倍</li></ul><blockquote><p><strong>判断到达目的端的路途中最小MTU方法：</strong></p><ul><li>不断增大数据报长度，且在IP首部设置不分片（DF）的标志比特，那么当路由器遇见此种情况就会发送一个ICMP差错报文。</li></ul></blockquote><h2 id="11-3-UDP和ARP之间的交互作用"><a href="#11-3-UDP和ARP之间的交互作用" class="headerlink" title="11.3 UDP和ARP之间的交互作用"></a>11.3 UDP和ARP之间的交互作用</h2><p>当使用UDP发送一个8192字节的数据报（会产生6个分片），并将ARP缓存清空。此时会发生以下情况：</p><ul><li>由于产生分片速度更快，在第一个ARP请求未响应前，每个分片都会产生一个ARP请求，共产生6个请求。</li><li>在接收到第一个ARP应答时，只发送最后一个数据报片，看来似乎将前5个数据报片全都丢弃了<ul><li>这是ARP的正常操作。在大多数的实现中，在等待一个ARP应答时，只将最后一个报文发送给特定目的主机。</li></ul></li><li>还有一个无法解释的现象是会收到7个ARP解答，而不是6个</li></ul><h2 id="11-4-最大UDP数据报长度"><a href="#11-4-最大UDP数据报长度" class="headerlink" title="11.4 最大UDP数据报长度"></a>11.4 最大UDP数据报长度</h2><p>IP数据报的最大长度是65535字节，这是由IP首部16比特总长度字段所限制的。去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节。但真实UDP最大长度有以下限制：</p><ul><li>可能会受到其程序接口的限制，如设置接收和发送缓存的长度会影响最大UDP长度</li><li>另外的限制来自于TCP&#x2F;IP的内核实现。可能存在一些实现特性（或差错），使IP数据报长度小于65535字节。</li></ul><blockquote><p>UDP编程接口允许应用程序指定每次返回的最大字节数。如果接收到的数据报长度大于应用程序所能处理的长度，那么会发生什么情况呢？</p><ul><li>取决于编程接口和实现，有的会丢弃多余数据，有的超出部分数据在后面的读取中返回</li></ul></blockquote><h2 id="11-5-习题"><a href="#11-5-习题" class="headerlink" title="11.5 习题"></a>11.5 习题</h2><ol><li>为什么除最后一片外,其他片中的数据长度均要求为8字节的整数倍?<ul><li>因为片偏移量是以8字节为单位</li></ul></li><li>分片后再分片？<ul><li>可以进行，仍然以片偏移字段进行恢复，其值是指当前分片在最初IP数据报中的位置</li></ul></li><li>UDP数据报因分片直接收到1、2、3，而未接受到4。那么当重传时，原来的123片能否使用重传的4重组？<ul><li>不能，每个分片都有唯一标识</li></ul></li><li>TCP检验和差错被丢弃20个，但UDP检验和差错而被丢弃的数据报一份也没有。请说明两个方面的原因<ul><li>如果输出UDP的检验和没有被使用，就不会验证一个进入UDP的检验和</li><li>大多数的UDP通信量都是本地的，而不是WAN的，因此没有服从所有的WAN特征。</li></ul></li><li>分片时IP首部中的选项是否也要被复制到每个数据报片中，或者只留在第一个数据报片中？<ul><li>不严格的和严格的源站选路选项被复制到每一个数据报片中。</li><li>时间戳选项和记录路由选项没有被复制到每一个数据报片中—它们只出现在第1个数据报片中。</li></ul></li></ol><h1 id="第17章-TCP：传输控制协议"><a href="#第17章-TCP：传输控制协议" class="headerlink" title="第17章 TCP：传输控制协议"></a>第17章 TCP：传输控制协议</h1><p><strong>TCP提供一种面向连接的、可靠的字节流服务</strong></p><p>TCP通过下列方式来提供可靠性：</p><ul><li>应用数据被分割成TCP认为最适合发送的数据块。而UDP则保持应用产生的数据报长度不变。</li><li>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li><li>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒</li><li>TCP将检测它首部和数据的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段</li><li>TCP将对收到的数据进行重新排序，以正确的顺序交给应用层</li><li>IP数据报会发生重复，TCP的接收端必须丢弃重复的数据</li><li>TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</li></ul><h2 id="17-1-TCP的首部"><a href="#17-1-TCP的首部" class="headerlink" title="17.1 TCP的首部"></a>17.1 <strong>TCP的首部</strong></h2><p>如果不计任选字段，首部通常是20个字节</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230613200442824.png"></p><ul><li>端口号：用于寻找发端和收端应用进程<ul><li>一个IP地址和一个端口号也称为一个插口（socket）。插口对（socketpair）(包含客户IP地址、客户端口号、服务器IP地址和服务器端口号的四元组)可唯一确定互联网络中每个TCP连接的双方。</li></ul></li><li>序号：标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节<ul><li>序号超过最大值后会从0开始</li></ul></li><li>确认序号：发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加1。只有ACK标志为1时确认序号字段才有效。</li><li>首部长度：首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的，最多有60字节的首部（(2^4-1)*4)。</li><li>6个标志比特:<ul><li>URG：紧急指针有效</li><li>ACK：确认序号有效</li><li>PSH：接收方尽快将这个保温段交给应用层</li><li>RST：重建连接</li><li>SYN：同步序号用来发起一个链接</li><li>FIN：发端完成发送任务</li></ul></li><li>窗口大小：用于流量控制</li><li>检验和：覆盖了整个TCP报文段，是强制性的，由发端计算和存储，并由收端进行验证。TCP检验和的计算和UDP检验和的计算相似。</li><li>紧急指针：是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。只有当URG标志置1时紧急指针才有效。</li><li>可选字段：最常见的是最长报文大小，通常在连接建立时发送</li></ul><h2 id="17-2-习题"><a href="#17-2-习题" class="headerlink" title="17.2 习题"></a>17.2 <strong>习题</strong></h2><ol><li>各种协议检验和包括IP数据报中的哪些部分，以及该检验和是强制的还是可选的？<ul><li>除了UDP的检验和，其他都是必需的。IP检验和只覆盖了IP首部，而其他字段都包含首部和数据。</li></ul></li><li>为什么我们已经讨论的所有Internet协议（IP,ICMP,IGMP,UDP,TCP）收到有检验和错的分组都仅作丢弃处理？<ul><li>源IP地址、源端口号或者协议字段可能被破坏了</li></ul></li><li>TCP提供了一种字节流服务，而收发双方都不保持记录的边界。应用程序如何提供它们自己的记录标识？<ul><li>使用特定字符或数据长度</li></ul></li><li>为什么在TCP首部的开始便是源和目的的端口号？<ul><li>一个ICMP差错报文必须至少返回引起差错的IP数据报中除了IP首部的前8个字节。当TCP收到一个ICMP差错报文时，它需要检查两个端口号以决定差错对应于哪个连接。因此，端口号必须包含在TCP首部的前8个字节里。</li></ul></li><li>为什么TCP首部有一个首部长度字段而UDP首部中却没有？<ul><li>TCP首部的最后有一些选项，但UDP首部中没有选项。（但其实也能通过IP报文长度字段推导出来）</li></ul></li></ol><h1 id="第18章-TCP连接的建立与终止"><a href="#第18章-TCP连接的建立与终止" class="headerlink" title="第18章 TCP连接的建立与终止"></a>第18章 TCP连接的建立与终止</h1><p> TCP的状态变迁图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614161733356.png"></p><h2 id="18-1-连接建立"><a href="#18-1-连接建立" class="headerlink" title="18.1 连接建立"></a>18.1 连接建立</h2><p>建立一条TCP连接，即<strong>三次握手</strong>：</p><ol><li>请求端发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN）。这个SYN段为报文段1。<ul><li>ISN随时间而变化，可看作是一个32比特的计数器，每4ms加1（有的地方又写每0.5秒增加64000）</li></ul></li><li>服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个序号。</li><li>客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认（报文段3）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614160138378.png"></p><p><strong>连接建立超时</strong>：当发送请求长时间未收到应答则会重传，当重传一定次数或时间则结束此次请求</p><p><strong>最大报文段长度</strong>：在建立连接时，连接的双方都要通告各自的MSS（TCP的可选字段），如未收到则默认536字节。在没有分段发生情况下，通常越大越好。</p><h2 id="18-2-连接终止"><a href="#18-2-连接终止" class="headerlink" title="18.2 连接终止"></a>18.2 连接终止</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614170223488.png"></p><p><strong>半关闭</strong>：连接的一端在结束它的发送后还能接收来自另一端数据</p><ul><li>如果应用程序不调用close而调用shutdown，且第2个参数值为1，则插口的API支持半关闭</li><li>为什么要有半关闭？如RSH命令需要向远程传输数据并接受返回结果，如果没有半关闭功能，则还需要采取其他方式通知数据已经传输完毕。</li></ul><blockquote><p>当四次挥手时，如果收到一个SYN会如何处理？</p><ul><li>发送一个带ACK的SYN（进入SYN_RCVD）。然后如果收到一个RST，而不是一个ACK，便又回到LISTEN状态并等待另一个连接请求的到来</li></ul></blockquote><p><strong>2MSL等待状态</strong>：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）</p><ul><li>2MSL会使得该端口不可用，但可以使用SO_REUSEADDR来重用（注意，这是实现所支持的，但TCP不能允许一个新的连接建立在相同的插口对，即四元组）</li></ul><p><strong>平静时间</strong>：TCP在重启动后的MSL秒内不能建立任何连接，即为平静时间</p><p> <strong>FIN_WAIT_2状态</strong>：只有收到另一端的FIN，才会从FIN_WAIT_2状态进入TIME_WAIT状态，也就意味着可能永远保持这个状态。另一端也将处于CLOSE_WAIT状态，并一直保持这个状态直到应用层决定进行关闭。</p><ul><li>在实现中，如果进行全关闭，则设置一个定时器，如果这个连接空闲10分钟75秒，TCP将进入CLOSED状态。</li></ul><p><strong>复位报文段</strong>：无论何时一个报文段发往四元组连接出现错误，TCP都会发出一个复位报文段，注意收到RST不会产生任何响应。有如下情况：</p><ul><li>到不存在的端口的连接请求。例如UDP发送到一个未使用的端口，则产生ICMP信息；而TCP则使用复位。</li><li>异常终止一个连接。通常有以下优点：<ul><li>丢弃任何待发数据并立即发送复位报文段；</li><li>RST的接收方能区分另一端执行的是异常关闭还是正常关闭。</li></ul></li><li>检测半打开连接。<ul><li>如果一方已经关闭或异常终止连接而另一方却还不知道，这样的TCP连接称为半打开</li><li>例如因掉电而重启，服务端已经丢失原来连接信息，此时客户端发送一个消息，服务端则以复位作为应答。</li></ul></li></ul><p><strong>两方同时发送建立连接</strong>：这种情况只会建立一条连接（注意两方必须属于同一四元组）</p><ul><li>两端几乎在同时发送SYN，并进入SYN_SENT状态。</li><li>当每一端收到SYN时，状态变为SYN_RCVD，同时它们都再发SYN并对收到的SYN进行确认。</li><li>当双方都收到SYN及相应的ACK时，状态都变迁为ESTABLISHED。</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614192431876.png"></li></ul><p><strong>两方同时关闭连接</strong>：</p><ul><li><p>当应用层发出关闭命令时，两端均从ESTABLISHED变为FIN_WAIT_1</p></li><li><p>双方各发送一个FIN，双方收到FIN后，状态由FIN_WAIT_1变迁到CLOSING，并发送最后的ACK</p></li><li><p>当收到最后的ACK时，状态变化为TIME_WAIT（有点不太理解为啥不直接closed，此时已经接收到ack了，如果是为了保证对方能正确接收到ack，难道对方超时后会重新发送FIN吗）</p><blockquote><p>如果最后ack丢失怎么办？重新发送FIN？</p></blockquote></li></ul><p><strong>TCP选项</strong>：</p><ul><li>每个选项的开始是1字节kind字段，说明选项的类型。kind字段为0和1的选项仅占1个字节。其他的选项在kind字节后还有len字节。它说明的长度是指总长度，包括kind字节和len字节。</li><li>设置无操作选项的原因在于允许发方填充字段为4字节的倍数。</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614195305445.png"></li></ul><blockquote><p><strong>习题</strong></p><ol><li>半打开连接和半关闭连接的区别是什么？<ul><li>在一个半关闭的连接上，一个端点已经发送了一个FIN，正等待另一端的数据或者一个FIN。一个半打开的连接是当一个端点崩溃了，而另一端还不知道的情况。</li></ul></li><li>如果启动sock程序作为一个服务器程序，然后终止它（还没有客户进程与它相连接），我们能立即重新启动这个服务器程序。这意味着它没有经历2MSL等待状态。<ul><li>一个连接只有经过了已建立状态才能进入2MSL等待状态。</li></ul></li><li>主动关闭方因超时而从FIN_WAIT_2变为CLOSED，如果此时被关闭方发送一个FIN，该如何处理？<ul><li>在一个已经关闭的连接上到达了一个FIN，会发送了一个复位报文（但如果还是TIME_WAIT状态则会重新开始2msl定时）。</li></ul></li><li>为什么服务器不将对客户FIN的ACK与自己的FIN合并，从而将报文段数减少为3个？<ul><li>服务器对客户的FIN的确认一般不会被延迟，而是在FIN到达后立即发送。</li><li>服务器收到客户的FIN后，并不一定要关闭它这一端的连接。</li></ul></li><li>假定MSL为120秒，试问系统能够初始化一个新连接然后进行主动关闭的最大速率是多少？<ul><li>最大数目的TCP端口号（65536-1024&#x3D;64512，忽略知名端口）除以TIME_WAIT状态的2MSL。</li></ul></li><li>分析处于TIME_WAIT状态的主机收到使其进入此状态的重复的FIN时所发生的情况<ul><li>重复的FIN会得到确认，2MSL定时器重新开始。</li></ul></li><li>分析处于TIME_WAIT状态的主机收到一个RST时所发生的情况。<ul><li>在TIME_WAIT状态中收到一个RST引起状态过早地终止，这就叫作TIME_WAIT断开。有RFC提出的简单的修改就是在TIME_WAIT状态时忽略RST段。</li></ul></li><li>在图1-8中，我们曾提到到来的TCP报文段可根据其目的端口号进行分用，请问这种说法是否正确？<ul><li>错误，只能根据四元组进行分用</li></ul></li></ol></blockquote><h1 id="第19章-TCP的交互数据流"><a href="#第19章-TCP的交互数据流" class="headerlink" title="第19章 TCP的交互数据流"></a>第19章 TCP的交互数据流</h1><p>通常TCP在接收到数据时并不立即发送ACK而是推迟发送，以便将ACK与需要沿该方向发送的数据一起发送。绝大多数实现TCP将以最大200 ms的时延等待是否有数据一起发送。在等待时，如果有数据则立即发送。</p><p><strong>Nagle算法</strong>：该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组（微小TCP报文），在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去<em>（TCP本来就是流，相当于积存较多的数据一起发送）</em>。</p><ul><li>有时也需要关闭Nagle算法。如小消息（鼠标移动）必须无时延地发送，</li></ul><p><strong>窗口大小通告</strong>：发送报文时会填写通告窗口大小，其值为当前缓冲区可用大小</p><h1 id="第20章-TCP的成块数据流"><a href="#第20章-TCP的成块数据流" class="headerlink" title="第20章 TCP的成块数据流"></a>第20章 TCP的成块数据流</h1><p><strong>滑动窗口</strong>：滑动窗口大小由对方指定的窗口值（和拥塞窗口中最小值）确定，因此可能会变大或变小</p><ul><li>称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。</li><li>当窗口右边沿向右移动时将允许发送更多的数据，称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时（此时报文中的窗口值变大）。</li><li>如果接收到一个指示窗口左边沿向左移动的ACK，则它被认为是一个重复ACK</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230615194408439.png"></p><p><strong>PUSH标志</strong>：使用该标志通知接收方将所收到的数据全部提交给接收进程。这里的数据包括与PUSH一起传送的数据以及接收方TCP已经为接收进程收到的其他数据。</p><ul><li>如果待发送数据将清空发送缓存，则大多数的源于伯克利的实现能够自动设置PUSH标志。而源于伯克利的实现一般从不将接收到的数据推迟交付给应用程序</li></ul><p><strong>慢启动</strong>：慢启动为发送方的TCP增加了拥塞窗口，记为cwnd。拥塞窗口被初始化为1个报文段（连接建立时发送的MSS值），每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加），因此经过一次RTT，cwnd会倍增。<strong>发送方取拥塞窗口与通告窗口中的最小值作为发送上限。</strong></p><ul><li>拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。</li></ul><p><strong>带宽时延乘积</strong>：一般窗口等于带宽时延积较好，如果小于则不能充分利用带宽，大于则好像浪费？</p><ul><li>时延是指往返时间。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230615204904420.png"></p><p><strong>紧急方式</strong>：它使一端可以告诉另一端有些具有某种方式的“紧急数据”已经放置在普通的数据流中。可以通过设置TCP首部URG比特为1，并且一个16bit的紧急指针被置为一个正的偏移量（该偏移量必须与TCP首部中的序号字段相加，以便得出紧急数据的<em>最后一个字节</em>的序号）</p><ul><li>作用：可以在滑动窗口为0时，通过发送紧急指针和URG标志来将紧急信息发给对方，使得对方能优先接收处理。</li><li>例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行。因此用户从键盘发出中断命令（Ctrl+C）。如果不使用紧急指针数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用程序。</li></ul><blockquote><p><strong>习题</strong></p><ol><li>如果API提供一种方法，使得发送方可以告诉其TCP打开PUSH标志，而接收方可以查询一个接收的报文段是否被设置了PUSH标志，试问该标志能否被用作一个记录标记？<ul><li>不，因为TCP超时之后可能重新对数据进行分组</li></ul></li><li>在一个Usenet记录中，有人抱怨说美国和日本之间的一个128 ms时延、速率为256 000 b&#x2F;s的链路吞吐量为120 000 b&#x2F;s（利用率为47%），而当链路通过卫星时其吞吐量则为33 000 b&#x2F;s（利用率为13％）。试问在这两种情况下窗口大小各为多少（假定卫星链路的时延为500 ms）？卫星链路的窗口大小应该如何调整？<ul><li>第一种情况是1920字节，卫星的情况是2062字节。直接将吞吐量和时延相乘即可。</li></ul></li></ol></blockquote><h1 id="第21章-TCP的超时与重传"><a href="#第21章-TCP的超时与重传" class="headerlink" title="第21章 TCP的超时与重传"></a>第21章 TCP的超时与重传</h1><p>TCP通过在发送时设置一个定时器来解决这种问题，当定时器溢出时还没有收到确认，它就重传该数据。通常重传时间每失败一次都会倍增，如2、4、8。</p><ul><li><p>当超时发生，先使用以下公式计算一个避退指数，一般A为0，D为当前RTT的一半。因此下一次超时时间为2*RTO，再下一次是4 *RTO</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230619172145792.png"></p></li><li><p>但是在习题21.1中给的答案又非如此，如第一次6，第二次2*6&#x3D;12，第三次4 *12&#x3D;48（可见答案，可能答案错误）。</p></li></ul><p>对每个连接，TCP管理4个不同的定时器：</p><ul><li>重传定时器使用于当希望收到另一端的确认。</li><li>坚持(persist)定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。第22章讨论。</li><li>保活(keepalive)定时器可检测到一个空闲连接的另一端何时崩溃或重启。</li><li>2MSL定时器测量一个连接处于TIME_WA IT状态的时间。</li></ul><h2 id="21-1-往返时间测量"><a href="#21-1-往返时间测量" class="headerlink" title="21.1 往返时间测量"></a>21.1 <strong>往返时间测量</strong></h2><ul><li><p>M为RTT，<em>A</em>是被平滑的RTT，D则是被平滑的均值偏差，<em>Err</em>是刚得到的测量结果与当前的RTT估计器之差。<em>A</em>和<em>D</em>均被用于计算下一个重传时间（RTO）。增量g起平均作用，取为1&#x2F;8（0.125）。偏差的增益是<em>h</em>，取值为0.25。当RTT变化时，较大的偏差增益将使<em>RTO</em>快速上升。</p></li><li><p>变量<em>A</em>和<em>D</em>分别被初始化为0和3秒</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230616114652804.png"></p></li><li><p>注意，每个时间只有一个定时器进行测量，例如报文3启动一个定时器，而在报文3的确认为返回前，其他报文都不会启动定时器（也就不测量往返时间）。有的实现中，测量时间值并非真实往返值，而是时钟滴答次数（见21.4.1）</p></li></ul><blockquote><p>分组重传，然后收到一个确认。那么这个ACK是针对第一个分组的还是针对第二个分组呢？</p><p><strong>Karn算法</strong>：</p><ul><li>对于超时重传的数据报的确认，不更新RTT。</li><li>重传的情况下，採用“指数退避”的方式。当第一次超时时，使用上面的公式计算一个初始避退指数，然后每超时一次则避退倍乘，下一次传送就使用这个避退指数。</li><li>重传数据确认之后。再次发送的数据假设正常被确定，则使用重传之前的RTO进行更新。</li></ul></blockquote><h2 id="21-2-拥塞避免算法"><a href="#21-2-拥塞避免算法" class="headerlink" title="21.2 拥塞避免算法"></a>21.2 <strong>拥塞避免算法</strong></h2><ul><li><p>拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点。</p></li><li><p>拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口<em>cwnd</em>和一个慢启动门限<em>ssthresh</em>。这样得到的算法的工作过程如下：</p><ul><li>对一个给定的连接，初始化<em>cwnd</em>为1个报文段（连接建立时发送的MSS值），<em>ssthresh</em>为65535个字节。</li><li>TCP的输出不能超过<em>cwnd</em>和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。</li><li>当拥塞发生时（超时或收到重复确认），<em>ssthresh</em>被设置为当前窗口大小的一半（<em>cwnd</em>和接收方通告窗口大小的最小值，但<em>最少为2个报文段</em>）。此外，如果是超时引起了拥塞，则<em>cwnd</em>被设置为1个报文段（这就是慢启动）。</li><li>当新的数据被对方确认时，就增加<em>cwnd</em>。如果<em>cwnd</em>小于或等于<em>ssthresh</em>，则正在进行慢启动，否则正在进行拥塞避免。慢启动一直持续到回到当拥塞发生时所处位置的半时候才停止，然后转为执行拥塞避免。</li><li>拥塞避免算法每收到一个ACK确认时将<em>cwnd</em>增加1&#x2F;<em>cwnd</em>（cwnd指的是报文段个数），而慢启动则是大致增加一个报文段MSS；</li></ul><blockquote><p>查看21.8拥塞实例解开了许多疑惑</p><ul><li>cwnd指的是报文段MSS个数，但实现中使用的是字节，因此算法中都是指MSS个数</li><li>慢启动时，每收到一个ACK，cwnd则+1，一次RTT会发送cwnd个报文段，因此cwnd会倍增</li><li>拥塞避免时，没收到一个ACK，cwnd增加1&#x2F;cwnd，同理一次RTT后，cwnd加1，也就增加一个报文段。<ul><li>计算公式如下，这公式中的cwnd指的字节，而非报文段个数。但没弄明白为啥会有segsize&#x2F;8，网上解释是这只是一个补充量，不在算法描述横纵。</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230619163800347.png"></li></ul></li></ul></blockquote></li></ul><h2 id="21-3-快速重传与快速恢复算法"><a href="#21-3-快速重传与快速恢复算法" class="headerlink" title="21.3 快速重传与快速恢复算法"></a>21.3 <strong>快速重传与快速恢复算法</strong></h2><ul><li>如果一连串收到3个或3个以上的重复ACK，就非常可能是一个报文段丢失了。于是就重传丢失的数据报文段，这就是快速重传算法。接下来执行的不是慢启动算法而是拥塞避免算法，这就是快速恢复算法。</li><li>具体算法流程如下：<ul><li>当收到第3个重复的ACK时，将<em>ssthresh</em>设置为当前拥塞窗口<em>cwnd</em>的一半。设置<em>cwnd</em>为<em>ssthresh</em>加上3倍的报文段大小（MSS）。</li><li>每次收到另一个重复的ACK时，<em>cwnd</em>增加1个报文段大小并发送1个分组（如果新的<em>cwnd</em>允许发送）。</li><li>当下一个确认新数据的ACK到达时，设置<em>cwnd</em>为<em>ssthresh</em>（在第1步中设置的值）。这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。</li></ul></li></ul><blockquote><p>当一个TCP连接关闭时，如果已经发送了16个窗口的数据，即得到16个RTT采样，那么被平滑的RTT、被平滑的均值偏差以及慢启动门限保存在路由表项中以备下次使用，下次就使用这些值进行初始化。</p></blockquote><h2 id="21-4-ICMP的差错处理"><a href="#21-4-ICMP的差错处理" class="headerlink" title="21.4 ICMP的差错处理"></a>21.4 <strong>ICMP的差错处理</strong></h2><ul><li>一个接收到的源站抑制引起拥塞窗口<em>cwnd</em>被置为1个报文段大小来发起慢启动，但是慢启动门限<em>ssthresh</em>没有变化，所以窗口将打开直至它或者开放了所有的通路（受窗口大小和往返时间的限制）或者发生了拥塞。</li><li>一个接收到的主机不可达或网络不可达实际上都被忽略，因为这两个差错都被认为是短暂现象。（这有可能是由于中间路由器被关闭而导致选路协议要花费数分钟才能稳定到另一个替换路由）</li></ul><p><strong>重新分组</strong></p><ul><li>当TCP超时并重传时，不一定要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能（不能够超过接收方声明的MSS）。</li></ul><p>参考<a href="https://blog.csdn.net/weixin_52244492/article/details/124274114">1</a></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230619164538648.png"></p><h1 id="第22章-TCP的坚持定时器"><a href="#第22章-TCP的坚持定时器" class="headerlink" title="第22章 TCP的坚持定时器"></a>第22章 TCP的坚持定时器</h1><p>当发送方窗口为0时，如果接收方更新窗口大小的ACK报文丢失（TCP不对ACK报文段进行确认），则双方就有可能因为等待对方而使连接终止：</p><ul><li>接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新。</li></ul><p>为防止这种死锁情况的发生，发送方使用一个坚持定时器来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为<strong>窗口探查</strong>。</p><ul><li>探查每隔60秒发送一次，这个过程将持续到或者窗口被打开，或者应用进程使用的连接被终止。</li></ul><p><strong>糊涂窗口综合症</strong>：其现象是交换的数据段大小不是全长而是一些较小的数据。由于每个数据段的有用数据（数据部分）较少，因而消耗的资源也更多，相应的传输效率也更低。</p><ul><li>产生原因：接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告），而发送方也可以发送少量的数据（而不是等待其他的数据以便发送一个大的报文段）。</li><li>解决办法：<ul><li>接收端：接收方不通告小窗口。通常的算法是接收方不通告一个比当前窗口大的窗口（可以为0），除非窗口可以增加一个报文段大小（也就是将要接收的MSS）或者可以增加接收方缓存空间的一半，不论实际有多少。</li><li>发送端：只有以下条件之一满足时才发送数据：(a)可以发送一个满长度的报文段；(b)可以发送至少是接收方通告窗口大小一半的报文段；(c)可以发送任何数据并且不希望接收ACK（也就是说，没有还未被确认的数据）或者该连接上不能使用Nagle算法</li></ul></li></ul><h1 id="第23章-TCP的保活定时器"><a href="#第23章-TCP的保活定时器" class="headerlink" title="第23章 TCP的保活定时器"></a>第23章 TCP的保活定时器</h1><p>保活并不是TCP规范中的一部分，但许多实现提供了保活计时器。</p><p>服务器向客户发送一个探查报文段，客户主机必须处于以下4个状态之一：</p><ul><li>客户主机依然正常运行，并从服务器可达。服务器在两小时以后将保活定时器复位。如果交换了数据，则定时器在交换数据后的未来2小时再复位。</li><li>客户主机已经崩溃，并且关闭或者正在重新启动。服务器将不能够收到对探查的响应，并在75秒后超时。服务器总共发送10个这样的探查，每个间隔75秒。认为客户主机已经关闭并终止连接。</li><li>客户主机崩溃并已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。</li><li>客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。</li></ul><p>保活功能：</p><ul><li>优点：激活keepalive选项比显式地编写应用程序探测报文更容易；keepalive探测报文比应用程序探测报文占用更少的网络带宽（因为keepalive探测报文和应答不包含任何数据)；如果连接不是空闲的，就不会发送探测报文。</li><li>缺点：keepalive选项可能会由于一个临时性的网络中断而引起一个非常好的连接断开；发送探测报文的间隔（2小时）一般不可以根据应用程序进行配置；会耗费带宽</li></ul><h1 id="第24章-TCP的未来和性能"><a href="#第24章-TCP的未来和性能" class="headerlink" title="第24章 TCP的未来和性能"></a>第24章 TCP的未来和性能</h1><h2 id="24-1-路径MTU发现"><a href="#24-1-路径MTU发现" class="headerlink" title="24.1 路径MTU发现"></a>24.1 路径MTU发现</h2><p><strong>TCP的路径MTU发现过程：</strong></p><ul><li>在连接建立时，TCP使用输出接口或对端声明的MSS中的最小MTU作为起始的报文段大小。路径MTU发现不允许TCP超过对端声明的MSS。如果对端没有指定一个MSS，则默认为536。</li><li>在该连接上的所有被TCP发送的IP数据报都将被设置DF比特。如果某个中间路由器需要对一个设置了DF标志的数据报进行分片，它就丢弃这个数据报，并产生一个ICMP的“不能分片”差错。</li><li>如果收到这个ICMP差错，TCP就减少段大小并进行重传。如果路由器产生的是一个较新的该类ICMP差错，则报文段大小被设置为下一跳的MTU减去IP和TCP的首部长度。如果是一个较旧的该类ICMP差错，则必须尝试下一个可能的最小MTU。<strong>当由这个ICMP差错引起的重传发生时，拥塞窗口不需要变化，但要启动慢启动。</strong></li></ul><p><strong>分组大小选择</strong>：并非越大越好，因为路由器需要接收整个分组才会进行发送，如果过大则导致接受分组耗时过多。当分组足够大也就和报文交换类似，这也是报文交换的缺点。</p><h2 id="24-2-长肥管道"><a href="#24-2-长肥管道" class="headerlink" title="24.2 长肥管道"></a>24.2 长肥管道</h2><p>具有大的带宽时延乘积的网络被称为长肥网络（Long Fat Network），其会出现以下问题：</p><ol><li>TCP首部中窗口大小为16 bit，从而将窗口限制在65535个字节内。窗口扩大选项可以解决这个问题。</li><li>在一个长肥网络LFN内的分组丢失会使吞吐量急剧减少。如果只有一个报文段丢失，利用快速重传和快速恢复算法来使管道避免急剧减少。但是即使使用这些算法，在一个窗口内发生的多个分组丢失也会典型地使管道急剧减少</li><li>TCP实现对每个窗口的RTT仅进行一次测量。它们并不对每个报文段进行RTT测量。在一个长肥网络LFN上需要更好的RTT测量机制</li><li>TCP对每个字节数据使用一个32 bit无符号的序号来进行标识，长肥管道足够快以至于在不到一个MSL的时候序号就发生了回绕。使用TCP的时间戳选项的PAWS(Protection Against Wrapped Sequence numbers)算法解决。</li></ol><h2 id="24-3-窗口扩大选项"><a href="#24-3-窗口扩大选项" class="headerlink" title="24.3 窗口扩大选项"></a>24.3 窗口扩大选项</h2><p>窗口扩大选项使TCP的窗口定义从16 bit增加为32 bit。通过定义一个一字节的移位记数器实现对16 bit的扩大操作来完成的。于是TCP在内部将实际的窗口大小维持为32 bit的值（最大的窗口是65535×2^14，而不是2 ^16×2 ^14，）。</p><p>算法过程：</p><ul><li>这个选项只能够出现在一个SYN报文段中，因此当连接建立起来后，在每个方向的扩大因子是固定的。</li><li>为了使用窗口扩大，两端必须在它们的SYN报文段中发送这个选项。主动建立连接的一方在其SYN中发送这个选项，但是被动建立连接的一方只能够在收到带有这个选项的SYN之后才可以发送这个选项。每个方向上的扩大因子可以不同。</li><li>如果主动连接的一方发送一个非零的扩大因子，但是没有从另一端收到一个窗口扩大选项，它就将发送和接收的移位记数器置为0。这就实现了新旧系统的兼容。</li><li>假定发送移位记数为S，而接收移位记数则为R。从另一端收到的每一个16 bit的通告窗口将被左移R位以获得实际的通告窗口大小。每次当我们向对方发送一个窗口通告的时候，我们将实际的32 bit窗口大小右移S比特，然后用它来替换TCP首部中的16 bit的值。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230619203724446.png"></p><h2 id="24-4-时间戳选项"><a href="#24-4-时间戳选项" class="headerlink" title="24.4 时间戳选项"></a>24.4 时间戳选项</h2><p>时间戳选项使发送方在每个报文段中放置一个32 bit的时间戳值。接收方在确认中返回这个数值，从而允许发送方为每一个收到的ACK计算RTT。</p><p>在连接建立阶段，主动发起连接的一方在它的SYN中指定选项。只有在它从另一方的SYN中收到了这个选项之后，该选项才会在以后的报文段中进行设置。</p><blockquote><p><strong>如果接收方发送一个确认了两个报文段的ACK，那么哪一个收到的时间戳应当放入回显应答字段中来发回去呢？</strong></p></blockquote><p>解决方法：对于每个连接只保持一个时间戳的数值。选择何时更新这个数值的算法非常简单：</p><ol><li>TCP跟踪下一个ACK中将要发送的时间戳的值（一个名为<em>tsrecent</em>的变量）以及最后发送的ACK中的确认序号（一个名为<em>lastack</em>的变量）。这个序号就是接收方期望的序号。</li><li>当一个包含有字节号<em>lastack</em>的报文段到达时，则该报文段中的时间戳被保存在<em>tsrecent</em>中。</li><li>无论何时发送一个时间戳选项，<em>tsrecent</em>就作为时间戳回显应答字段被发送，而序号字段被保存在<em>lastack</em>中。</li><li>简单来说：接收方采用包含最后确认的报文段的时间戳发送</li></ol><h2 id="24-5-PAWS：防止回绕的序号"><a href="#24-5-PAWS：防止回绕的序号" class="headerlink" title="24.5 PAWS：防止回绕的序号"></a>24.5 PAWS：防止回绕的序号</h2><p>假定使用了时间戳选项，发送方指定的时间戳对每个将要发送的窗口加1</p><p>PAWS算法不需要在发送方和接收方之间进行任何形式的时间同步。接收方所需要的就是时间戳的值应该单调递增，并且每个窗口至少增加1。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>470. 用 Rand7() 实现 Rand10()</title>
      <link href="/2023/06/01/leetcode/other/leetcode-470-%E7%94%A8Rand7()%20%E5%AE%9E%E7%8E%B0%20Rand10()-middle/"/>
      <url>/2023/06/01/leetcode/other/leetcode-470-%E7%94%A8Rand7()%20%E5%AE%9E%E7%8E%B0%20Rand10()-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="470-用-Rand7-实现-Rand10"><a href="#470-用-Rand7-实现-Rand10" class="headerlink" title="470. 用 Rand7() 实现 Rand10()"></a><a href="https://leetcode.cn/problems/implement-rand10-using-rand7/description/">470. 用 Rand7() 实现 Rand10()</a></h1><p>FIrst：没做出来，有个固定公式</p><hr><p><strong>方法1</strong>：</p><p>直接将两个rand7加或乘会导致得到的数字概率不一样，因此需要找到一种求得概率相同的方法：(rand_X() - 1) × Y + rand_Y() &#x3D;&#x3D;&gt; 可以等概率的生成[1, X * Y]范围的随机数。</p><p>这里就使用(rand7()-1)*7+rand7()来生成1~49的随机数，但直接求10的余数会导致概率不等，因此需要拒绝大于40的数。</p><p>进一步优化：通过减少需要拒绝的数从而减少拒绝概率，以致于少调用rand7.</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int rand10() &#123;        int ans&#x3D;41;        while(1)&#123;            ans&#x3D;(rand7()-1)*7+rand7();            if(ans&lt;&#x3D;40) return ans%10+1;        &#125;                return 0;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>减少rand7调用的优化代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rand10</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">41</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token operator">=</span><span class="token punctuation">(</span><span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">7</span><span class="token operator">+</span><span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token operator">&lt;=</span><span class="token number">40</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token operator">%</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            ans<span class="token operator">-=</span><span class="token number">40</span><span class="token punctuation">;</span> <span class="token comment">//rand9</span>            ans<span class="token operator">=</span><span class="token punctuation">(</span>ans<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">7</span><span class="token operator">+</span><span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//rand63</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token operator">&lt;=</span><span class="token number">60</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token operator">%</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            ans<span class="token operator">-=</span><span class="token number">60</span><span class="token punctuation">;</span> <span class="token comment">//rand3</span>            ans<span class="token operator">=</span><span class="token punctuation">(</span>ans<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">7</span><span class="token operator">+</span><span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//rand21</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token operator">&lt;=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token operator">%</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HJ16 购物单</title>
      <link href="/2023/04/18/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/HJ-16-%E8%B4%AD%E7%89%A9%E5%8D%95-middle/"/>
      <url>/2023/04/18/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/HJ-16-%E8%B4%AD%E7%89%A9%E5%8D%95-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="HJ16-购物单"><a href="#HJ16-购物单" class="headerlink" title="HJ16 购物单"></a><a href="https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=37&difficulty=&judgeStatus=&tags=&title=&gioEnter=menu"><strong>HJ16</strong> <strong>购物单</strong></a></h1><p>First：做了快两个小时，但还是有个测试用例没过。开始读题时还以为有一个物品数量限制。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>和01背包类似，只是此题多了一个条件，即必须选了主件才能选附件且每个物品只能选一次，解决办法就是将主件和附件可能的组合都列举出来，由于只能选一次，那么遍历组合得到dp最大的。</p><p>使用二维dp数组来记录状态，dp[i] [j] 表示i个物品（主件才算一个物品）j元满意度最大值。</p><p>01背包中，每个物品只需判断一次即可，而此题中每个物品会有多种组合，因此需要判断多次，找到最大值即可。</p><p>初始值皆为0</p><p>从上到下从左到右遍历</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123;    int N, m;    while (cin &gt;&gt; N &gt;&gt; m) &#123; &#x2F;&#x2F; 注意 while 处理多个 case        vector&lt;vector&lt;int&gt;&gt; prices(m,vector&lt;int&gt;(4,-1));        vector&lt;vector&lt;int&gt;&gt; values(m,vector&lt;int&gt;(4,0));        for(int i&#x3D;0;i&lt;m;++i)&#123;            int a,b,c;            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;                  a&#x2F;&#x3D;10;                  if(c&#x3D;&#x3D;0) &#123;                prices[i][0]&#x3D;a;                values[i][0]&#x3D;b;            &#125;            else &#123;                int idx&#x3D;prices[c-1][1]&#x3D;&#x3D;-1?1:2;                prices[c-1][idx]&#x3D;a;                values[c-1][idx]&#x3D;b;            &#125;                    &#125;        vector&lt;vector&lt;int&gt;&gt; pricesN,valuesN;        for(int i&#x3D;0;i&lt;prices.size();++i)&#123;                        if(prices[i][0]&#x3D;&#x3D;-1) continue;            vector&lt;int&gt; pricesTem,valuesTem;            pricesTem.push_back(prices[i][0]);            valuesTem.push_back(prices[i][0]*values[i][0]);            if(prices[i][1]!&#x3D;-1)&#123;                pricesTem.push_back(prices[i][0]+prices[i][1]);                valuesTem.push_back(prices[i][0]*values[i][0]+prices[i][1]*values[i][1]);            &#125;            if(prices[i][2]!&#x3D;-1)&#123;                pricesTem.push_back(prices[i][0]+prices[i][2]);                valuesTem.push_back(prices[i][0]*values[i][0]+prices[i][2]*values[i][2]);                pricesTem.push_back(prices[i][0]+prices[i][1]+prices[i][2]);                valuesTem.push_back(prices[i][0]*values[i][0]+prices[i][1]*values[i][1]+prices[i][2]*values[i][2]);            &#125;            pricesN.push_back(pricesTem);            valuesN.push_back(valuesTem);        &#125;        &#x2F;&#x2F; for(int i&#x3D;0;i&lt;pricesN.size();++i)&#123;        &#x2F;&#x2F;     for(int j&#x3D;0;j&lt;pricesN[i].size();++j)&#123;        &#x2F;&#x2F;         cout&lt;&lt;pricesN[i][j]&lt;&lt;&quot; &quot;&lt;&lt;valuesN[i][j]&lt;&lt;endl;        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; &#125;        N&#x2F;&#x3D;10;        vector&lt;vector&lt;int&gt;&gt; dp(pricesN.size()+1,vector&lt;int&gt;(N+1,0));        for(int i&#x3D;1;i&lt;&#x3D;pricesN.size();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;N;++j)&#123;                for(int k&#x3D;0;k&lt;pricesN[i-1].size();++k)&#123;                        if(j&gt;&#x3D;pricesN[i-1][k])                                         dp[i][j]&#x3D;max(max(dp[i-1][j],dp[i-1][j-pricesN[i-1][k]]+valuesN[i-1][k]),dp[i][j]);                &#125;                     &#x2F;&#x2F; cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;            &#125;            &#x2F;&#x2F; cout&lt;&lt;endl;        &#125;        cout&lt;&lt;dp[pricesN.size()][N]*10&lt;&lt;endl;    &#125;&#125;&#x2F;&#x2F; 64 位输出请用 printf(&quot;%lld&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此用例还未通过：</p><pre class="line-numbers language-none"><code class="language-none">4500 12100 3 0400 5 0300 5 01400 2 0500 2 0800 2 41400 5 4300 5 01400 3 8500 2 01800 4 0440 5 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确值为16700</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>887. 鸡蛋掉落</title>
      <link href="/2023/04/17/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD-difficult/"/>
      <url>/2023/04/17/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a><a href="https://leetcode.cn/problems/super-egg-drop/description/">887. 鸡蛋掉落</a></h1><p>First：没做出来</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>此题是在知道鸡蛋个数和层数确定f最小操作次数，可以转换下思路，若知道操作次数和鸡蛋个数能确定多大的层数，选择满足层数要求的最小操作次数即可。</p><p>使用二维dp数组来记录状态，dp[i] [j]表示i个操作次数和j个鸡蛋情况能确定的最大层数。</p><p>dp[i] [j]如果在某一层抛出，只会有两种结果：鸡蛋碎了，此时f一定在此层下面，因此用剩余的操作次数和鸡蛋可以在下面确定dp[i-1] [j-1]层；如果没碎，说明f在此层上面，因此用剩余的操作次数和鸡蛋可以在上面确定dp[i-1] [j]层。因此dp[i] [j]&#x3D;1+dp[i-1] [j-1] +dp[i-1] [j]。</p><p>由dp定义可知，dp[1] [k]皆为1，dp[k] [1]皆为k，其余初始化为0；</p><p>从递推公式可以看出是从上到下从左到右进行遍历</p><ul><li>时间复杂度：O(kn) </li><li>空间复杂度：O(kn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int superEggDrop(int k, int n) &#123;        int t&#x3D;n;&#x2F;&#x2F;t为操作次数        vector&lt;vector&lt;int&gt;&gt; dp(t+1,vector&lt;int&gt;(k+1,0));        for(int i&#x3D;0;i&lt;dp.size();++i) dp[i][1]&#x3D;i;        for(int j&#x3D;1;j&lt;&#x3D;k;++j) dp[1][j]&#x3D;1;        for(int i&#x3D;1;i&lt;&#x3D;t;++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;k;++j)&#123;                dp[i][j]&#x3D;1+dp[i-1][j]+dp[i-1][j-1];                            &#125;            if(dp[i][k]&gt;&#x3D;n) return i;        &#125;        return n;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划 + 二分查找</strong></p><p>使用二维dp数组来记录状态，dp[k] [n]表示k个鸡蛋和n层确定f所需最小操作次数。</p><p>dp[k] [n]如果在某x层抛出，只会有两种结果：鸡蛋碎了，此时f一定在此层下面，因此剩余的鸡蛋k-1和层数x-1确定f需要dp[k-1] [x-1]；如果没碎，说明f在此层上面，因此剩余的鸡蛋k和层数n-x确定f需要dp[k] [n-x]。由于不知道在哪一层抛出好，因此需要遍历小于j的每一层选择最小值，因此:</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230417143725709.png" alt="image-20230417143725709"></p><p>由于每次都需要遍历所有层，导致复杂度上升，而dp[k-1] [x-1]随x增大而增大，dp[k] [n-1]随x增大而减小，那么只有在两条曲线交汇点两段才能取到最小值，因此可以使用二分法来进行寻找。</p><p>由dp定义可知，dp[1] [k]皆为1，dp[k] [1]皆为k，其余初始化为0；</p><p>从递推公式可以看出是从上到下从左到右进行遍历</p><ul><li>时间复杂度：O(knlogn) </li><li>空间复杂度：O(kn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 19. 正则表达式匹配</title>
      <link href="/2023/04/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%89%91%E6%8C%87Offer-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-difficult/"/>
      <url>/2023/04/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%89%91%E6%8C%87Offer-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a><a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/description/">剑指 Offer 19. 正则表达式匹配</a></h1><p>First：没做出来，有一二十个用例没过，因为没注意到s的0个字符可以和p的多个字符匹配，初始化没做好</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示字符串s的前i-1个和字符串p的前j-1个是否匹配。</p><p>首先，如果s[i-1]和p[j-1]能够匹配（相等或p[j-1]&#x3D;’.’都算匹配），那么此时dp[i] [j]&#x3D;dp[i-1] [j-1]；如果p[j-1]&#x3D;’*’，由于’ *’前的字符可以出现0次或多次，那么当s[i-1]&#x3D;&#x3D;p[j-2]时，dp[i] [j]&#x3D;dp[i-1] [j] （出现多次）||dp[i] [j-2] (出现0次)，而不相等时，可以假设为出现0次，因此dp[i] [j] &#x3D;dp[i] [j-2]。</p><p>由dp定义可知，初始化为0，dp[0] [0] &#x3D;1，dp第一行若与 * 字符匹配，那么dp[0] [j]&#x3D;dp[0] [j-2];</p><p>从递推公式可以看出是从上到下，从左到右进行遍历</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isMatch(string s, string p) &#123;        int m&#x3D;s.size(),n&#x3D;p.size();        if(m&#x3D;&#x3D;0&amp;&amp;n&#x3D;&#x3D;0) return true;        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));        dp[0][0]&#x3D;1;        for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;            if(p[j-1]&#x3D;&#x3D;&#39;*&#39;) dp[0][j]&#x3D;dp[0][j-2];        &#125;        for(int i&#x3D;1;i&lt;&#x3D;m;++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;                if(p[j-1]&#x3D;&#x3D;&#39;*&#39;)&#123;                    dp[i][j]&#x3D;dp[i][j-2];                    if((s[i-1]&#x3D;&#x3D;p[j-2]||p[j-2]&#x3D;&#x3D;&#39;.&#39;)) dp[i][j]|&#x3D;dp[i-1][j];                                    &#125;else if((s[i-1]&#x3D;&#x3D;p[j-1]||p[j-1]&#x3D;&#x3D;&#39;.&#39;))&#123;                    dp[i][j]&#x3D;dp[i-1][j-1];                &#125;            &#125;        &#125;        return dp[m][n];            &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>638. 大礼包</title>
      <link href="/2023/04/14/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-638-%E5%A4%A7%E7%A4%BC%E5%8C%85-middle/"/>
      <url>/2023/04/14/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-638-%E5%A4%A7%E7%A4%BC%E5%8C%85-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="638-大礼包"><a href="#638-大礼包" class="headerlink" title="638. 大礼包"></a><a href="https://leetcode.cn/problems/shopping-offers/description/">638. 大礼包</a></h1><p>First：就直接回溯</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>先排除不能优惠的大礼包，即总价比直接买还贵的礼包。然后先计算按普通购买需要多少钱，不断遍历看能否使用大礼包，找到使用大礼包最多能节省多少钱</p><p>中止条件：当礼包idx值大于等于礼物数时终止</p><p>遍历过程：从小到大遍历，不断遍历每个礼包</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    int nospecial&#x3D;0;    int ans;public:    int shoppingOffers(vector&lt;int&gt;&amp; price, vector&lt;vector&lt;int&gt;&gt;&amp; special, vector&lt;int&gt;&amp; needs) &#123;        vector&lt;vector&lt;int&gt;&gt; filterSpecial;        for(int i&#x3D;0;i&lt;special.size();++i)&#123;            int sum&#x3D;0;            for(int j&#x3D;0;j&lt;special[i].size()-1;++j)&#123;                sum+&#x3D;price[j]*special[i][j];            &#125;            if(sum&gt;&#x3D;special[i].back()) &#123;                special[i].push_back(sum-special[i].back());                filterSpecial.push_back(special[i]);            &#125;        &#125;                for(int i&#x3D;0;i&lt;needs.size();++i) nospecial+&#x3D;price[i]*needs[i];        ans&#x3D;nospecial;        DFS(filterSpecial,needs,0,0);        return ans;    &#125;    void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; special, vector&lt;int&gt;&amp; needs,int idx,int save)&#123;        if(idx&gt;&#x3D;special.size()) return;        for(int i&#x3D;idx;i&lt;special.size();++i)&#123;            int flag&#x3D;1;            for(int j&#x3D;0;j&lt;special[i].size()-2;++j)&#123;                if(special[i][j]&gt;needs[j]) &#123;                    ans&#x3D;min(ans,nospecial-save);                    flag&#x3D;0;                    break;                &#125;            &#125;            if(flag&#x3D;&#x3D;0) continue;            for(int j&#x3D;0;j&lt;special[i].size()-2;++j)&#123;                needs[j]-&#x3D;special[i][j];            &#125;            DFS(special,needs,idx,save+special[i].back());            for(int j&#x3D;0;j&lt;special[i].size()-2;++j)&#123;                needs[j]+&#x3D;special[i][j];            &#125;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1504. 统计全 1 子矩形</title>
      <link href="/2023/04/10/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1504-%E7%BB%9F%E8%AE%A1%E5%85%A8%201%20%E5%AD%90%E7%9F%A9%E5%BD%A2-middle/"/>
      <url>/2023/04/10/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1504-%E7%BB%9F%E8%AE%A1%E5%85%A8%201%20%E5%AD%90%E7%9F%A9%E5%BD%A2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="1504-统计全-1-子矩形"><a href="#1504-统计全-1-子矩形" class="headerlink" title="1504. 统计全 1 子矩形"></a><a href="https://leetcode.cn/problems/count-submatrices-with-all-ones/description/">1504. 统计全 1 子矩形</a></h1><p>First：这道题折腾了好久</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示到第i行j列个网格在当前行向左最大矩形长度。</p><p>当前格子的dp值可由左边值推导，所以dp[i] [j]&#x3D;dp[i] [j-1]+1;    </p><p>初始值皆为0；从左到右从上到下遍历得到所有dp值。</p><p>当得到所有dp值后，以当前格子作为矩形的右下角，能得到的矩形数量即为当前格子上方所有格子的dp值相加，但是上方的格子的dp值并非单调增加，当单调递减时，那么无论上方dp值多大也只有最小那个值有用。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230410150532990.png" alt="image-20230410150532990" style="zoom: 80%;" /><ul><li>时间复杂度：O(mn^2) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numSubmat(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123;        if(mat.size()&#x3D;&#x3D;0) return 0;        int m&#x3D;mat.size(),n&#x3D;mat[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));        int ans&#x3D;0;        for(int i&#x3D;1;i&lt;&#x3D;m;++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;                           if(mat[i-1][j-1]&#x3D;&#x3D;1)&#123;                    dp[i][j]&#x3D;dp[i][j-1]+1;                    int col&#x3D;dp[i][j];                    for(int k&#x3D;i;k&gt;0;--k)&#123;                        col&#x3D;min(col,dp[k][j]);                        ans+&#x3D;col;                    &#125;                &#125;                          &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划+单调栈</strong></p><p>和方法1类似，先计算每个格子的dp值。在方法1中是对当前格子上方所有值进行遍历得到结果，这会导致进行许多重复运算。例如dp值都是单调增加时，直接在后面加上上次的和即可，但dp值也会存在一部分递减，对于此类情况，上方dp值无论多大，都取决于先遇到的最小值。</p><p>因此，使用一个单调递增栈来存储值，存储的是以当前dp值作为宽所能组成的最大矩形的长+宽（处理递减情况）。对于dp数组，从上到下进行处理，如果栈顶值大于当前dp值，则将其弹出，且当前矩形的高度height应该加上弹出值的高度。由于栈存储的是dp值并未存储上方值的和，因此使用一个sum来存储上方dp和，当遇见需要弹出栈顶值时，那么sum也应该减去栈顶元素所有矩形大小值。最后sum加上当前dp*height即可。</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numSubmat</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> mat<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>mat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m<span class="token operator">=</span>mat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token operator">=</span>mat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                           <span class="token keyword">if</span><span class="token punctuation">(</span>mat<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                                    <span class="token punctuation">&#125;</span>                                          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            stack<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">>></span> st<span class="token punctuation">;</span>            <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> height<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token operator">></span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    height<span class="token operator">+=</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>                    sum<span class="token operator">-=</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token operator">*</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sum<span class="token operator">+=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">*</span>height<span class="token punctuation">;</span>                ans<span class="token operator">+=</span>sum<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                                <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32. 最长有效括号</title>
      <link href="/2023/04/04/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7-difficult/"/>
      <url>/2023/04/04/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h1><p>First：很久以前做过</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[i] 表示以s[i]结束能形成的最长括号长度。</p><p>括号长度可以由两种类型增加，第一种是获取到匹配符号如<code>)</code>匹配到<code>(</code>。第二种就是<code>()()</code>，当匹配成功后还需要看左括号的左边字符，如果是<code>)</code>，则说明有并行括号。因此递推公式：</p><ul><li>当s[i]&#x3D;&#x3D;’)’且s[i-dp[i-1]-1] &#x3D;&#x3D;’(‘时，此时dp[i]&#x3D;dp[i-1]+2; 如果此时s[i-dp[i-1]-2] &#x3D;&#x3D;’)’，则dp[i]+&#x3D;dp[i-dp[i-1]-2];</li></ul><p>由dp定义可知，初始化皆为0；</p><p>从递推公式可以看出是从左到右进行遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int longestValidParentheses(string s) &#123;        int n&#x3D;s.size();        vector&lt;int&gt; dp(n,0);        int ans&#x3D;0;        for(int i&#x3D;1;i&lt;n;++i)&#123;         if(s[i]&#x3D;&#x3D;&#39;)&#39;&amp;&amp;i-dp[i-1]-1&gt;&#x3D;0&amp;&amp;s[i-dp[i-1]-1]&#x3D;&#x3D;&#39;(&#39;)&#123;             dp[i]&#x3D;dp[i-1]+2;             if(i-dp[i-1]-2&gt;&#x3D;0&amp;&amp;s[i-dp[i-1]-2]&#x3D;&#x3D;&#39;)&#39;) dp[i]+&#x3D;dp[i-dp[i-1]-2];             ans&#x3D;max(ans,dp[i]);         &#125;           &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>877. 石子游戏</title>
      <link href="/2023/04/01/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-middle/"/>
      <url>/2023/04/01/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="877-石子游戏"><a href="#877-石子游戏" class="headerlink" title="877. 石子游戏"></a><a href="https://leetcode.cn/problems/stone-game/description/">877. 石子游戏</a></h1><p>First：没做出来，解析也理解的不透</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示石头下标i到下标j先手与后手最大差值。在dp数组中不用管谁是先手，反正取了一个数之后，剩余区间一定是其后手，最后只需要判断每个区间的值就行，因为区间长度确定也能确定这个区间是谁在取数（固定alice先手）。</p><p>在区间为i j时，可以取左边或者右边，如果取左边值则dp[i] [j]&#x3D;piles[i]-dp[i+1] [j]（这是因为取了一个数之后剩余的一定是其后手），同理取右边也一样，因此dp[i] [j]&#x3D;max(piles[i]-dp[i+1] [j],piles[j]-dp[i] [j-1]);</p><p>当i&#x3D;&#x3D;j时，只有一堆石头，因此dp[i] [j]&#x3D;piles[i]，其余都为0；</p><p>由递推公式可知，遍历是从下到上、从左到右。</p><ul><li>时间复杂度：O(nn) </li><li>空间复杂度：O(nn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool stoneGame(vector&lt;int&gt;&amp; piles) &#123;        int n&#x3D;piles.size();        vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(n,0));        for(int i&#x3D;0;i&lt;n;++i) dp[i][i]&#x3D;piles[i];        for(int i&#x3D;n-1;i&gt;&#x3D;0;--i)&#123;            for(int j&#x3D;i+1;j&lt;n;++j)&#123;                dp[i][j]&#x3D;max(piles[i]-dp[i+1][j],piles[j]-dp[i][j-1]);            &#125;        &#125;        return dp[0][n-1]&gt;0;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>583. 两个字符串的删除操作</title>
      <link href="/2023/03/30/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-712-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8FASCII%E5%88%A0%E9%99%A4%E5%92%8C-middle/"/>
      <url>/2023/03/30/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-712-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8FASCII%E5%88%A0%E9%99%A4%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="712-两个字符串的最小ASCII删除和"><a href="#712-两个字符串的最小ASCII删除和" class="headerlink" title="712. 两个字符串的最小ASCII删除和"></a><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/">712. 两个字符串的最小ASCII删除和</a></h1><p>First：和583题类似，只是代价变了</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示word1前i+1个字符和word2前j+1个字符变成相等所需最小步骤。</p><p>递推公式：</p><ul><li><p>当s1[i]&#x3D;&#x3D;s2[j]时，此时无需修改字符，所以dp[i] [j]&#x3D;dp[i-1] [j-1]；</p></li><li><p>当s1[i]!&#x3D;s2[j]时，此时有两种操作可以使得字符相等，要么s1删除第i个字符变成dp[i-1] [j]一样的情况，要么s2删除第j个字符变成和dp[i] [j-1]一样情况。因此，dp[i][j]&#x3D;min(dp[i-1][j]+s1[i-1],dp[i][j-1]+s2[j-1]);</p></li></ul><p>由dp定义可知，dp[i] [0]&#x3D;dp[i-1] [0]+s1[i-1]，dp[0] [j]&#x3D;dp[0] [j-1]+s2[j-1];其余皆为0；</p><p>从递推公式可以看出是从左上方推导出当前结果，因此需要先外层从小到大遍历s1，再内层从小到大遍历s2</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minimumDeleteSum(string s1, string s2) &#123;        int m&#x3D;s1.size(),n&#x3D;s2.size();        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));        for(int i&#x3D;1;i&lt;&#x3D;m;++i) dp[i][0]+&#x3D;dp[i-1][0]+s1[i-1];        for(int j&#x3D;1;j&lt;&#x3D;n;++j) dp[0][j]+&#x3D;dp[0][j-1]+s2[j-1];        for(int i&#x3D;1;i&lt;&#x3D;m;++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;                if(s1[i-1]&#x3D;&#x3D;s2[j-1]) dp[i][j]&#x3D;dp[i-1][j-1];                else dp[i][j]&#x3D;min(dp[i-1][j]+s1[i-1],dp[i][j-1]+s2[j-1]);            &#125;        &#125;        return dp[m][n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小林coding-MySQL-笔记</title>
      <link href="/2023/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-MySQL-%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-MySQL-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>总结知识点，以便以后快速复习。</p><p><em>参考小林coding-MySQL</em>, <a href="https://www.xiaolincoding.com/mysql/">地址</a></p><h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><p>MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong></p><ul><li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。索引数据结构就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230324113843556.png" style="zoom:80%;" /><h2 id="1-1-执行一条-select-语句，期间发生了什么？"><a href="#1-1-执行一条-select-语句，期间发生了什么？" class="headerlink" title="1.1 执行一条 select 语句，期间发生了什么？"></a>1.1 执行一条 select 语句，期间发生了什么？</h2><h3 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h3><p>第一步要先连接 MySQL 服务，然后才能执行 SQL 语句。MySQL 是<strong>基于 TCP 协议</strong>进行传输的。</p><p><strong>连接器的工作</strong></p><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><blockquote><ol><li><p><strong>如何查看 MySQL 服务被多少个客户端连接了？</strong></p><p>执行 <code>show processlist</code> 命令</p></li><li><p><strong>空闲连接会一直占用着吗？</strong></p><p>不会，MySQL 使用 <code>wait_timeout</code> 参数控制最大空闲时长，默认值是 8 小时，如果空闲连接超过了这个时间，连接器就会自动将它断开。</p><p>一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候</p></li><li><p><strong>MySQL 的连接数有限制吗？</strong></p><p>MySQL 服务支持的最大连接数由 max_connections 参数控制，默认是 151 </p></li><li><p><strong>怎么解决长连接占用内存的问题？</strong></p><ul><li>定期断开长连接</li><li>客户端主动重置连接，客户端可以使用mysql_reset_connection 函数来重置连接，达到释放内存的效果，会将连接恢复到刚刚创建完时的状态</li></ul></li></ol></blockquote><hr><h3 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h3><ul><li>MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段</li><li>如果 SQL 是查询语句，MySQL 就会先去查询缓存里查找缓存数据。查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果</li><li>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果没有命中，就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</li></ul><blockquote><p>这里说的查询缓存是 server 层的</p><p>对于更新比较频繁的表，查询缓存的命中率很低的，因此MySQL 8.0 版本直接将查询缓存删掉了</p></blockquote><hr><h3 id="第三步：解析-SQL"><a href="#第三步：解析-SQL" class="headerlink" title="第三步：解析 SQL"></a>第三步：解析 SQL</h3><p>解析器会做如下两件事情。</p><ul><li><strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</li><li><strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断输入的 SQL 语句是否满足 MySQL 语法。</li></ul><blockquote><p>注意，表不存在或者字段不存在，并不是在解析器里做的。解析器只负责构建语法树和检查语法</p></blockquote><hr><h3 id="第四步：执行-SQL"><a href="#第四步：执行-SQL" class="headerlink" title="第四步：执行 SQL"></a>第四步：执行 SQL</h3><p>每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p><ul><li><strong>预处理阶段</strong><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列</li></ul></li><li><strong>优化阶段</strong>：优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</li><li><strong>执行阶段</strong>：由「执行器」完成，在执行的过程中，执行器会和存储引擎交互，交互是以记录为单位的。执行器和存储引擎的交互过程有以下三种方式：<ul><li>主键索引查询</li><li>全表扫描</li><li>索引下推</li></ul></li></ul><h2 id="1-2-MySQL-一行记录是怎么存储的？"><a href="#1-2-MySQL-一行记录是怎么存储的？" class="headerlink" title="1.2 MySQL 一行记录是怎么存储的？"></a>1.2 MySQL 一行记录是怎么存储的？</h2><p>当创建一个名为my_test的数据库，并在其中创建一张t_order表后，首先会在&#x2F;var&#x2F;lib&#x2F;mysql文件夹下创建一个my_test文件夹，其中包含3个文件：</p><ul><li><strong>db.opt</strong>：用来存储当前数据库的默认字符集和字符校验规则。</li><li><strong>t_order.frm</strong> ：用来保存每个表的元数据信息的，主要包含表结构定义。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是。</li><li><strong>t_order.ibd</strong>：t_order 的<strong>表数据</strong>会保存在这个文件。<ul><li>表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd），这个行为是由参数 innodb_file_per_table 控制的</li></ul></li></ul><hr><h3 id="表空间文件的结构"><a href="#表空间文件的结构" class="headerlink" title="表空间文件的结构"></a>表空间文件的结构</h3><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>：</p><p><strong>行</strong>：数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p><ul><li><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。Redundant太古老，另外三种格式十分相似，是紧凑的行格式。</p></li><li><p><strong>COMPACT 行格式</strong>：分为「记录的额外信息」和「记录的真实数据」两个部分</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230324163842422.png"></p><ul><li><p><strong>记录的额外信息</strong></p><ul><li><p><strong>变长字段长度列表</strong>：有些表字段设置的不定长，需要记录其字段实际存储长度，如varchar。注意此列表中只会存放不定长字段长度，且按照列的顺序<strong>逆序存放</strong>。</p><blockquote><p><strong>为什么「变长字段长度列表」的信息要按照逆序存放？</strong></p><p>因为「记录头信息」中指向下一个记录的指针，如果逆序存放那么真实数据和字段长度是关于记录头对称。使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率。</p><p><strong>每个数据库表的行格式都有「变长字段字节数列表」吗？</strong></p><p>变长字段长度列表」只出现在数据表有变长字段的时候</p></blockquote></li><li><p><strong>NULL 值列表</strong>：如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序<strong>逆序排列</strong>。</p><ul><li>值为1时代表该列为NULL，否则不为NULL。</li><li>NULL 值列表必须用整数个字节的位表示，如果二进制位个数不足整数个字节，则在左边补 <code>0</code></li><li>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表</li></ul></li><li><p><strong>记录头信息</strong></p><ul><li>delete_mask ：标识此条数据是否被删除。执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li><li>next_record：下一条记录的位置，记录与记录之间是通过链表组织的。指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li></ul></li></ul></li><li><p><strong>记录的真实数据</strong>：记录真实数据部分除了定义的字段，还有三个隐藏字段：</p><ul><li>row_id：如果指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_idrow_id不是必需的，占用 6 个字节。</li><li>trx_id：事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</li><li>roll_pointer：这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。</li></ul></li></ul></li><li><p><strong>页</strong>：记录是按照行来存储的，为了效率，<strong>数据库的读取以页为单位</strong>。默认每个页的大小为 16KB。</p></li><li><p><strong>区</strong>：索引分配空间按照区为单位分配，默认每个区包含64页，这样区中的每个页的物理位置时相邻的，就能使用顺序 I&#x2F;O 了。</p></li><li><p><strong>段</strong>：表空间是由各个段组成的，段是由多个区组成的</p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合</li></ul></li></ul><blockquote><p><strong>varchar(n) 中 n 最大取值为多少？</strong></p><ul><li><strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</li><li>在单字段情况下：<ul><li>如果字符集是ascii，那么变长列表要占2字节，NULL列表占1字节，因此varchar(n) 中 n 最大值 &#x3D; 65535 - 2 - 1 &#x3D; 65532。</li><li>在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532&#x2F;3 &#x3D; 21844。</li></ul></li><li>同理，多字段下所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535</li></ul><p><strong>行溢出后，MySQL 是怎么处理的？</strong></p><ul><li>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据末尾处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</li><li>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时：<ul><li>记录的真实数据处不会存储一部分数据，只存储 20 个字节的指针来指向溢出页</li></ul></li></ul></blockquote><h1 id="二、索引篇"><a href="#二、索引篇" class="headerlink" title="二、索引篇"></a>二、索引篇</h1><h2 id="2-1-索引基础"><a href="#2-1-索引基础" class="headerlink" title="2.1 索引基础"></a>2.1 索引基础</h2><p><strong>什么是索引？</strong></p><p>帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong>。</p><p>存储引擎，就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p><p><strong>InnoDB 存储引擎创建索引的选择</strong>：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li><li>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</li></ul><p><strong>B+Tree如何存储索引？</strong></p><blockquote><ul><li>B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，且每个节点里的数据是<strong>按主键顺序存放</strong>。</li><li>每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息</li><li>每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表（下图有误，叶子节点是双向链表）。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230324194955025.png" style="zoom:67%;" /></blockquote><hr><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul><li><p>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</p><blockquote><p><strong>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</strong></p><ul><li><em><strong>B+Tree vs B Tree</strong></em><ul><li>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</li><li>B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</li></ul></li><li><em><strong>B+Tree vs 二叉树</strong></em>：同样的数据二叉树层数会高很多，需要的磁盘IO也更多</li><li><em><strong>B+Tree vs Hash</strong></em>：Hash 表不适合做范围查询，它更适合做等值的查询</li></ul></blockquote></li><li><p>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</p><ul><li><p><strong>主键索引的 B+Tree 和二级索引的 B+Tree 区别</strong>：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul></li><li><p><strong>二级索引查询商品数据的过程</strong>：</p><ol><li>会先检二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值</li></ol></li></ul><ol start="2"><li>再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫<strong>「回表」</strong>，也就是说要查两个 B+Tree 才能查到数据。</li></ol><blockquote><p>当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查，如只查询主键列</p><p>这种在二级索引的 B+Tree 就能查询到结果的过程就叫作<strong>「覆盖索引」</strong>，也就是只需要查一个 B+Tree 就能找到数据。</p></blockquote></li><li><p>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</p><ul><li><p><strong>主键索引</strong>：建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值，使用<code>PRIMARY KEY</code>指定。</p></li><li><p><strong>唯一索引</strong>：建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值，使用<code>UNIQUE KEY</code>指定。</p></li><li><p><strong>普通索引</strong>：普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INDEX</span><span class="token punctuation">(</span>index_column_1<span class="token punctuation">,</span>index_column_2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>前缀索引</strong>:对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p><ul><li>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> table_name<span class="token punctuation">(</span>    column_list<span class="token punctuation">,</span>    <span class="token keyword">INDEX</span><span class="token punctuation">(</span>column_name<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</p><ul><li><p><strong>联合索引</strong>：通过将多个字段组合成一个索引，该索引就被称为联合索引。</p><ul><li><strong>联合索引存在最左匹配原则</strong>，即按照最左优先的方式进行索引的匹配，在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效</li></ul></li></ul></li><li><p>即如果创建了一个 <code>(a, b, c)</code> 联合索引，那么存储是会先按a进行排序，再a相同情况下对b进行排序，再ab都相同情况下对c排序，因此b和c在全局看都是无序的。<br>- 如果此时sql语句不查询a，那么就无法利用联合索引</p></li><li><p>其联合索引示意图如下，注意叶子节点应为双向链表</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328133805834.png"></p><blockquote><p><strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</strong></p></blockquote><p><strong>索引下推</strong></p><ul><li>在使用联合索引时，可能只会用到一个字段，而判断另一个字段是否满足条件是在联合索引里面判断还是回主键索引判断？</li><li>在Mysql5.6之前只能到主键索引」上找出数据行，再对比字段条件。</li><li>MySQL 5.6 引入的<strong>索引下推优化</strong>： 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li></ul><p><strong>索引区分度</strong>：建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。区分度就是某个字段 column 不同值的个数「除以」表的总行数。</p><hr><h3 id="什么时候需要-x2F-不需要创建索引？"><a href="#什么时候需要-x2F-不需要创建索引？" class="headerlink" title="什么时候需要 &#x2F; 不需要创建索引？"></a>什么时候需要 &#x2F; 不需要创建索引？</h3><p><strong>索引缺点：</strong></p><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li></ul><p><strong>什么时候适用索引？</strong></p><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的</li></ul><p><strong>什么时候不需要创建索引？</strong></p><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段无需创建索引</li><li>索引区分度不高的字段</li><li>表数据太少的时候，不需要创建索引；</li><li>经常更新的字段不用创建索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的</li></ul><hr><h3 id="有什么优化索引的方法？"><a href="#有什么优化索引的方法？" class="headerlink" title="有什么优化索引的方法？"></a>有什么优化索引的方法？</h3><p>常见优化索引的方法：</p><ul><li><strong>前缀索引优化</strong>：使用某个字段中字符串的前几个字符建立索引。<ul><li>优点：可以减小索引字段大小，从而增加一个索引页中存储的索引值，提高索引的查询速度</li><li>缺点：order by 就无法使用前缀索引；无法把前缀索引用作覆盖索引；</li></ul></li><li><strong>覆盖索引优化</strong>：指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。<ul><li>优点：不需要查询出包含整行记录的所有信息，也就减少了大量的 I&#x2F;O 操作</li></ul></li><li><strong>主键索引最好是自增的</strong>：若主键是自增的，每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。<ul><li>如果不是自增的，那么需要移动数据，甚至需要从一个页面复制数据到另外一个页面，影响效率</li></ul></li><li><strong>索引最好设置为 NOT NULL</strong>：原因如下：<ul><li>索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂</li><li>NULL 值是一个没意义的值，但是它会占用物理空间，例如InnoDB中需要占用至少一字节来存储</li></ul></li><li><strong>防止索引失效</strong>：发生索引失效的情况：<ul><li>当使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式会造成索引失效；</li><li>当在查询条件中对索引列做了计算、函数、类型转换操作，会造成索引失效；</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul></li></ul><h2 id="2-2-从数据页的角度看-B-树"><a href="#2-2-从数据页的角度看-B-树" class="headerlink" title="2.2 从数据页的角度看 B+ 树"></a>2.2 从数据页的角度看 B+ 树</h2><h3 id="InnoDB-是如何存储数据的？"><a href="#InnoDB-是如何存储数据的？" class="headerlink" title="InnoDB 是如何存储数据的？"></a>InnoDB 是如何存储数据的？</h3><p>InnoDB 的数据是<strong>按「数据页」为单位来读写</strong>的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。</p><p>每个数据页包含七个部分，作用如下：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230326211244266.png" style="zoom:67%;" /><p>数据页内包含用户记录，<strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。</p><p>数据页中的<strong>页目录</strong>，是当前页用户记录的索引，创建页目录过程如下：</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽，<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li></ol><hr><h3 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+ 树是如何进行查询的？"></a>B+ 树是如何进行查询的？</h3><p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下。</p><ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230326211937085.png" style="zoom:80%;" /><p>查找一个主键为6的记录过程如下：</p><ul><li>从根节点开始，通过二分法快速定位到页 30 中查找更详细的目录项；</li><li>在非叶子节点（页30）中，继续定位到叶子节点（页16）查找记录；</li><li>接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。</li></ul><p><strong>一张表只能有一个聚簇索引</strong>，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引&#x2F;辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p><blockquote><p>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「<strong>回表</strong>」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「<strong>索引覆盖</strong>」，也就是只需要查一个 B+ 树就能找到数据</p></blockquote><h2 id="2-3-为什么-MySQL-采用-B-树作为索引？"><a href="#2-3-为什么-MySQL-采用-B-树作为索引？" class="headerlink" title="2.3 为什么 MySQL 采用 B+ 树作为索引？"></a>2.3 为什么 MySQL 采用 B+ 树作为索引？</h2><blockquote><p>要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I&#x2F;0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I&#x2F;0 的操作次数内完成。</p></blockquote><p>MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：</p><ul><li><strong>B+ 树的非叶子节点不存放实际的记录数据</strong>，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</li><li><strong>B+ 树有大量的冗余节点</strong>（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li><li><strong>B+ 树叶子节点之间用链表连接了起来，有利于范围查询</strong>，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li></ul><h2 id="2-4-MySQL-单表不要超过-2000W-行，靠谱吗"><a href="#2-4-MySQL-单表不要超过-2000W-行，靠谱吗" class="headerlink" title="2.4 MySQL 单表不要超过 2000W 行，靠谱吗"></a>2.4 MySQL 单表不要超过 2000W 行，靠谱吗</h2><p><strong>单表数量限制</strong>：主键的大小可以限制表的上限。如主键声明 <code>int</code> 类型，也就是 32 位，那么支持 2^32-11条；</p><p>索引的数据存储是使用类似多叉树来存储，只在叶子节点存储数据，在非叶子节点存储索引，因此假设：</p><ul><li>非叶子节点内指向其他页的数量为 x</li><li>叶子节点内能容纳的数据行数为 y</li><li>B+ 数的层数为 z</li></ul><p>那么总存储记录个数为<strong>x^(z-1) *y</strong></p><p>每个页中，除页结构等大概还剩15k：</p><ul><li>在非叶节点中，主要记录的是主键与页号，主键我们假设是 Bigint (8 byte), 而页号也是固定的（4Byte）, 那么索引页中的一条数据也就是 12byte。那么x&#x3D;1280行。</li><li>在叶节点中，由于数据大小与设计的表结构有关，并不固定，假设一条数据1k，那么y&#x3D;15条；</li></ul><p>在存储中，B+树一般最多三层，那么总存储记录个数&#x3D;（1280 ^2） *15 &#x3D; 24576000 （约 2.45kw）</p><p>因此，<strong>在保持相同的层级（相似查询性能）的情况下，在行数据大小不同的情况下，其实这个最大建议值也是不同的</strong></p><p>MySQL 为了提高性能，会将表的索引装载到内存中，在 InnoDB buffer size 足够的情况下，<strong>只要索引能完成全加载进内存</strong>，那么超过2000万的查询也不会有问题。</p><h2 id="2-5-索引失效有哪些？"><a href="#2-5-索引失效有哪些？" class="headerlink" title="2.5 索引失效有哪些？"></a>2.5 索引失效有哪些？</h2><p>不同索引的查询过程：</p><ul><li>在使用「主键索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么就会在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后直接读取要查询的数据。</li><li>在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树：<ul><li>先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；</li><li>然后用上一步获取的主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后获取要查询的数据。</li></ul></li></ul><p><strong>索引失效情况如下：</strong></p><ul><li><p><strong>对索引使用左或者左右模糊匹配</strong>：当使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。而<code>like xx%</code>不会造成索引失效。</p><ul><li>这是因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</li></ul></li><li><p><strong>对索引使用函数</strong>：如果查询条件中对索引字段使用函数，就会导致索引失效。例如<code>where length(name)=6</code>。</p><ul><li>这是因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</li><li>但从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引</li></ul></li><li><p><strong>对索引进行表达式计算</strong>：在查询条件中对索引进行表达式计算，也是无法走索引的。例如<code>where id+1=10</code>不能走索引，而<code>where id=10-1</code>可以走索引。</p><ul><li>这是因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</li></ul></li><li><p><strong>对索引隐式类型转换</strong>：如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，在执行计划中这条语句会走全表扫描。（但是如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。）</p><ul><li>这是因为<strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong></li><li>第一个例子中，会自动使用一个函数把索引转换为一个整数，因此索引失效。而第二个例子中，会把字符串条件转换为整数，因此不会失效。</li></ul></li><li><p><strong>联合索引非最左匹配</strong>：联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，如果不能就不会走索引。</p><ul><li><p>这是因为在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p><blockquote><p>由于优化器的存在，字段排列顺序不重要，但必须有</p></blockquote></li></ul></li><li><p><strong>WHERE 子句中的 OR</strong>：在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><ul><li>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</li></ul></li></ul><blockquote><p><strong>MySQL 使用 like “%x“，索引一定会失效吗？</strong></p><p>不一定，如果表中除了主键之外就只有一个索引字段或联合索引，那么会通过全扫描二级索引的 B+ 树的方式查询到数据。</p><ul><li>原因：二级索引树的记录东西很少，就只有「索引列+主键值」，而聚簇索引记录的东西会更多，并且需要查询的数据在二级索引中都存在，不需要回表操作，因此优化器选择「全扫描二级索引树」的方式查询数据。</li><li>如果加上了一个非索引段，且查询的数据包括这个非索引段，那么会变成走全表扫描</li><li>同理，联合索引也存在不遵循最左匹配而全盘扫描索引树的情况</li></ul></blockquote><h2 id="2-6-count-和-count-1-有什么区别？哪个性能最好？"><a href="#2-6-count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="2.6 count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>2.6 count(*) 和 count(1) 有什么区别？哪个性能最好？</h2><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230404155345245.png" style="zoom:50%;" /><p><strong>count() 是什么？</strong></p><ul><li><p>该函数作用是统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。</p></li><li><p>函数的参数不仅可以是字段名，也可以是其他任意表达式。</p></li><li><p>下面语句是统计「 t_order 表中，1 这个表达式不为 NULL 的记录」有多少个。1 这个表达式就是单纯数字，它永远都不是 NULL，所以上面这条语句，其实是在统计 t_order 表中有多少个记录</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">from</span> t_order<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>count(主键字段) 执行过程是怎样的？</strong></p><ul><li>在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。</li><li>server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。</li></ul><blockquote><p>如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。</p><p>但是，如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。</p><ul><li>这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I&#x2F;O 成本比遍历聚簇索引的 I&#x2F;O 成本小，因此「优化器」优先选择的是二级索引。</li></ul></blockquote><p><strong>count(1) 执行过程是怎样的？</strong></p><ul><li>如果表里只有主键索引，没有二级索引时。InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，<strong>但是不会读取记录中的任何字段的值</strong>，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。</li><li>如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引</li></ul><p><strong>count(*) 执行过程是怎样的？</strong></p><ul><li>count(*) 其实等于 count(0)，当使用 count(*) 时，MySQL 会将 * 参数转化为参数 0 来处理。</li><li>所以，count(*) 执行过程跟 count(1) 执行过程基本一样的，性能没有什么差异。</li></ul><p><strong>count(字段) 执行过程是怎样的？</strong></p><ul><li>相比其他三种，此方式执行效率最差，会采用全表扫描的方式来计数。</li></ul><p><strong>为什么要通过遍历的方式来计数？</strong></p><ul><li>上述执行都是基于 Innodb 存储引擎，但是在 MyISAM 存储引擎里，执行 count 函数的方式是不一样的，通常在没有任何查询条件下的 count(*)，MyISAM 的查询速度要明显快于 InnoDB。而当带上 where 条件语句之后，MyISAM 也需要扫描表来进行记录个数的统计。</li><li>使用 MyISAM 引擎时，执行 count 函数只需要 O(1 )复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息存储了row_count值，由表级锁保证一致性，所以直接读取 row_count 值就是 count 函数的执行结果。</li><li>而 InnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的（因为在事务中可能会插入数据），所以无法像 MyISAM一样，只维护一个 row_count 变量。</li></ul><p><strong>如何优化 count(*)？</strong></p><ul><li><strong>近似值</strong>：如果对于统计个数不需要很精确，使用 show table status 或者 explain 命令来表进行估算。执行 explain 命令效率是很高的，因为它并不会真正的去查询</li><li><strong>额外表保存计数值</strong>：如果是想精确的获取表的记录总数，可以将这个计数值保存到单独的一张计数表中。在新增和删除操作时，需要额外维护这个计数表。</li></ul><h1 id="三、事务篇"><a href="#三、事务篇" class="headerlink" title="三、事务篇"></a>三、事务篇</h1><h2 id="3-1-事务隔离级别是怎么实现的？"><a href="#3-1-事务隔离级别是怎么实现的？" class="headerlink" title="3.1 事务隔离级别是怎么实现的？"></a>3.1 事务隔离级别是怎么实现的？</h2><p>在操作前先开启事务，等所有数据库操作执行完成后，才提交事务，对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，如果中途发生发生中断或错误，那么该事务期间对数据库所做的修改将会被回滚到没执行该事务之前的状态。</p><h4 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a><strong>事务有哪些特性？</strong></h4><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h4 id="InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？"><a href="#InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？" class="headerlink" title="InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？"></a><strong>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</strong></h4><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><h4 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h4><ul><li><p><strong>脏读</strong>：如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</p></li><li><p><strong>不可重复读</strong>：在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</p><ul><li>例如 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取数据，然后继续执行代码逻辑处理，在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</li></ul></li><li><p><strong>幻读</strong>：在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</p><ul><li>例如事务A在处理开始时查询了记录数量，而之后又有一个事务插入了数据，当事务A再次查询数据时会发现数据不一样，此现象称为幻读。</li></ul><blockquote><ul><li>脏读：读到其他事务未提交的数据；</li><li>不可重复读：前后读取的数据不一致；</li><li>幻读：前后读取的记录数量不一致。</li></ul><p><strong>这三个现象的严重性排序如下： 脏读 &gt; 不可重复读 &gt; 幻读</strong></p></blockquote></li></ul><h4 id="事务的隔离级别有哪些？"><a href="#事务的隔离级别有哪些？" class="headerlink" title="事务的隔离级别有哪些？"></a>事务的隔离级别有哪些？</h4><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下（隔离级别从上到下依次增高）：</p><ul><li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p>不同的隔离级别可能发生的现象如下：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230404165514197.png" style="zoom:50%;" /><p>MySQL与SQL 标准中规定的各级隔离级别允许发生的现象却有些出入，在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。</p><p><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象</strong>，解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><p><strong>四种隔离级别实现</strong></p><ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在<strong>「每个语句执行前」</strong>都会重新生成一个 Read View，而「可重复读」隔离级别是<strong>「启动事务时</strong>」生成一个 Read View，然后整个事务期间都在用这个 Read View。</li></ul><p>注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：</p><ul><li>第一种：begin&#x2F;start transaction 命令；执行此命令后并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；</li><li>第二种：start transaction with consistent snapshot 命令；只要执行此命令，就会马上启动事务</li></ul><hr><h4 id="Read-View-在-MVCC-里如何工作的"><a href="#Read-View-在-MVCC-里如何工作的" class="headerlink" title="Read View 在 MVCC 里如何工作的"></a>Read View 在 MVCC 里如何工作的</h4><p>Read View 有四个重要的字段：</p><ul><li><strong>m_ids</strong> ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。</li><li><strong>min_trx_id</strong> ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。</li><li><strong>max_trx_id</strong> ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；</li><li><strong>creator_trx_id</strong> ：指的是创建该 Read View 的事务的事务 id。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230404191137819.png" style="zoom:50%;" /><p>对于使用 InnoDB 存储引擎的数据库表，它的<strong>聚簇索引记录中都包含下面两个隐藏列</strong>：</p><ul><li><p><strong>trx_id</strong>，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里。记录中的 trx_id 对读取它的事务来说可以分为三种情况：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230404191749752.png" style="zoom:33%;" /></li><li><p><strong>roll_pointer</strong>，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针</strong>，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。</p></li></ul><p>一个事务去访问记录的时候，有这几种情况：</p><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>max_trx_id如果记录的 trx_id 值在 Read View 的min_trx_id和之间，需要判断 trx_id 是否在 m_ids 列表中：<ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）</strong></p><hr><h4 id="可重复读是如何工作的？"><a href="#可重复读是如何工作的？" class="headerlink" title="可重复读是如何工作的？"></a>可重复读是如何工作的？</h4><ul><li><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p></li><li><p>每次事务去读时都是将记录的trx_id与read view的min_trx_id 比较：</p><ul><li>如果比min_trx_id 小，则说明修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的。</li><li>如果在min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录，</li></ul></li><li><p><a href="https://www.xiaolincoding.com/mysql/transaction/mvcc.html#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">例子</a></p></li></ul><h4 id="读提交是如何工作的？"><a href="#读提交是如何工作的？" class="headerlink" title="读提交是如何工作的？"></a>读提交是如何工作的？</h4><ul><li><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</li><li>原理和可重复读一样，只是「<strong>每个语句执行前</strong>」都会重新生成一个 Read View</li><li><a href="https://www.xiaolincoding.com/mysql/transaction/mvcc.html#%E8%AF%BB%E6%8F%90%E4%BA%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">例子</a></li></ul><h2 id="3-2-MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#3-2-MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="3.2 MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>3.2 MySQL 可重复读隔离级别，完全解决幻读了吗？</h2><p><strong>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读</strong>。</p><p><strong>当前读是如何避免幻读的？</strong></p><ul><li>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</li><li>Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了<strong>间隙锁</strong>。<ul><li>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</li></ul></li></ul><p><strong>发生幻读现象场景</strong></p><ol><li>对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。<ul><li>事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，此时没有id&#x3D;5的记录，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。接着，事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。<a href="https://www.xiaolincoding.com/mysql/transaction/phantom.html#%E5%B9%BB%E8%AF%BB%E8%A2%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%97">例子</a></li></ul></li><li>对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。<ul><li>事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。然后事务 B 往插入一个 id&#x3D; 200 的记录并提交；事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。<a href="https://www.xiaolincoding.com/mysql/transaction/phantom.html#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%91%E7%94%9F%E5%B9%BB%E8%AF%BB%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%9C%BA%E6%99%AF">例子</a></li><li><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</li></ul></li></ol><h1 id="四、锁篇"><a href="#四、锁篇" class="headerlink" title="四、锁篇"></a>四、锁篇</h1><h2 id="4-1-MySQL-有哪些锁？"><a href="#4-1-MySQL-有哪些锁？" class="headerlink" title="4.1 MySQL 有哪些锁？"></a>4.1 MySQL 有哪些锁？</h2><p>MySQL有全局锁、表级锁、行级锁：</p><ul><li><p><strong>全局锁</strong></p><ul><li><p>开启与释放全局锁：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span><span class="token keyword">unlock</span> <span class="token keyword">tables</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>开启全局锁后，<strong>整个数据库就处于只读状态了</strong>，他线程执行对数据的增删改操作或对表结构的更改操作都会被阻塞</p></li><li><p>全局锁应用场景：主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p></li><li><p>全局锁缺点：整个数据库都是只读状态。业务只能读数据，而不能更新数据，这样会造成业务停滞。</p></li></ul><blockquote><p>备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</p><ul><li>如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</li></ul></blockquote></li><li><p><strong>表级锁</strong>，MySQL 表级别锁有以下几种：</p><ul><li><p><strong>表锁</strong>；</p><ul><li><p>对t_student表加锁和释放锁操作如下</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">lock</span> <span class="token keyword">tables</span> t_student <span class="token keyword">read</span><span class="token punctuation">;</span><span class="token comment">//表级别的共享锁，也就是读锁；</span><span class="token keyword">lock</span> <span class="token keyword">tables</span> t_stuent <span class="token keyword">write</span><span class="token punctuation">;</span><span class="token comment">//表级别的独占锁，也就是写锁；</span><span class="token keyword">unlock</span> <span class="token keyword">tables</span> <span class="token comment">//释放当前会话的所有表锁</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>注意，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p></li></ul></li><li><p><strong>元数据锁（MDL）</strong>;</p><ul><li>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</li><li>不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL；对一张表进行 CRUD 操作时，加的是 MDL 读锁；对一张表做结构变更操作的时候，加的是 MDL 写锁；</li><li>释放时机：在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</li><li>注意，在执行长事务期间，MDL一直会被占用，如果此时有线程要修改表结构其会被阻塞，但是如果后续有对该表的读操作也会被阻塞。如果大量读操作到来，那么线程会爆满。<ul><li>这是因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁</li></ul></li></ul></li><li><p><strong>意向锁</strong>；</p><ul><li>当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。因此可分为意向共享锁和意向独占锁。</li><li><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁和独占表锁发生冲突。</strong></li><li>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</li><li><strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</li></ul></li><li><p><strong>AUTO-INC 锁</strong></p><ul><li>表里的主键通常都会设置成自增的，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</li><li>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。但大量插入数据时会影响性能。</li><li>在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增<ul><li>在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。</li><li>但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生数据不一致的问题。</li></ul></li></ul></li></ul></li><li><p><strong>行级锁</strong></p><ul><li><strong>Record Lock</strong>，记录锁，也就是仅仅把一条记录锁上，分为独占锁和共享锁</li><li><strong>Gap Lock</strong>，间隙锁，锁定一个范围，但是不包含记录本身（是前开后开区间）；<ul><li>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</li></ul></li><li><strong>Next-Key Lock</strong>：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。是前开后闭区间。<ul><li>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。</li></ul></li></ul><blockquote><p><strong>插入意向锁</strong></p><ul><li>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁</li><li>如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止，在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</li><li>插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。</li><li>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁</li></ul></blockquote></li></ul><blockquote><p><strong>为什么间隙锁与间隙锁之间是兼容的？</strong></p><ul><li>间隙锁的意义只在于阻止区间被插入，因此是可以共存的。一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁。</li><li>但是next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。</li></ul></blockquote><h2 id="4-2-MySQL-是怎么加锁的？"><a href="#4-2-MySQL-是怎么加锁的？" class="headerlink" title="4.2 MySQL 是怎么加锁的？"></a>4.2 MySQL 是怎么加锁的？</h2><p><strong>什么 SQL 语句会加行级锁？</strong></p><ul><li><p>直接加锁语句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span><span class="token comment">//对读取的记录加共享锁(S型锁)</span><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span class="token comment">//对读取的记录加独占锁(X型锁)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。</p></li></ul><h3 id="MySQL-是怎么加行级锁的？"><a href="#MySQL-是怎么加行级锁的？" class="headerlink" title="MySQL 是怎么加行级锁的？"></a><strong>MySQL 是怎么加行级锁的？</strong></h3><p><strong>加锁的对象是索引，加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，next-key lock 是前开后闭区间，而间隙锁是前开后开区间。</p><p>next-key lock 在一些场景下会退化成记录锁或间隙锁：在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成退化成记录锁或间隙锁。</p><p>不同索引等值或范围查询加锁规则不同：</p><ul><li><p><strong>唯一索引等值查询</strong></p><ul><li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。</li><li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong>。加锁右边界为第一条大于的记录，左边界为右边界的上一条记录。<ul><li>为什么不可以针对不存在的记录加记录锁？锁是加在索引上的，自然就没办法锁住这条不存在的记录。</li></ul></li><li>如果唯一索引是主键索引，那么加锁只加在主键上。但如果是二级索引，除了会对二级索引项加行级锁，还会对查询到的记录的主键索引项上加「记录锁」</li></ul></li><li><p><strong>唯一索引范围查询</strong></p><ul><li><p>当唯一索引进行范围查询时，<strong>会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁</strong>：</p><ul><li><p>情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会<strong>退化成记录锁</strong>。</p></li><li><p>情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：</p><ul><li>当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li><li>当条件值的记录在表中，如果是「小于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li></ul><blockquote><p>为什么大于等于查询会退化成记录锁，而小于等于查询不会？</p><p>因为扫描记录时是从左到右进行扫描的，而next-key和间隙锁都不回对左边界进行加锁。而小于等于查询且记录存在时，如果使用记录锁，会使得其前面部分会被插入数据。</p></blockquote></li></ul></li></ul></li><li><p><strong>非唯一索引等值查询</strong></p><ul><li>因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这<strong>两个索引都加锁</strong>，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁。</li><li>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是<strong>非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁</strong>。</li><li>当查询的记录「不存在」时，<strong>扫描到第一条不符合条件的二级索引记录（大于该条件），该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁</strong>。</li></ul></li><li><p><strong>非唯一索引范围查询</strong></p><ul><li>非唯一索引和主键索引的范围查询不同之处在于<strong>非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况</strong></li></ul><blockquote><p><strong>在 age &gt;&#x3D; 22 的范围查询中，明明查询 age &#x3D; 22 的记录存在并且属于等值查询，为什么不会像唯一索引那样，将 age &#x3D; 22 记录的二级索引上的 next-key 锁退化为记录锁？</strong></p><p>因为 age 字段是非唯一索引，不具有唯一性，所以如果只加记录锁（记录锁无法防止插入，只能防止删除或者修改），就会导致其他事务插入一条 age &#x3D; 22 的记录，这样前后两次查询的结果集就不相同了，出现了幻读现象。</p></blockquote></li><li><p><strong>没有加索引的查询</strong></p><ul><li>如果没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，<strong>每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表</strong>，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。</li><li>因此，在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了</li></ul></li></ul><blockquote><p><strong>如何避免update 没加索引会锁全表这种事故的发生？</strong></p><ul><li>可以将 MySQL 里的 <code>sql_safe_updates</code> 参数设置为 1，开启安全更新模式。当设置后，update 语句必须满足如下条件之一才能执行成功：<ul><li>使用 where，并且 where 条件中必须有索引列；</li><li>使用 limit；</li><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul></li><li>delete 语句必须满足以下条件能执行成功：<ul><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul></li><li>如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患</li></ul><p><strong>MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</strong></p><ul><li>针对当前读的语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。</li></ul></blockquote><h2 id="4-3-MySQL-死锁了，怎么办？"><a href="#4-3-MySQL-死锁了，怎么办？" class="headerlink" title="4.3 MySQL 死锁了，怎么办？"></a>4.3 MySQL 死锁了，怎么办？</h2><p>假设有两个事务都是先执行查询记录是否存在，然后插入记录。如果两个事务在查询记录时加的间隙锁位置相同或包含，插入数据时需要先申请一个插入意向锁，若插入位置已经有间隙锁，那么会被阻塞，此时会形成死锁。</p><p><strong>Insert 语句是怎么加行级锁的？</strong></p><ul><li>Insert 语句在正常执行时是不会生成锁结构的，它是靠聚簇索引记录自带的 trx_id 隐藏列来作为隐式锁来保护记录的。</li><li>隐式锁就是在 Insert 过程中不加锁，只有以下特殊情况下，才会将隐式锁转换为显示锁：<ul><li>如果记录之间加有间隙锁，为了避免幻读，此时是不能插入记录的；<ul><li>当需要插入一条记录时，需要查看待插入记录的下一个记录是否有间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（<em>PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</em>）</li></ul></li><li>如果 Insert 的记录和已有记录存在唯一键冲突，此时也不能插入记录；<ul><li>如果主键索引重复，插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加 S 型记录锁</strong>。</li><li>如果唯一二级索引重复，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录<strong>添加 S 型 next-key 锁</strong>。</li></ul></li></ul></li></ul><p><strong>如何避免死锁？</strong></p><ul><li>设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚。InnoDB 的<code>innodb_lock_wait_timeout</code> 用来设置超时时间。</li><li>开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。参数 <code>innodb_deadlock_detect</code> 设置为 on表示开启。</li></ul><h1 id="五、日志篇"><a href="#五、日志篇" class="headerlink" title="五、日志篇"></a>五、日志篇</h1><h2 id="5-1-MySQL-日志：undo-log、redo-log、binlog-有什么用？"><a href="#5-1-MySQL-日志：undo-log、redo-log、binlog-有什么用？" class="headerlink" title="5.1 MySQL 日志：undo log、redo log、binlog 有什么用？"></a>5.1 MySQL 日志：undo log、redo log、binlog 有什么用？</h2><p><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</p><p><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</p><p><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</p><hr><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230407191425152.png" style="zoom: 50%;" /><p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p><ul><li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li><li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li><li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li></ul><p>每个undo log 都有一个 roll_pointer 指针和一个 trx_id 事务id：</p><ul><li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li><li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</li></ul><p><strong>undo log 两大作用：</strong></p><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><blockquote><p><strong>undo log 是如何持久化到磁盘？</strong></p><ul><li>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。</li><li>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。</li></ul></blockquote><hr><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>redo log存在原因：Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p><p>redo log 是物理日志，记录了某个数据页做了什么修改，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><ul><li>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</li><li>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</li></ul><p>redo log 是为了防止 Buffer Pool 中的脏页丢失而设计的，那么如果随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了。因此redo log 是循环写的方式。</p><blockquote><p><strong>修改 Undo 页面，需要记录对应 redo log 吗？</strong></p><ul><li>需要的。在内存修改该 Undo 页面后，需要记录对应的 redo log。</li></ul><p><strong>WAL （Write-Ahead Logging）技术</strong>。<strong>指MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p></blockquote><p><strong>redo log 和 undo log 区别</strong>：</p><ul><li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li><li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230407192922396.png" style="zoom:50%;" /><p><strong>产生的 redo log 是直接写入磁盘的吗？</strong></p><ul><li>执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作</li><li>redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘</li></ul><p><strong>redo log 什么时候刷盘？</strong></p><ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，细节<a href="https://www.xiaolincoding.com/mysql/log/how_update.html#redo-log-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%B7%E7%9B%98">见此</a>）。</li></ul><hr><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p><ul><li>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。</li></ul><blockquote><p><strong>为什么有了 binlog， 还要有 redo log？</strong></p><ul><li>历史原因，MySQL自带的MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。所以InnoDB 使用 redo log 来实现 crash-safe 能力。</li></ul></blockquote><p><strong>binlog 什么时候刷盘</strong></p><ul><li>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。</li><li>一个事务的 binlog 是不能被拆开的，因此无论这个事务有多大（比如有很多条语句），也要保证一次性写入。这是因为一个线程只能同时有一个事务在执行，如果被分开就破坏了原子性</li></ul><p><strong>redo log 和 binlog 区别</strong></p><ol><li>适用对象不同<ul><li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li><li>redo log 是 Innodb 存储引擎实现的日志；</li></ul></li><li>文件格式不同<ul><li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。 STATEMENT 有动态函数的问题，比如用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li><li>ROW：记录行数据最终被修改成什么样了，不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录</li><li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li></ul></li><li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li></ul></li><li>写入方式不同<ul><li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li><li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li></ul></li><li>用途不同<ul><li>binlog 用于备份恢复、主从复制；</li><li>redo log 用于掉电等故障恢复。</li></ul></li></ol><blockquote><p><strong>如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？</strong></p><ul><li>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。</li><li>因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。</li><li>binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。</li></ul></blockquote><p><strong>主从复制是怎么实现？</strong></p><ul><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li><li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li><li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230407194533560.png" style="zoom:50%;" /><p><strong>MySQL 主从复制还有哪些模型？</strong></p><ul><li><strong>同步复制</strong>：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式的可用性和性能较差，基本上没法用</li><li><strong>异步复制</strong>（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。</li><li><strong>半同步复制</strong>：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分从库复制成功响应回来就行。这种<strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong>。</li></ul><hr><h3 id="update-语句中三种日志执行过程"><a href="#update-语句中三种日志执行过程" class="headerlink" title="update 语句中三种日志执行过程"></a>update 语句中三种日志执行过程</h3><ol><li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li><li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘，这就是 **WAL 技术。</li><li>至此，一条记录更新完了。在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li><li>事务提交，剩下的就是「两阶段提交」。</li></ol><hr><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p><strong>为什么需要两阶段提交？</strong></p><ul><li>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现有的提交不成功，这样就造成两份日志之间的逻辑不一致。</li></ul><p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p><p><strong>两阶段提交的过程</strong>：将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog，具体如下：</p><ul><li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘；</li><li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功</li></ul><p><strong>两阶段提交异常重启会出现什么现象？</strong></p><ul><li>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：<ul><li>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务。对应时刻 A 崩溃恢复的情况。</li><li>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务。对应时刻 B 崩溃恢复的情况。</li></ul></li></ul><p><strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong></p><p><strong>两段提交缺点</strong>：</p><ul><li>磁盘 I&#x2F;O 次数高：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li><li>锁竞争激烈：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li></ul><h4 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h4><p>MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I&#x2F;O 的次数</p><p>引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：</p><ul><li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；</li><li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；</li><li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit 操作；</li></ul><blockquote><p><strong>MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？</strong></p><ul><li>设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。</li><li>将 sync_binlog 设置为大于 1 的值，表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。</li><li>将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache</li></ul></blockquote><h2 id="5-2-Buffer-Pool"><a href="#5-2-Buffer-Pool" class="headerlink" title="5.2 Buffer Pool"></a>5.2 Buffer Pool</h2><p>Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能：</p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘</li></ul><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。uffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 <code>128MB</code> 。</p><p>Buffer Pool 除了缓存「<strong>索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息</strong>等</p><p>为了管理在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。</p><blockquote><p><strong>查询一条记录，就只需要缓冲一条记录吗？</strong></p><ul><li>查询一条记录时，会把整个页的数据加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。</li></ul></blockquote><p><strong>如何管理空闲页？</strong></p><ul><li>为了能够快速找到空闲的缓存页，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）。</li><li>Free 链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。</li><li>Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，所以相当于 Free 链表节点都对应一个空闲的缓存页。</li><li>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。</li></ul><p><strong>如何管理脏页？</strong></p><ul><li>跟 Free 链表类似，使用<strong>Flush 链表</strong>来管理脏页，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</li></ul><p><strong>如何提高缓存命中率？</strong></p><ul><li>Buffer Pool 里有三种页和链表来管理数据：<ul><li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li><li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。</li><li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。脏页同时存在于 LRU 链表和 Flush 链表。</li></ul></li><li>MySQL改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。young 区域在 LRU 链表的前半部分，old 区域则是在后半部分。</li><li>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部。</li></ul><p><strong>什么是 Buffer Pool 污染？</strong></p><ul><li>当某一个 SQL 语句扫描了大量的数据时，在 Buffer Pool 空间比较有限的情况下，可能会将 Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 Buffer Pool 污染。</li><li><strong>解决办法</strong>：在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：<ul><li>如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该缓存页就不会被从 old 区域移动到 young 区域的头部；</li><li>如果后续的访问时间与第一次访问的时间不在某个时间间隔内，那么该缓存页移动到 young 区域的头部；</li><li>也就是，只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</li></ul></li></ul><p><strong>脏页什么时候会被刷入磁盘？</strong></p><ul><li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li><li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li><li>MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；</li><li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>264. 丑数 II</title>
      <link href="/2023/03/23/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-264-%E4%B8%91%E6%95%B0II-middle/"/>
      <url>/2023/03/23/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-264-%E4%B8%91%E6%95%B0II-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a><a href="https://leetcode.cn/problems/ugly-number-ii/description/">264. 丑数 II</a></h1><p>First：用set方法做出来了，但没想到用动态规划</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>set</strong></p><p>使用一个set来存储已经找到的丑数，由于set自带排序，因此set的第一个数是其中最小的数。不断弹出第一个数，知道找到第n个数为止。</p><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int nthUglyNumber(int n) &#123;        if(n&#x3D;&#x3D;1) return 1;        set&lt;long long&gt; st;        st.insert(2);        st.insert(3);        st.insert(5);        int count&#x3D;1;        while(!st.empty())&#123;            long long cur&#x3D;*st.begin();            st.erase(st.begin());            count++;            &#x2F;&#x2F; cout&lt;&lt;cur&lt;&lt;&quot; &quot;;            if(count&#x3D;&#x3D;n) return cur;            st.insert(cur*2);            st.insert(cur*3);            st.insert(cur*5);        &#125;        return 0;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>使用一维数组存储已经找到的丑数，dp[i]表示第i个丑数。</p><p>由于已经找到的每一个数都可以推导出3个丑数，因此使用3个指针p2,p3,p5记录当前能分别与2、3、5进行相乘的下标。dp[i] &#x3D;min(dp[p2]*2, dp[p3] *3, dp[p5] *5)；</p><p>这里三个指针和三个数相乘并没有严格对应关系，因为后面的丑数必定是由前面的丑数推导得到，而每一个值都可以推导三个丑数，如果新推导出的丑数等于当前丑数乘以2、3、5中一个，那么就说明其对应指针应该+1，这是因为不需要其再当前值再进行推导，否则会出现重复。</p><p>第一个丑数是1，因此三个指针皆初始化为1.</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int ans&#x3D;INT_MIN;        int count&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            count+&#x3D;nums[i];            ans&#x3D;max(ans,count);            if(count&lt;0) count&#x3D;0;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
            <tag> Alg-三指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>152. 乘积最大子数组</title>
      <link href="/2023/03/22/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-152%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84-middle/"/>
      <url>/2023/03/22/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-152%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组</a></h1><p>First：以前做过，顺利做出来，但还是想了一阵</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [0]表示以i结尾的最大子数组乘积，dp[i] [1]表示以i结尾的最小子数组乘积。</p><p>由于负数再乘以一个负数就可以得到一个正数，因此最大值可能是由前一个最小值乘以当前值得到，也可能由前一个最大值乘以当前值得到，也可能是当前值得到。所以dp[i] [0]&#x3D;max(dp[i-1] [0]*nums[i], max(dp[i-1] [1] *nums[i], nums[i]))；同理，dp[i] [1]&#x3D;max(dp[i-1] [0] *nums[i], max(dp[i-1] [1] *nums[i], nums[i]))；</p><p>初始值任意即可。</p><p>有递推公式可知，只能从前向后遍历。</p><p>还可优化为常数空间</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; dp(2,nums[0]);        int ans&#x3D;nums[0];        for(int i&#x3D;1;i&lt;nums.size();++i)&#123;            int tmp&#x3D;dp[0];            dp[0]&#x3D;max(dp[0]*nums[i],max(dp[1]*nums[i],nums[i]));            dp[1]&#x3D;min(tmp*nums[i],min(dp[1]*nums[i],nums[i]));            ans&#x3D;max(ans,max(dp[0],dp[1]));                &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>221. 最大正方形</title>
      <link href="/2023/03/22/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2-middle/"/>
      <url>/2023/03/22/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/description/">221. 最大正方形</a></h1><p>First：以前做过，顺利做出来</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示到以matrix[i-1] [j-1]作为右下角所能围城的最大正方形。</p><p>观察可知，当前位置所能围城的最大正方形由左边第一个值、上方第一个值、左上方第一个值决定，因此dp[0] [0]&#x3D;min(dp[i-1] [j],min(dp[i-1] [j-1],dp[i][j-1]))+1;。</p><p>只能向右或向下移动，那么要知道当前方格最大正方形就需要知道上方方格和左边方格，因此从左到右遍历由上到下遍历。</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;        int m&#x3D;matrix.size(),n&#x3D;matrix[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));        int ans&#x3D;0;        for(int i&#x3D;1;i&lt;&#x3D;m;++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;                if(matrix[i-1][j-1]&#x3D;&#x3D;&#39;0&#39;) continue;                     dp[i][j]&#x3D;min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1]))+1;                           ans&#x3D;max(ans,dp[i][j]);                            &#125;        &#125;        return ans*ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>140. 单词拆分 II</title>
      <link href="/2023/03/22/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86II-difficult/"/>
      <url>/2023/03/22/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86II-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="140-单词拆分-II"><a href="#140-单词拆分-II" class="headerlink" title="140. 单词拆分 II"></a><a href="https://leetcode.cn/problems/word-break-ii/description/">140. 单词拆分 II</a></h1><p>First：直接用回溯就行，效率也挺高能打败100%，感觉配不上困难。不过答案记忆化搜索好像有剪枝之类的方法还没细看。</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>使用一个idx记录当前回溯位置，如果在idx位置开始能匹配任意一个单词，则将匹配单词加入到path中，并递归遍历idx+words.size()的情况。</p><p>中止条件：当idx等于s.size()，则将path加入到ans中。</p><p>遍历过程：对于wordDict中的每个单词，都查看当前位置是否能匹配，若能匹配则将当前单词加入到path中，然后递归遍历新位置。</p><p>剪枝：无</p><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;string&gt; ans;    string path;public:    void dealWord(string &amp;s, vector&lt;string&gt;&amp; wordDict,int idx)&#123;        if(idx&#x3D;&#x3D;s.size())&#123;            path.pop_back();            ans.push_back(path);            path+&#x3D;&#39; &#39;;            return;        &#125;        for(string &amp;words:wordDict)&#123;            if(idx+words.size()&gt;s.size()) continue;            string tmp&#x3D;s.substr(idx,words.size());            if(tmp&#x3D;&#x3D;words)&#123;                path+&#x3D;tmp+&#39; &#39;;                dealWord(s,wordDict,idx+words.size());                path&#x3D;path.substr(0,path.size()-tmp.size()-1);            &#125;        &#125;    &#125;    vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;        dealWord(s,wordDict,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>120. 三角形最小路径和</title>
      <link href="/2023/03/21/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-middle/"/>
      <url>/2023/03/21/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode.cn/problems/triangle/description/">120. 三角形最小路径和</a></h1><p>First：傻了，开始以为和树深度遍历差不多，后来才发现树每个节点只有一个父节点，而这题每个节点却可能有两个父节点。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j+1]表示到第i行j列节点的最小路径</p><p>由题中可知，当前节点的父节点可能是其上方节点或上方节点的左边一个节点，因此dp[i] [j]&#x3D;min(dp[i-1] [j],dp[i-1] [j-1])+triangle[i] [j-1];。</p><p>到第0行第0列个节点的路径为triangle[0] [0]，所以dp[0] [1]&#x3D;1。</p><p>由递推公式只，其由左上方推导得到，因此从上到下遍历，从左到右遍历。另外，此题还可优化为常数空间。</p><ul><li>时间复杂度：O(n^2) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;        vector&lt;int&gt; dp(triangle.size()+1,INT_MAX);        dp[1]&#x3D;triangle[0][0];        for(int i&#x3D;1;i&lt;triangle.size();++i)&#123;            for(int j&#x3D;triangle[i].size();j&gt;0;--j)&#123;                dp[j]&#x3D;min(dp[j],dp[j-1])+triangle[i][j-1];            &#125;        &#125;        int ans&#x3D;INT_MAX;        for(int i&#x3D;0;i&lt;dp.size();++i) ans&#x3D;min(ans,dp[i]);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91. 解码方法</title>
      <link href="/2023/03/18/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95-middle/"/>
      <url>/2023/03/18/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode.cn/problems/decode-ways/description/">91. 解码方法</a></h1><p>First：思想较简单，但还是错了一次。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[i] 表示到s前i-1个字符的解码总数。</p><p>由于编码长度只有2，那么dp[i]只会与dp[i-1]和dp[i-2]有关，分为两种长度分为进行判断。、</p><ul><li>当s[i-1]!&#x3D;0时，最末尾字符属于编码集，那么dp[i]+&#x3D;dp[i-1]。</li><li>当s[i-2]&#x3D;1或 s[i-2]&#x3D;’2’&amp;&amp;s[i-1]&gt;&#x3D;’0’&amp;&amp;s[i-1]&lt;&#x3D;’6’时，此时末尾两位字符也是在编码集中，那么dp[i]+&#x3D;dp[i-2]</li></ul><p>当s[0]&#x3D;&#x3D;0时，无法存在正确解码，所有只有当s[0]!&#x3D;0时，将dp[0]和dp[1]初值设为1；</p><p>dp[i]需要由前面的dp得到，因此从左到右遍历。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numDecodings(string s) &#123;        int n&#x3D;s.size();        vector&lt;int&gt; dp(n+1,0);        if(s[0]!&#x3D;&#39;0&#39;) &#123;            dp[1]&#x3D;1;            dp[0]&#x3D;1;        &#125;                for(int i&#x3D;2;i&lt;&#x3D;n;++i)&#123;                        if(s[i-1]!&#x3D;&#39;0&#39;) dp[i]+&#x3D;dp[i-1];            if(s[i-2]&#x3D;&#x3D;&#39;1&#39;||(s[i-2]&#x3D;&#x3D;&#39;2&#39;&amp;&amp;s[i-1]&gt;&#x3D;&#39;0&#39;&amp;&amp;s[i-1]&lt;&#x3D;&#39;6&#39;)) dp[i]+&#x3D;dp[i-2];        &#125;        return dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 66. 构建乘积数组</title>
      <link href="/2023/03/18/leetcode/%E6%95%B0%E7%BB%84/leetcode-%E5%89%91%E6%8C%87Offer66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84-middle/"/>
      <url>/2023/03/18/leetcode/%E6%95%B0%E7%BB%84/leetcode-%E5%89%91%E6%8C%87Offer66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a><a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/description/">剑指 Offer 66. 构建乘积数组</a></h1><p>FIrst：顺利做出，以前好像做过</p><hr><p><strong>方法1</strong>：<strong>左右乘积列表</strong></p><p>由于不能使用除法，因此对于每个数的乘积结果只需要知道其左边乘积和右边乘积即可。</p><p>使用两个数组left和right分别记录当前位置左边乘积和右边乘积，最后将两个数组对应位置相乘即可。</p><p>优化空间为O(1)：由于答案不计为空间复杂度，先使用ans数据记录左边乘积，然后从右边进行遍历，定义一个变量t来记录乘积，即可优化为常数空间。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; constructArr(vector&lt;int&gt;&amp; a) &#123;        int n&#x3D;a.size();        vector&lt;int&gt; left(n,1),right(n,1),ans(n,1);        for(int i&#x3D;1,j&#x3D;n-2;i&lt;n;++i,--j)&#123;            left[i]&#x3D;left[i-1]*a[i-1];            right[j]&#x3D;right[j+1]*a[j+1];        &#125;        for(int i&#x3D;0;i&lt;n;++i)&#123;            ans[i]&#x3D;left[i]*right[i];        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>316. 去除重复字母</title>
      <link href="/2023/03/17/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D-middle/"/>
      <url>/2023/03/17/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316. 去除重复字母"></a><a href="https://leetcode.cn/problems/remove-duplicate-letters/description/">316. 去除重复字母</a></h1><p>First：磕磕绊绊还是做出来了，但错了几次</p><hr><p><strong>方法1</strong>：<strong>栈+哈希表</strong></p><p>要想找到字典序最小的结果，那么不重复的字母不能被删除，重复的字母如果其后面有比它小的字母那么就要将其删除，否则不能删。因此可以使用栈来做。</p><p>首先遍历所有字母得到每个字母出现的次数，然后使用一个栈st来存储当前入栈字母，使用一个set来快速找到某字母是否入栈。依次遍历元素，如果当前元素未入栈，那么就不断弹出比其大且在气候有重复的字母，然后将其入栈。如果当前元素已入栈，就将重复数减1即可（为了避免后面的数字要弹出栈中的数字，如bba）。最后弹出栈中所有元素并逆序即为答案。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string removeDuplicateLetters(string s) &#123;        unordered_map&lt;char,int&gt; map;        unordered_set&lt;char&gt; mset;&#x2F;&#x2F;用于存储已经放入栈中的元素        for(char c:s) ++map[c];        stack&lt;char&gt; st;        for(int i&#x3D;0;i&lt;s.size();++i)&#123;                        if(mset.count(s[i])&#x3D;&#x3D;0)&#123;                while(!st.empty()&amp;&amp;s[i]&lt;&#x3D;st.top()&amp;&amp;map[st.top()]&gt;1)&#123;                    --map[st.top()];                    mset.erase(st.top());                    st.pop();                    &#125;                st.push(s[i]);                mset.insert(s[i]);            &#125;else --map[s[i]];         &#125;        string ans;        while(!st.empty())&#123;            ans+&#x3D;st.top();            st.pop();        &#125;        reverse(ans.begin(),ans.end());        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1128. 等价多米诺骨牌对的数量</title>
      <link href="/2023/03/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-1128-%E7%AD%89%E4%BB%B7%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F-simple/"/>
      <url>/2023/03/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-1128-%E7%AD%89%E4%BB%B7%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="1128-等价多米诺骨牌对的数量"><a href="#1128-等价多米诺骨牌对的数量" class="headerlink" title="1128. 等价多米诺骨牌对的数量"></a><a href="https://leetcode.cn/problems/number-of-equivalent-domino-pairs/description/">1128. 等价多米诺骨牌对的数量</a></h1><p>First：开始想用哈希表来做，但还要自己写哈希函数就改为使用排序来做，但效率有点低。看了答案才知对数字大小有限制，可以设计一种哈希方法来做。</p><hr><p><strong>方法1</strong>：<strong>排序</strong></p><p>先将数组中的所有值都变成前小后大，然后对其进行排序，最大统计相同元素的个数count，count个相同元素可以组成count*(count-1)&#x2F;2对，将所有结果相加即可。</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) &#123;        for(int i&#x3D;0;i&lt;dominoes.size();++i)&#123;            if(dominoes[i][0]&gt;dominoes[i][1]) swap(dominoes[i][0],dominoes[i][1]);        &#125;        sort(dominoes.begin(),dominoes.end(),[](vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)&#123;            return a[0]&lt;b[0]||(a[0]&#x3D;&#x3D;b[0]&amp;&amp;a[1]&lt;b[1]);        &#125;);                int ans&#x3D;0;        int idx&#x3D;0,count&#x3D;1;        while(idx&lt;dominoes.size()-1)&#123;            if(dominoes[idx][0]&#x3D;&#x3D;dominoes[idx+1][0]&amp;&amp;dominoes[idx][1]&#x3D;&#x3D;dominoes[idx+1][1])&#123;                ++count;                            &#125;else&#123;                ans+&#x3D;count*(count-1)&#x2F;2;                count&#x3D;1;            &#125;            ++idx;        &#125;        if(count!&#x3D;1) ans+&#x3D;count*(count-1)&#x2F;2;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>哈希表 + 计数</strong></p><p>仍然交换每一对数值，使其变成前小后大。由于数字都小于9，因此可以设计一种哈希函数投影到长度为100的数组中，即x*10+y为投影函数。</p><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) &#123;        int nums[100]&#x3D;&#123;0&#125;;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;dominoes.size();++i)&#123;            if(dominoes[i][0]&gt;dominoes[i][1]) swap(dominoes[i][0],dominoes[i][1]);            ++nums[dominoes[i][0]*10+dominoes[i][1]];        &#125;        for(int i&#x3D;0;i&lt;100;++i)&#123;            ans+&#x3D;nums[i]*(nums[i]-1)&#x2F;2;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>85. 最大矩形</title>
      <link href="/2023/03/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2-diffcult/"/>
      <url>/2023/03/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2-diffcult/</url>
      
        <content type="html"><![CDATA[<h1 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a><a href="https://leetcode.cn/problems/maximal-rectangle/description/">85. 最大矩形</a></h1><p>First：没做出来，看了解析才知是柱状图最大矩形的拓展题</p><hr><p><strong>方法1</strong>：<strong>单调栈</strong></p><p>对于矩阵中的每个为1数字，都可以求得其左边连续1的个数，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230315153448196.png" alt="image-20230315153448196"></p><p>当按上述方法求得所有值后，然后按每一列来进行看待，这么一列就可以看成一组柱状图，然后求其最大矩形即可。最后求得所有列中最大矩形的值作为答案即可。</p><p>而求柱状图中最大举行可参考84题，使用单调栈即可。</p><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int getMaxSize(vector&lt;vector&lt;int&gt;&gt; &amp;lens,int idx)&#123;        stack&lt;int&gt; mst;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;lens.size();++i)&#123;            while(!mst.empty()&amp;&amp;lens[mst.top()][idx]&gt;lens[i][idx])&#123;                int cur&#x3D;mst.top();                mst.pop();                ans&#x3D;max(ans,lens[cur][idx]*(i-mst.top()-1));            &#125;            mst.push(i);        &#125;        return ans;    &#125;    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;        int m&#x3D;matrix.size(),n&#x3D;matrix[0].size();        vector&lt;vector&lt;int&gt;&gt; lens(m,vector&lt;int&gt;(n,0));        for(int i&#x3D;0;i&lt;m;++i)&#123;            for(int j&#x3D;0;j&lt;n;++j)&#123;                if(matrix[i][j]&#x3D;&#x3D;&#39;1&#39;)&#123;                    if(j&gt;0) lens[i][j]&#x3D;lens[i][j-1]+1;                    else lens[i][j]&#x3D;1;                &#125;            &#125;        &#125;        lens.insert(lens.begin(),vector&lt;int&gt;(n,0));        lens.push_back(vector&lt;int&gt;(n,0));        int ans&#x3D;0;        for(int idx&#x3D;0;idx&lt;n;++idx)&#123;            ans&#x3D;max(ans,getMaxSize(lens,idx));        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. 最长回文子串</title>
      <link href="/2023/03/01/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-middle/"/>
      <url>/2023/03/01/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5. 最长回文子串</a></h1><p>First：用动态规划和中心扩展都可以，解析里的那个O(n)解法还没看</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示以s以位置i开头位置j结尾所形成的字符串是否是回文，因此选最长的回文返回。</p><p>递推公式：</p><ul><li>当j-i&#x3D;1时，此时只有两个数字，因此直接比较是否是回文</li><li>当j-i&gt;1时，此区间是否是回文与j+1和i-1区间有关，且和s[i]&#x3D;&#x3D; s[j]有关，因此 dp[i][j]&#x3D;dp[i+1][j-1]&amp;&amp;s[i]&#x3D;&#x3D;s[j];</li></ul><p>dp除i&#x3D;&#x3D;j初始化为1外，其余皆初始化为0</p><p>从递推公式可以看出是从左下方推导出当前结果，因此需要先外层从大到小遍历s，再内层从小到大遍历s</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n^2^)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ansl<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>ansr<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">-</span>i<span class="token operator">></span>ansr<span class="token operator">-</span>ansl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    ansr<span class="token operator">=</span>j<span class="token punctuation">;</span>                    ansl<span class="token operator">=</span>i<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>ansl<span class="token punctuation">,</span>ansr<span class="token operator">-</span>ansl<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>对于S中的每个字符都向左右进行扩展，然后得到最大扩展回文子串。注意，每个字符串只需要两种扩展，第一种是以当前字符为中心，第二种是以当前字符和左边字符进行扩展。</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">getLongRes</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>left<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>right<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token operator">--</span>left<span class="token punctuation">;</span>                <span class="token operator">++</span>right<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">++</span>left<span class="token punctuation">;</span>        <span class="token operator">--</span>right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ansl<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>ansr<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> left<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token function">getLongRes</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">></span>ansr<span class="token operator">-</span>ansl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ansr<span class="token operator">=</span>right<span class="token punctuation">;</span>                ansl<span class="token operator">=</span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            left<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>right<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">getLongRes</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">></span>ansr<span class="token operator">-</span>ansl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ansr<span class="token operator">=</span>right<span class="token punctuation">;</span>                ansl<span class="token operator">=</span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>ansl<span class="token punctuation">,</span>ansr<span class="token operator">-</span>ansl<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2：Manacher算法</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>153. 寻找旋转排序数组中的最小值</title>
      <link href="/2023/02/28/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-middle/"/>
      <url>/2023/02/28/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="475-供暖器"><a href="#475-供暖器" class="headerlink" title="475. 供暖器"></a><a href="https://leetcode.cn/problems/heaters/description/">475. 供暖器</a></h1><p>First：较为复杂，考虑了四种情况来讨论，但看解析考虑两种情况即可</p><hr><p><strong>方法1</strong>：<strong>二分查找</strong></p><p>还是使用常规二分查找，只是边界更新判定不同。假设旋转后数组可表示为[旋转部分，原来部分]可分为以下情况</p><ul><li>如果nums[mid]&gt;&#x3D;nums[left]：<ul><li>且nums[mid]&lt;nums[right]:则说明此时此区间是有序的，因此将right&#x3D;mid即可</li><li>且nums[mid]&gt;&#x3D;nums[right]:则说明mid处于旋转部分，因此需要将left&#x3D;mid+1</li></ul></li><li>如果nums[mid]&lt;nums[left]<ul><li>且nums[mid]&gt;nums[right]:不存在此种情况</li><li>且nums[mid]&lt;&#x3D;nums[right]:则说明mid位于原来部分，因此将right&#x3D;mid；</li></ul></li></ul><p>对于上述四种情况，其实可以合并为第2种和第4种情况两种情况，因此只需判断这两种情况即可。</p><ul><li>时间复杂度：O(logn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findMin(vector&lt;int&gt;&amp; nums) &#123;        int left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;right)&#123;            int mid&#x3D;left+(right-left)&#x2F;2;            if(nums[mid]&gt;&#x3D;nums[left])&#123;                if(nums[mid]&lt;nums[right]) right&#x3D;mid;                else left&#x3D;mid+1;            &#125;else &#123;                if(nums[mid]&gt;nums[right]) left&#x3D;mid+1;                else right&#x3D;mid;            &#125;        &#125;        return nums[left];    &#125;&#125;;&#x2F;&#x2F;简化情况后class Solution &#123;public:    int findMin(vector&lt;int&gt;&amp; nums) &#123;        int left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;right)&#123;            int mid&#x3D;left+(right-left)&#x2F;2;            if(nums[mid]&lt;&#x3D;nums[right]) right&#x3D;mid;            else left&#x3D;mid+1;        &#125;        return nums[left];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>215. 数组中的第K个最大元素</title>
      <link href="/2023/02/28/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-middle/"/>
      <url>/2023/02/28/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h1><p>First：先使用的最小堆来做，后面用基于快速排序的方法时边界条件弄了挺久</p><hr><p><strong>方法1</strong>：<strong>基于快速排序的查找</strong></p><p>快速排序每次可以确定一个值的最终位置，利用此点，使用快速排序+二分查找的方法来找结果</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;right)&#123;            int pos&#x3D;left;            int lt&#x3D;left,rt&#x3D;right;            while(lt&lt;rt)&#123;                                while(nums[lt]&lt;&#x3D;nums[pos]&amp;&amp;lt&lt;rt) ++lt;                while(nums[rt]&gt;nums[pos]&amp;&amp;lt&lt;rt) --rt;                swap(nums[rt],nums[lt]);            &#125;            if(nums[pos]&gt;&#x3D;nums[lt])&#123;                swap(nums[pos],nums[lt]);                pos&#x3D;lt;            &#125;else&#123;                swap(nums[pos],nums[lt-1]);                pos&#x3D;lt-1;            &#125;            if(pos&#x3D;&#x3D;nums.size()-k) return nums[pos];            else if(pos&gt;nums.size()-k) right&#x3D;pos-1;            else left&#x3D;pos+1;                    &#125;        return nums[nums.size()-k];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法2</strong>：<strong>最小堆</strong></p><p>使用一个容量为k的最小堆，不断向堆中加入数据，如果堆容量大于k则弹出一个数据，最后取堆顶数据即为答案。</p><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; mque;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(mque.size()&lt;k)&#123;                mque.push(nums[i]);            &#125;else&#123;                if(mque.top()&lt;nums[i])&#123;                    mque.pop();                    mque.push(nums[i]);                &#125;            &#125;        &#125;        return mque.top();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
      <link href="/2023/02/27/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-middle/"/>
      <url>/2023/02/27/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h1><p>First：主要是细节上的边界判定，查找上边界和下边界分别写了，而解析综合在一起了。关于二分查找边界设定可见代码随想录的<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#_704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a></p><hr><p><strong>方法1</strong>：<strong>二分查找</strong></p><p>分别查找上边界和下边界，注意上下边界的不同主要是使用等于target时的边界更新规则。</p><ul><li>时间复杂度：O(logn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">searchRange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">)</span> left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> right<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">>=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token punctuation">)</span> left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> right<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">>=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>二分查找两种写法</strong></p><ul><li><p>若while(left&lt;&#x3D;right)，则说明是一个左闭右闭的，如果nums[mid]&gt;target，此时right&#x3D;mid-1，因为nums[mid]一定不是target，</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 定义target在左闭右闭的区间里，[left, right]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span>            <span class="token keyword">int</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 防止溢出 等同于(left + right)/2</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                right <span class="token operator">=</span> middle <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在左区间，所以[left, middle - 1]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在右区间，所以[middle + 1, right]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// nums[middle] == target</span>                <span class="token keyword">return</span> middle<span class="token punctuation">;</span> <span class="token comment">// 数组中找到目标值，直接返回下标</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 未找到目标值</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>若while(left&lt;right)，则说明是一个左闭右开的，如果nums[mid]&gt;target，此时right&#x3D;mid，因为区间是左闭右开的</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定义target在左闭右开的区间里，即：[left, right)</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span>            <span class="token keyword">int</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                right <span class="token operator">=</span> middle<span class="token punctuation">;</span> <span class="token comment">// target 在左区间，在[left, middle)中</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在右区间，在[middle + 1, right)中</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// nums[middle] == target</span>                <span class="token keyword">return</span> middle<span class="token punctuation">;</span> <span class="token comment">// 数组中找到目标值，直接返回下标</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 未找到目标值</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注意！两种写法left更新都是mid+1；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>856. 括号的分数</title>
      <link href="/2023/02/23/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-856-%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%95%B0-middle/"/>
      <url>/2023/02/23/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-856-%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%95%B0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="856-括号的分数"><a href="#856-括号的分数" class="headerlink" title="856. 括号的分数"></a><a href="https://leetcode.cn/problems/score-of-parentheses/description/">856. 括号的分数</a></h1><p>First：用两个栈实现了。</p><hr><p><strong>方法1</strong>：<strong>双栈</strong></p><p>此题主要是需要判断括号中是否有括号，使用一个特殊字符来标记当前匹配括号中是否有括号</p><p>使用两个栈：st1存储压入栈的左括号，为了判断当前匹配的括号情况，因此对于每匹配成功一个括号，则像st1中压入一个特殊字符N，然后在栈st2中压入此括号得分。</p><p>当遍历到右括号时，不断弹出st1中栈顶的N字符，并同时st2中栈顶数字，并将数字相加得到add。如果add等于0，则说明当前匹配括号中无子括号，则当前括号得分1，否则得到为add*2，最后向st1中压入N，向st2中压入当前得分。最后将st2中的所有值相加即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">scoreOfParentheses</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> stNum<span class="token punctuation">;</span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>add<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'('</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> add<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token char">'('</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    add<span class="token operator">+=</span>stNum<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    stNum<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token char">'N'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>add<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>add<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stNum<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token operator">+=</span>stNum<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stNum<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1498. 满足条件的子序列数目</title>
      <link href="/2023/02/22/leetcode/%E6%95%B0%E7%BB%84/leetcode-1498-%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/"/>
      <url>/2023/02/22/leetcode/%E6%95%B0%E7%BB%84/leetcode-1498-%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1498-满足条件的子序列数目"><a href="#1498-满足条件的子序列数目" class="headerlink" title="1498. 满足条件的子序列数目"></a><a href="https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/">1498. 满足条件的子序列数目</a></h1><p>First：在细节上纠结了挺久，最后发现如果不预处理数的话对于大数据很难处理</p><hr><p><strong>方法1</strong>：<strong>双指针</strong> </p><p>由于是计算子序列数目，因此元素顺序对子序列无影响。先对数组进行从小到大排序，对于每一个小于等于target的数cur，都使用二分查找一个最大值K，使得cur+K&lt;&#x3D;target，由此可以得到[cur,K]中得到的子序列皆满足要求，不断遍历将结果相加即可。</p><p>为避免区间较大时计算幂会溢出，使用一个数组来存储从1到n的2次幂结果，且每个结果皆会除以1e9+7。这样预处理当数据较大时也能节约时间。</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numSubseq(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;unsigned int&gt; powNum(nums.size(),1);        for(int i&#x3D;1;i&lt;powNum.size();++i)&#123;            powNum[i]&#x3D;powNum[i-1]*2%(int(1e9)+7);        &#125;        sort(nums.begin(),nums.end());        unsigned long long  count&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(nums[i]&gt;target) break;            int idx&#x3D;upper_bound(nums.begin(),nums.end(),target-nums[i])-nums.begin();            if(idx&gt;&#x3D;nums.size()||nums[idx]&gt;target-nums[i]) --idx;            if(idx&gt;&#x3D;i)count+&#x3D;powNum[idx-i];        &#125;        return count%(int(1e9)+7);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++知识点总结</title>
      <link href="/2023/02/20/c++/c++%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/20/c++/c++%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>C++八股总结。参考<a href="https://zhuanlan.zhihu.com/p/92901691?utm_id=0">1</a>、<a href="https://github.com/imarvinle/interview-1#newdelete">2</a></p><hr><hr><h1 id="C-与C的不同点："><a href="#C-与C的不同点：" class="headerlink" title="C++与C的不同点："></a>C++与C的不同点：</h1><p>C++基本兼容C的语法，但相比C多了：</p><ul><li>支持面向对象的编程思想</li><li>支持运算符重载</li><li>支持泛型编程、模板</li><li>支持异常处理</li><li>类型检查严格</li></ul><h1 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h1><p>使用名字空间是为了避免独立开发时造成的命名冲突。</p><p>名字空间内部可以再定义名字空间，内层的名字空间与外层的名字空间的成员，可以重名，内层会屏蔽外层的同名标识符。</p><p>可以给名字空间取别名</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">空间名<span class="token double-colon punctuation">::</span>标识符 <span class="token comment">// 有名名字空间中的成员</span><span class="token double-colon punctuation">::</span>标识符 <span class="token comment">//无名名字空间中的成员，且通过此访问被屏蔽的全局变量</span><span class="token keyword">namespace</span> n123 <span class="token operator">=</span> n1<span class="token double-colon punctuation">::</span>n2<span class="token double-colon punctuation">::</span>n3<span class="token punctuation">;</span> <span class="token comment">//名字空间取别名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h1><p>使用struct和class定义一个类的区别是：</p><ul><li>默认的继承访问权限。struct 是 public 的，class 是 private 的。</li><li>struct成员默认为public；class成员默认为private。</li></ul><p>class可以用于template定义类型，而struct不行</p><p>在C++中，class就是利用struct实现的。</p><blockquote><p>在C++中定义一个类后，如果定义同名函数，则此同名函数会隐藏同名类，而C中则不会，因为其定义一个变量是<code>struct T a</code></p></blockquote><h1 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h1><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员(像访问普通变量一样)</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><h1 id="void"><a href="#void" class="headerlink" title="void*"></a>void*</h1><p>C语言中void* 可以与任意类型指针 自动转换。<br>C++中void* 不能给其他类型的指针直接赋值，必须强制类型转换，但其他类型的指针可以自动给void*赋值(为了类型检查，更加安全）。</p><h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><p>assert断言，是宏，而非函数。其作用是如果它的条件返回错误，则终止程序执行。</p><p>断言assert 是仅在Debug 版本起作用的宏，它用于检查”不应该”发生的情况。</p><h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h1><ul><li>sizeof 对数组，得到整个数组所占空间大小。</li><li>sizeof 对指针，得到指针本身所占空间大小。</li></ul><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">volatile</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可能会被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化（如多次连续赋值不能优化为一次赋值）。</li><li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是 volatile</li></ul><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>const有两重语义：变量只读(如修饰形参），修饰常量（定义变量），因此会导致优化不彻底，C++11提出了constexpr。</p><p>const可分为顶层const（变量本身是个常量）和底层const（指针所指对象是个常量）：</p><ul><li>当执行对象的拷贝操作时：<ul><li>拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换（一般来说，非常量可以转化为常量，反之不行）。</li><li>如果拷出对象是一个变量且是顶层const，那么拷入对象（引用或指针）必须有底层const</li></ul></li><li>重载时：<ul><li>顶层 const 不影响传入函数的对象，一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参区分开</li><li>底层const会影响重载，如果形参是某种类型的指针或引用，则通过区分其是否指向的是常量对象还是非常量对象可以实现函数重载。</li></ul></li></ul><p>const作用：</p><ul><li>修饰变量，说明该变量不可以被改变（顶层const）；</li><li>修饰指针，分为指向常量的指针（底层const）和指针常量（顶层const）；</li><li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改（底层const，注意引用本身已经是一个顶层const，其底层实现是一个指针常量）；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ul><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li><p>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</p></li><li><p>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。</p></li><li><p>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</p><ul><li>经过static修饰的类成员会变成静态成员，其单独存储在data内存段中，所有的类对象共享</li><li>静态成员在类内声明，但必须在类外定义、初始化。初始化时需要加“类名::”限定符表示它属于哪个类，但无需增加 static</li></ul></li><li><p>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，这种成员没有this指针,因此在 static 函数内不能访问非静态成员。但可以直接访问静态成员变量、静态成员函数</p><blockquote><p>静态成员变量、函数依然受访问控制限定符的影响</p></blockquote></li></ul><h1 id="using"><a href="#using" class="headerlink" title="using"></a>using</h1><p><strong>using作用</strong>：</p><ul><li><p>引入命名空间成员</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> namespace_name<span class="token double-colon punctuation">::</span>name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使得某个特定命名空间中所有名字都可见</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> namespace_name name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>派生类中使用using，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span></span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>using和typedef区别</strong></p><ul><li><p>声明函数指针时using更易理解</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//typedef</span><span class="token keyword">using</span> FP <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//别名声明</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>using相比typedef最大一个特点是可以被模板化，而typedef定义模板别名只能嵌套进模板化的struct（其如果用来定义对象时又使用了模板形参，则定义对象时需要加typename）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                            <span class="token comment">//MyAllocList&lt;T>是</span><span class="token keyword">using</span> MyAllocList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">;</span>   <span class="token comment">//std::list&lt;T, MyAlloc&lt;T>>的同义词</span>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span> lw<span class="token punctuation">;</span>                         <span class="token comment">//用户代码</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                            <span class="token comment">//MyAllocList&lt;T>是</span><span class="token keyword">struct</span> <span class="token class-name">MyAllocList</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">//std::list&lt;T, MyAlloc&lt;T>></span>    <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span> type<span class="token punctuation">;</span>      <span class="token comment">//的同义词  </span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token double-colon punctuation">::</span>type lw<span class="token punctuation">;</span>                   <span class="token comment">//用户代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="C-实现-C-类"><a href="#C-实现-C-类" class="headerlink" title="C 实现 C++ 类"></a>C 实现 C++ 类</h1><p>需要实现三大特性：封装、继承、多态，<a href="https://zhuanlan.zhihu.com/p/352015650">参考</a></p><p><strong>实现封装</strong>：</p><ul><li>封装就是类将属性和属性操作封装在一个不可分割的独立实体，只提供对外访问属性的操作方法。用户无需知道对象的内部实现细节，但能通过对外提供的接口访问内部属性数据。</li><li>用C的函数指针模仿C++实现简单的封装。C++中调用成员变量都是通过this指针，因此定义函数时需要多加一个当前类变量指针来模拟this指针，然后调用变量时使用此指针来访问成员变量。</li><li>模拟构造和析构：C的结果体变量创建和销毁时不会自动调用函数，因此需要手动定义用于构造和析构的连个函数，然后在结构体变量定义后调用函数进行初始化和销毁</li></ul><p><strong>实现继承</strong>：</p><ul><li>直接在子类首部定义一个父类变量，并在构造和析构时调用父类的构造析构函数（只能实现共有继承）。</li></ul><p><strong>实现多态</strong>：</p><ul><li>C++实现多态是使用一个虚函数表和一直指向其的指针</li><li>由于实现封装时使用的函数指针实现，因此定义子类时将父类的函数指针指向新函数即可。</li></ul><h1 id="内存对齐和pragma-pack-n"><a href="#内存对齐和pragma-pack-n" class="headerlink" title="内存对齐和pragma pack(n)"></a>内存对齐和pragma pack(n)</h1><p>现在计算机内存空间都是按照byte字节划分的，理论上讲对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址上访问，这就需要各种数据类型按照一定的规则在空间上排列，而不是一个接一个的排放，这就是<strong>内存对齐</strong>。</p><ul><li>cpu对内存的读取不是连续的而是分块读取的，块的大小只能是2^i^个字节数，从cpu的读取性能和效率来考虑，若读取的数据未对齐，则需要两次总线周期来访问内存，因而效率会大打折扣</li></ul><p><strong>内存对齐规则</strong></p><ul><li>结构体第一个变量的地址（起始地址）能够被其最宽的成员大小整除</li><li>结构体每个成员相对于起始地址的偏移能够被其自身大小和对齐系数的较小值整除，如果不能则在前一个成员后面补充字节</li><li>结构体总体大小能够被最宽的成员的大小和对齐系数中的较小值整除，如不能则在后面补充字节</li></ul><p>在32位系统中，默认对齐系数是4，而64位默认对齐系数是8。</p><p>可通过**pragma pack(n)**来修改对齐系数</p><blockquote><p>变量顺序也会影响对齐大小</p></blockquote><h1 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h1><p><strong>位域</strong>：在结构体定义时，可以指定某个（非静态）成员变量所占用的二进制位数（Bit）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">bs</span><span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> n<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>:</code>后面的数字用来限定成员变量占用的位数。</li></ul><p>语言标准规定：</p><ul><li>位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度，<code>:</code>后面的数字不能超过这个长度。</li><li>只有有限的几种数据类型可以用于位域，即整型（<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>long long</code>）和枚举型</li></ul><p>注意：</p><ul><li>位域在内存中的布局是与机器有关的</li><li>带符号类型中的位域的行为将因具体实现而定</li><li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域（因为地址最小单位是字节）</li></ul><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>重载规则：</p><ul><li>函数名必须相同</li><li>参数列表不同(个数不同、类型不同、参数排列顺序不同等)</li><li>函数的返回类型可以相同也可以不相同</li><li>若两个函数只有返回类型不同，而参数列表完全相同，则不能称为重载函数</li></ul><p>重载实现的机制：</p><ul><li>C++代码在编译时会把函数的参数类型添加到参数名中，借助这个方式来实现函数重载。因此，C++代码不能调用C函数（C语言编译器编译出的函数）</li></ul><p><code>extern &quot;C&quot;</code>:</p><ul><li>告诉C++编译器按照C语言的方式声明函数，这样就可以实现C和C++混合编程</li></ul><p>重载解析：</p><ul><li>实参的类型和形参的匹配情况有三种：<ol><li>编译器找到与实参最佳的匹配函数，编译器将生成调用代码。</li><li>编译找不到匹配函数，编译器将给出错误信息。</li><li>编译器找到多个匹配函数，但没有一个最佳的，这种错误叫二义性（如果编译器没有找到一个最佳调用版本，则会进行类型提升，就可能产生二义性错误）。</li></ol></li><li>选择匹配函数规则：<ul><li>优先每个参数都完全匹配的方案，其次参数完全匹配的个数，再其次是浪费内存的字节数</li></ul></li></ul><p>注意：</p><ul><li>函数的重载关系发生在同一作用域下，不同作用域下的同名函数，构成隐藏关系</li><li>C++函数的形参如果是指针类型，编译时函数名中会追加Px</li></ul><h1 id="默认形参"><a href="#默认形参" class="headerlink" title="默认形参"></a>默认形参</h1><ul><li>C++中函数的形参可以设置默认值，调用函数时如果没有提供实参数，则使用默认形参。</li><li>若某个参数设置了默认值，则其后面所有参数必须设置默认值</li><li>函数的默认形参是在编译阶段确定的，因此只能使用常量、常量表达式、全局变量数据作为默认值。</li><li>默认形参可能会对函数重载造成二义性问题，需慎重</li><li>如果函数的声明和定义需要分开，那么只需要在声明中定义，实现中不定义否则编译器可能报错</li></ul><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>内联函数就把函数编译好的二进制指令直接复制到函数的调用位置，相当于不用执行进入函数的步骤，直接执行函数体。</p><p><strong>编译器对 inline 函数的处理步骤</strong>：</p><ol><li>将 inline 函数体复制到 inline 函数调用点处；</li><li>为所用 inline 函数中的局部变量分配内存空间；</li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><p><strong>优缺点</strong>：</p><ul><li><p>优点：</p><ul><li>无需函数跳转，因此可以提高运行速度</li></ul></li><li><p>缺点：</p><ul><li>可执行文件增大，本质是牺牲空间来换取时间</li></ul></li></ul><p><strong>宏函数和内联函数区别</strong>：</p><ul><li>宏函数在预处理阶段进行代码替换，而内联函数是在编译阶段插入代码</li><li>宏定义没有类型检查，而内联函数有类型检查</li><li>宏函数不是真正的函数，只是代码替换，不会有参数压栈、出栈以及返回值，也不会检查参数类型，因此所有类型都能使用，但会有安全隐患。</li><li>内联函数是真正的函数，被调用时会进行传参，省去了参数压栈、栈帧开辟与回收，可以有返回值，并会严格检查参数类型</li></ul><p><strong>内联适用的条件</strong>：</p><ul><li>由于内联会造成可执行文件变大，并增加内存开销，因此只有频繁调用的简单函数适合作为内联。</li><li>带有递归特性和动态绑定特性的函数，无法实施内联，因此编译器会忽略声明部分的inline关键字。</li></ul><p><strong>注意</strong></p><ul><li>“inline”只是对编译器的建议：被”inline”修饰的函数不一定被内联</li><li>不能包含循环、递归、switch 等复杂操作</li><li>虚函数（virtual）可以是内联函数（inline）吗？<ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul></li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用就是取别名，声明一个标识符为引用，就表示该标识符是另一个对象的外号。</p><p>在C++中引用底层是使用一个指针常量来实现的</p><p>引用特性：</p><ul><li>引用必须初始化，不存在空引用，但有悬空引用（变量死了，名还留着）</li><li>可以引用无名对象（临时对象），但必须定义为常引用</li><li>引用不能更换目标</li><li>引用目标如果具有const属性，引用也需要具有const属性</li></ul><p>指针和引用的相同点和不同点：</p><ul><li>相同点：跨函数共享变量，优化传参效率，避免传参的时候调用拷贝构造</li><li>不同点：<ul><li>引用时一种取别名的机制，而C语言中的指针是一种数据类型（代表内存编号的无符号整数），但由于引用底层是指针实现，因此占用内存大小相同</li><li>指针可以为空，引用不可以为空</li><li>指针可以不初始化，引用必须初始化</li><li>指针可以改变指向，引用不能引用其他对象（可以定义指针的指针，不能定义引用的引用。可以定义指针的引用，不能定义引用的指针。可以定义指针的数组，但不能定义引用的数组。可以定义数组的引用）</li></ul></li></ul><h1 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h1><ul><li><p>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</p></li><li><p>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</p></li><li><p>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</p></li></ul><h1 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a>enum 枚举类型</h1><p>enum可分为限域和非限域：</p><ul><li><p>未限域<code>enum</code>，枚举名的名字属于包含这个<code>enum</code>的作用域，这意味着作用域内不能含有相同名字的其他东西</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Color</span> <span class="token punctuation">&#123;</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">//black, white, red在Color所在的作用域</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>限域<code>enum</code>，枚举名的名字属于<code>enum</code>作用域</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color</span> <span class="token punctuation">&#123;</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//black, white, red//限制在Color域内</span><span class="token comment">//默认情况下，限域枚举的底层类型是int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>限域<code>enum</code>优点：</p><ul><li><p>减少命名空间污染</p></li><li><p>在作用域中，枚举名是强类型。未限域<code>enum</code>中的枚举名会隐式转换为整型</p></li><li><p>可以被前置声明，而非限域不行（除非指定底层类型，但编译器实现时需要知道所有枚举值从而选择一个最小的底层类型）</p></li></ul><h1 id="C-的内存管理"><a href="#C-的内存管理" class="headerlink" title="C++的内存管理"></a>C++的内存管理</h1><p><strong>new、delete</strong></p><ul><li><p>new &#x2F; new[]：完成两件事，先底层调用 malloc 分了配内存，然后调用构造函数（创建对象）。</p></li><li><p>delete&#x2F;delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</p></li><li><p>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</p></li></ul><p><strong>new&#x2F;delete和malloc&#x2F;free的相同点和不同点</strong>：</p><ul><li><p>相同点：都能管理堆内存，都不能重复释放内存</p></li><li><p>不同点：</p><table><thead><tr><th align="center"></th><th align="center">new&#x2F;delete</th><th align="center"><strong>malloc&#x2F;free</strong></th></tr></thead><tbody><tr><td align="center"><strong>身份</strong></td><td align="center">运算符</td><td align="center">标准库函数</td></tr><tr><td align="center"><strong>计算类型大小</strong></td><td align="center">自动计算</td><td align="center">需手动计算申请字节数</td></tr><tr><td align="center"><strong>返回值</strong></td><td align="center">带类型的地址</td><td align="center">void*地址</td></tr><tr><td align="center"><strong>构造析构函数</strong></td><td align="center">自动调用</td><td align="center">不会自动调用</td></tr><tr><td align="center"><strong>出错处理</strong></td><td align="center">抛出异常</td><td align="center">返回nULL</td></tr></tbody></table></li></ul><p>注意：</p><ul><li>new&#x2F;delete与malloc&#x2F;free不能混用，因为new和delete会自动调用类、结构的构造函数、析构函数。</li><li>delete&#x2F;delete[]不能重复释放同一块内存</li><li>delete&#x2F;delete[]释放野指针的后果不确定，但释放空指针是安全的</li></ul><blockquote><ul><li><p>malloc、calloc、realloc、alloca区别</p></li><li><p>定位 new(placement new)：在用户指定的内存位置上（这个内存是已经预先分配好的）构建新的对象，因此这个构建过程不需要额外分配内存，只需要调用对象的构造函数在该内存位置上构造对象即可</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Object <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token function">ClassConstruct</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//address：placement new所指定的内存地址</span><span class="token comment">//ClassConstruct：对象的构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>delete this 合法吗？合法，但：</p><ul><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证 <code>delete this</code> 后没有人使用了</li></ul></li></ul></blockquote><h1 id="类的访问控制"><a href="#类的访问控制" class="headerlink" title="类的访问控制"></a>类的访问控制</h1><ul><li>private：声明为 private 的类成员只能由类的成员函数和友元（类或函数）使用。</li><li>protected：声明为 protected 的类成员可由类的成员函数和友元（类或函数）使用。 此外，它们还可由派生自该类的类使用。</li><li>public：声明为 public 的类成员可由任意函数使用。</li></ul><p>类继承时，遵循private&gt;protected&gt;public将父类成员权限转换。</p><h1 id="类的创建过程"><a href="#类的创建过程" class="headerlink" title="类的创建过程"></a>类的创建过程</h1><ol><li>分配类型所需要空间，无论栈还是堆。</li><li>先调用虚基类的构造函数</li><li>根据继承表依次调用父类的构造函数</li><li>设置虚指针指定的虚表</li><li>根据定义成员变量的顺序依次调用成员变量的构造函数。</li><li>执行构造函数体中的代码。</li></ol><h1 id="构造函数与初始化列表"><a href="#构造函数与初始化列表" class="headerlink" title="构造函数与初始化列表"></a>构造函数与初始化列表</h1><p><strong>构造函数</strong></p><ul><li>构造函数可以被重载</li><li>缺省构造是编译器自动生成的一个什么都不做的构造函数（其实不是真正语法意义上的函数，而是功能意义上的函数，编译器作为可执行指令的生成者，它会直接生成具有某项功能的二进制指令，不需要借助高级语言语义上的函数完成此任务）</li><li>无参构造未必无参，当给有参构造的所有参数设置默认形参，调用这种构造函数就不需要传参。</li><li>如果一个类是其他类的成员变量，那么一定要保证它有一个无参构造</li><li>如果构造函数的参数只有一个，那么Test t &#x3D; n语句就不会出错，它会自动调用单参构造来达到类型转换的效果。如果想禁止这种类型转换需要在单参构造前加 explicit。</li><li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li></ul><p><strong>初始化列表</strong></p><ul><li><p>更高效：少了一次调用默认构造函数的过程。</p></li><li><p>有些场合必须要用初始化列表：</p><ol><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。</li></ol></li><li><p>用花括号初始化器列表列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">S</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">v</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructed with a "</span> <span class="token operator">&lt;&lt;</span> l<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-element list\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><blockquote><p>explicit 修饰的构造函数可用来防止隐式转换</p></blockquote><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><ul><li>析构函数没有参数、没有返回值、不能重载</li><li>析构函数会在销毁对象时自动调用，在对象的整个生命周期内最多被调用一次</li><li>析构函数执行过程：<ol><li>先更改虚指针的指向（使得析构函数中不再有多态）</li><li>先执行析构函数本身代码</li><li>调用成员类的析构函数</li><li>调用父类的析构函数</li><li>调用虚基类的析构函数</li></ol></li><li>如果类中没有动态资源，也不需要做善后工作，缺省析构就完全共用了，不需要再实现新析构函数</li><li>类对象的创建过程与释放对比：<ul><li>创建：分配内存（对象）-&gt; 父类构造-&gt; 成员构造-&gt; 自己构造<ul><li>父类构造：按照继承表从左到右依次构造。</li><li>成员构造：按照声明顺序从上至下依次构造。</li></ul></li><li>释放：自己析构-&gt; 成员析构-&gt; 父类析构-&gt; 释放内存（对象）<ul><li>成员析构：按照声明顺序从下到上依次构造。</li><li>父类析构：按照继承表从右到左依次构造。</li></ul></li></ul></li></ul><p><strong>虚析构函数</strong>：虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p><h1 id="拷贝构造和赋值构造"><a href="#拷贝构造和赋值构造" class="headerlink" title="拷贝构造和赋值构造"></a>拷贝构造和赋值构造</h1><p>拷贝构造：</p><ul><li><p>拷贝构造的参数应该加 const 保护，但编译器并没有强行限制。</p><pre class="line-numbers language-none"><code class="language-none">类名(类&amp; )&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>赋值构造：</p><ul><li><p>当一类对象给另一个类对象赋值时，就会调用赋值构造</p></li><li><p>定义一个类时使用&#x3D;操作符是调用拷贝构造，并非赋值构造</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">类<span class="token operator">&amp;</span> opeator <span class="token operator">=</span> <span class="token punctuation">(</span>类<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>T a<span class="token operator">=</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>什么情况下需要实现拷贝构造和赋值构造？</p><ul><li>当类成员中有指针成员，需要深拷贝时</li></ul><p>注意：</p><ul><li>一旦为一个类实现了拷贝构造，那么也一定要实现赋值构造和析构函数。</li><li>缺省的拷贝构造、赋值构造函数不光会拷贝本类的数据，也会调用成员类对象和父类的拷贝构造和赋值构造</li></ul><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><p><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。</p><ul><li><p><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值</p><ul><li>在函数的参数列表与函数体之间有const修饰的函数，这个const其实就是在修饰this指针,<code>this</code> 指针的类型为：<code>const ClassName* const</code>，因此不能修改成员变量（mutable修饰的变量能被修改），但能修改传入的参数（<strong>普通函数不能声明为常函数</strong>）。</li></ul></li><li><p>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</p></li><li><p>成员函数是如何区别调用它的是哪个类对象的？</p><ul><li>借助了this指针，类的每个成员函数都有一个隐藏的参数this指针，它指向类对象。</li></ul></li><li><p>类的构造函数中也同样有this指针，指向的就是正在构造的这个对象。</p></li><li><p><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址</p></li></ul><h1 id="友元类和友元函数"><a href="#友元类和友元函数" class="headerlink" title="友元类和友元函数"></a>友元类和友元函数</h1><p><strong>友元函数</strong>：在定义一个类的时候，可以把一些函数（包括全局函数和其他类的成员函数）声明为“友元”，这样那些函数就成为该类的友元函数，在友元函数内部就可以访问该类对象的私有成员</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">friend</span>  返回值类型  函数名<span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">friend</span>  返回值类型  其他类的类名<span class="token double-colon punctuation">::</span>成员函数名<span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>不能把其他类的私有成员函数声明为友元</li></ul><p><strong>友元类</strong>：一个类 A 可以将另一个类 B 声明为自己的友元，类 B 的所有成员函数就都可以访问类 A 对象的私有成员</p> <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">friend  class  类名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：</p><ul><li><p>友元关系在类之间不能传递，即类 A 是类 B 的友元，类 B 是类 C 的友元，并不能导出类 A 是类 C 的友元</p></li><li><p>友元关系是单向性的</p></li><li><p>友元声明数量不受限制</p></li><li><p>友元类不可用在类中定义，友元函数可以在类中定义。两者皆可在三种权限范围内进行定义。</p></li></ul><h1 id="操作符函数重载"><a href="#操作符函数重载" class="headerlink" title="操作符函数重载"></a>操作符函数重载</h1><p>不能修改操作符的参数个数，不能发明新的操作符。不能重载的操作符有：</p><ul><li>域限定符 ::</li><li>直接成员访问操作符 .</li><li>三目操作符 ?:</li><li>字节长度操作符 sizeof</li><li>类型信息操作符 typeid</li></ul><p>重载操作符不能修改操作符的优先级，且无法重载所有基本类型的操作符运算</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>子类的指针或引用可以隐式转换成父类的指针或引用，这是一种缩小类型的转换；父类的指针或引用不可以转换成子类的指针或引用，这是一种扩大类型的转换。</li><li>子类会隐藏父类的同名成员，可以通过域限定符 父类::隐藏成员 进行访问父类中的隐藏成员（或使用父类的指针或引用来指向子类对象，然后访问父类中的隐藏成员）</li><li>子类以私有或保护方式继承父类，会禁止向上造型（子类的指针或引用不能隐式转换成父类的指针或引用，<strong>要想实现多态只能以公开方式继承父类</strong>）。</li><li>在C++中一个子类可以有多个父类，在继承表中按照顺序继承多个父类中的属性和行为，并按照顺序表，调用父类的构造函数（当子类指针转换成父类的隐式指针时候，编译器会自动计算父类中的内容在子类中的位置，地址会自动进行偏移计算）。</li></ul><p><strong>砖石继承</strong>：一个子类继承多个父类，这些父类有一个共同的祖先</p><ul><li>钻石继承不会导致继承错误，但访问祖先类中的成员时每次需要使用 类名::成员名 ，重点是这种继承会造成冗余</li></ul><p><strong>虚继承</strong>：当进行钻石继承时，祖先类中的内容会有冗余，而进行虚继承后，在子类中的内容只会保留一份</p><ul><li>一旦进行了虚继承祖先类的构造函数只执行一次，由孙子类直接调用，祖先类的有参构造也需要在孙子类中显示调用</li><li>在虚拟继承（钻石）中祖先类拷贝构造也由孙子类直接调用</li></ul><blockquote><p>虚继承和虚函数异同：</p><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移</li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul></blockquote><h1 id="覆盖和多态"><a href="#覆盖和多态" class="headerlink" title="覆盖和多态"></a>覆盖和多态</h1><p>重载（静态多态）、隐藏、覆盖（重写）的区别：</p><ul><li><p>重载：同一作用域下的同名函数，函数签名不同（类型、个数、顺序、常函数等），构成重载关系。</p></li><li><p>覆盖的条件：</p><ul><li><p>必须是虚函数</p></li><li><p>必须是父子类之间</p></li><li><p>函数签名必须相同（参数列表完全一致，const属性也会影响覆盖的结果）</p></li><li><p>返回值必须是同类型或父子类（子类的返回值要能向父类隐式转换）</p></li><li><p>访问属性不会影响覆盖</p></li><li><p>常函数属性也会影响覆盖</p></li></ul></li><li><p>隐藏：</p><ul><li>父子类之间的同名成员如果没有形成覆盖，且能通过编译，必定构成隐藏。</li><li><strong>两个函数，函数名相同参数不同，无论基类函数是不是虚函数，都会被隐藏。</strong></li></ul></li></ul><p><strong>动态多态</strong>：当子类覆盖了父类的虚函数时，通过父类指针指向子类对象时，调用虚函数，会根据具体的对象是谁来决定执行谁的函数</p><p>动态多态的条件</p><ul><li>父子类之间有的函数是覆盖关系。</li><li>父类的指针或引用指向子类的对象。</li></ul><p>注意：</p><ul><li>在父类的构造函数中调用虚函数，此时子类还没有创建完成，因此只能调用父类的虚函数，而不是覆盖版本的虚函数。</li><li>在父类的析构函数中调用虚函数，此时子类已经释放完成，因此只能调用父类的虚函数，而不是覆盖版本的虚函数。</li></ul><h1 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h1><p>纯虚函数：在虚函数的声明的后面添加&#x3D;0，无需实现。</p><ul><li>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</li></ul><p>抽象类：成员函数中有纯虚函数，这种类叫抽象类，抽象类不能实例化</p><ul><li>抽象类必须被继承且纯虚函数被覆盖后，由子类实例化对象</li><li>如果继承抽象类，但没有覆盖纯虚函数，那么子类也将成为抽象类，不能实例化</li></ul><p>纯抽象类：所有成员函数都是纯虚函数，这种只能被继承的类叫纯抽象类。</p><h1 id="虚函数表和虚析构"><a href="#虚函数表和虚析构" class="headerlink" title="虚函数表和虚析构"></a>虚函数表和虚析构</h1><p>虚函数表：</p><ul><li>在C++的类中，一旦成员函数中有虚函数，这个类中就会多一个虚函数表指针，这个指针指向一个虚函数表，表里面记录了这个类中所有的虚函数，</li><li>当这个类被继承，它的子类中也会有一个虚函数表（不管子类中有没有虚函数），如果子类的成员函数中有函数签名与父类的虚函数一样，就会用子类中的函数替换它在虚函数表中的位置，这样就达到了覆盖的效果。如果新增虚函数，也会被添加到该虚表中。</li><li>当通过类指针或引用调用函数时，会根据对象中实际的虚函数表记录来调用函数，这样就达到了多态的效果。</li><li>多态类中的虚函数表建立在编译阶段。</li></ul><p>虚析构：</p><ul><li><p>当使用delete释放一个父类指针时，不管实际指向的对象是子类还是父类都只会调用父类的析构函数（多态肯定会出现的问题）。如果子类的析构函数有需要负责释放的内存，就会造成内存泄漏</p><ul><li>注意，如果是多继承，使用第二个基类的指针指向派生类，且没有将析构定义为虚函数，delete该指针时会报错，因为this指针位置不对，是偏移后的地址。</li></ul></li><li><p>为了解决这个问题，可以把父类的析构函数设置为虚函数，<em>析构函数进行覆盖时不会比较函数名</em>。</p></li><li><p>当父类的析构函数为虚函数时，通过父类指针或引用释放子类对象时，会自动调用子类的析构函数，子类的析构函数执行完成后也会调用父类的析构函数。</p></li></ul><h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><p>C++中为了兼容C语言，<code>(目标类型)源类型</code> 依然可以继续使用，但C语言的强制类型转换安全性差，因此建议使用C++中的强制类型转换。</p><p>数据类型转换的本质：数据类型转换，就是对数据所占用的二进制位做出重新解释。</p><p>C++提供四种强制类型转换，且没有很大安全隐患：</p><ul><li><p>static_cast&lt;目标类型&gt;(data)   </p><ul><li>静态转换的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。</li><li>用于具体类型之间的转换，也可以用于具体类型指针和void指针之间的转换</li><li>但不能在两个具体类型的指针之间进行转换,不能将整数转换为指针类型</li></ul></li><li><p>dynamic_cast&lt;目标类型&gt;(data)  </p><ul><li>用于将多态基类的<strong>指针或引用</strong>强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。</li><li>既允许向上转型（派生类到基类），也允许向下转型（基类到派生类）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。</li><li>dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数；static_cast 在编译期间完成类型转换，能够更加及时地发现错误。</li><li>dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用</li><li>reinterpret_cast也能用于转换为派生类的指针，但不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。</li></ul></li><li><p>const_cast&lt;目标类型&gt;(data)    </p><ul><li><p>功能：为值类型加上const（只是经常不用，因为存在默认转换）或为指针或引用去除 const 属性和volatile 属性（根据声明决定去除属性），它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//去掉const：</span>type <span class="token operator">*</span> variable <span class="token operator">=</span><span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span> <span class="token keyword">typename</span><span class="token operator">*</span> <span class="token operator">></span></span></span> <span class="token punctuation">(</span>expression）<span class="token comment">//加上const：</span><span class="token keyword">const</span> type <span class="token operator">*</span> variable <span class="token operator">=</span><span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span> <span class="token keyword">typename</span> <span class="token operator">></span></span></span> <span class="token punctuation">(</span>expression<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果去掉 const的操作不唯一的话，例如常量指针或指针常量，目标指针的声明就是 确定采用哪一种方式</p></li><li><p>注意，<strong>变量本身的const属性是不能去除的</strong>，要想修改变量的值，一般是去除指针（或引用）的const属性，再进行间接修改（这里使用了编译时的常量折叠）。</p><ul><li>注意，这种行为在C++中属于未定义行为。</li><li>例如下面代码，使用ps指针进行修改，变量会被修改，但打印s和ps会发现s仍然是原来字符串，而ps则发生了改变，但两个地址确实一样的。这是因为编译器会对常量进行优化，编译时就修改了打印的值。</li><li>相应的，因为编译器进行了替换，例如函数调用也看不见被修改后的值</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> string s <span class="token operator">=</span> <span class="token string">"Inception"</span><span class="token punctuation">;</span>string<span class="token operator">&amp;</span> p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span> <span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">&amp;</span><span class="token operator">></span></span></span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>string<span class="token operator">*</span> ps <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span> <span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">*</span><span class="token operator">></span></span></span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// &amp;s 的类型是 const string*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>reinterpret_cast&lt;目标类型&gt;(data)  </p><ul><li>用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个比特复制的操作。</li><li>高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换</li></ul></li></ul><h1 id="如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="如何定义一个只能在堆上（栈上）生成对象的类？"></a>如何定义一个只能在堆上（栈上）生成对象的类？</h1><p><a href="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618">参考</a></p><p><strong>只能在堆上</strong>:</p><ul><li>方法：将析构函数设置为私有</li><li>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</li><li>为啥不将构造函数设为私有？因为会导致栈上也无法建立对象</li></ul><p><strong>只能在栈上</strong>:</p><ul><li>方法：将 new 和 delete 重载为私有</li><li>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</li></ul><h1 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h1><p>I&#x2F;O流的打开模式：</p><ul><li>ios::in     以读权限打开文件，不存在则失败，存在不清空</li><li>ios::out    以写权限打开文件，不存在则创建，存在则清空</li><li>ios::app    打开文件用于追加，不存在则创建，存在不清空</li><li>ios::binary 以二进制模式进行读写 </li><li>ios::ate    打开时定位到文件末尾</li><li>ios::trunc  打开文件时清空</li></ul><p>fstream&#x2F;ifstream&#x2F;ofstream 类用于进行文件操作，其函数：</p><ul><li>构造函数或成员函数 open 用于打开文件</li><li>good成员函数检查流是否可用</li><li>eof成员函数用于输入流是否结束</li></ul><p>二进制读写：read&#x2F;write：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">read</span> <span class="token punctuation">(</span>char_type <span class="token operator">*</span>__s<span class="token punctuation">,</span>streamsize __n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span> <span class="token punctuation">(</span>char_type <span class="token operator">*</span>__s<span class="token punctuation">,</span>streamsize __n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="运行时类型信息-RTTI"><a href="#运行时类型信息-RTTI" class="headerlink" title="运行时类型信息 (RTTI)"></a>运行时类型信息 (RTTI)</h1><p><strong>dynamic_cast</strong>：用于多态类型的转换</p><p><strong>类型信息typeid</strong>：用于获取数据的类型信息，返回一个 type_info 对象的引用</p><ul><li>其name成员函数，可以获取类型的名字，内建类型名字使用缩写</li><li>同时还支持 &#x3D;&#x3D; !&#x3D; 用来比较是否是同一种类型</li><li>如果用于判断父子类的指针或引用，它不能准确判断出实际的对象类型。但可以判断出具有多态继承关系的父子类的指针或引用的实际对象</li><li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li></ul><p><strong>type_info</strong>：类描述编译器在程序中生成的类型信息。 </p><ul><li>此类的对象可以有效存储指向类型的名称的指针。 </li><li>type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。</li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>  可以抛出异常的代码  <span class="token keyword">throw</span> 数据<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>类型 变量名<span class="token punctuation">)</span>  <span class="token comment">// 根据数据类型进行捕获</span><span class="token punctuation">&#123;</span>  处理异常，如果无法处理可以继续抛出异常<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意:</p><ul><li>不能抛出局部对象的指针或引用（构造函数和析构函数不能抛出异常）</li><li>如果异常没有被捕获处理，程序就会停止。</li><li>捕获异常的顺序是自上而下的，而不是最精准的匹配，针对子类异常捕获时要放在父类的前面。</li><li>函数的异常声明： 返回值类型 函数名(参数列表)throw(类型1,类型2,…)<ul><li>如果不写异常声明表示什么类型的异常都可能抛出。</li><li>如果写了异常声明表示只抛出某些类型的异常，一旦超出异常声明的范围，程序会直接停止，无法捕获。</li><li>throw() 表示什么类型都不会抛出</li></ul></li></ul><h1 id="迭代器失效情况"><a href="#迭代器失效情况" class="headerlink" title="迭代器失效情况"></a>迭代器失效情况</h1><p>参考<a href="https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers">1</a>、<a href="https://www.cnblogs.com/zhchoutai/p/8449786.html">2</a></p><p><strong>失效情况：</strong></p><ul><li><code>erase()</code><ul><li>当序列容器调用<code>erase()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效。<ul><li>C++03: deque在头尾删除，只会使得被删除迭代器和引用无效。而在其他位置删除会使得所有迭代器和引用都失效。c++11中有一点改变，见参考2.（应该是可能失效）</li></ul></li><li>当关联容器调用<code>erase()</code>方法后，只会使当前迭代器失效，不会造成其他迭代器失效</li></ul></li><li><code>insert()</code><ul><li>当序列容器调用<code>insert()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效。<ul><li>C++11: deque在头尾插入，会使得所有迭代器无效但引用不受影响。而在其他位置插入会使得所有迭代器和引用都失效。</li></ul></li><li>当关联容器调用<code>insert()</code>方法后，，不会造成其他迭代器失效</li></ul></li><li>如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/qgST0.png"></p><h1 id="函数调用过程？被调用函数参数怎么压栈的"><a href="#函数调用过程？被调用函数参数怎么压栈的" class="headerlink" title="函数调用过程？被调用函数参数怎么压栈的"></a>函数调用过程？被调用函数参数怎么压栈的</h1><h1 id="编译过程，linux二进制格式"><a href="#编译过程，linux二进制格式" class="headerlink" title="编译过程，linux二进制格式"></a>编译过程，linux二进制格式</h1>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mprpc</title>
      <link href="/2023/02/15/%E9%A1%B9%E7%9B%AE/mprpc/"/>
      <url>/2023/02/15/%E9%A1%B9%E7%9B%AE/mprpc/</url>
      
        <content type="html"><![CDATA[<p><em>根据<strong>C++实现网络通信框架</strong>项目所写</em>, <a href="">视频地址</a></p><hr><hr><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><h2 id="1-1-技术栈"><a href="#1-1-技术栈" class="headerlink" title="1.1 技术栈"></a>1.1 技术栈</h2><ul><li>RPC远程过程调用原理以及实现</li><li>Protobuf数据序列化和反序列化协议</li><li>ZooKeeper分布式一致性协调服务应用以及编程</li><li>muduo网络库编程</li><li>conf配置文件读取</li><li>异步日志</li><li>CMake构建项目集成编译环境</li><li>github管理项目</li></ul><h2 id="1-2-单机服务器、集群和分布式"><a href="#1-2-单机服务器、集群和分布式" class="headerlink" title="1.2 单机服务器、集群和分布式"></a>1.2 单机服务器、集群和分布式</h2><p><strong>单机服务器</strong></p><p>缺点：</p><ul><li>受限于硬件资源，聊天服务器所能承受的用户并发量有限</li><li>任意模块的修改，都会整个项目代码重新编译部署</li><li>系统中，有的任务是CPU密集型，有的则是IO密集型，造成各模块对硬件资源的需求不一样</li></ul><p><strong>集群</strong></p><p>每一台服务器独立运行一个工程的所有模块。</p><ul><li>优点：并发量提升</li><li>缺点：代码还需重新编译且需要多次部署，有的模块如后台管理不需要高并发不需要多次部署</li></ul><p><strong>分布式</strong></p><p>一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工</p><p>作共同提供服务，每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节</p><p>点模块集群部署。</p><h2 id="1-3-RPC通信原理"><a href="#1-3-RPC通信原理" class="headerlink" title="1.3 RPC通信原理"></a>1.3 RPC通信原理</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221113162552596.png"></p><ul><li><p>黄色部分：设计rpc方法参数的打包和解析，也就是数据的序列化和反序列化，使用Protobuf。</p></li><li><p>绿色部分：网络部分，包括寻找rpc服务主机，发起rpc调用请求和响应rpc调用结果，使用muduo网络库和zookeeper服务配置中心（专门做服务发现）。</p></li></ul><p>mprpc框架主要包含以上两个部分的内容</p><h2 id="1-4-Protobuf"><a href="#1-4-Protobuf" class="headerlink" title="1.4 Protobuf"></a>1.4 Protobuf</h2><p><code>protobuf</code> (protocol buffer) 是谷歌内部的混合语言数据标准。通过将结构化的数据进行序列化(串行化)，用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p><h3 id="1-4-1-message"><a href="#1-4-1-message" class="headerlink" title="1.4.1 message"></a>1.4.1 message</h3><blockquote><p><code>protobuf</code>中定义一个消息类型是通过关键字<code>message</code>字段指定的，这个关键字类似于C++&#x2F;Java中的class关键字。使用protobuf编译器将<code>proto</code>编译成C++代码之后，每个<code>message</code>都会生成一个名字与之对应的C++类，该类公开继承自<code>google::protobuf::Message</code>。</p></blockquote><p>声明protobuf版本</p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span><span class="token operator">=</span><span class="token string">"proto3"</span><span class="token punctuation">;</span><span class="token comment">//protobuf版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>声明定义message或service所在包（c++中对应为namespace）</p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">package</span> fixbug<span class="token punctuation">;</span><span class="token comment">//声明代码所在包（namespace）</span><span class="token keyword">package</span> a<span class="token punctuation">.</span>fixbug<span class="token punctuation">;</span><span class="token comment">//二级</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>message实例</strong></p><p>message有三种成员类型：数据、列表、映射表</p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">message</span> <span class="token class-name">ResultCode</span><span class="token punctuation">&#123;</span>    <span class="token builtin">int32</span> errcode<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token builtin">bytes</span> errmsg<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//登录消息类型</span><span class="token keyword">message</span> <span class="token class-name">LoginRequest</span><span class="token punctuation">&#123;</span>    <span class="token builtin">bytes</span> name<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//1:消息类型字段</span>    <span class="token builtin">bytes</span> pwd<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">// map&lt;int32,string> test=3; //映射表</span><span class="token punctuation">&#125;</span><span class="token comment">//登录相应消息类型</span><span class="token keyword">message</span> <span class="token class-name">LoginResponse</span><span class="token punctuation">&#123;</span>    <span class="token positional-class-name class-name">ResultCode</span> result<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//1为标识号</span>    <span class="token builtin">bool</span> success<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//定义User类型</span><span class="token keyword">message</span> <span class="token class-name">User</span><span class="token punctuation">&#123;</span>    <span class="token builtin">bytes</span> name<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token builtin">uint32</span> age<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">enum</span> <span class="token class-name">Sex</span><span class="token punctuation">&#123;</span><span class="token comment">//枚举</span>        MAN<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        WOMAN<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token positional-class-name class-name">Sex</span> sex<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">message</span> <span class="token class-name">GetFriendListsResponse</span><span class="token punctuation">&#123;</span>    <span class="token positional-class-name class-name">ResultCode</span> result<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">repeated</span> <span class="token positional-class-name class-name">User</span> friend_list<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//列表类型</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>message字段规则</strong></p><ul><li><code>required</code>:消息体中必填字段，不设置会导致编解码异常。</li><li><code>optional</code>: 消息体中可选字段，可通过default关键字设置默认值。</li><li><code>repeated</code>: 消息体中可重复字段，重复的值的顺序会被保留。其中，proto3默认使用packed方式存储，这样编码方式比较节省内存。</li></ul><blockquote><p>在proto3版本中，字段规则上移除了required，并把optional字段改名为singular。所有没有指定字段规则的字段默认为optional，</p></blockquote><p><strong>标识号</strong></p><p>在消息体的定义中，每个字段都必须要有一个唯一的标识号，标识号是[0,2^29-1]范围内的一个整数</p><p><strong>数据定义</strong></p><p>许多标准的简单数据类型都可以用作<code>message</code>字段类型，包括<code>bool</code>,<code>int32</code>,<code>float</code>,<code>double</code>和<code>string</code>。还可以使用其他<code>message</code>类型作为字段类型在消息体中添加更多结构，如上面的ResultCode。</p><p><strong>函数方法</strong></p><p>用<code>message</code>关键字声明的的消息体，允许你检查、操作、读、或写整个消息，包括解析二进制字符串，以及序列化二进制字符串。除此之外，也定义了下列方法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LoginResponse<span class="token operator">:</span>缺省的构造函数。<span class="token operator">~</span><span class="token function">LoginResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>缺省的析构函数。<span class="token function">LoginResponse</span><span class="token punctuation">(</span><span class="token keyword">const</span> LoginResponse<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">:</span>拷贝构造函数。LoginResponse<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> LoginResponse<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">:</span>赋值 <span class="token punctuation">(</span>Assignment ）操作符。<span class="token keyword">const</span> UnknownFieldSet<span class="token operator">&amp;</span> <span class="token function">unknown_fields</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token operator">:</span>返回当解析信息时遇到的未知字段的集合。UnknownFieldSet<span class="token operator">*</span> <span class="token function">mutable_unknown_fields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>返回当前解析信息时遇到的未知字段的集合的一个mutale指针。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>message实例</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> LoginRequest req<span class="token punctuation">;</span> req<span class="token punctuation">.</span><span class="token function">set_name</span><span class="token punctuation">(</span><span class="token string">"wang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> req<span class="token punctuation">.</span><span class="token function">set_pwd</span><span class="token punctuation">(</span><span class="token string">"123434"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对象序列化</span> std<span class="token double-colon punctuation">::</span>string send_str<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">SerializeToString</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>send_str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> send_str <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// send_str反序列化</span> LoginRequest reqB<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>reqB<span class="token punctuation">.</span><span class="token function">ParseFromString</span><span class="token punctuation">(</span>send_str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> reqB<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> reqB<span class="token punctuation">.</span><span class="token function">pwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">//GetFriendListsResponse 定义列表成员示例</span> GetFriendListsResponse rsp<span class="token punctuation">;</span> ResultCode <span class="token operator">*</span>rc <span class="token operator">=</span> rsp<span class="token punctuation">.</span><span class="token function">mutable_result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> rc<span class="token operator">-></span><span class="token function">set_errcode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> User <span class="token operator">*</span>user1 <span class="token operator">=</span> rsp<span class="token punctuation">.</span><span class="token function">add_friend_list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> user1<span class="token operator">-></span><span class="token function">set_name</span><span class="token punctuation">(</span><span class="token string">"zhang san"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> user1<span class="token operator">-></span><span class="token function">set_age</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> user1<span class="token operator">-></span><span class="token function">set_sex</span><span class="token punctuation">(</span>User<span class="token double-colon punctuation">::</span>MAN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置枚举</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> rsp<span class="token punctuation">.</span><span class="token function">friend_list_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>protobuf编译</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ main.cc test.pb.cc <span class="token parameter variable">-o</span> t <span class="token parameter variable">-std</span><span class="token operator">=</span>c++11 <span class="token parameter variable">-L</span> /usr/local/lib <span class="token parameter variable">-lprotobuf</span> <span class="token parameter variable">-pthread</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-4-2-service"><a href="#1-4-2-service" class="headerlink" title="1.4.2 service"></a>1.4.2 service</h3><p>message定义了消息类型，service则定义了方法</p><p>protobuf默认不生成service类，需使用如下option开启：</p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">option</span> cc_generic_services<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>service实例</strong></p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">service</span> <span class="token class-name">UserServiceRpc</span><span class="token punctuation">&#123;</span>    <span class="token keyword">rpc</span> <span class="token function">Login</span><span class="token punctuation">(</span><span class="token class-name">LoginRequest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">LoginResponse</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">rpc</span> <span class="token function">GetFriendLists</span><span class="token punctuation">(</span><span class="token class-name">GetFriendListsQuest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">GetFriendListsResponse</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>定义的UserServiceRpc默认会生成两个类：UserServiceRpc和UserServiceRpc_Stub</p><p><strong>UserServiceRpc</strong></p><p>是被调用类，其继承自protobuf的service基类</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UserServiceRpc</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span><span class="token class-name">Service</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  <span class="token comment">// This class should be treated as an abstract interface.</span>  <span class="token keyword">inline</span> <span class="token function">UserServiceRpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">UserServiceRpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">typedef</span> UserServiceRpc_Stub Stub<span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>ServiceDescriptor<span class="token operator">*</span> <span class="token function">descriptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Login</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                       <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>LoginRequest<span class="token operator">*</span> request<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>LoginResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">GetFriendLists</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                       <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>GetFriendListsQuest<span class="token operator">*</span> request<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>GetFriendListsResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// implements Service ----------------------------------------------</span>  <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>ServiceDescriptor<span class="token operator">*</span> <span class="token function">GetDescriptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>UserServiceRpc_Stub</strong></p><p>UserServiceRpc_Stub是调用类，其继承自UserServiceRpc类，通过使用此类来调用方法，</p><p>注意，其没有默认的初始化构造函数，需通过RpcChannel指针来初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UserServiceRpc_Stub</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">UserServiceRpc</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">UserServiceRpc_Stub</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcChannel<span class="token operator">*</span> channel<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">UserServiceRpc_Stub</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcChannel<span class="token operator">*</span> channel<span class="token punctuation">,</span>                   <span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>Service<span class="token double-colon punctuation">::</span>ChannelOwnership ownership<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">~</span><span class="token function">UserServiceRpc_Stub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">Login</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                       <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>LoginRequest<span class="token operator">*</span> request<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>LoginResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">GetFriendLists</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                       <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>GetFriendListsQuest<span class="token operator">*</span> request<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>GetFriendListsResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcChannel<span class="token operator">*</span> channel_<span class="token punctuation">;</span>  <span class="token keyword">bool</span> owns_channel_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意看Login和GetFriendLists方法实现如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">UserServiceRpc_Stub</span><span class="token double-colon punctuation">::</span><span class="token function">Login</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                              <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>LoginRequest<span class="token operator">*</span> request<span class="token punctuation">,</span>                              <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>LoginResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                              <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  channel_<span class="token operator">-></span><span class="token function">CallMethod</span><span class="token punctuation">(</span><span class="token function">descriptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">method</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       controller<span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">UserServiceRpc_Stub</span><span class="token double-colon punctuation">::</span><span class="token function">GetFriendLists</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                              <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>GetFriendListsQuest<span class="token operator">*</span> request<span class="token punctuation">,</span>                              <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>GetFriendListsResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                              <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  channel_<span class="token operator">-></span><span class="token function">CallMethod</span><span class="token punctuation">(</span><span class="token function">descriptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">method</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       controller<span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个方法都是通过调用channel的CallMethod来调用，因此需要使用一个MyRpcChannel类继承RpcChannel类，实现其CallMethod方法来完成序列号、调用等操作。</p><h1 id="2-mprpc实现"><a href="#2-mprpc实现" class="headerlink" title="2. mprpc实现"></a>2. mprpc实现</h1><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221113162552596.png"></p><p>如上图，黄色部分的序列化和反序列化都是通过调用protobuf来完成，而mprpc框架主要使用muduo来接受请求调用然后调用相应函数，最后返回结果。</p><p>Caller的功能由RpcChannel类来实现，而Callee的功能由RpcProvidre类来实现。</p><h2 id="2-1-RpcProvidre类"><a href="#2-1-RpcProvidre类" class="headerlink" title="2.1 RpcProvidre类"></a>2.1 RpcProvidre类</h2><p>RpcProvider类需要实现接受请求，然后将其解析得到需要调用的方法和参数，然后调用相应方法和参数，最后将调用结果序列化发送给调用方。</p><p><strong>私有成员</strong></p><p>将OnMessage绑定到muduo库，当有消息到来时，所有反序列化、调用函数等操作都在OnMessage函数中进行</p><p>最后将调用结果发送到调用方是在SendRpcResponse方法中进行</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//组合eventloop</span>muduo<span class="token double-colon punctuation">::</span>EventLoop m_eventLoop<span class="token punctuation">;</span><span class="token comment">// service服务类型信息</span><span class="token keyword">struct</span> <span class="token class-name">ServiceInfo</span> <span class="token punctuation">&#123;</span>  google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Service <span class="token operator">*</span>m_service<span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">const</span> google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>MethodDescriptor <span class="token operator">*</span><span class="token operator">></span>      m_methodMap<span class="token punctuation">;</span>  <span class="token comment">//保存服务方法</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//存储服务对象和其服务方法的所有信息</span>std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> ServiceInfo<span class="token operator">></span> m_serviceMap<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">OnConnection</span><span class="token punctuation">(</span><span class="token keyword">const</span> muduo<span class="token double-colon punctuation">::</span>TcpConnectionPtr <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">OnMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> muduo<span class="token double-colon punctuation">::</span>TcpConnectionPtr <span class="token operator">&amp;</span><span class="token punctuation">,</span> muduo<span class="token double-colon punctuation">::</span>Buffer <span class="token operator">*</span><span class="token punctuation">,</span>               muduo<span class="token double-colon punctuation">::</span>Timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// closure回调操作，用于序列号rpc的响应和网络发送</span><span class="token keyword">void</span> <span class="token function">SendRpcResponse</span><span class="token punctuation">(</span><span class="token keyword">const</span> muduo<span class="token double-colon punctuation">::</span>TcpConnectionPtr <span class="token operator">&amp;</span><span class="token punctuation">,</span>                     google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Message <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>公有成员</strong></p><p>用户通过NotiFyService发布方法，然后调用Run函数即可</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//发布Rpc方法的函数 主要是通过遍历将service中的函数指针和函数名都保存起来，方便调用</span><span class="token keyword">void</span> <span class="token function">NotiFyService</span><span class="token punctuation">(</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Service <span class="token operator">*</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//启动rpc服务节点，开始提供rpc远程网络调用服务：绑定消息函数，启动server监听</span><span class="token keyword">void</span> <span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键函数</strong></p><p>OnMessage（当请求到来，如何进行处理）：</p><ul><li>通过请求头大小及请求参数大小等解析出请求service_name和method_name及请求参数，然后根据服务名和方法名在存储服务及对应方法的map中找到对应的类指针，然后就通过该指针调用相应方法。</li><li>注意看以下代码，调用方法是使用service的CallMethod方法进行（每个service都会实现一个CallMethod方法，传入对应方法就可以调用），而CallMethod最后一个参数是回调函数，当CallMethod执行完后会回调done-run()方法。在这里使用SendRpcResponse定义了一个closure类用于回调。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//获取service对象</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Service <span class="token operator">*</span>service <span class="token operator">=</span> it<span class="token operator">-></span>second<span class="token punctuation">.</span>m_service<span class="token punctuation">;</span><span class="token comment">//获取method方法</span><span class="token keyword">const</span> google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>MethodDescriptor <span class="token operator">*</span>method <span class="token operator">=</span> mit<span class="token operator">-></span>second<span class="token punctuation">;</span><span class="token comment">//生成rpc方法调用的请求request和响应response参数</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Message <span class="token operator">*</span>request <span class="token operator">=</span>    service<span class="token operator">-></span><span class="token function">GetRequestPrototype</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>request<span class="token operator">-></span><span class="token function">ParseFromString</span><span class="token punctuation">(</span>args_str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"request parse error! content:%s"</span><span class="token punctuation">,</span> args_str<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Message <span class="token operator">*</span>response <span class="token operator">=</span>    service<span class="token operator">-></span><span class="token function">GetResponsePrototype</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// method方法绑定一个closure的回调函数</span><span class="token comment">//相当于使用SendRpcResponse函数重写了closure类中的Run方法,在用户自己写得服务中最后会执行done->run(),最终会执行SendRpcResponse方法</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure <span class="token operator">*</span>done <span class="token operator">=</span>    google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">NewCallback</span><span class="token generic class-name"><span class="token operator">&lt;</span>RpcProvider<span class="token punctuation">,</span>                                  <span class="token keyword">const</span> muduo<span class="token double-colon punctuation">::</span>TcpConnectionPtr <span class="token operator">&amp;</span><span class="token punctuation">,</span>                                  google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Message <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>        <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>RpcProvider<span class="token double-colon punctuation">::</span>SendRpcResponse<span class="token punctuation">,</span> conn<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用rpc方法</span>service<span class="token operator">-></span><span class="token function">CallMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-MprpcChannel类"><a href="#2-2-MprpcChannel类" class="headerlink" title="2.2 MprpcChannel类"></a>2.2 MprpcChannel类</h2><p>在使用中，用户都是通过调用protobuf提供的<em>ServiceRpc_Stub</em>类来调用函数的，而<em>ServiceRpc_Stub</em>初始化需要一个<em>RpcChannel</em>，当调用<em>ServiceRpc_Stub</em>的函数时最后都会转到调用<em>RpcChannel</em>的CallMethod方法，因此需要将<em>MprpcChannel</em>类继承rpcchannel类，实现其虚有方法CallMethod即可。</p><p>例如，自定义的一个方法，使用stub调用时其底层是使用CallMethod进行调用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">FriendServiceRpc_Stub</span><span class="token double-colon punctuation">::</span><span class="token function">getFriendList</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                              <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>getFriendListRequest<span class="token operator">*</span> request<span class="token punctuation">,</span>                              <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>getFriendListResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                              <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  channel_<span class="token operator">-></span><span class="token function">CallMethod</span><span class="token punctuation">(</span><span class="token function">descriptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">method</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       controller<span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MprpcChannel类只有一个成员：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//所有通过stub代理对象调用的rpc方法，都到这里做rpc方法调用数据的序列化和网络发送</span><span class="token keyword">void</span> <span class="token function">CallMethod</span><span class="token punctuation">(</span><span class="token keyword">const</span> google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>MethodDescriptor<span class="token operator">*</span> method<span class="token punctuation">,</span>                google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                <span class="token keyword">const</span> google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Message<span class="token operator">*</span> request<span class="token punctuation">,</span>                google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Message<span class="token operator">*</span> response<span class="token punctuation">,</span>                google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在CallMethod方法中，主要是将要调用的方法名和参数进行序列化然后发送到远程，然后等待其返回结果，最后将返回结果反序列化即可。</p><h2 id="2-3-mprpccontroller类"><a href="#2-3-mprpccontroller类" class="headerlink" title="2.3 mprpccontroller类"></a>2.3 mprpccontroller类</h2><p>此类主要是用来控制rpc调用过程中出现的错误信息，如设置错误，获取错误信息。</p><h2 id="2-4-Mprpc框架使用"><a href="#2-4-Mprpc框架使用" class="headerlink" title="2.4 Mprpc框架使用"></a>2.4 Mprpc框架使用</h2><p>先使用protobuf定义好远程调用service、方法和参数，比如定义提供<em>FriendServiceRpc</em>，其中包括GetFriendList方法</p><p><strong>callee</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">FriendService</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> fixbug<span class="token double-colon punctuation">::</span><span class="token class-name">FriendServiceRpc</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> <span class="token function">GetFriendList</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> userid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">getFriendList</span><span class="token punctuation">(</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                     <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>getFriendListRequest<span class="token operator">*</span> request<span class="token punctuation">,</span>                     <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>getFriendListResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                     <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于提供服务者，定义<em>FriendService</em>类继承<em>FriendServiceRpc</em>类，实现其虚有方法getFriendList，为使逻辑清晰，注意在此getFriendList方法中只是将设计的远程调用参数转为本地调用需要的参数，然后调用业务逻辑，最后将返回的参数打包成远程接口参数，并没有在此函数中执行真正的业务逻辑。</p><p>最后，用户只需要将此业务注册发布即可</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"first log message test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"%s:%s:%d"</span><span class="token punctuation">,</span><span class="token constant">__FILE__</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">,</span><span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//框架初始化</span>  <span class="token class-name">MprpcApplication</span><span class="token double-colon punctuation">::</span><span class="token function">Init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>  RpcProvider provider<span class="token punctuation">;</span>  provider<span class="token punctuation">.</span><span class="token function">NotiFyService</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">FriendService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  provider<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>caller</strong></p><p>调用方都是通过protobu生成的service_stub去调用，只需要在定义service_stub变量时使用mprpcchannel初始化，然后定义请求参数和接受参数变量，再调用stub的方法即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//需要先调用框架的初始化函数</span>  <span class="token class-name">MprpcApplication</span><span class="token double-colon punctuation">::</span><span class="token function">Init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//调用远程发布的rpc方法Login</span>  fixbug<span class="token double-colon punctuation">::</span>FriendServiceRpc_Stub <span class="token function">stub</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">MprpcChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//相当于调用RpcChannel->RpcChannel::callMethod</span>  <span class="token comment">// stub.Login();</span>  fixbug<span class="token double-colon punctuation">::</span>getFriendListRequest request<span class="token punctuation">;</span>  request<span class="token punctuation">.</span><span class="token function">set_id</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  fixbug<span class="token double-colon punctuation">::</span>getFriendListResponse response<span class="token punctuation">;</span>  MprpcController controller<span class="token punctuation">;</span>  stub<span class="token punctuation">.</span><span class="token function">getFriendList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>controller<span class="token punctuation">,</span> <span class="token operator">&amp;</span>request<span class="token punctuation">,</span> <span class="token operator">&amp;</span>response<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>controller<span class="token punctuation">.</span><span class="token function">Failed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> controller<span class="token punctuation">.</span><span class="token function">ErrorText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">errcode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"rpc login response: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> name <span class="token operator">:</span> response<span class="token punctuation">.</span><span class="token function">friends</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> name<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"rpc login response error:%s"</span><span class="token punctuation">,</span>               response<span class="token punctuation">.</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">errmsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mit-6.824</title>
      <link href="/2023/02/15/%E9%A1%B9%E7%9B%AE/Mit-6.824/"/>
      <url>/2023/02/15/%E9%A1%B9%E7%9B%AE/Mit-6.824/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab1：MapReduce"><a href="#Lab1：MapReduce" class="headerlink" title="Lab1：MapReduce"></a>Lab1：MapReduce</h1><p>MapReduce框架：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620115253482.png"></p><h2 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a><strong>任务描述</strong></h2><p>实现分布式MapReduce，一个coordinator，一个worker（启动多个），在这次实验都在一个机器上运行。worker通过rpc和coordinator交互。worker请求任务,进行运算,写出结果到文件。coordinator需要关心worker的任务是否完成，在超时情况下将任务重新分配给别的worker。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>系统的输入是一堆文件，每个文件对应一个 Map 任务。任务由 Worker 向 Coordinator 请求，由 Coordinator 向下分发。</li><li>在分发 Map 任务时，Coordinator 同时会传递 Reduce 的任务数量（NReduce）给 Worker。</li><li>每个 Map Worker 会生成 NReduce 个中间文件，将不同的 Key 哈希到不同文件里。文件命名为mr-n-m，其中n为文件序号，m为reduce序号</li><li>每个Reduce Worker x会读取所有mr-*-x文件，然后使用map函数对其处理，然后将其输出</li><li>使用临时文件方法来避免crash发生</li><li>使用互斥访问来避免并行执行时异常发生</li></ul><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>使用一个结构体来描述任务信息：</p><pre class="line-numbers language-none"><code class="language-none">type TaskInfo struct &#123;TaskType  string &#x2F;&#x2F;分为四种类型：Map、Reduce、Wait(等待所有Map执行完)、None(无任务，结束)FilePath  stringNReduce   intRidx      int &#x2F;&#x2F;reduce 任务idxFileN     int &#x2F;&#x2F;总文件数FileIdx   int &#x2F;&#x2F;当前任务文件序列号StartTime int64&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了简便，没有分开map任务信息和reduce信息。各字段说明如下：</p><ul><li>TaskType：分为Map、Reduce、Wait(等待所有Map或Reduce任务执行完)、None(无任务，结束)</li><li>FilePath：Map任务执行时的输入文件，Reduce任务忽略此字段</li><li>NReduce：Map将每个单词置于不同文件中，放置位置是使用单词的哈希函数除NReduce求得（这就使得将所有单词分离到不同Reduce任务中）。</li><li>Ridx：reduce 任务idx，即用于识别属于该reduce任务的文件</li><li>FileN：在Map任务重，每个输入文件都会输出NReduce个临时文件，因此在Reduce任务中需要知道所有文件数量才能读取完临时文件</li><li>FileIdx：当前任务文件序列号，用于Map任务时输出临时文件的文件名</li><li>StartTime：任务开始时间，主要用于判断当前任务是否已经超时，如果超时则使用重新分配此任务</li></ul><p>在实现的队列结构中，使用一个哈希表和mutex：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TaskQue <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>mQue  <span class="token keyword">map</span><span class="token punctuation">[</span>TaskInfo<span class="token punctuation">]</span><span class="token builtin">int</span>mutex sync<span class="token punctuation">.</span>Mutex<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>另外实现了pop、insert、getLen、empty、delete函数，主要是使用mutex来避免多线程访问时出现异常。</p><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a><em>Coordinator</em></h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Coordinator <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// Your definitions here.</span>mapDo       TaskQuemapDoing    TaskQuereduceDo    TaskQuereduceDoing TaskQuenReduce     <span class="token builtin">int</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>coordinator用于协调worker，其主要由四个队列组成：</p><ul><li>mapDo：需要执行map任务的队列</li><li>mapDoing：正在执行map任务的队列</li><li>reduceDo：需要执行reduce任务的队列</li><li>reduceDoing：正在执行reduce任务的队列</li></ul><p>主要实现了两个RPC函数：</p><ul><li><p>请求任务函数：GetTask，主要用于判断是分配Map、Reduce还是等待或结束程序，另外为了简便，还是此函数中判断了是否有超时任务，如果有则将其重新分配</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Coordinator<span class="token punctuation">)</span> <span class="token function">GetTask</span><span class="token punctuation">(</span>args <span class="token builtin">int</span><span class="token punctuation">,</span> reply <span class="token operator">*</span>TaskInfo<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span><span class="token comment">//map和reduce正在执行的任务超过10秒，则重新执行</span><span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span>mapDoing<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> key<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token keyword">range</span> c<span class="token punctuation">.</span>mapDoing<span class="token punctuation">.</span>mQue <span class="token punctuation">&#123;</span><span class="token keyword">if</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>key<span class="token punctuation">.</span>StartTime <span class="token operator">></span> <span class="token number">10</span> <span class="token punctuation">&#123;</span>tmp <span class="token operator">:=</span> c<span class="token punctuation">.</span>mapDoing<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>mapDo<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmp<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span>reduceDoing<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> key<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token keyword">range</span> c<span class="token punctuation">.</span>reduceDoing<span class="token punctuation">.</span>mQue <span class="token punctuation">&#123;</span><span class="token keyword">if</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>key<span class="token punctuation">.</span>StartTime <span class="token operator">></span> <span class="token number">10</span> <span class="token punctuation">&#123;</span>tmp <span class="token operator">:=</span> c<span class="token punctuation">.</span>reduceDoing<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>reduceDo<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmp<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span>mapDo<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>reply <span class="token operator">=</span> c<span class="token punctuation">.</span>mapDo<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>mapDoing<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span>mapDoing<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>reply <span class="token operator">=</span> TaskInfo<span class="token punctuation">&#123;</span><span class="token string">"Wait"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span>reduceDo<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>reply <span class="token operator">=</span> c<span class="token punctuation">.</span>reduceDo<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>reduceDoing<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> c<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>reply <span class="token operator">=</span> TaskInfo<span class="token punctuation">&#123;</span><span class="token string">"None"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>reply <span class="token operator">=</span> TaskInfo<span class="token punctuation">&#123;</span><span class="token string">"Wait"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>任务完成报告函数：FinReport，主要是判断完成的Map还是Reduce任务，并将其从相应的doing队列中移除</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Coordinator<span class="token punctuation">)</span> <span class="token function">FinReport</span><span class="token punctuation">(</span>args TaskInfo<span class="token punctuation">,</span> reply <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> args<span class="token punctuation">.</span>TaskType <span class="token operator">==</span> <span class="token string">"Map"</span> <span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>mapDoing<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> args<span class="token punctuation">.</span>TaskType <span class="token operator">==</span> <span class="token string">"Reduce"</span> <span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>reduceDoing<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><p>实现请求任务和报告任务完成函数的远程调用，根据请求任务的结果判断是执行Map任务还是Reduce任务或等待或结束进程。</p><p><strong>Map任务执行实现</strong>：根据taskinfo中的信息读取输入文件，使用mapf函数得到中间值，然后根据每个单词的不同哈希值将其存储到不同文件中（输出时使用时json进行编码）</p><ul><li>为了通过crash test，每个单词输出到临时文件，当所有单词输出完成后才将临时文件重命名。即使在重命名时程序崩溃，由于输出文件是使用的覆盖，因此也不会出现异常。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">doMap</span><span class="token punctuation">(</span>task <span class="token operator">*</span>TaskInfo<span class="token punctuation">,</span> mapf <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>KeyValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// fmt.Printf("Map id:%v, map time:%v\n", task.FileIdx, task.StartTime)</span>intermediate <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>KeyValue<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>filename <span class="token operator">:=</span> task<span class="token punctuation">.</span>FilePathfile<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"cannot open %v"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>content<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"cannot read %v"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>kva <span class="token operator">:=</span> <span class="token function">mapf</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span>intermediate <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>intermediate<span class="token punctuation">,</span> kva<span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">//生成临时文件，避免程序崩溃时导致错误发生</span>nReduce <span class="token operator">:=</span> task<span class="token punctuation">.</span>NReduceoutFiles <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>os<span class="token punctuation">.</span>File<span class="token punctuation">,</span> nReduce<span class="token punctuation">)</span>fileEncs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>json<span class="token punctuation">.</span>Encoder<span class="token punctuation">,</span> nReduce<span class="token punctuation">)</span><span class="token keyword">for</span> outIdx <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> outIdx <span class="token operator">&lt;</span> nReduce<span class="token punctuation">;</span> outIdx<span class="token operator">++</span> <span class="token punctuation">&#123;</span>outFiles<span class="token punctuation">[</span>outIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> ioutil<span class="token punctuation">.</span><span class="token function">TempFile</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"mr-tmp-*"</span><span class="token punctuation">)</span>fileEncs<span class="token punctuation">[</span>outIdx<span class="token punctuation">]</span> <span class="token operator">=</span> json<span class="token punctuation">.</span><span class="token function">NewEncoder</span><span class="token punctuation">(</span>outFiles<span class="token punctuation">[</span>outIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> kv <span class="token operator">:=</span> <span class="token keyword">range</span> intermediate <span class="token punctuation">&#123;</span>hashIdx <span class="token operator">:=</span> <span class="token function">ihash</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>Key<span class="token punctuation">)</span> <span class="token operator">%</span> nReduceenc <span class="token operator">:=</span> fileEncs<span class="token punctuation">[</span>hashIdx<span class="token punctuation">]</span>err <span class="token operator">:=</span> enc<span class="token punctuation">.</span><span class="token function">Encode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kv<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"kv encode failed! Error: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> outIdx<span class="token punctuation">,</span> file <span class="token operator">:=</span> <span class="token keyword">range</span> outFiles <span class="token punctuation">&#123;</span>newName <span class="token operator">:=</span> <span class="token string">"mr-"</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>FileIdx<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>outIdx<span class="token punctuation">)</span>oldName <span class="token operator">:=</span> filepath<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>os<span class="token punctuation">.</span><span class="token function">Rename</span><span class="token punctuation">(</span>oldName<span class="token punctuation">,</span> newName<span class="token punctuation">)</span>file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">CallFinReport</span><span class="token punctuation">(</span><span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Reduce任务执行实现</strong>：从所有属于该reduce任务的文件中读取数据，然后使用sort进行排序，再使用reducef函数输出。同理，为了通过crash test，使用临时文件进行输出。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">doReduce</span><span class="token punctuation">(</span>task <span class="token operator">*</span>TaskInfo<span class="token punctuation">,</span> reducef <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>intermediate <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>KeyValue<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> idx <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> idx <span class="token operator">&lt;</span> task<span class="token punctuation">.</span>FileN<span class="token punctuation">;</span> idx<span class="token operator">++</span> <span class="token punctuation">&#123;</span>fileName <span class="token operator">:=</span> <span class="token string">"mr-"</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>Ridx<span class="token punctuation">)</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"file:%v read failed!\n"</span><span class="token punctuation">,</span> fileName<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>dec <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">NewDecoder</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> kv KeyValue<span class="token keyword">if</span> err <span class="token operator">:=</span> dec<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kv<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>intermediate <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>intermediate<span class="token punctuation">,</span> kv<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>sort<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span><span class="token function">ByKey</span><span class="token punctuation">(</span>intermediate<span class="token punctuation">)</span><span class="token punctuation">)</span>outFile<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">TempFile</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"mr-tmp-out-*"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"create temp file failed!"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>i <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>intermediate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>j <span class="token operator">:=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token keyword">for</span> j <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>intermediate<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> intermediate<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>Key <span class="token operator">==</span> intermediate<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Key <span class="token punctuation">&#123;</span>j<span class="token operator">++</span><span class="token punctuation">&#125;</span>values <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> k <span class="token operator">:=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span> <span class="token punctuation">&#123;</span>values <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> intermediate<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>output <span class="token operator">:=</span> <span class="token function">reducef</span><span class="token punctuation">(</span>intermediate<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Key<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token comment">// this is the correct format for each line of Reduce output.</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>outFile<span class="token punctuation">,</span> <span class="token string">"%v %v\n"</span><span class="token punctuation">,</span> intermediate<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Key<span class="token punctuation">,</span> output<span class="token punctuation">)</span>i <span class="token operator">=</span> j<span class="token punctuation">&#125;</span>newName <span class="token operator">:=</span> <span class="token string">"mr-out-"</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>Ridx<span class="token punctuation">)</span>os<span class="token punctuation">.</span><span class="token function">Rename</span><span class="token punctuation">(</span>outFile<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> newName<span class="token punctuation">)</span>outFile<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">CallFinReport</span><span class="token punctuation">(</span><span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>early exit test不通过：</p><ul><li>此测试是为了测试在任务未完成情况下，是否有worker或master退出</li><li>在实现中，请求任务时会检测所有任务是否完成，如果为完成则wait，否则退出。</li></ul></blockquote><h1 id="Lab2：Raft"><a href="#Lab2：Raft" class="headerlink" title="Lab2：Raft"></a>Lab2：Raft</h1><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230426174946043.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230426174922607.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230428103956852.png"></p><p>bug</p><ul><li>当kv上层检测到需要发送Snapshot时，调用Snapshot函数，但此时raft底层从主raft收到安装镜像调用，将log进行修改，此时如果不进行log边界检查就会发生错误。</li><li>踩了一个坑，添加日志消息rpc的args中的entry需要进行深拷贝，否则可能因为log被修改从而导致args.entry发生改变。<ul><li>折腾了好久才发现这问题，其他rpc没进行深拷贝主要是因为其切片不会被改变，导致形成了思维定势。</li></ul></li></ul><h2 id="Label2A和Label2B"><a href="#Label2A和Label2B" class="headerlink" title="Label2A和Label2B"></a>Label2A和Label2B</h2><p>由于2A中的选举和2B中的日志复制有一部分相关，所以一起，但也可单独做2A，只是做2B的时候还需要修改2A代码</p><h3 id="任务描述-1"><a href="#任务描述-1" class="headerlink" title="任务描述"></a><strong>任务描述</strong></h3><p>实现分布式选举及分布式日志复制</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>raft结构体如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Raft <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>mu        sync<span class="token punctuation">.</span>Mutex          <span class="token comment">// Lock to protect shared access to this peer's state</span>peers     <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>labrpc<span class="token punctuation">.</span>ClientEnd <span class="token comment">// RPC end points of all peers</span>persister <span class="token operator">*</span>Persister          <span class="token comment">// Object to hold this peer's persisted state</span>me        <span class="token builtin">int</span>                 <span class="token comment">// this peer's index into peers[]</span>dead      <span class="token builtin">int32</span>               <span class="token comment">// set by Kill()</span>applyCh <span class="token operator">*</span><span class="token keyword">chan</span> ApplyMsg <span class="token comment">//通过此通道提交日志和snapshot</span><span class="token comment">//persistent state</span>currentTerm <span class="token builtin">int</span>     <span class="token comment">//当前term</span>votedFor    <span class="token builtin">int</span>     <span class="token comment">//当前投票给谁</span>log         <span class="token punctuation">[</span><span class="token punctuation">]</span>Entry <span class="token comment">//日志信息</span><span class="token comment">//Volatile state</span>state        <span class="token builtin">int</span>   <span class="token comment">//当前raft的状态：follower、candidate、leader之一</span>lastRecTime  <span class="token builtin">int64</span> <span class="token comment">//当前raft最后一次收到消息时间，毫秒时间戳</span>commitIndex  <span class="token builtin">int</span>   <span class="token comment">//当前日志待提交的序号</span>lastApplied  <span class="token builtin">int</span>   <span class="token comment">//已提交日志的序号</span>lastLogIndex <span class="token builtin">int</span>   <span class="token comment">//最后一个日志序号</span><span class="token comment">//Reinitialized after election</span>nextIndex  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment">//所有raft的下一个要发送日志的位置</span>matchIndex <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment">//和其他raft成功匹配的日志位置</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在结构体中添加了lastRecTime来记录最后一次收到消息时间，来实现超时选举。添加state来记录当时状态，lastLogIndex来记录最后一个日志位置。</p><p>创建raft时，commitIndex、lastApplied、lastLogIndex都初始化为1，votedFor&#x3D;-1，currentTerm&#x3D;0。为了lastApplied和commitIndex等使用方便，log初始化时添加了一个日志，使得不用每次访问log添加偏移。</p><p><strong>分布式选举</strong>：为每个raft创建一个定时器，当超过时间阈值进行选举，当收到日志消息或心跳时都会对lastRecTime进行更新</p><p><strong>日志复制</strong>：将心跳信息和发送日志合并为一个函数，心跳信息只是日志为空。通过检测日志是否匹配来更新nextIndex，从而更快完成日志复制。</p><p>主要有两个RPC方法，即：RequestVote（用于投票）和AppendEntries（用于接受心跳、添加日志等消息）</p><p>相应的，主要也是在三个函数中对这两个rpc方法进行调用：</p><ul><li>startElect（调用RequestVote进行选举）</li><li>syncAllEntries（调用AppendEntries用于添加同步日志）</li><li>sendAllHeartBeat（调用AppendEntries发送心跳）</li></ul><p>以下进行分别介绍这5个函数，其他方法如start等都较为简单</p><h4 id="RequestVote"><a href="#RequestVote" class="headerlink" title="RequestVote"></a>RequestVote</h4><p>request和reply结构体如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> RequestVoteArgs <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Term         <span class="token builtin">int</span> <span class="token comment">//rpc发起者的term</span>CandidateId  <span class="token builtin">int</span> <span class="token comment">//rpc发起者的序号</span>LastLogIndex <span class="token builtin">int</span> <span class="token comment">//rpc发起者的最后一个日志的序号</span>LastLogTerm  <span class="token builtin">int</span> <span class="token comment">//rpc发起者的最后一个日志的term</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> RequestVoteReply <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Term        <span class="token builtin">int</span> <span class="token comment">//被调用者的当前term</span>VoteGranted <span class="token builtin">bool</span> <span class="token comment">//被调用者是否同意投票给调用者</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此函数主要用于判断是否接受投票，其主要判断条件如下：</p><ul><li>如果请求方的term小于当前term，拒绝投票</li><li>在请求方的term不小于当前term的情况下，如果当前未投票，则比较日志谁最新。日志最新比较规则是最大term大者最新，若term相等，则日志长度越长者越新</li></ul><p>因此，此函数里面主要的实现逻辑就是上述条件。注意，如果args的term大于当前term，则必须更改当前raft的状态为follower并更新term，且将votedFor置为-1。</p><p>为了避免重复选举，每接收到一个vote都会对最后接受时间lastRecTime进行更新</p><h4 id="startElect"><a href="#startElect" class="headerlink" title="startElect"></a>startElect</h4><p>当每个raft最后一次收到消息时间超过阈值，则调用此函数进行新一轮选举。逻辑如下：</p><ul><li>首先将state置为candidate，votedFor设置自己，且将currentTerm+1</li><li>然后对除自己之外的raft发送投票请求<ul><li>当同意投票数量大于一半时（自己也算一票），则当前raft变为leader（注意，需要先判断此时currentTerm是否等于函数开始时的term，这是为了防止发起投票时，有其他raft发起新的投票）。由于超过半数就变为leader，为了防止多次变为leader，需当前状态为candidate才变为leader</li><li>如果收到拒绝投票，则判断reply的term是否大于当前term，若大于则更新当前term且将状态更改为follower</li></ul></li></ul><h4 id="AppendEntries"><a href="#AppendEntries" class="headerlink" title="AppendEntries"></a>AppendEntries</h4><p>request和reply结构体如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> RequestAppendArgs <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Term         <span class="token builtin">int</span>     <span class="token comment">//发起者当前term</span>LeaderId     <span class="token builtin">int</span>     <span class="token comment">//发起者id</span>PrevLogIndex <span class="token builtin">int</span>     <span class="token comment">//当前要添加日志的前一个日志位置</span>PrevLogTerm  <span class="token builtin">int</span>     <span class="token comment">//当前要添加日志的前一个日志的term</span>Entries      <span class="token punctuation">[</span><span class="token punctuation">]</span>Entry <span class="token comment">//要添加的日志</span>LeaderCommit <span class="token builtin">int</span>     <span class="token comment">//发起者的commit大小，主要用于接受者提交日志</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> RequestAppendReply <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Term       <span class="token builtin">int</span>    <span class="token comment">//接收方当前term</span>Success    <span class="token builtin">bool</span>   <span class="token comment">//是否成功添加日志</span>FailReason <span class="token builtin">string</span> <span class="token comment">//添加失败的原因，有点多余这参数，</span>UpdateNext <span class="token builtin">int</span>    <span class="token comment">//添加失败，即日志冲突时，需要将leader的nextIndex更新为UpdateNext</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此函数主要用于添加日志和接收心跳（心跳就是一个日志为空），其主要逻辑如下：</p><ul><li>如果args.term&lt;当前term，则拒绝添加日志，返回false</li><li>如果日志为空，则此消息时日志，对lastRecTime进行更新，且根据心跳消息中的LeaderCommit提交此raft的日志。</li><li>在上述两都不满足情况下，则说明此次请求是一个正常添加日志请求<ul><li>首先需要判断args.PrevLogIndex是否大于rf.lastLogIndex，大于则说明当前日志长度不够则返回false，且将reply.UpdateNext&#x3D;rf.lastLogIndex（注意，lastLogIndex可能为0，因此当其为0时需要将UpdateNext置为1，因为nextIndex最小为1）</li><li>args.PrevLogIndex小于等于rf.lastLogIndex，则需要判断rf.log[args.PrevLogIndex].Term 是否等于 args.PrevLogTerm，如果不等则说明日志不匹配，则返回false，且将UpdateNext更新为args.PrevLogIndex<ul><li>2C中如果只将UpdateNext更新为args.PrevLogIndex则会无法通过，需要优化。其优化规则是在当前日志中找到第一个日志term为rf.log[args.PrevLogIndex].Term的日志，这样就可以使得同一个term内的日志只退回一次。</li></ul></li><li>如果需添加日志的前一个日志不冲突，则比较需添加日志是否与当前日志冲突，若冲突则更改。不冲突，则添加。在添加日志后同样需要检查LeaderCommit，来更新当前的commit并提交日志。</li></ul></li></ul><h4 id="sendAllHeartBeat"><a href="#sendAllHeartBeat" class="headerlink" title="sendAllHeartBeat"></a>sendAllHeartBeat</h4><p>主要用于发送心跳信息，使用time.sleep每150ms发送一次，逻辑如下：</p><ul><li>每次发送前都需要判断当前状态是否为leader，如果不是则结束</li><li>向除自己外的raft发送心跳，LeaderCommit应该设置为min(rf.lastApplied, rf.matchIndex[idx])，如果reply.Term &gt; rf.currentTerm，则更新term并将状态置为follower。</li><li>注意，为了避免leader自己超时，每次发送心跳时也需要更新自己的lastRecTime</li></ul><blockquote><p>LeaderCommit没有按论文中的Fig2设置为commitIndex，这是为了避免日志还未同步完成就通过心跳消息发送了commit，此时日志可能还是错误的，就会导致错误日志被提交。当时这个折腾了老久。。。</p></blockquote><h4 id="syncAllEntries"><a href="#syncAllEntries" class="headerlink" title="syncAllEntries"></a>syncAllEntries</h4><p>此函数用于向其他raft同步日志，包括第一次成为leader时同步日志和有新日志时进行同步。逻辑如下：</p><ul><li>此函数为除自己为的raft都创建一个线程，线程一直运行，只有当term发生改变（又一次被选为leader）和不再为leader时才推出线程。</li><li>判断是否需要发送日志是通过比较lastLogIndex和rf.nextIndex[i]，如果lastLogIndex大于等于rf.nextIndex[i]则说明需要发送日志。<ul><li>如果reply为success，则需要将nextIndex更新为lastLogIndex + 1，matchIndex更新为lastLogIndex</li><li>如果reply失败：<ul><li>若由于第一次同步等原因日志不匹配导致失败，此时需要对nextIndex进行更新为UpdateNext</li><li>若由于此term小于被请求的term，则更改term、状态等并退出线程。</li></ul></li></ul></li><li>每次同步完日志后，需要遍历日志，找到序号最小且其被超过一半的raft提交的日志（即大于matchIndex超过一半），将commitIndex更新为此日志位置。<strong>注意</strong>，为了避免Fig8错误，若找到日志的term不等于当前term，则不更新commitIndex。<ul><li>还有一个更简单的方法，即通过找matchIndex的中位数，但尝试了下，有些测试有问题，还没解决。</li></ul></li><li>注意在此线程中没进入临界区都需要判断是否为leader或term是否发生变化。</li></ul><h2 id="Label2C"><a href="#Label2C" class="headerlink" title="Label2C"></a>Label2C</h2><p>主要实现persist函数和readPersist，其是对currentTerm、votedFor、log进行序列化保存和反序列化读取（把state也保存了。。）。根据example来写就行，注意readPersist中读取数据后，需要更新lastLogIndex值。</p><p>只会在创建raft时调用readPersist。按理说只要上述需要保存的三个变量发生变化就调用persist函数，但为了效率，只有当log和currentTerm发生变化时调用，即start函数、RequestVote和AppendEntries函数中调用</p><p>为了通过2C测试，需要对nextIndex更新做优化，否则可能无法通过。</p><h2 id="Label2D"><a href="#Label2D" class="headerlink" title="Label2D"></a>Label2D</h2><p>还有缺陷，将snapcommon中的iter减小后能通过lab2D，主要原因是发送同步消息时如果网络不通会很久才超时，有的要等5秒以上（网络其实早已经恢复，但还是很久才超时），从而导致每个iter处理时间很长（实验设计中同步消息是一个协程在做）</p><p>实现：</p><ul><li>此实验raft结构体添加了lastIncludedTerm和lastIncludedIndex，并需要将其持久化，且访问log需要带上lastIncludedIndex偏移。</li><li>修改persist函数，对snapshot也进行持久化。readPersist函数也需要读取snapshot。注意！提交ApplyMsg消息时不能持有锁，因为提交一定数量消息后会进行快照，此时调用Snapshot函数，而Snapshot函数中会申请锁，从而导致死锁。解决办法是创建一个协程来提交ApplyMsg消息。</li><li>实现Snapshot函数：此函数根据已经有的快照来修剪log，需同时修改lastIncludedTerm、lastIncludedIndex、commitIndex、lastApplied，且需要持久化。</li><li>实现InstallSnapshot函数：此函数对发送来得snapshot进行安装，安装成功后需要修改参数等，且需提交带snapshot的ApplyMsg</li><li>修改syncAllEntries函数：当nextIndex&lt;&#x3D;lastIncludedIndex时调用InstallSnapshot函数，需要对reply进行处理，如果term大于currentTerm则结束同步协程</li></ul><p>后续可做工作：</p><ul><li>发送日志消息时设置超时时间，如果超时则重发（已简单尝试，但会出错，考虑加上时间来排除重复请求）</li><li>合并发送日志函数和心跳函数。</li></ul><h1 id="Lab3：Kvraft"><a href="#Lab3：Kvraft" class="headerlink" title="Lab3：Kvraft"></a>Lab3：Kvraft</h1><p>整体逻辑：</p><ul><li>客户端不断轮询服务器知道请求成功</li><li>服务端使用一个线程来处理所有对数据的操作</li></ul><p>客户端：主要实现Get和PutAppend逻辑都差不多，都是先生成请求，不断向服务器发送请求知道请求成功，由于不知道leader，因此每次请求不成功就更改服务器id</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>ck <span class="token operator">*</span>Clerk<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>ck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ck<span class="token punctuation">.</span>requestId<span class="token operator">++</span>ck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>serverId <span class="token operator">:=</span> ck<span class="token punctuation">.</span>leaderIdargs <span class="token operator">:=</span> GetArgs<span class="token punctuation">&#123;</span>key<span class="token punctuation">,</span> ck<span class="token punctuation">.</span>me<span class="token punctuation">,</span> ck<span class="token punctuation">.</span>requestId<span class="token punctuation">&#125;</span><span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"ck[%v] send Get rpc..., args=%v"</span><span class="token punctuation">,</span> ck<span class="token punctuation">.</span>me<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>reply <span class="token operator">:=</span> GetReply<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>ok <span class="token operator">:=</span> ck<span class="token punctuation">.</span>servers<span class="token punctuation">[</span>serverId<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">"KVServer.Get"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>args<span class="token punctuation">,</span> <span class="token operator">&amp;</span>reply<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ok<span class="token punctuation">)</span> <span class="token operator">||</span> reply<span class="token punctuation">.</span>Err <span class="token operator">==</span> ErrWrongLeader <span class="token punctuation">&#123;</span>serverId <span class="token operator">=</span> <span class="token punctuation">(</span>serverId <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>ck<span class="token punctuation">.</span>servers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> reply<span class="token punctuation">.</span>Err <span class="token operator">==</span> ErrNoKey <span class="token punctuation">&#123;</span>ck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ck<span class="token punctuation">.</span>leaderId <span class="token operator">=</span> serverIdck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"ck[%v] get no key"</span><span class="token punctuation">,</span> ck<span class="token punctuation">.</span>me<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> reply<span class="token punctuation">.</span>Err <span class="token operator">==</span> OK <span class="token punctuation">&#123;</span>ck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ck<span class="token punctuation">.</span>leaderId <span class="token operator">=</span> serverIdck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"ck[%v] success get value=%v, args=%v"</span><span class="token punctuation">,</span> ck<span class="token punctuation">.</span>me<span class="token punctuation">,</span> reply<span class="token punctuation">.</span>Value<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token keyword">return</span> reply<span class="token punctuation">.</span>Value<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务端：主要实现对Get和PutAppend rpc的响应函数，及对raft底层提交的日志进行处理applyLoop。主要使用三个哈希表来记录状态：kvdb（记录数据库）、  clientLastReq（每个客户端记录的最后一个请求），applyWaitCh（记录每个请求对应的通道）。</p><ul><li>Get函数中，先使用start函数，根据返回值判断此kv是否为leader，如果是leader则需要创建一个通道用来等待服务处理完成的结果</li><li>applyLoop函数中，根据底层raft提交的日志消息不断处理，如果是snapshot日志则需要根据快照恢复状态，如果kv.maxraftstate-kv.rf.GetRaftStateSize()小于一定阈值则说明需要进行快照了。如果是普通操作，则先判断其操作ID是否重复，如果重复则不根据当前日志对数据库进行操作，否则进行操作并在哈希表中记录</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>KVServer<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>args <span class="token operator">*</span>GetArgs<span class="token punctuation">,</span> reply <span class="token operator">*</span>GetReply<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Your code here.</span><span class="token keyword">if</span> kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"kv[%v] is killed, return ErrWrongLeader"</span><span class="token punctuation">,</span> kv<span class="token punctuation">.</span>me<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>op <span class="token operator">:=</span> Op<span class="token punctuation">&#123;</span>GetOp<span class="token punctuation">,</span> args<span class="token punctuation">.</span>Key<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span>ClientId<span class="token punctuation">,</span> args<span class="token punctuation">.</span>RequestId<span class="token punctuation">&#125;</span>kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>index<span class="token punctuation">,</span> term<span class="token punctuation">,</span> isLeader <span class="token operator">:=</span> kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token keyword">if</span> term <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrNoKey<span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>isLeader <span class="token punctuation">&#123;</span>kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token comment">// DPrintf("kv[%v] is not a leader, return ErrWrongLeader", kv.me)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"kv[%v] start deal get, op=%v"</span><span class="token punctuation">,</span> kv<span class="token punctuation">.</span>me<span class="token punctuation">,</span> op<span class="token punctuation">)</span>curCh <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> applyRes<span class="token punctuation">)</span>command <span class="token operator">:=</span> commandEntry<span class="token punctuation">&#123;</span>op<span class="token punctuation">,</span> curCh<span class="token punctuation">&#125;</span>kv<span class="token punctuation">.</span>applyWaitCh<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> commandkv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token operator">!</span>kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> res <span class="token operator">:=</span> <span class="token operator">&lt;-</span>curCh<span class="token punctuation">:</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> res<span class="token punctuation">.</span>Errreply<span class="token punctuation">.</span>Value <span class="token operator">=</span> res<span class="token punctuation">.</span>Value<span class="token keyword">if</span> res<span class="token punctuation">.</span>Err <span class="token operator">==</span> OK <span class="token punctuation">&#123;</span><span class="token keyword">if</span> res<span class="token punctuation">.</span>Value <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>res<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrNoKey<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>DealTimeOut<span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token operator">&lt;-</span>curCh <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//需要接受处理结果，否则applyloop会死等</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"kv[%v] timeout, return ErrWrongLeader"</span><span class="token punctuation">,</span> kv<span class="token punctuation">.</span>me<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//当kv crash时</span><span class="token keyword">if</span> kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>KVServer<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>args <span class="token operator">*</span>GetArgs<span class="token punctuation">,</span> reply <span class="token operator">*</span>GetReply<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Your code here.</span><span class="token keyword">if</span> kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"kv[%v] is killed, return ErrWrongLeader"</span><span class="token punctuation">,</span> kv<span class="token punctuation">.</span>me<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>op <span class="token operator">:=</span> Op<span class="token punctuation">&#123;</span>GetOp<span class="token punctuation">,</span> args<span class="token punctuation">.</span>Key<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span>ClientId<span class="token punctuation">,</span> args<span class="token punctuation">.</span>RequestId<span class="token punctuation">&#125;</span>kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>index<span class="token punctuation">,</span> term<span class="token punctuation">,</span> isLeader <span class="token operator">:=</span> kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token keyword">if</span> term <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrNoKey<span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>isLeader <span class="token punctuation">&#123;</span>kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token comment">// DPrintf("kv[%v] is not a leader, return ErrWrongLeader", kv.me)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"kv[%v] start deal get, op=%v"</span><span class="token punctuation">,</span> kv<span class="token punctuation">.</span>me<span class="token punctuation">,</span> op<span class="token punctuation">)</span>curCh <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> applyRes<span class="token punctuation">)</span>command <span class="token operator">:=</span> commandEntry<span class="token punctuation">&#123;</span>op<span class="token punctuation">,</span> curCh<span class="token punctuation">&#125;</span>kv<span class="token punctuation">.</span>applyWaitCh<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> commandkv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token operator">!</span>kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> res <span class="token operator">:=</span> <span class="token operator">&lt;-</span>curCh<span class="token punctuation">:</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> res<span class="token punctuation">.</span>Errreply<span class="token punctuation">.</span>Value <span class="token operator">=</span> res<span class="token punctuation">.</span>Value<span class="token keyword">if</span> res<span class="token punctuation">.</span>Err <span class="token operator">==</span> OK <span class="token punctuation">&#123;</span><span class="token keyword">if</span> res<span class="token punctuation">.</span>Value <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>res<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrNoKey<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>DealTimeOut<span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token operator">&lt;-</span>curCh <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//需要接受处理结果，否则applyloop会死等</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"kv[%v] timeout, return ErrWrongLeader"</span><span class="token punctuation">,</span> kv<span class="token punctuation">.</span>me<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//当kv crash时</span><span class="token keyword">if</span> kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>遇到问题</p><ul><li>completion after heal (3A) 无法通过<ul><li>将请求响应等待超时时间设置的过大，导致没有超时返回ERRWrongLeader, 就不会重新发送请求将值设置为15，导致无法通过</li></ul></li></ul></blockquote><h1 id="Lab4：Sharded-KV-Service"><a href="#Lab4：Sharded-KV-Service" class="headerlink" title="Lab4：Sharded KV Service"></a>Lab4：Sharded KV Service</h1><h2 id="Label4A"><a href="#Label4A" class="headerlink" title="Label4A"></a>Label4A</h2><p>此实验需要实现一个高容错的配置管理中心，因此使用raft作为底层同步协议，使用多个服务器作为一个group，从而提供配置服务。</p><p>整体逻辑：</p><ul><li>每进行一次配置变动就形成新版本配置，且以前配置都需要在configs中进行保存</li><li>由于多个服务器需要进行同步，因此配置变动操作需要先提交给raft底层，然后根据raft apply的日志不断进行操作，因此需要有一个函数applyLoop不断循环处理raft提交的日志。</li><li>由于需要将操作提交到底层，因此需要一个结构体Op来描述各种操作及携带的数据，然后applyLoop根据日志中的Op进行相应处理。</li><li>在提交给raft后，需要等待操作完成，这里使用通道进行等待，没个操作对应一个通道，当applyLoop处理完一个操作就在对应通道发送信号。因此使用一个哈希表applyWaitCh来存储日志序号（每提交一个操作都会有唯一的日志序号）对应的通道。</li><li>当处理Join、Move、Leave操作后，需要对shard配置进行重新分配使得配置均衡。一个简单的算法就是不断找出当前分片数最多的服务器A和分片数最少得服务器B，然后将最后一个分片分配给分片数最少得服务器（注意这里不要用map存储，因为map取第一个值是随机的，从而导致多个服务器状态不同），知道分片最多服务器和分片最少服务器分片数量最多相差1。</li><li>和kvraft一样，为了过滤重复请求，使用一个哈希表 clientLastReq来记录每个客户端已被处理的最大请求和对应请求结果（用于get）</li><li>这里没有提供persister，因此无需进行snapshot处理</li></ul><p>各结构体如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ShardCtrler <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>mu      sync<span class="token punctuation">.</span>Mutexme      <span class="token builtin">int</span>rf      <span class="token operator">*</span>raft<span class="token punctuation">.</span>RaftapplyCh <span class="token keyword">chan</span> raft<span class="token punctuation">.</span>ApplyMsg<span class="token comment">// Your data here.</span>clientLastReq <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int64</span><span class="token punctuation">]</span>applyRes  <span class="token comment">//记录每个客户端已被处理的最大请求和对应请求结果，用于过滤重复请求</span>applyWaitCh   <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token keyword">chan</span> applyRes <span class="token comment">//存储日志序号（每提交一个操作都会有唯一的日志序号）对应的通道</span>lastApply <span class="token builtin">int</span> <span class="token comment">//最近被处理的日志序号，</span>configs   <span class="token punctuation">[</span><span class="token punctuation">]</span>Config <span class="token comment">// indexed by config num  存储当前所有配置</span>curConfId <span class="token builtin">int</span> <span class="token comment">//最后一个配置序号</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> applyRes <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Err   ErrreqId <span class="token builtin">int</span>Value Config<span class="token punctuation">&#125;</span><span class="token keyword">type</span> Op <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// Your data here.</span>Operation <span class="token builtin">string</span>ClientID  <span class="token builtin">int64</span>RequestId <span class="token builtin">int</span>Servers   <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token comment">//JoinOp</span>GIDs      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>            <span class="token comment">//LeaveOp</span>Shard     <span class="token builtin">int</span>              <span class="token comment">//MoveOp</span>GID       <span class="token builtin">int</span>              <span class="token comment">//MoveOp</span>Num       <span class="token builtin">int</span>              <span class="token comment">//QueryOp</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Label4B"><a href="#Label4B" class="headerlink" title="Label4B"></a>Label4B</h2><p>此部分需要实现一个分片kv服务，有多组group，每组group的多个服务器使用同一raft来同步数据，每组group存储不同分片，客户端通过哈希函数可确定需要访问哪个分片。由于配置会发生变化，因此还需要向其他group发送或接收分片数据。</p><p>主要逻辑：</p><ul><li>首先，和4a一样，客户端的各种操作需要向底层raft提交来进行操作，然后使用函数applyLoop不断循环处理raft提交的日志。</li><li>由于配置不断发生改变，因此使用一个线程detecConfLoop不断获取新配置。注意，只有在当前配置curConf和上一个配置preConf之间的数据已经同步完成才能获取新配置，且只获取比当前版本号大1的新配置。同步数据是否完成包含两个部分：<ul><li>发送数据是否完成：将不属于当前配置的切片发送给相应服务器，当未发送完成时需要向其他服务器发送，每当发送成功一个切片后需要向raft提交删除相应切片数据日志</li><li>接受数据是否完成：属于当前配置的切片是否已经接收完毕，每当接收一个切片数据就向raft提交更新切片数据日志。</li><li>注意，数据的更新和删除必须通过raft，才能使得整个group的状态一致。</li></ul></li><li></li></ul><p>bug1</p><ul><li>restart错误，未成功安装底层提交的镜像，因为判断是否安装的条件写反了</li><li>append重复提交应当成功处理</li><li>同一更新配置命令可能会提交两次（即使通道一直等待处理结果，也可能因为机器重启导致提交相同的配置两次）。当两次配置都被应用，导致value值被清空。解决方法：重复检测，如果新配置不比当前配置大则不配置。</li><li>底层raft有点问题，重新启动时需要提交一条空日志后raft才会向上层提交日志</li><li>记录客户端请求id时需要记录请求结果，当检测到重复请求时，返回上次请求结果，特别是GET请求。</li><li>需要特别处理shard配置为0时，此时将服务端设置为自己向自己发送消息。</li><li>发送更新shard消息时，由于网络不稳定，有时一直无法得到结果（call不通，不返回false，也没有reply）。解决方法：每次都随机在GRoup挑选一个进行发送，使得不会因为一个机器网络问题而一直不对后面机器进行尝试。</li><li>因为网络问题，shard数据已经发送成功，但返回结果时出现问题，且接收端应用了新配置，导致后面不断发送shard分片数据时，返回错误结果。解决方法：条件判定出错了，应该先判断是否为旧分片数据（使用confignum判断），然后再判断当前配置是否允许接受改分片</li><li>服务器重启后，日志还未重放完，此时发送shard数据从而导致数据缺失（一些操作已经返回操作成功结果，导致客户端不会在新服务器请求）。解决方法：设置一个是否重放完成标志，并在创建服务器后插入一条特殊日志，当应用到特殊日志时，就将标志设为true，在检测配置循环中，每次都判断标志。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式存储 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mymuduo</title>
      <link href="/2023/02/15/%E9%A1%B9%E7%9B%AE/mymuduo/"/>
      <url>/2023/02/15/%E9%A1%B9%E7%9B%AE/mymuduo/</url>
      
        <content type="html"><![CDATA[<p><em>根据<strong>剖析muduo网络库核心代码</strong>项目所写</em>, <a href="https://fixbug.ke.qq.com/">视频地址</a></p><hr><hr><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><p><strong>知识储备</strong></p><ul><li>1、TCP协议和UDP协议</li><li>2、TCP编程和UDP编程步骤</li><li>3、IO复用接口编程select、poll、epoll编程</li><li>4、Linux的多线程编程pthread、进程和线程模型 C++20标准加入了协程的支持</li></ul><h2 id="1-1-阻塞、非阻塞、同步、异步"><a href="#1-1-阻塞、非阻塞、同步、异步" class="headerlink" title="1.1 阻塞、非阻塞、同步、异步"></a>1.1 <strong>阻塞、非阻塞、同步、异步</strong></h2><blockquote><p>典型的一次IO的两个阶段是什么？ 数据准备 和 数据读写</p></blockquote><p> 在数据准备上，根据系统IO操作的就绪状态可以分为：</p><ul><li>阻塞：调用IO方法的线程会进入阻塞状态。比如epoll_wait（阻塞类sockfd），调用此方法，会使得线程被阻塞</li><li>非阻塞：调用IO方法的线程不会进入阻塞状态，不改变线程的状态，其通过调用方法返回值进行判断。</li></ul><p>在数据读写上，根据应用程序和内核的交互方式可以分为：</p><ul><li>同步：当前线程需要等待数据读写完成才能进行下一步操作。例如，当epoll_wait返回之后使用recv去读数据，此时需要等recv读完数据才能进行下一步操作</li><li>异步：当前线程将数据读写工作交给其他线程（如内核），读写操作完成后再通知当前线程，其无需等待当前线程完成就能进行下一步操作（在IO异步上一般都需要操作系统提供支持，如Linux下使用aio_read）。</li></ul><p><strong>陈硕大神原话：在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步IO。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328153046452.png"></p><p><strong>总结</strong>：无论是同步异步、阻塞非阻塞，其差异都是等待任务完成或不等任务完成而是完成后发出通知提醒（等通知，这通知是系统级别实现，而无需死等。如果应用层面则也可以是回调）。</p><p>上面说的同步异步指的是IO层级，应用级别的同步异步也一样（比如A需要处理任务，A向B传入需要处理的任务和任务结束后的回调函数，B在任务处理完后进行回调）</p><blockquote><p><strong>作者总结</strong>：</p><ul><li><p>一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪”和“数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。</p></li><li><p>同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。</p></li></ul></blockquote><h2 id="1-2-Unix-x2F-Linux上的五种IO模型"><a href="#1-2-Unix-x2F-Linux上的五种IO模型" class="headerlink" title="1.2 Unix&#x2F;Linux上的五种IO模型"></a>1.2 <strong>Unix&#x2F;Linux上的五种IO模型</strong></h2><p><strong>（同步）阻塞blocking</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105628921.png"></p><p><strong>同步非阻塞 non-blocking</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105721152.png"></p><p><strong>IO复用（IO multiplexing）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105734893.png"></p><p><strong>信号驱动（signal-driven）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105744974.png"></p><p>内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。</p><p><strong>异步不阻塞（asynchronous）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105758521.png"></p><p>aio_read所使用的结构体</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">aiocb</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> aio_fildesoff_t aio_offset<span class="token keyword">volatile</span> <span class="token keyword">void</span> <span class="token operator">*</span>aio_bufsize_t aio_nbytes<span class="token keyword">int</span> aio_reqprio<span class="token keyword">struct</span> <span class="token class-name">sigevent</span> aio_sigevent <span class="token comment">//信号量</span><span class="token keyword">int</span> aio_lio_opcode<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-好的网络服务器设计"><a href="#1-3-好的网络服务器设计" class="headerlink" title="1.3 好的网络服务器设计"></a>1.3 <strong>好的网络服务器设计</strong></h2><blockquote><p>在这个多核时代，服务端网络编程如何选择线程模型呢？ 赞同libev作者的观点：one loop per thread is usually a good model，这样多线程服务端编程的问题就转换为如何设计一个高效且易于使用的event loop，然后每个线程run一个event loop就行了（当然线程间的同步、互斥少不了，还有其它的耗时事件需要起另外的线程来做）。</p></blockquote><p>event loop 是 non-blocking 网络编程的核心，在现实生活中，non-blocking 几乎总是和 IO multiplexing 一起使用，原因有两点：</p><ul><li><p>没有人真的会用轮询 (busy-pooling) 来检查某个 non-blocking IO 操作是否完成，这样太浪费</p><p>CPU资源了。</p></li><li><p>IO-multiplex 一般不能和 blocking IO 用在一起，因为 blocking IO 中read() &#x2F;write() &#x2F;accept() &#x2F;connect() 都有可能阻塞当前线程，这样线程就没办法处理其他 socket上的 IO 事件了。</p></li></ul><p>所以，当我们提到 non-blocking 的时候，实际上指的是 non-blocking + IO-multiplexing，单用其中任何一个都没有办法很好的实现功能。（这里的非阻塞主要指的还是异步，是指在当前线程中除了IO复用时进行阻塞，其他操作都不能阻塞当前线程，其实就是把处理事件交给其他线程</p><blockquote><p>epoll + fork不如epoll + pthread？</p><p>强大的nginx服务器采用了epoll+fork模型作为网络模块的架构设计，实现了简单好用的负载算法，使各个fork网络进程不会忙的越忙、闲的越闲，并且通过引入一把乐观锁解决了该模型导致的<strong>服务器惊群</strong>现象，功能十分强大。</p></blockquote><h2 id="1-4-Reactor模型"><a href="#1-4-Reactor模型" class="headerlink" title="1.4 Reactor模型"></a>1.4 <strong>Reactor模型</strong></h2><blockquote><p>The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.</p></blockquote><p><strong>重要组件</strong>：<strong>Event事件、Reactor反应堆、Demultiplex事件分发器（应该叫事件解码器，将多个事件进行聚合，如epoll）、Evanthandler事件处理器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024113236711.png"></p><p>muduo库的Multiple Reactors模型如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024113253413.png"></p><p>在这个模型中，其实是将reactor和demultiplex都结合到reactor中，mainReactor将事件进一步细分到subReactor中（例如mainReactor负责新用户的链接，然后将这些链接分发到subReactor中）</p><h2 id="1-5-epoll"><a href="#1-5-epoll" class="headerlink" title="1.5 epoll"></a>1.5 <strong>epoll</strong></h2><p><strong>select的缺点</strong></p><ul><li>1、单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，当然可以更改数量，但由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；(在linux内核头文件中，有这样的定义：#define __FD_SETSIZE 1024</li><li>2、内核 &#x2F; 用户空间内存拷贝问题，select需要复制大量的句柄数据结构，产生巨大的开销</li><li>3、select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件</li><li>4、select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程（也不能算缺点，只是不支持ET）</li></ul><p>相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依</p><p>然存在。</p><blockquote><p>以select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核&#x2F;用户空间大量的句柄结构内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到100万级别的并发访问，是一个很难完成的任务。</p></blockquote><p><strong>epoll原理以及优势</strong></p><blockquote><p><strong>设想一下如下场景</strong>：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p><p>在select&#x2F;poll时代，服务器进程每次都把这100万个连接告诉操作系统（从用户态复制句柄数据结构到内核态），让操作系统内核去查询这些套接字上是否有事件发生，轮询完成后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select&#x2F;poll一般只能处理几千的并发连接。</p></blockquote><p>epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统（文件系统一般用什么数据结构实现？B+树，磁盘IO消耗低，效率很高）。把原先的select&#x2F;poll调用分成以下3个部分：</p><ul><li>调用epoll_create()建立一个epoll对象（在epoll文件系统中为这个句柄对象分配资源）</li><li>调用epoll_ctl向epoll对象中添加这100万个连接的套接字</li><li>调用epoll_wait收集发生的事件的fd资源</li></ul><p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除事件。</p><p>epoll_wait的效率也非常高，因为调用epoll_wait时，并没有向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接（猜测当内核得知某sockfd有消息时，会去epoll中找到对应的sockfd进行标记，而epoll的实现使得查找非常块）。</p><p>epoll_create在内核上创建的eventpoll结构如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> rbr<span class="token punctuation">;</span><span class="token comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span><span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdlist<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>LT模式</strong></p><p>内核数据没被读完，就会一直上报数据。</p><p><strong>ET模式</strong></p><p>内核数据只上报一次。</p><p><strong>muduo采用的是LT</strong></p><ul><li>不会丢失数据或者消息<ul><li>应用没有读取完数据，内核是会不断上报的</li></ul></li><li>低延迟处理<ul><li>每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息</li></ul></li><li>跨平台处理<ul><li>像select一样可以跨平台使用</li></ul></li></ul><h1 id="2-muduo"><a href="#2-muduo" class="headerlink" title="2. muduo"></a>2. muduo</h1><p>muduo主要分为了以下几大类：</p><ul><li><strong>Channel</strong>：封装了每个sockfd设置感兴趣事件和对发生事件的处理，其成员主要包括fd、events、revents、callbacks </li><li><strong>Poller</strong>：封装系统IO复用的通用接口，其主要成员包括ownerLoop、记录注册的channels<ul><li><strong>EPollPoller</strong>：Poller类的派生类，使用epoll实现了Poller类的各种接口，其成员包括epollfd、记录发生事件的events_</li></ul></li><li><strong>EventLoop</strong>：是一个Reactor，其作为Poller类和Channel类的使用者，Poller和Channel的通信都是通过EventLoop来完成，其使用Poller类来获得发生事件的Channel，然后调用Channel的相应回调。<ul><li>主要成员包括poller、wakeupfd（唤醒当前Eventloop）、activeChannels_(记录发生事件的channel)、pendingFuctors_（当前需要执行的回调）。</li></ul></li><li><strong>Thread</strong>：封装了线程创建、线程启动等线程基础操作</li><li><strong>EventLoopThread</strong>：将EventLoop和Thread绑定，封装成一个Thread执行一个loop<ul><li><strong>EventLoopThreadPool</strong>：EventLoopThread的线程池封装，使得mainLoop更方便进行subLoop任务的分发</li></ul></li><li><strong>Socket</strong>：封装socket的常用操作，如设置非阻塞、监听、noDelay等，但并不包含创建sockfd</li><li><strong>Acceptor</strong>：主要封装了listenfd相关的操作，其监听新连接用户，并分发给subLoop</li><li><strong>Buffer</strong>：封装缓冲区常见操作，其内部是一个char类型的vector</li><li><strong>TcpConnection</strong>：封装一个连接信息，其内包含本地地址、对端地址、socket、channel、以及读写buffer</li><li><strong>TcpServer</strong>：上述所有类的综合使用者，用户通过使用此类来设置各种回调，通过此类来管理subLoop个数等</li></ul><p><strong>读</strong>：</p><ul><li>设置读事件回调</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110214049385.png"></p><ul><li>当读事件发生</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110214042301.png"></p><p><strong>写</strong>：</p><ul><li><p>发送数据</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110215931048.png"></p></li><li><p>当写事件发生：和读事件发生流程一样，只是最后一步执行的writeCallback</p></li></ul><p><strong>新用户到来</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110214730307.png"></p><p><strong>服务器启动</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110215755177.png"></p><p>流程图都在飞书的processon上</p><h2 id="2-1-Channel"><a href="#2-1-Channel" class="headerlink" title="2.1 Channel"></a>2.1 Channel</h2><p>封装了每个sockfd设置感兴趣事件函数和对发生事件的处理，注意！Channel不直接与Poller打交道，其通过EventLoop来与Poller进行通信，比如向Poller中设置感兴趣事件，Poller返回事件等。</p><p>通过设置sockfd的各种回调，当有事件发生时，Poller调用每个事件对应channel的<em>HandleEvent</em>函数进行判断处理发生了哪些事件以及调用相应回调</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//这三个是作为事件标识</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kNoneEvent<span class="token punctuation">;</span>   <span class="token comment">// 0</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kReadEvent<span class="token punctuation">;</span>   <span class="token comment">// EPOLLIN | EPOLLPRI</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kWriteEvent<span class="token punctuation">;</span>  <span class="token comment">// EPOLLOUT;</span>EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>  <span class="token comment">//事件循环</span><span class="token keyword">const</span> <span class="token keyword">int</span> fd_<span class="token punctuation">;</span>     <span class="token comment">//监听的sockfd</span><span class="token keyword">int</span> revents_<span class="token punctuation">;</span>      <span class="token comment">//返回的事件</span><span class="token keyword">int</span> events_<span class="token punctuation">;</span>       <span class="token comment">// sockfd上监听的事件</span><span class="token keyword">int</span> index_<span class="token punctuation">;</span>  <span class="token comment">// 此Poller的状态，如新添加、已删除等，主要是用于Poller中判断状态</span><span class="token comment">//绑定TcpConnection对象的弱引用，可用于判断对象是否存活和得到shared指针</span><span class="token comment">//用于观察注册回调的TcpConnection对象是否存活，避免调用回调函数时出错</span>std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> tie_<span class="token punctuation">;</span><span class="token keyword">bool</span> tied_<span class="token punctuation">;</span>  <span class="token comment">//是否绑定标志</span><span class="token comment">//用于处理revents的四种回调函数</span>ReadEventCallback readCallback_<span class="token punctuation">;</span>EventCallback writeCallback_<span class="token punctuation">;</span>EventCallback closeCallback_<span class="token punctuation">;</span>EventCallback errorCallback_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> EventCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token keyword">using</span> ReadEventCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>Timestamp<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token function">Channel</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">Channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fd得到poller通知以后，处理事件的函数</span> <span class="token keyword">void</span> <span class="token function">HandleEvent</span><span class="token punctuation">(</span>Timestamp receiveTime<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置回调函数</span> <span class="token keyword">void</span> <span class="token function">setReadCallback</span><span class="token punctuation">(</span>ReadEventCallback cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   readCallback_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">//这里使用move感觉没啥用，除非function中有申请的资源</span> <span class="token keyword">void</span> <span class="token function">setWriteCallback</span><span class="token punctuation">(</span>EventCallback cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> writeCallback_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">setCloseCallback</span><span class="token punctuation">(</span>EventCallback cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> closeCallback_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">setErrorCallback</span><span class="token punctuation">(</span>EventCallback cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> errorCallback_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//绑定TcpConnection对象，防止当TcpConnection对象被手动remove后，channel还在执行回调操作</span> <span class="token keyword">void</span> <span class="token function">tie</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> fd_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//获取当前设置的Event</span> <span class="token keyword">int</span> <span class="token function">events</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> events_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//供poller设置发生事件</span> <span class="token keyword">int</span> <span class="token function">setRevents</span><span class="token punctuation">(</span><span class="token keyword">int</span> revt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> revents_ <span class="token operator">=</span> revt<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>   <span class="token comment">//设置或取消读 写事件:</span> <span class="token keyword">void</span> <span class="token function">enableReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   events_ <span class="token operator">|=</span> kReadEvent<span class="token punctuation">;</span>   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">disableReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   events_ <span class="token operator">&amp;=</span> <span class="token operator">~</span>kReadEvent<span class="token punctuation">;</span>   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">enableWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   events_ <span class="token operator">|=</span> kWriteEvent<span class="token punctuation">;</span>   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">disableWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   events_ <span class="token operator">&amp;=</span> <span class="token operator">~</span>kWriteEvent<span class="token punctuation">;</span>   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">disableAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   events_ <span class="token operator">=</span> kNoneEvent<span class="token punctuation">;</span>   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//判断当前事件状态，是否设置读或写事件或无事件</span> <span class="token keyword">bool</span> <span class="token function">isWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> events_ <span class="token operator">&amp;</span> kWriteEvent<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">bool</span> <span class="token function">isReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> events_ <span class="token operator">&amp;</span> kReadEvent<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">bool</span> <span class="token function">isNoneEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> events_ <span class="token operator">==</span> kNoneEvent<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//得到Channel状态</span> <span class="token keyword">int</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> index_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//设置Channel状态</span> <span class="token keyword">void</span> <span class="token function">setIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> index_ <span class="token operator">=</span> index<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//返回此channel所属的eventloop</span> EventLoop <span class="token operator">*</span><span class="token function">ownerLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> loop_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//在所属的eventloop移除此channel</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//更新poller中对应的channel的事件</span> <span class="token comment">//安全的处理事件，作为handleEvent函数的底层函数</span> <span class="token keyword">void</span> <span class="token function">handleEventWithGuard</span><span class="token punctuation">(</span>Timestamp receiveTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-Poller"><a href="#2-2-Poller" class="headerlink" title="2.2 Poller"></a>2.2 Poller</h2><h3 id="2-2-1-Poller基类"><a href="#2-2-1-Poller基类" class="headerlink" title="2.2.1 Poller基类"></a>2.2.1 Poller基类</h3><p>主要封装统一IO复用的接口，以便实现Poll、Epoll等。其成员比较简单，就一个channels记录管理的channel和ownerLoop记录所属的EventLoop</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">protected</span><span class="token operator">:</span> <span class="token comment">// key:sockfd value:sockfd所属的channel通道类型</span> <span class="token keyword">using</span> ChannelMap <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> Channel <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span> ChannelMap channels_<span class="token punctuation">;</span><span class="token comment">//记录管理的Channel</span><span class="token keyword">private</span><span class="token operator">:</span> EventLoop <span class="token operator">*</span>ownerLoop_<span class="token punctuation">;</span><span class="token comment">//记录poller绑定的EventLoop</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> ChannelList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Channel <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token function">Poller</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Poller</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">//统一IO复用接口，扩展类如select、poll和Epoll都必须实现这几个接口</span> <span class="token keyword">virtual</span> Timestamp <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">int</span> timeousMs<span class="token punctuation">,</span> ChannelList <span class="token operator">*</span>activeChannels<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">updateChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">removeChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//判断channel是否存在此poller中</span> <span class="token keyword">bool</span> <span class="token function">hasChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">// eventloop通过该接口获取默认的IO复用的具体实现</span> <span class="token comment">//为避免基类引用派生类头文件，此函数是在一个单独的cc文件中进行实现</span> <span class="token keyword">static</span> Poller <span class="token operator">*</span><span class="token function">newDefaultPoller</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><p>hasChannel函数中通过判断channel指针避免了由于sockfd复用而导致的错乱情况</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token class-name">Poller</span><span class="token double-colon punctuation">::</span><span class="token function">hasChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> it<span class="token operator">=</span>channels_<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>channel<span class="token operator">-></span><span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//it->second==channel应该是为了避免sockfd被复用时而channel不对的情况</span>    <span class="token keyword">return</span> it<span class="token operator">!=</span>channels_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>it<span class="token operator">-></span>second<span class="token operator">==</span>channel<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-2-EPollPoller"><a href="#2-2-2-EPollPoller" class="headerlink" title="2.2.2 EPollPoller"></a>2.2.2 EPollPoller</h3><p>基于Poller接口实现了Epoll，相比Poller，主要增加了epollfd和events成员以及epoll常用函数的封装</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> EventList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>epoll_event<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">int</span> epollfd_<span class="token punctuation">;</span><span class="token comment">//epoll的fd</span>EventList events_<span class="token punctuation">;</span><span class="token comment">//记录epoll返回的发生事件</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kInitEventListSize <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>  <span class="token comment">//给events的初始长度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token function">EPollPoller</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">EPollPoller</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>  <span class="token comment">//重写Poller的抽象方法</span> Timestamp <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">int</span> timeoutMs<span class="token punctuation">,</span> ChannelList <span class="token operator">*</span>activeChannels<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">updateChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">removeChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">//将poll返回的发生事件的channel写入到activeChannels中</span> <span class="token keyword">void</span> <span class="token function">fillActiveChannels</span><span class="token punctuation">(</span><span class="token keyword">int</span> numEvents<span class="token punctuation">,</span> ChannelList <span class="token operator">*</span>activeChannels<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">//更新channel通道设置的事件</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> operation<span class="token punctuation">,</span> Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-EventLoop"><a href="#2-3-EventLoop" class="headerlink" title="2.3 EventLoop"></a>2.3 EventLoop</h2><p>EventLoop相当于提供了一个Reactor，通过Poller来获取发生的事件，再调用相应的channel的回调函数</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> ChannelList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Channel <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>atomic_bool looping_<span class="token punctuation">;</span>  <span class="token comment">//原子操作，通过CAS实现</span>std<span class="token double-colon punctuation">::</span>atomic_bool quit_<span class="token punctuation">;</span>     <span class="token comment">//标志是否退出loop循环</span><span class="token keyword">const</span> pid_t threadId_<span class="token punctuation">;</span>      <span class="token comment">//当前loop所在线程id</span>Timestamp pollReturnTime_<span class="token punctuation">;</span>  <span class="token comment">// poller返回发生事件的时间点</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Poller<span class="token operator">></span> poller_<span class="token punctuation">;</span><span class="token comment">//唤醒当前loop所在线程的fd</span><span class="token keyword">int</span> wakeupFd_<span class="token punctuation">;</span>  <span class="token comment">//当mainLoop获取新用户channel时，通过轮询算法选择一个subloop，通过该成员唤醒subLoop处理channel</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Channel<span class="token operator">></span> wakeupChanel_<span class="token punctuation">;</span>  <span class="token comment">// wakeupfd_的channel的指针</span>ChannelList activeChannels_<span class="token punctuation">;</span>  <span class="token comment">//记录发生事件的所有channel</span>Channel <span class="token operator">*</span>currentActiveChannel_<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>atomic_bool callingPendingFuctors_<span class="token punctuation">;</span>  <span class="token comment">//当前loop是否有需要执行的回调操作</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Functor<span class="token operator">></span> pendingFuctors_<span class="token punctuation">;</span>  <span class="token comment">//存储loop需要执行的所有回调操作</span>std<span class="token double-colon punctuation">::</span>mutex mutex_<span class="token punctuation">;</span>  <span class="token comment">//保护pendingFuctors_的线程安全操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> Functor <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token function">EventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">EventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//开启事件循环</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//退出事件循环</span> <span class="token keyword">void</span> <span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Timestamp <span class="token function">pollReturnTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> pollReturnTime_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//在当前loop中执行</span> <span class="token keyword">void</span> <span class="token function">runInLoop</span><span class="token punctuation">(</span>Functor cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//把cb放入队列中，唤醒loop所在的线程，再执行cb</span> <span class="token keyword">void</span> <span class="token function">queueInLoop</span><span class="token punctuation">(</span>Functor cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//唤醒loop所在线程</span> <span class="token keyword">void</span> <span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// eventloop使用poller对channel操作的方法</span> <span class="token keyword">void</span> <span class="token function">updateChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">removeChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">bool</span> <span class="token function">hasChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//判断eventloop对象是否在自己线程中</span> <span class="token keyword">bool</span> <span class="token function">isInLoopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> threadId_ <span class="token operator">==</span> <span class="token class-name">CurrentThread</span><span class="token double-colon punctuation">::</span><span class="token function">tid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token function">handleRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// wakeupfd_的读回调函数</span> <span class="token keyword">void</span> <span class="token function">doPendingFunctors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//执行需要执行的回调操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-Thread"><a href="#2-4-Thread" class="headerlink" title="2.4 Thread"></a>2.4 Thread</h2><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> started_<span class="token punctuation">;</span><span class="token comment">//是否已经启动</span><span class="token keyword">bool</span> joined_<span class="token punctuation">;</span><span class="token comment">//是否join</span><span class="token comment">//使用智能指针，避免使用thread初始化是就开始启动线程</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">></span> thread_<span class="token punctuation">;</span>pid_t tid_<span class="token punctuation">;</span><span class="token comment">//记录线程id</span>ThreadFunc func_<span class="token punctuation">;</span><span class="token comment">//线程执行的回调函数</span>std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span><span class="token comment">//线程名</span><span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>atomic_int numCreated_<span class="token punctuation">;</span><span class="token comment">//现有线程创建个数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> ThreadFunc <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token keyword">explicit</span> <span class="token function">Thread</span><span class="token punctuation">(</span>ThreadFunc<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//启动线程</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取线程是否启动</span> <span class="token keyword">bool</span> <span class="token function">started</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> started_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//获取线程id</span> pid_t <span class="token function">tid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> tid_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//获取设置的线程名</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> name_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//获取当前通过Thread创建的线程数量</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numCreated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> numCreated_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token function">setDefaultName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//一个thread对象记录的就是一个新线程的详细信息</span><span class="token keyword">void</span> <span class="token class-name">Thread</span><span class="token double-colon punctuation">::</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  started_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  sem_t sem<span class="token punctuation">;</span>  <span class="token comment">//信号量 muduo书中说多线程别用信号量？？</span>  <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//开启线程，</span>  thread_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//获取线程的tid值</span>    tid_ <span class="token operator">=</span> <span class="token class-name">CurrentThread</span><span class="token double-colon punctuation">::</span><span class="token function">tid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//开启一个新线程，专门执行该线程函数</span>    <span class="token function">func_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//必须等待上面新创建的线程的tid值</span>  <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5-EventLoopThread"><a href="#2-5-EventLoopThread" class="headerlink" title="2.5 EventLoopThread"></a>2.5 EventLoopThread</h2><p>将EventLoop和Thread绑定，封装成一个Thread执行一个loop</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span><span class="token keyword">bool</span> exiting_<span class="token punctuation">;</span>      <span class="token comment">//线程是否正在退出</span>Thread thread_<span class="token punctuation">;</span>     <span class="token comment">//线程</span>std<span class="token double-colon punctuation">::</span>mutex mutex_<span class="token punctuation">;</span>  <span class="token comment">//互斥访问loop_</span>std<span class="token double-colon punctuation">::</span>condition_variable cond_<span class="token punctuation">;</span>  <span class="token comment">//条件变量，用于是否已经成功创建通信</span>ThreadInitCallback callback_<span class="token punctuation">;</span>  <span class="token comment">//上层设置的回调函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> ThreadInitCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token function">EventLoopThread</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadInitCallback <span class="token operator">&amp;</span>cb <span class="token operator">=</span> <span class="token function">ThreadInitCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                 <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">EventLoopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建线程，启动loop</span> EventLoop <span class="token operator">*</span><span class="token function">startLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">//线程创建时传入的回调函数，里面进行创建loop等操作</span> <span class="token keyword">void</span> <span class="token function">threadFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-1-EventLoopThreadPool"><a href="#2-5-1-EventLoopThreadPool" class="headerlink" title="2.5.1 EventLoopThreadPool"></a>2.5.1 EventLoopThreadPool</h3><p>封装成一个线程池，使得TcpServer能更方便管理多个subLoop。</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// mainReactor，设置这个成员是考虑轮询算法寻找subLoop时，当不存在subLoop时能将mainLoop作为作为返回结果</span>EventLoop <span class="token operator">*</span>baseLoop_<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span><span class="token keyword">bool</span> started_<span class="token punctuation">;</span><span class="token keyword">int</span> numThreads_<span class="token punctuation">;</span><span class="token comment">//轮询时下一个位置指向</span><span class="token keyword">int</span> next_<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>EventLoopThread<span class="token operator">>></span> threads_<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>EventLoop <span class="token operator">*</span><span class="token operator">></span> loops_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> ThreadInitCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token function">EventLoopThreadPool</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>baseLoop<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>nameArg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">EventLoopThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setThreadNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> numThreads<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> numThreads_ <span class="token operator">=</span> numThreads<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadInitCallback <span class="token operator">&amp;</span>cb <span class="token operator">=</span> <span class="token function">ThreadInitCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//如果工作在多线程中，baseLoop以轮询方式分配channel给subloop</span> EventLoop <span class="token operator">*</span><span class="token function">getNextLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>EventLoop <span class="token operator">*</span><span class="token operator">></span> <span class="token function">getAllLoops</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">bool</span> <span class="token function">started</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> started_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> name_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">EventLoopThreadPool</span><span class="token double-colon punctuation">::</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadInitCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  started_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numThreads_<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>name_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> buf<span class="token punctuation">,</span> <span class="token string">"%s%d"</span><span class="token punctuation">,</span> name_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    EventLoopThread <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">EventLoopThread</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    threads_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>EventLoopThread<span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//底层创建线程，绑定一个新的Eventloop，并记录该loop地址</span>    loops_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token operator">-></span><span class="token function">startLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//没有创建其他线程，只有一个mainLoop</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>numThreads_ <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">cb</span><span class="token punctuation">(</span>baseLoop_<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//如果用户传了cb则需执行下回调******************</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-6-Socket"><a href="#2-6-Socket" class="headerlink" title="2.6 Socket"></a>2.6 Socket</h2><p>Socket封装socket的常用操作，如设置非阻塞、监听、noDelay等，但并不包含创建sockfd。</p><p>注意与Channel的区别，Channel是管理事件和事件发生回调，而Socket则设置socket的属性、绑定监听等</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> sockfd_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">explicit</span> <span class="token function">Socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">sockfd_</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">~</span><span class="token function">Socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> sockfd_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">bindAddress</span><span class="token punctuation">(</span><span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>localAddr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span>InetAddress <span class="token operator">*</span>peeraddr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">shutdownWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置不等待而直接发送</span> <span class="token keyword">void</span> <span class="token function">setTcpNoDelay</span><span class="token punctuation">(</span><span class="token keyword">bool</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置端口释放后立即就可以被再次使用</span> <span class="token keyword">void</span> <span class="token function">setReuseAddr</span><span class="token punctuation">(</span><span class="token keyword">bool</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//允许许多个线程或进程，绑定在同一个端口上</span> <span class="token keyword">void</span> <span class="token function">setReusePort</span><span class="token punctuation">(</span><span class="token keyword">bool</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置是否开启心跳</span> <span class="token keyword">void</span> <span class="token function">setKeepAlive</span><span class="token punctuation">(</span><span class="token keyword">bool</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-7-Acceptor"><a href="#2-7-Acceptor" class="headerlink" title="2.7 Acceptor"></a>2.7 Acceptor</h2><p>封装了listenfd相关的操作，其监听新连接用户，并分发给subLoop</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>  <span class="token comment">// acceptor使用的用户定义的loop，也叫mainloop</span>Socket acceptSocket_<span class="token punctuation">;</span><span class="token comment">//listenfd对应的socket</span>Channel acceptChannel_<span class="token punctuation">;</span><span class="token comment">//listenfd对应的channel</span>NewConnectionCallback newConnectionCallback_<span class="token punctuation">;</span>  <span class="token comment">//当有新连接到来，需要做的回调</span><span class="token keyword">bool</span> listenning_<span class="token punctuation">;</span><span class="token comment">//是否监听标志</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> NewConnectionCallback <span class="token operator">=</span>     std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token function">Acceptor</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>listenAddr<span class="token punctuation">,</span> <span class="token keyword">bool</span> reuseport<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">Acceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setNewConnectionCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> NewConnectionCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   newConnectionCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">bool</span> <span class="token function">listenning</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> listenning_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//开始监听</span> <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">// listenfd有事件发生即有新用户连接，调用此函数</span> <span class="token keyword">void</span> <span class="token function">handleRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// listenfd有事件发生即有新用户连接，调用此函数</span><span class="token keyword">void</span> <span class="token class-name">Acceptor</span><span class="token double-colon punctuation">::</span><span class="token function">handleRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  InetAddress peerAddr<span class="token punctuation">;</span>  <span class="token keyword">int</span> connfd <span class="token operator">=</span> acceptSocket_<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>peerAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>connfd <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newConnectionCallback_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//轮询找到subloop，将其唤醒，分发当前客户端的channel</span>      <span class="token function">newConnectionCallback_</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> peerAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token double-colon punctuation">::</span><span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"%s:%s:%d accept err:%d \n"</span><span class="token punctuation">,</span> <span class="token constant">__FILE__</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span>              errno<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// EMFILE表示服务器sockfd资源用完</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EMFILE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"%s:%s:%d sockfd reached limit \n"</span><span class="token punctuation">,</span> <span class="token constant">__FILE__</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">,</span>                <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-8-Buffer"><a href="#2-8-Buffer" class="headerlink" title="2.8 Buffer"></a>2.8 <strong>Buffer</strong></h2><p>封装缓冲区常见操作，其内部是一个char类型的vector</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer</span><span class="token comment">///</span><span class="token comment">/// @code</span><span class="token comment">/// +-------------------+------------------+------------------+</span><span class="token comment">/// | prependable bytes |  readable bytes  |  writable bytes  |</span><span class="token comment">/// |                   |     (CONTENT)    |                  |</span><span class="token comment">/// +-------------------+------------------+------------------+</span><span class="token comment">/// |                   |                  |                  |</span><span class="token comment">/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> buffer_<span class="token punctuation">;</span>  <span class="token comment">//缓冲区</span>size_t readerIndex_<span class="token punctuation">;</span>        <span class="token comment">//可读位置</span>size_t writerIndex_<span class="token punctuation">;</span>        <span class="token comment">//可写位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">static</span> <span class="token keyword">const</span> size_t kCheapPrepend <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token keyword">static</span> <span class="token keyword">const</span> size_t kInitialSize <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token keyword">explicit</span> <span class="token function">Buffer</span><span class="token punctuation">(</span>size_t initialSize <span class="token operator">=</span> kInitialSize<span class="token punctuation">)</span>     <span class="token operator">:</span> <span class="token function">buffer_</span><span class="token punctuation">(</span>kCheapPrepend <span class="token operator">+</span> initialSize<span class="token punctuation">)</span><span class="token punctuation">,</span>       <span class="token function">readerIndex_</span><span class="token punctuation">(</span>kCheapPrepend<span class="token punctuation">)</span><span class="token punctuation">,</span>       <span class="token function">writerIndex_</span><span class="token punctuation">(</span>kCheapPrepend<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//可读数据长度</span> size_t <span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> writerIndex_ <span class="token operator">-</span> readerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//可写数据长度</span> size_t <span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> buffer_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> writerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//预留空间长度，初始的预留空间是为消息长度而准备</span> size_t <span class="token function">prependableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> readerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//返回缓冲区中可读地址的起始地址</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> readerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//读取len长度后调用此函数</span> <span class="token keyword">void</span> <span class="token function">retrieve</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">//如果数据没读完</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     readerIndex_ <span class="token operator">+=</span> len<span class="token punctuation">;</span>  <span class="token comment">//应用只读取了可读缓冲区的一部分，</span>   <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>     <span class="token function">retrieveAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//已经读完，需将缓冲区复位为初始状态</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">retrieveAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> readerIndex_ <span class="token operator">=</span> writerIndex_ <span class="token operator">=</span> kCheapPrepend<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//把onMessage函数上报的buffer数据，转成string类型返回</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">retrieveAllAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">return</span> <span class="token function">retrieveAsString</span><span class="token punctuation">(</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">retrieveAsString</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   std<span class="token double-colon punctuation">::</span>string <span class="token function">result</span><span class="token punctuation">(</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//上面已经把缓冲区的数据读出，需要对缓冲区进行复位操作</span>   <span class="token function">retrieve</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> result<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//确保len长度的数据能被写入</span> <span class="token keyword">void</span> <span class="token function">ensureWriteableBytes</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token function">makeSpace</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//把data中的len长的数据添加到缓冲区中</span> <span class="token keyword">void</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> data<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">ensureWriteableBytes</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span><span class="token function">copy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> data <span class="token operator">+</span> len<span class="token punctuation">,</span> <span class="token function">beginWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   writerIndex_ <span class="token operator">+=</span> len<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//从fd上读取数据</span> size_t <span class="token function">readFd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> saveErrno<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//通过fd发送数据</span> size_t <span class="token function">writeFd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> saveErrno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">//返回buffer首元素地址，即数组的起始地址，&amp;*不能抵消，因为*被重写过</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token operator">*</span>buffer_<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token operator">*</span>buffer_<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//通过整理buffer空间或增加buffer空间使得容量够写</span> <span class="token keyword">void</span> <span class="token function">makeSpace</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">//如果可写空间加上前面预留空间（预留空间可能由于依次被读完而变长）还是小于要求的长度</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">prependableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> len <span class="token operator">+</span> kCheapPrepend<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     buffer_<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>writerIndex_ <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>     <span class="token comment">//如果数据空间够用，则将现有数据前移</span>     size_t readable <span class="token operator">=</span> <span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> readerIndex_<span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>               <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> kCheapPrepend<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//返回可写处的指针</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">beginWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> writerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">beginWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> writerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * @brief 从fd上读取数据  低层的Poller工作在LT模式 * buffer缓冲区有大小，但是从fd上读数据时，却不知道tcp数据最终的大小， * 如果不断将buffer进行扩容，效率很低;而如果预先就设为很大空间，当用户数量很多时，内存容量消耗极大 * 因此，使用一个栈上临时变量来存储现有缓冲区不够存的数据，最后将其写入缓冲区中 * @param fd sockfd * @param saveErrno 错误 * @return size_t 成功读取大小 */</span>size_t <span class="token class-name">Buffer</span><span class="token double-colon punctuation">::</span><span class="token function">readFd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> saveErrno<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> extrabuf<span class="token punctuation">[</span><span class="token number">65536</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">//栈上空间 64k</span>  <span class="token keyword">struct</span> <span class="token class-name">iovec</span> vec<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// buffer缓冲区剩余的可写空间大小</span>  <span class="token keyword">const</span> size_t writeable <span class="token operator">=</span> <span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_base <span class="token operator">=</span> <span class="token function">beginWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_len <span class="token operator">=</span> writeable<span class="token punctuation">;</span>  vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_base <span class="token operator">=</span> extrabuf<span class="token punctuation">;</span>  vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_len <span class="token operator">=</span> <span class="token keyword">sizeof</span> extrabuf<span class="token punctuation">;</span>  <span class="token comment">/**************************************************************************/</span>  <span class="token comment">//当缓冲区可写空间小于extrabuf时，使用buffer和extrabuf一起作为readv写入的空间</span>  <span class="token comment">//反之，如果可写空间大于extrabuf空间时，就没有必要再使用一个extrabuf来作为暂存了</span>  <span class="token comment">//因为buffer在写入数据时，如果空间不够会自动扩容为原来2倍，而即使加上一个extrabuf能存储的数据也没有扩容后的大</span>  <span class="token comment">//这样效率效率还没有直接使用一个buffer让其自动扩容效率高，毕竟buffer</span>  <span class="token comment">//resize时也会进行拷贝复制</span>  <span class="token comment">//使用extra就会在readv中写入一次数据，还需再将其拷贝到buffer中，而不使用的话就是只有readv将数据写入到buf中</span>  <span class="token comment">// extrabuf的使用原因是为了避免buffer不断扩容而导致效率低</span>  <span class="token comment">//这里不用担心如果空间不够存，使用的是LT模式，没读完的数据后面会不断唤醒读</span>  <span class="token keyword">const</span> <span class="token keyword">int</span> iovcnt <span class="token operator">=</span> <span class="token punctuation">(</span>writeable <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span> extrabuf<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// readv能自动将数据写入到多个缓冲区中，缓冲区都在vec数组中</span>  <span class="token keyword">const</span> size_t n <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">readv</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> vec<span class="token punctuation">,</span> iovcnt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>saveErrno <span class="token operator">=</span> errno<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> writeable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// buffer的缓冲区够存储数据</span>    writerIndex_ <span class="token operator">+=</span> n<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// extrabuf里也写入了数据</span>    writerIndex_ <span class="token operator">=</span> buffer_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将extrabuf追加到buffer中</span>    <span class="token function">append</span><span class="token punctuation">(</span>extrabuf<span class="token punctuation">,</span> n <span class="token operator">-</span> writeable<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-9-TcpConnection"><a href="#2-9-TcpConnection" class="headerlink" title="2.9 TcpConnection"></a>2.9 <strong>TcpConnection</strong></h2><p>封装一个连接信息，其内包含本地地址、对端地址、socket、channel、以及读写buffer</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>  <span class="token comment">// subLoop地址</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>atomic_int state_<span class="token punctuation">;</span><span class="token comment">//TcpConnection状态</span>  <span class="token keyword">bool</span> reading_<span class="token punctuation">;</span>  <span class="token comment">//可读标志</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Socket<span class="token operator">></span> socket_<span class="token punctuation">;</span><span class="token comment">//one Tcpconnection one socket</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Channel<span class="token operator">></span> channel_<span class="token punctuation">;</span><span class="token comment">//one Tcpconnection one channel</span>  <span class="token keyword">const</span> InetAddress localAddr_<span class="token punctuation">;</span>  <span class="token comment">//本地地址</span>  <span class="token keyword">const</span> InetAddress peerAddr_<span class="token punctuation">;</span>   <span class="token comment">//对端地址</span>  ConnectionCallback connectionCallback_<span class="token punctuation">;</span>        <span class="token comment">//有新连接时的回调</span>  MessageCallback messageCallback_<span class="token punctuation">;</span>              <span class="token comment">//有读写消息的回调</span>  WriteCompleteCallback writeCompleteCallback_<span class="token punctuation">;</span>  <span class="token comment">//消息发送完成的回调</span>  <span class="token comment">// HighWaterMarkCallback:读写数据达到警戒线的回调。比如当发送数据过快，接收方来不及接受时，此时发送方需要进行处理比如需要停止发送，</span>  HighWaterMarkCallback highWaterMarkCallback_<span class="token punctuation">;</span>  CloseCallback closeCallback_<span class="token punctuation">;</span>  size_t highWaterMark_<span class="token punctuation">;</span>  <span class="token comment">//水位线标志，超过此数则表示达到警戒线</span>  Buffer inputBuffer_<span class="token punctuation">;</span>   <span class="token comment">//接受数据缓冲</span>  Buffer outputBuffer_<span class="token punctuation">;</span>  <span class="token comment">//发送数据缓冲</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">TcpConnection</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span> sockfd<span class="token punctuation">,</span>                <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>localAddr<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>peerAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">~</span><span class="token function">TcpConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  EventLoop <span class="token operator">*</span><span class="token function">getLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> loop_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> name_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span><span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> localAddr_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span><span class="token function">peerAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> peerAddr_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">bool</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> state_ <span class="token operator">==</span> kConnected<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">//发送数据</span>  <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// void send(const void *message, int len);</span>  <span class="token comment">//关闭连接</span>  <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//设置回调函数</span>  <span class="token keyword">void</span> <span class="token function">setConnectionCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> ConnectionCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    connectionCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">setMessageCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> MessageCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> messageCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">setWriteCompleteCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> WriteCompleteCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    writeCompleteCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">setHighWaterMarkCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> HighWaterMarkCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    highWaterMarkCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">setCloseCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> CloseCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> closeCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">//连接建立时的回调函数</span>  <span class="token keyword">void</span> <span class="token function">connectEstablished</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//连接销毁的回调函数</span>  <span class="token keyword">void</span> <span class="token function">connectDestroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">enum</span> <span class="token class-name">StateE</span> <span class="token punctuation">&#123;</span> kDisconnected<span class="token punctuation">,</span> kConnecting<span class="token punctuation">,</span> kConnected<span class="token punctuation">,</span> kDisconnecting <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>StateE state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> state_ <span class="token operator">=</span> state<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//发送数据</span><span class="token comment">//应用写得快，而内核发送数据慢，需要把待发送数据写入缓冲区，而且设置水位回调</span><span class="token keyword">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">sendInLoop</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>message<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  size_t nwrote <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  size_t remaining <span class="token operator">=</span> len<span class="token punctuation">;</span>  <span class="token keyword">bool</span> faultError <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">//之前已经调用过shutdown，不能再进行发送了</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>state_ <span class="token operator">==</span> kDisconnected<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"disconnected, give up writing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// channel未设置写感兴趣事件（说明无数据待从缓冲区中写入）且缓冲区没有待发送数据</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel_<span class="token operator">-></span><span class="token function">isWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> outputBuffer_<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    nwrote <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">write</span><span class="token punctuation">(</span>channel_<span class="token operator">-></span><span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> message<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nwrote <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      remaining <span class="token operator">=</span> len <span class="token operator">-</span> nwrote<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> writeCompleteCallback_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//当一次将数据发送完成，就不用再给channel设置epollout事件了</span>        loop_<span class="token operator">-></span><span class="token function">queueInLoop</span><span class="token punctuation">(</span>            std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>writeCompleteCallback_<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      nwrote <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> EWOULDBLOCK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"TcpConnection::sendInLoop\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EPIPE <span class="token operator">||</span> errno <span class="token operator">==</span> ECONNREFUSED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          faultError <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/****************************************************/</span>  <span class="token comment">//说明这次write没有全部发送出去，剩余数据需要保存到缓冲区中，</span>  <span class="token comment">//然后给channel注册epollout事件，poller发现tcp的发送缓冲区有空间，会通知相应的sock-channel，调用WriteCallback方法</span>  <span class="token comment">//最终也就是调用handleWrite方法，把发送缓冲区中的数据全部发送完成</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>faultError <span class="token operator">&amp;&amp;</span> remaining <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//目前发送缓冲区剩余的待发送数据长度</span>    size_t oldLen <span class="token operator">=</span> outputBuffer_<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldLen <span class="token operator">+</span> remaining <span class="token operator">>=</span> highWaterMark_ <span class="token operator">&amp;&amp;</span> oldLen <span class="token operator">&lt;</span> highWaterMark_ <span class="token operator">&amp;&amp;</span>        highWaterMarkCallback_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      loop_<span class="token operator">-></span><span class="token function">queueInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>highWaterMarkCallback_<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                   oldLen <span class="token operator">+</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    outputBuffer_<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>message <span class="token operator">+</span> nwrote<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel_<span class="token operator">-></span><span class="token function">isWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//这里一定要注册channel的写事件，否则poller不会给channel通知epollout</span>      channel_<span class="token operator">-></span><span class="token function">enableWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//啥时候执行写回调？poller怎么通知写回调，数据不是都先到buffer中的吗</span><span class="token comment">//这是因为只要注册了EPOLLOUT事件，当内核写缓冲可写时，会不断发送EPOLLOUT信号，然后调用此函数将buffer中的数据进行发送</span><span class="token keyword">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">handleWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>channel_<span class="token operator">-></span><span class="token function">isWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> savedError <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ssize_t n <span class="token operator">=</span> outputBuffer_<span class="token punctuation">.</span><span class="token function">writeFd</span><span class="token punctuation">(</span>channel_<span class="token operator">-></span><span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>savedError<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      outputBuffer_<span class="token punctuation">.</span><span class="token function">retrieve</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>outputBuffer_<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        channel_<span class="token operator">-></span><span class="token function">disableWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>writeCompleteCallback_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">//唤醒loop_对应的thread线程，执行回调</span>          <span class="token comment">//其实此时就是在loop_对应的thread线程中</span>          loop_<span class="token operator">-></span><span class="token function">queueInLoop</span><span class="token punctuation">(</span>              std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>writeCompleteCallback_<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//当用户shutdown时数据如果没发送完成，不会真的shutdown，只是将标志置为kDisconnecting，而是会等待用户把数据发送完成</span>        <span class="token comment">//当数据发送完成后，则再执行一次shutdownInLoop</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>state_ <span class="token operator">==</span> kDisconnecting<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token function">shutdownInLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"TcpConnection::handleWrite() error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"TcpConnection fd=%d is down, no more writing \n"</span><span class="token punctuation">,</span>              channel_<span class="token operator">-></span><span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-10-TcpServer"><a href="#2-10-TcpServer" class="headerlink" title="2.10 TcpServer"></a>2.10 <strong>TcpServer</strong></h2><p>上述所有类的综合使用者，用户通过使用此类来设置各种回调，通过此类来管理subLoop个数等</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> ConnectionMap <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> TcpConnectionPtr<span class="token operator">></span><span class="token punctuation">;</span>EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>  <span class="token comment">//用户定义的loop</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string ipPort_<span class="token punctuation">;</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Acceptor<span class="token operator">></span> acceptor_<span class="token punctuation">;</span>  <span class="token comment">// mainLoop的监听新连接事件</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>EventLoopThreadPool<span class="token operator">></span> threadPool_<span class="token punctuation">;</span>  <span class="token comment">// one loop per thread</span>ConnectionCallback connectionCallback_<span class="token punctuation">;</span>        <span class="token comment">//有新连接时的回调</span>MessageCallback messageCallback_<span class="token punctuation">;</span>              <span class="token comment">//有读写消息的回调</span>WriteCompleteCallback writeCompleteCallback_<span class="token punctuation">;</span>  <span class="token comment">//消息发送完成的回调</span>ThreadInitCallback threadInitCallback_<span class="token punctuation">;</span>  <span class="token comment">//线程初始化的回调</span>std<span class="token double-colon punctuation">::</span>atomic_int started_<span class="token punctuation">;</span><span class="token keyword">int</span> nextConnId_<span class="token punctuation">;</span><span class="token comment">//TcpConnection的id，是用来加到TcpConnection名字中</span>ConnectionMap connections_<span class="token punctuation">;</span>  <span class="token comment">//保存所有的连接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> ThreadInitCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token keyword">enum</span> <span class="token class-name">Option</span> <span class="token punctuation">&#123;</span>   kNoReusePort<span class="token punctuation">,</span>   kReusePort<span class="token punctuation">,</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token function">TcpServer</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>listenAddr<span class="token punctuation">,</span>           <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string nameArg<span class="token punctuation">,</span> Option option <span class="token operator">=</span> kNoReusePort<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">TcpServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setThreadInitCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadInitCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   threadInitCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">setConnectionCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> ConnectionCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   connectionCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">setMessageCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> MessageCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> messageCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">setWriteCompleteCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> WriteCompleteCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   writeCompleteCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//设置低层subloop的个数</span> <span class="token keyword">void</span> <span class="token function">setThreadNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> numThreads<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//开启服务器监听</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">//当Acceptor有新连接时会调用的回调函数</span> <span class="token keyword">void</span> <span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>peerAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">removeConnection</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr <span class="token operator">&amp;</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">removeConnectionInLoop</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr <span class="token operator">&amp;</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//当有新的客户端连接，acceptor会执行这个回调</span><span class="token comment">//根据轮询算法选择一个subLoop，唤醒subLoop，把当前connfd封装成channel分发给subloop</span><span class="token keyword">void</span> <span class="token class-name">TcpServer</span><span class="token double-colon punctuation">::</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>peerAddr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//根据轮询选择一个subloop来管理channel</span>  EventLoop <span class="token operator">*</span>ioLoop <span class="token operator">=</span> threadPool_<span class="token operator">-></span><span class="token function">getNextLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> buf<span class="token punctuation">,</span> <span class="token string">"-%s#%d"</span><span class="token punctuation">,</span> ipPort_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nextConnId_<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">++</span>nextConnId_<span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>string connName <span class="token operator">=</span> name_ <span class="token operator">+</span> buf<span class="token punctuation">;</span>  <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"TcpServer::newConnection [%s] - new connection [%s] from %s\n"</span><span class="token punctuation">,</span>           name_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> connName<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> peerAddr<span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//通过sockfd获取其绑定的ip地址和端口信息</span>  sockaddr_in local<span class="token punctuation">;</span>  <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>local<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> local<span class="token punctuation">)</span><span class="token punctuation">;</span>  socklen_t addrlen <span class="token operator">=</span> <span class="token keyword">sizeof</span> local<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token double-colon punctuation">::</span><span class="token function">getsockname</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>sockaddr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>local<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addrlen<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"sockets::getLocalAddr\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  InetAddress <span class="token function">localAddr</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//根据连接成功的sockfd，创建TcpConnection连接对象</span>  TcpConnectionPtr <span class="token function">conn</span><span class="token punctuation">(</span>      <span class="token keyword">new</span> <span class="token function">TcpConnection</span><span class="token punctuation">(</span>ioLoop<span class="token punctuation">,</span> connName<span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> localAddr<span class="token punctuation">,</span> peerAddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  connections_<span class="token punctuation">[</span>connName<span class="token punctuation">]</span> <span class="token operator">=</span> conn<span class="token punctuation">;</span>  <span class="token comment">//下面的回调都来源于用户设置给TcpServer => TcpConnection => channel =>Poller</span>  <span class="token comment">//=>notify channel调用回调</span>  conn<span class="token operator">-></span><span class="token function">setConnectionCallback</span><span class="token punctuation">(</span>connectionCallback_<span class="token punctuation">)</span><span class="token punctuation">;</span>  conn<span class="token operator">-></span><span class="token function">setMessageCallback</span><span class="token punctuation">(</span>messageCallback_<span class="token punctuation">)</span><span class="token punctuation">;</span>  conn<span class="token operator">-></span><span class="token function">setWriteCompleteCallback</span><span class="token punctuation">(</span>writeCompleteCallback_<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//设置如何关闭连接的回调 用户调用shutdwon => socket关闭写端 =></span>  <span class="token comment">// poller通知channel EPOLLHUP事件 => channel调用closeCallback =></span>  <span class="token comment">// TcpConnection::handleClose() => TcpServer::removeConnection</span>  conn<span class="token operator">-></span><span class="token function">setCloseCallback</span><span class="token punctuation">(</span>      std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpServer<span class="token double-colon punctuation">::</span>removeConnection<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//直接调用connectEstablished方法</span>  ioLoop<span class="token operator">-></span><span class="token function">runInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpConnection<span class="token double-colon punctuation">::</span>connectEstablished<span class="token punctuation">,</span> conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-问题"><a href="#3-问题" class="headerlink" title="3. 问题"></a>3. 问题</h1><h2 id="介绍一下项目"><a href="#介绍一下项目" class="headerlink" title="介绍一下项目"></a>介绍一下项目</h2><p>此项目是一个基于Reactor模式的web服务器，采用epoll多路复用机制+线程池来高效处理并发连接。在实现中，使用epoll的水平触发模式来进行监听，使用C++11提供的智能指针来避免内存泄露，使用了eventfd来高效唤醒线程，为统一管理日志文件，实现了一个简单的异步日志系统。</p><h2 id="什么是优雅关闭连接？"><a href="#什么是优雅关闭连接？" class="headerlink" title="什么是优雅关闭连接？"></a>什么是优雅关闭连接？</h2><blockquote><p>优雅关闭：如果发送缓存中还有数据未发出则将其发出去，并且收到所有数据的ACK之后，发送FIN包，开始关闭过程。使用shutdown函数。</p><p>强制关闭：如果缓存中还有数据，则这些数据都将被丢弃，然后发送RST包，直接重置TCP连接。使用close()函数。</p><p>close()和shutdown()的区别：</p><ul><li>close会关闭连接，并释放所有连接对应的资源，而shutdown并不会释放掉套接字和所有资源。</li><li>close有引用计数，例如父子进程都打开了某个文件描述符，其中某个进程调用了close函数，会使close函数的引用计数减1，直到套接字的引用计数为0，才会真正的关闭连接。而shutdown函数可以无视引用计数，直接关闭连接。</li><li>close的引用计数的存在导致不一定会发出FIN结束报文，而shutdown一定会发出FIN报文。</li><li>shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() &#x2F; closesocket() 将套接字从内存清除。</li><li>调用 close()关闭套接字时，或调用 shutdown() 关闭输出流时，都会向对方发送 FIN 包。FIN 包表示数据传输完毕，计算机收到 FIN 包就知道不会再有数据传送过来。</li><li>默认情况下，close()引用计数为0后会立即往网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。<em><strong>*也就意味着，调用 close()将丢失输出缓冲区中的数据，而调用 shutdown() 不会。*</strong></em></li></ul></blockquote><p>在代码实现中，当用户调用shutdown函数时，不会马上就调用shutdown关闭socket，而是先将状态置为disconnecting，如果当前连接发送缓冲区无数据则调用shutdown函数关闭socket，否则等到每次处理写事件时当数据发送完成都会判断当前状态是否是disconnecting，如果是则调用shutdown关闭socket</p><h2 id="eventfd是什么？有什么好处？"><a href="#eventfd是什么？有什么好处？" class="headerlink" title="eventfd是什么？有什么好处？"></a>eventfd是什么？有什么好处？</h2><blockquote><p>参考 <a href="https://juejin.cn/post/6844903592457928711">1</a> <a href="https://zhuanlan.zhihu.com/p/40572954">2</a> <a href="https://zhuanlan.zhihu.com/p/424198922">3</a></p></blockquote><p><strong>简介</strong></p><ul><li>eventfd是linux系统提供的一个轻量级的进程间通信的系统调用，eventfd通过一个进程间共享的64位计数器完成进程间通信，这个计数器由在linux内核空间维护，用户可以通过调用write方法向内核空间写入一个64位的值，也可以调用read方法读取这个值。</li></ul><p><strong>使用</strong></p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/eventfd.h></span></span><span class="token keyword">int</span> <span class="token function">eventfd</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> initval<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>flags可以设置以下三个标志位：</p><ul><li>EFD_CLOEXEC：简单说就是fork子进程时不继承，对于多线程的程序设上这个值不会有错的。</li><li>EFD_NONBLOCK：如果没有设置了这个标志位，那read操作将会阻塞直到计数器中有值。如果有设置这个标志位，计数器没有值的时候也会立即返回-1；</li><li>EFD_SEMAPHORE：支持semophore语义的read，简单说就值递减1。</li></ul></li></ul><p><strong>典型应用场景及优势</strong></p><p>在信号通知的场景下，相比pipe有非常大的资源和性能优势。其根本在于counter（计数器）和channel（数据信道）的区别。</p><ul><li>第一，是打开文件数量的巨大差别。由于pipe是半双工的传统IPC方式，所以两个线程通信需要两个pipe文件，而用eventfd只要打开一个文件，省了一半。另外，pipe只能在两个进程&#x2F;线程间使用，即需要之前准备好两个pipe；而eventfd是广播式的通知，可以多对多的。</li><li>第二，是内存使用的差别。eventfd是一个计数器，内核维护几乎成本忽略不计，大概是自旋锁+唤醒队列，8个字节的传输成本也微乎其微。但pipe可就完全不是了，一来一回数据在用户空间和内核空间有多达4次的复制，而且更糟糕的是，内核还要为每个pipe分配至少4K的虚拟内存页，即便传输的数据长度为0。</li></ul><p><strong>实现原理</strong></p><ul><li><p>eventfd在内核中的数据结构如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">eventfd_ctx</span> <span class="token punctuation">&#123;</span>        wait_queue_head_t wqh<span class="token punctuation">;</span><span class="token comment">//等待队列头节点</span>        __u64 count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//等待队列是内核中的重要数据结构，在进程调度、异步通知等多种场景都有很多的应用。其节点结构并不复杂，即自带自旋锁的双向循环链表的节点</span><span class="token keyword">struct</span> <span class="token class-name">__wait_queue_head</span> <span class="token punctuation">&#123;</span>spinlock_t lock<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">list_head</span> task_list<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">__wait_queue_head</span> wait_queue_head_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>read()函数：read操作目的是要将count值返回用户空间并清零。ctx中的count值是共享数据，通过加irq自旋锁实现对其的独占安全访问。</p></li></ul><p><strong>进程是如何被唤醒的</strong></p><ul><li>当写进程调用eventfd_write过程中，会调用 waitqueue_active(&amp;ctx-&gt;wqh) 判断ctx-&gt;wqh是否为空，若不为空，则调用 wake_up_locked_poll(&amp;ctx-&gt;wqh, EPOLLIN); 激活可写事件（因为读进程读取时发现不可读，会生成一个 wait 对象放到 ctx-&gt;wqh队列中，然后休眠，所以此时 ctx-&gt;wqh）。</li></ul><h2 id="实现一个无锁队列-用原子操作"><a href="#实现一个无锁队列-用原子操作" class="headerlink" title="实现一个无锁队列(用原子操作)"></a>实现一个无锁队列(用原子操作)</h2><blockquote><p>参考 <a href="https://www.cnlzhnn.com/cas%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/">1</a> <a href="https://luyuhuang.tech/2022/10/30/lock-free-queue.html">2</a> <a href="https://developer.aliyun.com/article/497473">3</a></p><p><code>c++</code>提供了<code>atomic</code>模板支持一系列原子操作的类，提供的方法能保证操作具有原子性，即获取该类型变量的值时，永远能获得修改前或修改后的值，不会获得修改过程中的值，以确保不会在并发操作时产生不明确的行为。</p><p>该模板不具有拷贝构造函数，因为原子读和原子写是两个独立的原子操作，不能确保两个独立的操作加在一起仍然能保证原子性。</p><p>该类提供了如下几种接口：</p><ul><li><code>stroe</code> 原子写操作</li><li><code>load</code> 原子读操作</li><li><code>exchange</code> 修改当前值，并保证过程具有原子性</li><li><code>compare_exchange_weak</code></li><li><code>compare_exchange_strong</code></li></ul><p><code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>即为<code>CAS</code>操作，参数要求传入期待值和设定值：</p><ul><li>若当前值与期待值相等，则将当前值修改为设定值，返回<code>true</code></li><li>若当前值与期待值不等，则将期待值修改为当前值，返回<code>false</code></li></ul><p><code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>的区别：</p><ul><li><code>weak</code>允许偶然出乎意料的返回，比如当前值和期待值相等时候返回<code>false</code>，但在多数循环算法中是可以接受的，通常比<code>strong</code>具有更高的性能。</li></ul></blockquote><p><strong>CAS无锁栈</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*  CAS无锁栈  */</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">ConcurrentStack</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        Node<span class="token operator">*</span> new_node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        new_node<span class="token operator">-></span>m_next <span class="token operator">=</span> m_head<span class="token punctuation">;</span>        <span class="token comment">//如果m_head没有发生变化，则将其置为new_node；如果m_head发生变化，此时compare_exchange_weak函数返回false，并将new_node->m_next更改为新的m_head值，此时继续循环。</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>m_head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>new_node<span class="token operator">-></span>m_next<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    T <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        Node<span class="token operator">*</span> _now <span class="token operator">=</span> m_head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Node<span class="token operator">*</span> _next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">do</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>_now <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            _next <span class="token operator">=</span> _now<span class="token operator">-></span>m_next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>m_head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>_now<span class="token punctuation">,</span> _next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果m_head没有发生变化，则将其更改为_next；否则将now更改为新的m_head，继续不断循环遍历</span>        T _tmp <span class="token operator">=</span> _now<span class="token operator">-></span>m_data<span class="token punctuation">;</span>        <span class="token keyword">delete</span> _now<span class="token punctuation">;</span>        <span class="token keyword">return</span> _tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> <span class="token class-name">Node</span>    <span class="token punctuation">&#123;</span>        <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token function">m_data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        T m_data<span class="token punctuation">;</span>        Node<span class="token operator">*</span> m_next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span> m_head <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>CAS无锁队列</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*  CAS无锁队列  */</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">lock_free_queue</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span>    <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> data<span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">></span> next<span class="token punctuation">;</span>        <span class="token function">node</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> data_<span class="token punctuation">)</span> <span class="token operator">:</span>            <span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>data_<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">></span> head <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">></span> tail <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node<span class="token operator">*</span> new_node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token operator">*</span> _ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token comment">//判断是否是空队列</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>tail<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">)</span>            _ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        node<span class="token operator">*</span> old_tail <span class="token operator">=</span> tail<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//感觉原来的有点问题，做了一点修改 old_tail不是原子变量         </span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>old_tail <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span>tail<span class="token operator">-></span>next<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            old_tail <span class="token operator">=</span> tail<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            _ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        tail<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>old_tail<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node<span class="token operator">*</span> old_head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>old_head <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>old_head<span class="token punctuation">,</span> old_head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            old_head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//感觉不太需要这一步，这一步应该是为了最后返回的时候判断值是否更改</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> old_head <span class="token operator">?</span> old_head<span class="token operator">-></span>data <span class="token operator">:</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双缓冲区异步日志是什么？为什么要这样做？"><a href="#双缓冲区异步日志是什么？为什么要这样做？" class="headerlink" title="双缓冲区异步日志是什么？为什么要这样做？"></a>双缓冲区异步日志是什么？为什么要这样做？</h2><p>由于消费者的写文件速度比较慢，一定不能影响了生产者的写入效率，所以我们可以用两个消息队列来分别存储：正在写入的日志信息，正在读取的日志信息，也就是所谓的“双缓冲”技术。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230311205746535.png"></p><p><strong>缓冲区什么时候交换？</strong></p><p>当生产者所写的缓冲区已满时，需要将两个缓冲区进行交换，为了加快交换效率只需交换两个缓冲区地址即可。例如可使用queue来作为缓冲区。</p><ul><li>满足一定大小时进行交换。每次生产者像缓冲区中写数据时，如果缓冲区带下超过限制，则交换缓冲区（缓冲区2如果此时如果还有数据则不进行交换，继续写）</li><li>超过一定时间进行交换。可能写日志频率较低，很久都无法满足交换数量，此时应该设定一个timerfd，每当达到一定时间就交换缓冲区，避免过久不写日志导致日志丢失。</li></ul><h2 id="定时器是怎么实现的？还有什么实现方式？"><a href="#定时器是怎么实现的？还有什么实现方式？" class="headerlink" title="定时器是怎么实现的？还有什么实现方式？"></a>定时器是怎么实现的？还有什么实现方式？</h2><p>定时器可使用timerfd实现，timerfd 可以和 epoll 配合起来，让 epoll 监听 timerfd 的可读事件，这样 timerfd 超时触发可读事件，<code>epoll_wait</code> 被唤醒，业务进行周期处理，从而也能达到定时器的目的。</p><p><strong>timerfd简介</strong>：</p><ul><li><p>timerfd 被 new 出来之后 （ <code>timerfd_create</code> ），可以设置超时时间（ <code>timerfd_setting</code> ），超时之后，该句柄可读，读出来的是超时的次数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 创建一个 timerfd 句柄</span><span class="token keyword">int</span> <span class="token function">timerfd_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> clockid<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 启动或关闭 timerfd 对应的定时器</span><span class="token keyword">int</span> <span class="token function">timerfd_settime</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">itimerspec</span> <span class="token operator">*</span>new_value<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">itimerspec</span> <span class="token operator">*</span>old_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取指定 timerfd 距离下一次超时还剩的时间</span><span class="token keyword">int</span> <span class="token function">timerfd_gettime</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">itimerspec</span> <span class="token operator">*</span>curr_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>timerfd原理</strong></p><ul><li><p>核心结构体：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">timerfd_ctx</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 真正的内核定时器</span>    <span class="token keyword">union</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">hrtimer</span> tmr<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">alarm</span> alarm<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> t<span class="token punctuation">;</span>    <span class="token comment">// wait 对象挂接的表头</span>    wait_queue_head_t wqh<span class="token punctuation">;</span>    <span class="token comment">// 记录超时的次数</span>    u64 ticks<span class="token punctuation">;</span>    <span class="token comment">// 定时器类型</span>    <span class="token keyword">int</span> clockid<span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>timerfd_create内部过程</p><ul><li>创建并初始化了一个 <code>timerfd_ctx</code> 的结构体（在这个 ctx 结构体内有个表头 <code>ctx-&gt;wqh</code> 很重要，是和 epoll 产生联系的关键点）；</li><li>初始化了定时器，根据类型可以创建 <code>alarm</code> 类型或者高精度的 <code>hrtimer</code> 类型的定时器（ 注意：timerfd 本身并没有实现定时器的功能，定时器直接使用的是内核封装好的定时器，timerfd 只针对“文件”的封装）；</li><li>创建一个匿名 fd，绑定 <code>timerfd_fops</code> 操作表；</li></ul></li><li><p>timerfd_settime</p><ul><li>通过 fd 获取到 file，再获取到核心结构体 timerfd_ctx；</li><li>然后再操作定时器，启动定时器即可；</li></ul></li><li><p>timerfd_gettime</p><ul><li>通过 fd 获取到 file，再获取到核心结构体 <code>timerfd_ctx</code> ；</li><li>然后通过 <code>timerfd_ctx</code> 里面存储的信息，计算举例下一次超时的时间即可；</li></ul></li></ul><p><strong>timerfd 怎么唤醒 epoll_wait？</strong></p><ul><li><p>定时器到期之后，内核调用回调：</p><pre class="line-numbers language-none"><code class="language-none">timerfd_tmrproc (在初始化的时候配置)-&gt; timerfd_trigger    -&gt; wake_up_locked_poll （唤醒 timerfd 上所有的等待对象）        -&gt; ep_poll_callback<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>应该就是epoll_ctl注册时像timerfd的wqh注册事件，然后当定时器到期后，内核不断唤醒队列中的事件，调用回调操作</p></li></ul><p><strong>定时器其他实现方法</strong></p><p>linux提供以下多种计时函数：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230311214830639.png"></p><ul><li>前四个函数比较鸡肋，会让调用线程挂起，原地等待定时器超时。但是在非阻塞网络编程中，绝对不能用让线程挂起的方式来等待一段时间，这样一来程序会失去响应。</li><li>alarm()和setitimer()，它们的通知机制采用了信号SIGALRM，由于SIGALRM信号不可靠，会造成超时通知不可靠，而且多线程中处理信号也是一个麻烦事，也不考虑。</li><li>timer_create()&#x2F;timer_settime()系列函数是POSIX规定，精度达到纳秒级，提供了一个数据结构<code>struct sigevent</code>可以指定一个实时信号作为通知信号，同时也可以设置线程ID，将信号传递到指定的线程。</li></ul><h2 id="epoll的边沿触发和水平触发有什么区别？"><a href="#epoll的边沿触发和水平触发有什么区别？" class="headerlink" title="epoll的边沿触发和水平触发有什么区别？"></a>epoll的边沿触发和水平触发有什么区别？</h2><p><strong>定义</strong></p><ul><li>水平触发：只要套接字可读&#x2F;可写epollwait都会将描述符返回。即只要套接字的接收缓冲中尚有数据或发送缓冲有空间容纳要发送的数据。这个套接字都会被epoll_wait返回。</li><li>边缘触发：当套接字的缓冲状态发生变化时返回。对于读缓冲，有新到达的数据被添加到读缓冲时触发。对于写缓冲，当缓冲发生容量变更的时候触发</li></ul><p><strong>内核调度实现方式</strong></p><ul><li>在epoll_wait的时候，阻塞等待事件发生， 事件发生时通过回调挂到ready list链表中</li><li>epoll_wait返回， 处理ready list, 返回事件给调用者</li><li>此时ET模式已经将事件从ready list中删除，LT模式中还存在</li><li>此时假设应用程序处理完了事件， 再次epoll_wait.  ET模式继续阻塞</li><li>LT模式由于ready list中依然存在事件则不会阻塞， 对这些socket调用poll方法获取最新的事件信息，如果确认没事件了才会删除。</li></ul><p><strong>边缘触发可能造成饥饿</strong></p><p>如果用边缘触发处理，对一个套接字就需要循环读取，直到没有数据可读为止。如果其中一个连接源源不断的发送数据，这个套接口的读循环就无法退出，导致其它连接没有机会被处理。</p><p><strong>边缘触发优势场景</strong></p><p>对于水平触发模式out事件必须按需注册。主要的注册方式有以下两种：</p><ul><li>上层调用send，将数据添加到应用层的发送缓冲，如果当前没有注册out则注册out,当epoll通知out激活时，发送应用缓冲中的数据，如果数据发送完毕注销out。</li><li>上层调用send，直接发送，如果数据未发送完或返回EAGAIN,则注册out，当epoll通知out激活时，继续发送未发送完成的数据，如果数据发送完毕注销out。</li></ul><p>上述的添加和注销out都是通过epoll_ctl完成，因此水平触发需要不断开关out信号，当数据频繁发送但一次不能写成功时就会不断开关out信号。</p><p>而对于边缘触发模式则无此需要。</p><ul><li>假如发送每次均能将数据全部发完。那么out的注册和注销都不会发生。</li><li>如果接收方慢导致每次均无法将数据全部发送完，那么out将只会注册一次，注销不会发生。</li></ul><p><strong>为什么选择使用LT？</strong></p><p>虽然ET在某些场景如一直读写下会更高效，但可能会遗漏事件产生bug，从而导致代码编写逻辑更为复杂。</p><h2 id="epoll为什么高效，相比select和poll"><a href="#epoll为什么高效，相比select和poll" class="headerlink" title="epoll为什么高效，相比select和poll"></a>epoll为什么高效，相比select和poll</h2><blockquote><p>自己简单理解</p><p>select使用一个结构体来管理sockfd，其内有一个bitmap，向select添加sockfd也就是将bitmap对应值进行更改为1。同理，当有事件发生时，系统返回的bitmap中如果值为1则代表此sockfd有事件 发生。</p><ul><li>由于select返回的是一个bitmap而不是发生事件的集合，因此还需要遍历整个bitmap找出有事件发生的sockfd，导致其效率很低。</li><li>且bitmap需要在内核态和用户态不断复制，导致效率很低。</li></ul><p>相比select，poll变化不大，原理也相同，poll使用数组来取代bitmap，因而也就没有大小限制。同样，poll也需要遍历整个数组来找出有事件发生的sockfd，其也只有水平触发。</p><p>epoll的一个巨大改进之处在于将发生事件的sockfd使用一个数据进行保存（通过在内核空间直接建立一个文件系统，使用红黑树），提高了效率</p></blockquote><blockquote><p>参考 <a href="https://heapdump.cn/article/3841322">1</a> <a href="https://zhuanlan.zhihu.com/p/530640921">2</a></p></blockquote><p><strong>epoll原理详解</strong></p><ul><li><p><em>当</em>某一进程调用 epoll_create 方法时，Linux 内核会创建一个 eventpoll 结构体，这个结构体中有两个成员与epoll的使用方式密切相关，如下所示：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token punctuation">&#123;</span>　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>　　<span class="token comment">/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，　　也就是这个epoll监控的事件*/</span>　　<span class="token keyword">struct</span> <span class="token class-name">rb_root</span> rbr<span class="token punctuation">;</span>　　<span class="token comment">/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span>　　<span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdllist<span class="token punctuation">;</span>　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在调用 epoll_create 时，内核除了帮我们在 epoll 文件系统里建了个 file 结点，在内核 cache 里建了个红黑树用于存储以后 epoll_ctl 传来的 socket 外，还会再建立一个 rdllist 双向链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 rdllist 双向链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到 timeout 时间到后即使链表没数据也返回。所以，epoll_wait 非常高效。</p></li><li><p>所有添加到epoll中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的事件放到上面的rdllist双向链表中。</p></li><li><p>当调用 epoll_wait 检查是否有发生事件的连接时，只是检查eventpoll对象中的rdllist双向链表是否有元素而已，如果rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx效率非常高。epoll_ctl在向epoll对象中添加、修改、删除事件时，从rbr红黑树中查找事件也非常快，也就是说epoll是非常高效的，它可以轻易地处理百万级别的并发连接。</p></li></ul><h2 id="假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？-其实就是不间断的提供服务，参考nginx的平滑升级"><a href="#假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？-其实就是不间断的提供服务，参考nginx的平滑升级" class="headerlink" title="假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？(其实就是不间断的提供服务，参考nginx的平滑升级)"></a>假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？(其实就是不间断的提供服务，参考nginx的平滑升级)</h2><blockquote><p>参考 <a href="http://www.manongjc.com/detail/55-ddjnjhttaswtzpx.html">1</a></p></blockquote><p>简单想法：向代理服务器中添加新服务器ip，新服务器上运行新任务，新来的连接均导向新服务器。</p><h2 id="HTTP报文都有哪些字段？"><a href="#HTTP报文都有哪些字段？" class="headerlink" title="HTTP报文都有哪些字段？"></a>HTTP报文都有哪些字段？</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230313115843376.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230313120014727.png"></p><p><strong>url和host区别</strong></p><p>url里面除了域名还包括端口号，当不指定时是默认端口号，url可使得同一台主机提供多个http服务。</p><p>通过host指定应用，你可以用相同的IP+端口访问不同的应用，而不必担心端口问题。例如nginx以下配置，server_name就是通过host来比较：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">server<span class="token punctuation">&#123;</span>    listen <span class="token number">80</span>;    server_name www.webkit.cc;    root /path/to/your/root/directory/;    index  index.html;<span class="token punctuation">&#125;</span>server<span class="token punctuation">&#123;</span>    listen <span class="token number">80</span>;    server_name another—website.com;    root /another/root/directory/;    index  index.html;<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一个请求到来具体的处理过程是怎样的"><a href="#一个请求到来具体的处理过程是怎样的" class="headerlink" title="一个请求到来具体的处理过程是怎样的"></a>一个请求到来具体的处理过程是怎样的</h2><ol><li>首先通过listenfd建立TCP连接，然后使用epoll通知程序调用listenfd的accept来获取连接</li><li>然后使用封装好的TcpConnection类来封装连接信息，为平衡个处理线程的负载，采取不断循环将此连接信息分配到各线程，然后使用eventfd将处理线程唤醒。</li><li>处理线程将此连接注册到所属线程的epoll上，当有消息进入时epoll_wait不再阻塞，将信息读入此连接所属缓存区中，然后从缓冲区中读出信息并进行处理。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110214042301.png"></p><h2 id="线程的唤醒还有哪些方式？"><a href="#线程的唤醒还有哪些方式？" class="headerlink" title="线程的唤醒还有哪些方式？"></a>线程的唤醒还有哪些方式？</h2><blockquote><p>参考 <a href="handleR">1</a></p></blockquote><p>epoll等机制本身可以设置一个超时时间，但有时需要将epoll立即唤醒处理事件，可使用以下机制：</p><ol><li>使用eventfd方式，每个线程所使用的eventloop都会有一个eventfd，并将其注册到所属的epoll上，当需要唤醒此线程时，只需要向此eventfd写入一个1个64位的数即可。</li><li>使用管道<code>fd</code>，创建一个管道，将管道的一端（管道<code>fd</code>中的一个）绑定到<code>epollfd</code>上，需要唤醒时，向管道的另一端写入1字节，工作线程就立即被唤醒；</li><li>使用<code>socketpair</code>，<code>socketpair</code>是一对相互连接的<code>socket</code>，相当于服务器和客户端的两个端点，每一端都可以读写数据，向其中一端写入数据后，就可以从另一端读取数据了。</li></ol><p>其他的诸如pthread_cond_wait&#x2F;signal、semaphore等机制不好与epoll等结合。</p><h2 id="怎么检查内存泄漏的？"><a href="#怎么检查内存泄漏的？" class="headerlink" title="怎么检查内存泄漏的？"></a>怎么检查内存泄漏的？</h2><blockquote><p>参考<a href="%E6%80%8E%E4%B9%88%E6%A3%80%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%EF%BC%9F">1</a> <a href="https://sites.google.com/site/shuzhifeng/linux-ping-tai-zhong-diao-shi-c-c-nei-cun-xie-lou-fang-fa">2</a></p></blockquote><p>主要分为静态分析和动态分析：</p><ul><li>静态分析：<ul><li>review原来带，判断申请内存和释放内存是否匹配</li><li>参考1，重载new和delete等操作符，每次申请内存时多申请一块内存作为一个链表节点，当释放内存时重链表中删除此节点。最终如果链表为空则说明不存在内存泄露。</li></ul></li><li>动态分析：使用一些实时检测工具valgrind, Rational purify</li></ul><h2 id="用到了哪些智能指针和RAII机制，几种锁的区别是什么"><a href="#用到了哪些智能指针和RAII机制，几种锁的区别是什么" class="headerlink" title="用到了哪些智能指针和RAII机制，几种锁的区别是什么"></a>用到了哪些智能指针和RAII机制，几种锁的区别是什么</h2><p><strong>智能指针使用</strong>：</p><ul><li>unique_ptr: 包括Poller，Channel，Socket等</li><li>shared_ptr：TcpConnection、thread、EventLoopThreadPoll</li><li>weak_ptr：Channel中使用一个tie_来判断此channel是否被释放</li></ul><p><strong>几种锁定义及特点</strong>：</p><ul><li>互斥锁：对于读者和写者来说。只要有一方获取了锁，另一方则不能继续获取，进而执行临界区代码。</li><li>读写锁：读写锁适合于对数据结构的读次数比写次数多得多的情况.因为,读模式锁定时可以共享,以写 模式锁住时意味着独占,所以读写锁又叫共享-独占锁.</li><li>自旋锁：轮询忙等待。被自旋锁保护的临界区代码执行时不能进行挂起状态。自旋锁的初衷就是在短期间内进行轻量级的锁定。一个被争用的自旋锁使得请求它的线程在等待锁重新可用的期间进行不断轮询，所以自旋锁不应该被持有时间过长。如果需要长时间锁定的话, 最好使用信号量。</li></ul><h2 id="任务队列是怎么实现的，除了加锁还有什么方式"><a href="#任务队列是怎么实现的，除了加锁还有什么方式" class="headerlink" title="任务队列是怎么实现的，除了加锁还有什么方式"></a>任务队列是怎么实现的，除了加锁还有什么方式</h2><p>可用CAS原子操作实现，见无锁队列实现</p><h2 id="如何解决死锁"><a href="#如何解决死锁" class="headerlink" title="如何解决死锁"></a>如何解决死锁</h2><p><strong>死锁的必要条件</strong></p><ol><li>互斥：一个执行流获取互斥锁后，其它执行流不能再获取该锁；</li><li>不可剥夺：A执行流拿着锁，其它执行流不能释放；</li><li>循环等待：多个执行流拿着对方想要的锁，并且各执行流还去请求对方的锁；</li><li>请求与保持：执行流本身使用着一把锁并不释放，还在请求别的锁；</li></ol><p><strong>解决死锁的几种算法</strong></p><ol><li>有序资源分配法：所有资源的使用都要有序的使用，要保证资源一次申请完且在申请不同类资源时，必须按各类设备的编号依次申请</li><li>银行家算法：一个银行家的借贷业务，必须保证其借贷人在一定时间内归还本金，以至于资金可以顺利周转，不至于倒闭。</li></ol><p><strong>死锁的预防和恢复</strong></p><ol><li>资源掠夺法：当前系统中存在多个死锁程序时，选择葫芦一部分死锁程序，并抢占他的资源，将这些稀有分配给其他进程使用，直到死锁不存在为止；</li><li>撤销进程法：放弃处于死锁进程中的进程，直接撤销该进程，直到死锁不存在为止；</li><li>进程回退法：进程自按获取顺序自愿放弃获取的资源，系统保存进程的历史信息，设置还原点。</li></ol><h2 id="怎么进行压测的"><a href="#怎么进行压测的" class="headerlink" title="怎么进行压测的"></a>怎么进行压测的</h2><h2 id="为什么要用非阻塞io"><a href="#为什么要用非阻塞io" class="headerlink" title="为什么要用非阻塞io"></a>为什么要用非阻塞io</h2><p>如果使用阻塞io，会在数据准备阶段等待大量时间，而在等待期间线程会被挂起，若想此时处理其他任务就只能开启其他线程进行处理。</p><p>网络任务通常会有大量连接，如果每个连接都阻塞在数据准备阶段，则需要巨量线程来处理连接，会给线程调度带来巨大挑战，并导致数据处理效率降低、</p><h2 id="为什么要做这个项目"><a href="#为什么要做这个项目" class="headerlink" title="为什么要做这个项目"></a>为什么要做这个项目</h2><p>。。</p><h2 id="Reactor模式是什么"><a href="#Reactor模式是什么" class="headerlink" title="Reactor模式是什么"></a>Reactor模式是什么</h2><p>见1.4节</p><h1 id="5-出现哪些问题，如何解决"><a href="#5-出现哪些问题，如何解决" class="headerlink" title="5. 出现哪些问题，如何解决"></a>5. 出现哪些问题，如何解决</h1><p>一些小错误，使用eventfd唤醒时，向其中写入64位的数，判断的是写入1个字节，应该判断写入8个字节。</p><h2 id="5-1-有的连接shutdown错误，且会出现有的连接revent报错-errno-x3D-32，"><a href="#5-1-有的连接shutdown错误，且会出现有的连接revent报错-errno-x3D-32，" class="headerlink" title="5.1 有的连接shutdown错误，且会出现有的连接revent报错 errno&#x3D;32，"></a>5.1 有的连接shutdown错误，且会出现有的连接revent报错 errno&#x3D;32，</h2><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p>1000个客户端 60s</p><p>短连接</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328164436193.png"></p><p>线程池为4</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328170702370.png"></p><p>长连接</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328164909909.png"></p><p>线程池为4</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328170456563.png"></p><p>muduo测试</p><p>短连接</p><p>线程池为0</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328165926466.png"></p><p>线程池为4</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328170105847.png"></p><p>长连接</p><p>线程池为0</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328165709766.png"></p><p>线程池为4</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328165352821.png"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多线程服务器编程：使用muduo C++网络库 笔记</title>
      <link href="/2023/02/15/%E9%A1%B9%E7%9B%AE/muduo%E7%BD%91%E7%BB%9C%E5%BA%93-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/02/15/%E9%A1%B9%E7%9B%AE/muduo%E7%BD%91%E7%BB%9C%E5%BA%93-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>阅读《Linux多线程服务器编程：使用muduo C++网络库》笔记</p><hr><hr><h1 id="第1章-线程安全的对象生命期管理"><a href="#第1章-线程安全的对象生命期管理" class="headerlink" title="第1章 线程安全的对象生命期管理"></a>第1章 线程安全的对象生命期管理</h1><h2 id="1-1-当析构函数遇到多线程"><a href="#1-1-当析构函数遇到多线程" class="headerlink" title="1.1 当析构函数遇到多线程"></a>1.1 当析构函数遇到多线程</h2><blockquote><p>当一个对象能被多个线程同时看到时，那么对象的销毁时机就会变得模糊不清，可能出现多种竞态条件（race condition）</p><ul><li>在即将析构一个对象时，从何而知此刻是否有别的线程正在执行该对象的成员函数</li><li>如何保证在执行成员函数期间，对象不会在另一个线程被析构？</li><li>在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？</li></ul></blockquote><p>使用shared_ptr能一劳永逸地解决这些问题，减轻C++多线程编程的精神负担</p><h3 id="1-1-1-线程安全的定义"><a href="#1-1-1-线程安全的定义" class="headerlink" title="1.1.1 线程安全的定义"></a>1.1.1 线程安全的定义</h3><p>一个线程安全的class应当满足以下三个条件：</p><ul><li>多个线程同时访问时，其表现出正确的行为。</li><li>无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织（interleaving）</li><li>调用端代码无须额外的同步或其他协调动作。</li></ul><blockquote><p>C++标准库里的大多数class都不是线程安全的，包括std:: string、std::vector、std::map等，因为这些class通常需要在外部加锁才能供多个线程同时访问</p></blockquote><p>本书中定义了两个有关锁的工具类：</p><ul><li>MutexLock类：封装临界区，其是一个简单的资源类，用RALL手法封装互斥器的创建与销毁</li><li>MutexLockGuard类：封装临界区的进入和退出，即加锁和解锁。MutexLockGuard一般是个栈上对象，它的作用域刚好等于临界区域。（创建了一个此类对象，其析构通常在return后，因此保护了共享数据）</li></ul><p>编写单个的线程安全的class不算太难，只需用同步原语保护其内部状态。但如果此对象是通过动态指针创建的，那么仍需要解决race condition。</p><h2 id="1-2-对象的创建很简单"><a href="#1-2-对象的创建很简单" class="headerlink" title="1.2 对象的创建很简单"></a>1.2 对象的创建很简单</h2><p>对象构造要做到线程安全，&#x3D;&#x3D;唯一的要求是在构造期间不要泄露this指针&#x3D;&#x3D;，即：</p><ul><li>不要在构造函数中注册任何回调</li><li>也不要在构造函数中把this传给跨线程的对象</li><li>即便在构造函数的最后一行也不行（此类可能是一个基类，其先于派生类构造，此时派生类可能还没构造完）</li></ul><p><strong>原因</strong>：在构造函数执行期间对象还没有完成初始化，如果this被泄露（escape）给了其他对象（其自身创建的子对象除外），那么别的线程有可能访问这个半成品对象，这会造成难以预料的后果。</p><h2 id="1-3-销毁太难"><a href="#1-3-销毁太难" class="headerlink" title="1.3 销毁太难"></a>1.3 销毁太难</h2><p>对一般成员函数而言，做到线程安全的办法是让它们顺次执行，而不要并发执行，也就是让每个成员函数的临界区不重叠</p><blockquote><p>但是成员函数用来保护临界区的互斥器可能会被析构函数销毁掉</p><p>比如，一个类对象能被所有线程所见，一个线程执行到析构函数并持有互斥锁，另一个线程开始执行某函数，此时这个线程可能永远阻塞，也可能进入临界区然后core dump</p></blockquote><p><strong>作为数据成员的mutex不能保护析构</strong></p><p>作为class数据成员的MutexLock只能用于同步本class的其他数据成员的读和写，它不能保护安全地析构</p><blockquote><p>因为MutexLock成员的生命期最多与对象一样长，而析构动作可说是发生在对象身故之后</p></blockquote><p>同时读写一个class的两个对象，有潜在的死锁可能</p><blockquote><p>比如swap函数，两个线程都使用swap调用相同的两个对象，则有可能锁死</p><p>一个函数如果要锁住相同类型的多个对象，为了保证始终按相同的顺序加锁，我们可以比较mutex对象的地址，始终先加锁地址较小的mutex</p></blockquote><h2 id="1-4-线程安全的Observer有多难"><a href="#1-4-线程安全的Observer有多难" class="headerlink" title="1.4 线程安全的Observer有多难"></a>1.4 线程安全的Observer有多难</h2><p>Observer模式示例：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220911221246890.png"></p><p>一个动态创建的对象是否还活着，光看指针是看不出来的（引用也一样看不出来）</p><blockquote><p>针就是指向了一块内存，这块内存上的对象如果已经销毁，那么就根本不能访问。既然不能访问又如何知道对象的状态呢？</p><p>且万一原址又创建了一个新的对象呢？再万一这个新的对象的类型异于老的对象呢？</p></blockquote><p>对象的关系主要有三种：</p><ul><li>composition组合：在类中定义一个对象，其生命周期一致。在多线程里不会遇到什么麻烦，因为对象x的生命期由其唯一的拥有者owner控制，owner析构的时候会把x也析构掉</li><li>association关联：表示一个对象a用到了另一个对象b，调用了后者的成员函数（将一个类指针传到了类中使用）。从代码形式上看，a持有b的指针（或引用），但是b的生命期不由a单独控制。（似乎一个简单的解决办法是创建一个对象池，其只创建但不销毁，但也会存在许多问题）</li><li>aggregation聚合：聚合是一种特殊的关联关系，它是较强的一种关联关系（在类中动态创建了一个对象）。其面对情况和关联类似。</li></ul><h2 id="1-5-原始指针有何不妥"><a href="#1-5-原始指针有何不妥" class="headerlink" title="1.5 原始指针有何不妥"></a>1.5 原始指针有何不妥</h2><p>直接给其他类传指针对象是不妥得，无法判断此对象是否存货，可以使用shared_ptr，但需要注意循环引用</p><p><strong>空悬指针</strong></p><p>有两个指针p1和p2，指向堆上的同一个对象Object，p1和p2位于不同的线程中。假设线程A通过p1指针将对象销毁了，那p2就成了空悬指针。</p><blockquote><p>一种解决办法就是添加一个中间层指针proxy，此中间指针指向对象地址，p1和p2都指向proxy。（但如果p2看第一眼的时候proxy不是零，正准备去调用Object的成员函数，期间对象已经被p1给销毁了，此时也会存在问题）</p><p>另一种解决办法就是使用shared_ptr，其自带引用计数，当不存在引用时才销毁对象</p></blockquote><h2 id="1-6-神器shared-ptr-x2F-weak-ptr"><a href="#1-6-神器shared-ptr-x2F-weak-ptr" class="headerlink" title="1.6 神器shared_ptr&#x2F;weak_ptr"></a>1.6 神器shared_ptr&#x2F;weak_ptr</h2><p>shared_ptr和weak_ptr是引用计数型智能指针，具体用法略过</p><p>一些关键点：</p><ul><li>shared_ptr控制对象的生命期。shared_ptr是强引用，只要有一个指向x对象的shared_ptr存在，该x对象就不会析构。当指向对象x的最后一个shared_ptr析构或reset()的时候，x保证会被销毁</li><li>weak_ptr不控制对象的生命期，但是它知道对象是否还活着。如果对象还活着，那么它可以提升为有效的shared_ptr；如果对象已经死了，提升会失败，返回一个空的shared_ptr。<em>“提升／lock()”行为是线程安全的</em>。</li><li>shared_ptr&#x2F;weak_ptr的“计数”在主流平台上是原子操作，没有用锁，性能不俗</li><li>shared_ptr&#x2F;weak_ptr的线程安全级别与std::string和STL容器一样</li></ul><h2 id="1-7-插曲：系统地避免各种指针错误"><a href="#1-7-插曲：系统地避免各种指针错误" class="headerlink" title="1.7 插曲：系统地避免各种指针错误"></a>1.7 插曲：系统地避免各种指针错误</h2><p>C++里可能出现的内存问题大致有这么几个方面：</p><ul><li>1．缓冲区溢出：用std::vector<char>&#x2F;std::string或自己编写Buffer class来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区</li><li>2．空悬指针／野指针：用shared_ptr&#x2F;weak_ptr</li><li>3．重复释放：用scoped_ptr，只在对象析构的时候释放一次</li><li>4．内存泄漏：用scoped_ptr，对象析构的时候自动释放内存</li><li>5．不配对的new[]&#x2F;delete：把new[]统统替换为std::vector&#x2F;scoped_array</li><li>6．内存碎片：在9.2.1和1.8探讨</li></ul><blockquote><p>scoped_ptr&#x2F;shared_ptr&#x2F;weak_ptr都是值语意，要么是栈上对象，或是其他对象的直接数据成员，或是标准库容器里的元素。（其实就是说这几种智能指针用得时候都是使用对象，而不是定义这几种智能指针的指针）</p><p>如果这几种智能指针是对象x的数据成员，而它的模板参数T是个incomplete类型，那么x的析构函数不能是默认的或内联的，必须在.cpp文件里边显式定义，否则会有编译错或运行错</p></blockquote><h2 id="1-8-应用到Observer上"><a href="#1-8-应用到Observer上" class="headerlink" title="1.8 应用到Observer上"></a>1.8 应用到Observer上</h2><p>observer使用weak_ptr</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220911221605354.png"></p><p>使用weak_ptr能部分解决Observer模式的线程安全，但还有以下问题待解决：</p><ul><li>侵入性：强制要求Observer必须以shared_ptr来管理。</li><li>不是完全线程安全：observer的析构函数可能会调用其他对象的函数，但是此函数可能不存在</li><li>锁争用：即Observable的三个成员函数都用了互斥器来同步，这会造成register_()和unregister()等待notifyObservers()，而后者的执行时间是无上限的，因为它同步回调了用户提供的update()函数</li><li>死锁：万一L62的update()虚函数中调用了(un)register呢？如果mutex_是不可重入的，那么会死锁</li></ul><h2 id="1-9-再论shared-ptr的线程安全"><a href="#1-9-再论shared-ptr的线程安全" class="headerlink" title="1.9 再论shared_ptr的线程安全"></a>1.9 再论shared_ptr的线程安全</h2><p>shared_ptr本身不是100％线程安全的，它的引用计数本身是安全且无锁的，但对象的读写则不是，因为shared_ptr有两个数据成员，读写操作不能原子化</p><ul><li>一个shared_ptr对象实体可被多个线程同时读取</li><li>两个shared_ptr对象实体可以被两个线程同时写入，“析构”算写操作</li><li>如果要从多个线程读写同一个shared_ptr对象，那么需要加锁。</li><li><em>以上是shared_ptr对象本身的线程安全级别，不是它管理的对象的线程安全级别。</em></li></ul><p>&#x3D;&#x3D;在多个线程中同时访问同一个shared_ptr，正确的做法是用mutex保护&#x3D;&#x3D;</p><h2 id="1-10-shared-ptr技术与陷阱"><a href="#1-10-shared-ptr技术与陷阱" class="headerlink" title="1.10 shared_ptr技术与陷阱"></a>1.10 shared_ptr技术与陷阱</h2><p><strong>意外延长对象的生命期</strong>：shared_ptr是强引用（“铁丝”绑的），只要有一个指向x对象的shared_ptr存在，该对象就不会析构，而其又能拷贝和赋值</p><p><strong>函数参数</strong>：因为要修改引用计数shared_ptr的拷贝开销比拷贝原始指针要高，在不拷贝的情况下可以使用const reference方式传递</p><p><strong>析构动作在创建时被捕获</strong>：这是一个非常有用的特性，这意味着</p><ul><li>虚析构不再是必需的。</li><li>shared_ptr<void>可以持有任何对象，而且能安全地释放。</li><li>shared_ptr对象可以安全地跨越模块边界，比如从DLL里返回，而不会造成从模块A分配的内存在模块B里被释放这种错误。</li><li>二进制兼容性，即便Foo对象的大小变了，那么旧的客户代码仍然可以使用新的动态库，而无须重新编译</li><li>析构动作可以定制。</li></ul><p><strong>析构所在的线程</strong>：</p><ul><li>当最后一个指向x的shared_ptr离开其作用域的时候，x会在线程中析构，这个线程不一定是对象诞生的线程。</li><li>如果对象的析构比较耗时，那么可能会拖慢关键线程的速度</li><li>可以用一个单独的线程来专门做析构，通过一个BlockingQueue&lt;shared_ptr<void> &gt;把对象的析构都转移到那个专用线程，从而解放关键线程。</li></ul><p><strong>现成的RAII handle</strong></p><ul><li>RAII（资源获取即初始化）是C++语言区别于其他所有编程语言的最重要的特性</li><li>&#x3D;&#x3D;每一个明确的资源配置动作（例如new）都应该在单一语句中执行，并在该语句中立刻将配置获得的资源交给handle对象（如shared_ptr），程序中一般不出现delete&#x3D;&#x3D;</li><li>避免循环引用的通常做法是owner持有指向child的shared_ptr，child持有指向owner的weak_ptr</li></ul><h2 id="1-11-对象池"><a href="#1-11-对象池" class="headerlink" title="1.11 对象池"></a>1.11 对象池</h2><blockquote><p>有时只允许程序中出现一个类对象，但其可以被多个线程使用，当有线程使用而对象不存在时则创建对象，当没有线程使用时则析构，解决办法则是定义一个<em>对象池</em></p></blockquote><p>一个简单的对象池示例，其根据key返回对象</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220911225550229.png"></p><p>但是，上述map定义会导致stock对象永远不会销毁，应改成weak_ptr定义</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220911225749678.png"></p><p>但是stocks的大小只增不减，stocks.size()是曾经存活过的Stock对象的总数，即便活的Stock对象数目降为0。当对象创建很多时，就会导致内存一直得不到释放。</p><p>解决的办法是，利用shared_ptr的定制析构功能</p><blockquote><p>定义shared_ptr时，自定义一个析构函数来释放空间</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220911230353031.png"></p><p>上面代码在定义析构函数时，将this指针绑定在了析构函数中，这会导致线程安全问题：如果这个StockFactory先于Stock对象析构，那么会core dump</p><p><em>解决办法是使用下面的弱回调技术</em></p></blockquote><h3 id="1-11-1-enable-shared-from-this"><a href="#1-11-1-enable-shared-from-this" class="headerlink" title="1.11.1 enable_shared_from_this"></a>1.11.1 <strong>enable_shared_from_this</strong></h3><p>上小节中，StockFactory可能先于Stock对象析构，解决办法就是使用shared_ptr来管理stockfactory，获得当前对象的shared_ptr可以先继承enable_shared_from_this类，然后调用shared_from_this()函数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912094909137.png"></p><blockquote><p>function里保存了一份shared_ptr<StockFactory>，可以保证调用StockFactory::deleteStock的时候那个StockFactory对象还活着</p></blockquote><p><strong>注意</strong>：shared_from_this()不能在构造函数里调用，因为在构造StockFactory的时候，它还没有被交给shared_ptr接管</p><h3 id="1-11-2-弱回调"><a href="#1-11-2-弱回调" class="headerlink" title="1.11.2 弱回调"></a>1.11.2 弱回调</h3><blockquote><p>shared_ptr绑到boost:function里，那么回调的时候StockFactory对象始终存在</p><p>有时候我们需要“如果对象还活着，就调用它的成员函数，否则忽略之”，称之为“弱回调”</p></blockquote><p>利用weak_ptr可以实现弱回调，可以把weak_ptr绑到boost::function里，这样对象的生命期就不会被延长。然后在回调的时候先尝试提升为shared_ptr，如果提升成功，说明接受回调的对象还健在，那么就执行回调；如果提升失败，就不必劳神了。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912095447284.png"></p><h2 id="1-12-替代方案"><a href="#1-12-替代方案" class="headerlink" title="1.12 替代方案"></a>1.12 替代方案</h2><p>除了使用shared_ptr&#x2F;weak_ptr，做到线程安全的对象回调与析构还有以下办法：</p><ul><li>所有线程通过一个全局对象去访问想访问的对象（加了个中间层）</li><li>只创建不销毁</li><li>自己编写引用计数的智能指针</li><li>使用unique_ptr</li></ul><h2 id="1-13-心得与体会"><a href="#1-13-心得与体会" class="headerlink" title="1.13 心得与体会"></a>1.13 心得与体会</h2><ul><li>尽量减少使用跨线程的对象</li><li>原始指针暴露给多个线程往往会造成race condition或额外的簿记负担</li><li>统一用shared_ptr&#x2F;scoped_ptr来管理对象的生命期，在多线程中尤其重要</li><li>shared_ptr是值语意，当心意外延长对象的生命期。例如boost::bind和容器都可能拷贝shared_ptr</li><li>weak_ptr是shared_ptr的好搭档，可以用作弱回调、对象池等</li></ul><h1 id="第2章-线程同步精要"><a href="#第2章-线程同步精要" class="headerlink" title="第2章 线程同步精要"></a>第2章 线程同步精要</h1><blockquote><p>并发编程有两种基本模型，一种是message passing，另一种是shared memory。</p><p>在分布式系统中，运行在多台机器上的多个进程的并行编程只有一种实用模型：message passing1。</p><p>在单机上，可以使用message passing作为多个进程的并发模型。这样整个分布式系统的架构的一致性很强，扩容（scale out）起来也较容易。</p></blockquote><p><strong>线程同步的四项原则</strong>：</p><ul><li>首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑immutable对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。</li><li>其次是使用高级的并发编程构件，如TaskQueue、Producer-Consumer Queue、CountDownLatch等等。</li><li>最后不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。</li><li>除了使用atomic整数之外，不自己编写lock-free代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如spin lock vs. mutex。</li></ul><h2 id="2-1-互斥器"><a href="#2-1-互斥器" class="headerlink" title="2.1 互斥器"></a>2.1 互斥器</h2><p>互斥器（mutex）保护了临界区，任何一个时刻最多只能有一个线程在此mutex划出的临界区内活动。单独使用mutex时，主要为了保护共享数据。</p><p><strong>主要使用原则</strong></p><ul><li>用RAII手法封装mutex的创建、销毁、加锁、解锁这四个操作，保证锁的生效期间等于一个作用域（scope），不会因异常而忘记解锁。</li><li>只用非递归的mutex（即不可重入的mutex）</li><li>不手工调用lock()和unlock()函数，一切交给栈上的Guard对象的构造和析构函数负责。Guard对象的生命期正好等于临界区。保证始终在同一个函数同一个scope里对某个mutex加锁和解锁。避免在foo()里加锁，然后跑到bar()里解锁；也避免在不同的语句分支中分别加锁、解锁。这种做法被称为Scoped Locking。</li><li>在每次构造Guard对象的时候，思考一路上（调用栈上）已经持有的锁，防止因加锁顺序不同而导致死锁（deadlock）。由于Guard对象是栈上对象，看函数调用栈就能分析用锁的情况，非常便利</li></ul><p><strong>次要使用原则</strong></p><ul><li>不使用<em>跨进程</em>的mutex，进程间通信只用TCP sockets</li><li>加锁、解锁在同一个线程，线程a不能去unlock线程b已经锁住的mutex（RAII自动保证）</li><li>别忘了解锁（RAII自动保证）</li><li>不重复解锁（RAII自动保证）</li><li>必要的时候可以考虑用PTHREAD_MUTEX_ERRORCHECK来排错</li></ul><h3 id="2-1-1-只使用非递归的mutex"><a href="#2-1-1-只使用非递归的mutex" class="headerlink" title="2.1.1 只使用非递归的mutex"></a>2.1.1 只使用非递归的mutex</h3><blockquote><p>mutex分为递归（recursive）和非递归（non-recursive）两种，或叫可重入（reentrant）与非可重入</p><p>唯一区别在于：同一个线程可以重复对recursive mutex加锁，但是不能重复对non-recursive mutex加锁。</p><p>non-recursive和recursive的性能差别其实不大，因为少用一个计数器，前者略快一点点</p></blockquote><p>non-recursive mutex优点就是多次加锁会立刻导致死锁，使得代码问题及时暴露</p><p>典型情况是以为拿到一个锁就能修改对象了，没想到外层代码已经拿到了锁，正在修改（或读取）同一个对象</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912112117338.png"></p><p>post()加锁，然后修改foos对象；traverse()加锁，然后遍历foos向量。这些都是正确的。</p><p>但是，如果Foo::doit()间接调用了post()，那么会很有戏剧性的结果：</p><ul><li>mutex是非递归的，于是死锁了。</li><li>mutex是递归的，由于push_back()可能（但不总是）导致vector迭代器失效，程序偶尔会crash。</li></ul><p>使用非递归的优点就体现出来了，使我们能更早发现程序的逻辑错误并解决</p><p>如果一个函数既可能在已加锁的情况下调用，又可能在未加锁的情况下调用，那么就拆成两个函数：</p><ul><li>跟原来的函数同名，函数加锁，转而调用第2个函数。</li><li>给函数名加上后缀WithLockHold，不加锁，把原来的函数体搬过来。</li></ul><blockquote><p>可能出现两个问题：</p><ul><li><p>（a）误用了加锁版本，死锁了（使用2.1.2方法解决）</p></li><li><p>（b）误用了不加锁版本，数据损坏了</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912112442239.png"></p></li></ul></blockquote><h3 id="2-1-2-死锁"><a href="#2-1-2-死锁" class="headerlink" title="2.1.2 死锁"></a>2.1.2 死锁</h3><p>解决死锁：应使得临界区不交叉</p><h2 id="2-2-条件变量"><a href="#2-2-条件变量" class="headerlink" title="2.2 条件变量"></a>2.2 条件变量</h2><p>条件变量即等待某个条件成立然后被唤醒，其学名叫<em>管程</em></p><p><strong>条件变量wait使用</strong>：</p><ul><li>1．必须与mutex一起使用，该布尔表达式的读写需受此mutex保护。</li><li>2．在mutex已上锁的时候才能调用wait()。</li><li>3．把判断布尔条件和wait()放到while循环中。</li></ul><p><strong>条件变量signal&#x2F;broadcast使用</strong>：</p><ul><li>1．不一定要在mutex已上锁的情况下调用signal（理论上）</li><li>2．在signal之前一般要修改布尔表达式。</li><li>3．修改布尔表达式通常要用mutex保护（至少用作full memory barrier）。</li><li>4．注意区分signal与broadcast：“broadcast通常用于表明状态变化，signal通常用于表示资源可用。</li></ul><p>条件变量是非常底层的同步原语，很少直接使用，一般都是用它来实现高层的同步措施，如BlockingQueue<T>或CountDownLatch。</p><blockquote><p>倒计时（CountDownLatch）是一种常用且易用的同步手段。它主要有两种用途：</p><ul><li>主线程发起多个子线程，等这些子线程各自都完成一定的任务之后，主线程才继续执行。通常用于主线程等待多个子线程完成初始化。</li><li>主线程发起多个子线程，子线程都等待主线程，主线程完成其他一些任务之后通知所有子线程开始执行。通常用于多个子线程等待主线程发出“起跑”命令。</li></ul><p>CountDownLatch简单实现如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912195311021.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912195328455.png"></p></blockquote><blockquote><p>BlockingQueue简单实现如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912195438814.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912195500887.png"></p></blockquote><p>互斥器和条件变量构成了多线程编程的全部必备同步原语，用它们即可完成任何多线程同步任务，二者不能相互替代</p><h2 id="2-3-不要用读写锁和信号量"><a href="#2-3-不要用读写锁和信号量" class="headerlink" title="2.3 不要用读写锁和信号量"></a>2.3 不要用读写锁和信号量</h2><p><strong>读写锁区分了read和write两种行为，但是其并不一定比mutex好</strong></p><ul><li>正确性，在持有read lock时可能会调用修改数据的函数</li><li>性能，读写锁因为要更新当前reader数目，因此其开销不比mutex小，且如果竞争不激烈，mutex会更快</li><li>如果允许读锁提升为写锁，那么有些情况本应发生死锁的情况只是发生了程序崩溃，使得不易排查</li><li>通常reader lock是可重入的，writer lock是不可重入的。但是为了防止writer饥饿，writer lock通常会阻塞后来的reader lock，因此reader lock在重入的时候可能死锁</li><li>如果确实对并发读写有极高的性能要求，可以考虑read-copy-update</li></ul><p><strong>条件变量配合互斥器可以完全替代信号量</strong></p><ul><li>信号量有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能</li><li>使用信号量的一些场景如哲学家就餐，可以进行简化，设计成简单的资源争抢</li></ul><h2 id="2-4-封装MutexLock、MutexLockGuard、Condition"><a href="#2-4-封装MutexLock、MutexLockGuard、Condition" class="headerlink" title="2.4 封装MutexLock、MutexLockGuard、Condition"></a>2.4 封装MutexLock、MutexLockGuard、Condition</h2><p>MutexLock、MutexLockGuard类定义</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220913110208143.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220913110223337.png"></p><p>注意上面代码的最后一行定义了一个宏，这个宏的作用是防止程序里出现如下错误：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220913110443295.png"></p><p>上述代码还有改进地方：</p><ul><li>mutex创建为PTHREAD_MUTEX_DEFAULT类型，而不是PTHREAD_MUTEX_NORMAL类型（实际上这二者很可能是等同的），严格的做法是用mutexattr来显示指定mutex的类型</li><li>没有检查返回值。这里不能用assert()检查返回值，因为assert()在release build里是空语句。</li></ul></blockquote><p>Condition类将mutex和条件变量绑定了，没有实现wait时指定mutex，定义如下</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914095528426.png"></p><p>如果一个class要包含MutexLock和Condition，请注意它们的声明顺序和初始化顺序，mutex_应先于condition_构造，并作为后者的构造参数：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914095635228.png"></p></blockquote><h2 id="2-5-线程安全的Singleton实现"><a href="#2-5-线程安全的Singleton实现" class="headerlink" title="2.5 线程安全的Singleton实现"></a>2.5 线程安全的Singleton实现</h2><p>Singleton的线程安全实现使用double checked locking也是靠不住的，可使用pthread_once来保证</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914100255773.png"></p><p>使用方法：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914100320437.png"></p><blockquote><p>这个Singleton没有考虑对象的销毁。在长时间运行的服务器程序里，这不是一个问题，反正进程也不打算正常退出。在短期运行的程序中，程序退出的时候自然就释放所有资源了（前提是程序里不使用不能由操作系统自动关闭的资源，比如跨进程的mutex）</p></blockquote><h2 id="2-6-sleep-3-不是同步原语"><a href="#2-6-sleep-3-不是同步原语" class="headerlink" title="2.6 sleep(3)不是同步原语"></a>2.6 sleep(3)不是同步原语</h2><blockquote><p>生产代码中线程的等待可分为两种：</p><ul><li>一种是等待资源可用（要么等在select&#x2F;poll&#x2F;epoll_wait上，要么等在条件变量上43）；</li><li>一种是等着进入临界区（等在mutex上）以便读写共享数据。后一种等待通常极短，否则程序性能和伸缩性就会有问题。</li></ul></blockquote><p>在程序的正常执行中，如果需要等待一段已知的时间，应该往event loop里注册一个timer，然后在timer的回调函数里接着干活，因为线程是个珍贵的共享资源，不能轻易浪费</p><p>如果等待某个事件发生，那么应该采用条件变量或IO事件回调，不能用sleep来轮询</p><p>等待某个事件发生，正确的做法是用select()等价物或Condition，抑或（更理想地）高层同步工具；在用户态做轮询（polling）是低效的。</p><h2 id="2-7-归纳与总结"><a href="#2-7-归纳与总结" class="headerlink" title="2.7 归纳与总结"></a>2.7 归纳与总结</h2><p>前面几节内容归纳如下：</p><ul><li>线程同步的四项原则，尽量用高层同步设施（线程池、队列、倒计时）</li><li>使用普通互斥器和条件变量完成剩余的同步任务，采用RAII惯用手法（idiom）和Scoped Locking。</li></ul><h2 id="2-8-借shared-ptr实现copy-on-write"><a href="#2-8-借shared-ptr实现copy-on-write" class="headerlink" title="2.8 借shared_ptr实现copy-on-write"></a>2.8 借shared_ptr实现copy-on-write</h2><p>使用普通mutex替换读写锁，都基于用shared_ptr来管理共享数据，原理如下：</p><ul><li>shared_ptr是引用计数型智能指针，如果当前只有一个观察者，那么引用计数的值为147。</li><li>对于write端，如果发现引用计数为1，这时可以安全地修改共享对象，不必担心有人正在读它。</li><li>对于read端，在读之前把引用计数加1，读完之后减1，这样保证在读的期间其引用计数大于1，可以阻止并发写。</li><li>比较难的是，对于write端，如果发现引用计数大于1，该如何处理？将原来数据复制一份，在复制数据上进行修改，然后再拷贝回去（不直接在原来数据上修改是因为还有线程在读，读线程的互斥锁可能只有取数据那一小部分临界区，而进行处理的操作可能没在临界区）。</li></ul><blockquote><p>示例</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914105842469.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914105909144.png"></p><p>读函数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914110003319.png"></p><p>写函数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914110031548.png"></p></blockquote><h1 id="第3章-多线程服务器的适用场合与常用编程模型"><a href="#第3章-多线程服务器的适用场合与常用编程模型" class="headerlink" title="第3章 多线程服务器的适用场合与常用编程模型"></a>第3章 多线程服务器的适用场合与常用编程模型</h1><h2 id="3-1-进程与线程"><a href="#3-1-进程与线程" class="headerlink" title="3.1 进程与线程"></a>3.1 进程与线程</h2><p>多进程设计时需要思考以下内容：</p><ul><li>容错</li><li>扩容</li><li>负载均衡</li><li>退休（暂停使用）</li></ul><p>线程的特点是共享地址空间，从而可以高效地共享数据</p><h2 id="3-2-单线程服务器的常用编程模型"><a href="#3-2-单线程服务器的常用编程模型" class="headerlink" title="3.2 单线程服务器的常用编程模型"></a>3.2 单线程服务器的常用编程模型</h2><p>Reactor模式：non-blocking IO＋IO multiplexing（IO多路复用）</p><p>其基本结构是一个事件循环（event loop），以事件驱动（event-driven）和事件回调的方式实现业务逻辑：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914111640559.png"></p><blockquote><p>基于事件驱动的编程模型也有其本质的缺点，它要求事件回调函数必须是非阻塞的。对于涉及网络IO的请求响应式协议，它容易割裂业务逻辑，使其散布于多个回调函数之中，相对不容易理解和维护</p></blockquote><h2 id="3-3-多线程服务器的常用编程模型"><a href="#3-3-多线程服务器的常用编程模型" class="headerlink" title="3.3 多线程服务器的常用编程模型"></a>3.3 多线程服务器的常用编程模型</h2><p>主要有以下几种方法：</p><ul><li>每个请求创建一个线程，使用阻塞式IO操作</li><li>使用线程池，同样使用阻塞式IO操作（相比上一种能提高性能）</li><li>使用non-blocking IO＋IO multiplexing（one loop per thread）</li><li>Leader&#x2F;Follower等高级模式</li></ul><h3 id="3-3-1-one-loop-per-thread"><a href="#3-3-1-one-loop-per-thread" class="headerlink" title="3.3.1 one loop per thread"></a>3.3.1 one loop per thread</h3><p>此模型下，程序里的每个IO线程有一个event loop（或者叫Reactor），用于处理读写和定时事件</p><blockquote><p>好处：</p><ul><li>线程数目基本固定，可以在程序启动的时候设置，不会频繁创建与销毁。</li><li>可以很方便地在线程间调配负载。</li><li>IO事件发生的线程是固定的，同一个TCP连接不必考虑事件并发。</li></ul></blockquote><p>Eventloop代表了线程的主循环，需要让哪个线程干活，就把timer或IOchannel（如TCP连接）注册到哪个线程的loop里即可，因此这个loop必须得是线程安全的</p><p>对于non-trivial的服务端程序，一般会采用non-blocking IO＋IO multiplexing，每个connection&#x2F;acceptor都会注册到某个event loop上，程序里有多个event loop，每个线程至多有一个event loop。</p><h3 id="3-3-2-线程池"><a href="#3-3-2-线程池" class="headerlink" title="3.3.2 线程池"></a>3.3.2 线程池</h3><p>对于没有IO而光有计算任务的线程，使用event loop有点浪费，用blocking queue实现的任务队列（TaskQueue）效果会更好</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220915095054503.png"></p><p>用这种方式实现线程池特别容易，以下是启动容量（并发数）为N的线程池：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220915095146398.png"></p><p>使用方法：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220915095225249.png"></p><p>可以用BlockingQueue<T>实现数据的生产者消费者队列，T是数据类型而非函数对象，queue的消费者从中拿到数据进行处理</p><h3 id="3-3-3-推荐模式"><a href="#3-3-3-推荐模式" class="headerlink" title="3.3.3 推荐模式"></a>3.3.3 推荐模式</h3><p>推荐的C++多线程服务端编程模式为：one (event) loop per thread+ thread pool：</p><ul><li>event loop（也叫IO loop）用作IO multiplexing，配合non-blocking IO和定时器。</li><li>thread pool用来做计算，具体可以是任务队列或生产者消费者队列。</li></ul><h2 id="3-4-进程间通信只用TCP"><a href="#3-4-进程间通信只用TCP" class="headerlink" title="3.4 进程间通信只用TCP"></a>3.4 进程间通信只用TCP</h2><blockquote><p>Linux下进程间通信（IPC）的方式很多：匿名管道（pipe）、具名管道（FIFO）、POSIX消息队列、共享内存、信号（signals）等等，更不必说Sockets了。同步原语（synchronization primitives）也很多，如互斥器（mutex）、条件变量（condition variable）、读写锁（reader-writer lock）、文件锁（record locking）、信号量（semaphore）等等</p></blockquote><p>进程间通信选Sockets主要好处在于：可以跨主机，具有伸缩性。而其他IPC都不能跨机器。</p><p>使用TCP这种字节流（byte stream）方式通信，会有marshal&#x2F;unmarshal的开销，这要求选用合适的消息格式，准确地说是wire format，推荐Google Protocol Buffers</p><blockquote><p>优点：</p><ul><li>TCP port由一个进程独占，且操作系统会自动回收（<em>listening port和已建立连接的TCP socket都是文件描述符，在进程结束时操作系统会关闭所有文件描述符</em>）</li><li>port是独占的，那么可以防止程序重复启动，后面那个进程抢不到port，自然就没法初始化了，避免造成意料之外的结果</li><li>两个进程通过TCP通信，如果一个崩溃了，操作系统会关闭连接，另一个进程几乎立刻就能感知</li><li>TCP协议的一个天生的好处是“可记录、可重现”，很方便使用工具进行分析</li><li>TCP连接是可再生的，连接的任何一方都可以退出再启动，重建连接之后就能继续工作，这对开发牢靠的分布式系统意义重大</li></ul></blockquote><p><strong>分布式系统中使用TCP长连接通信</strong></p><ul><li>分布式系统的软件设计和功能划分一般应该以“进程”为单位。从宏观上看，一个分布式系统是由运行在多台机器上的多个进程组成的，进程之间采用TCP长连接通信</li><li>容易定位分布式系统中的服务之间的依赖关系，TCP短连接和UDP则不具备这一特性</li><li>通过接收和发送队列的长度也较容易定位网络或程序故障</li></ul><h2 id="3-5-多线程服务器的适用场合"><a href="#3-5-多线程服务器的适用场合" class="headerlink" title="3.5 多线程服务器的适用场合"></a>3.5 多线程服务器的适用场合</h2><blockquote><p>开发服务端程序的一个基本任务是处理并发连接，现在服务端网络编程处理并发连接主要有两种方式：</p><ul><li>当“线程”很廉价时，一台机器上可以创建远高于CPU数目的“线程”。这时一个线程只处理一个TCP连接，通常使用阻塞IO。例如，Python gevent、Go goroutine、Erlang actor。这里的“线程”由语言的runtime自行调度，与操作系统线程不是一回事。</li><li>当线程很宝贵时，一台机器上只能创建与CPU数目相当的线程。这时一个线程要处理多个TCP连接上的IO，通常使用非阻塞IO和IO multiplexing。例如，libevent、muduo、Netty。这是原生线程，能被操作系统的任务调度器看见。</li></ul></blockquote><p>如果要在一台多核机器上提供一种服务或执行一个任务，可用的模式有：</p><ul><li>1．运行一个单线程的进程（不可伸缩，无法发挥多喝机器的计算能力）</li><li>2．运行一个多线程的进程</li><li>3．运行多个单线程的进程<ul><li>a. 简单地把模式1中的进程运行多份</li><li>b. 主进程+woker进程，如果必须绑定到一个TCP port，比如httpd+fastcgi</li></ul></li><li>4．运行多个多线程的进程</li></ul><p><strong>程序是否应该使用多线程判断方法</strong>：</p><ul><li>如果执行任务时间远大于进程启动和销毁开销，那么应该使用进程</li><li>如果执行任务时间接近进程开销大很多且也并未接近线程开销，那么使用线程（这里的接近是指大约在高一个数量级左右）</li><li>如果执行任务时间接近线程开销，那么直接就在当前线程执行或使用线程池</li></ul><h3 id="3-5-1-必须用单线程的场合"><a href="#3-5-1-必须用单线程的场合" class="headerlink" title="3.5.1 必须用单线程的场合"></a>3.5.1 必须用单线程的场合</h3><p>有两种场合必须使用单线程：</p><ul><li>1．程序可能会fork()（作者认为只有守护进程类型必须坚持单线程模式）</li><li>2．限制程序的CPU占用率（单线程最多使用一个核，占用率不会很高，不会影响其他任务）</li></ul><h3 id="3-5-2-单线程程序的优缺点"><a href="#3-5-2-单线程程序的优缺点" class="headerlink" title="3.5.2 单线程程序的优缺点"></a>3.5.2 单线程程序的优缺点</h3><p>单线程程序的优势：简单</p><p>单线程程序的缺点：非抢占（如果事件a优先级高级事件b，而a所需时间比b短，但如果b先来则开始处理，其实已经发生优先级反转）</p><h3 id="3-5-3-适用多线程程序的场景"><a href="#3-5-3-适用多线程程序的场景" class="headerlink" title="3.5.3 适用多线程程序的场景"></a>3.5.3 适用多线程程序的场景</h3><p>多线程的适用场景是：提高响应速度，让IO和“计算”相互重叠，降低延迟</p><p>一个程序要做成多线程的，大致要满足：</p><ul><li>有多个CPU可用。单核机器上多线程没有性能优势</li><li>线程间有共享数据，即内存中的全局状态（如果没有共享数据，用模型3b就行。虽然我们应该把线程间的共享数据降到最低，但不代表没有）</li><li>共享的数据是可以修改的，而不是静态的常量表（如果数据不能修改，那么可以在进程间用shared memory，模式3就能胜任）</li><li>提供非均质的服务。即，事件的响应有优先级差异，我们可以用专门的线程来处理优先级高的事件。防止优先级反转。</li><li>不是逻辑简单的IO bound或CPU bound程序，即程序要有相当的计算量。</li><li>利用异步操作。比如logging。无论往磁盘写log file，还是往log server发送消息都不应该阻塞critical path。</li><li>能scale up。一个好的多线程程序应该能享受增加CPU数目带来的好处</li><li>具有可预测的性能。随着负载增加，性能缓慢下降，超过某个临界点之后会急速下降。线程数目一般不随负载变化。</li><li>多线程能有效地划分责任与功能，让每个线程的逻辑比较简单，任务单一，便于编码。而不是把所有逻辑都塞到一个event loop里，不同类别的事件之间相互影响</li></ul><p>书里提供了一个服务器集群管理示例，可阅读</p><p><strong>线程的分类</strong></p><ul><li>1．IO线程，这类线程的主循环是IO multiplexing，阻塞地等在select&#x2F;poll&#x2F;epoll_wait系统调用上。这类线程也处理定时事件。有些简单计算也可以放入其中，比如消息的编码或解码。</li><li>2．计算线程，这类线程的主循环是blockingqueue，阻塞地等在conditionvariable上。这类线程一般位于thread pool中。这种线程通常不涉及IO，一般要避免任何阻塞操作。</li><li>3．第三方库所用的线程，比如logging，又比如database connection。</li></ul><p>服务器程序一般不会频繁地启动和终止线程，可在程序启动的时候就创建</p><h2 id="3-6-“多线程服务器的适用场合”例释与答疑"><a href="#3-6-“多线程服务器的适用场合”例释与答疑" class="headerlink" title="3.6 “多线程服务器的适用场合”例释与答疑"></a>3.6 “多线程服务器的适用场合”例释与答疑</h2><ol><li>Linux能同时启动多少个线程？</li></ol><blockquote><p>对于32-bit Linux，一个进程的地址空间是4GiB，其中用户态能访问3GiB左右，而一个线程的默认栈（stack）大小是10MB，一个进程大约最多能同时启动300个线程。对于64-bit系统，线程数目可大大增加</p></blockquote><ol start="2"><li>多线程能提高并发度吗？</li></ol><blockquote><p>单纯采用thread per connection的模型，那么并发连接数最多300，这远远低于基于Reactor模式的并发连接数（几千乃至上万，甚至几万）</p><p>thread per connection不适合高并发场合，其scalability不佳。one loop per thread的并发度足够大，且与CPU数目成正比</p></blockquote><ol start="3"><li>多线程能提高吞吐量吗？</li></ol><blockquote><p>对于计算密集型服务，不能。这里指的时总体吞吐量，能加快单个任务运算速度。</p></blockquote><ol start="4"><li>多线程能降低响应时间吗？</li></ol><blockquote><p>如果设计合理，充分利用多核资源的话，可以。在突发（burst）请求时效果尤为明显</p></blockquote><ol start="5"><li>多线程程序如何让IO和“计算”相互重叠，降低latency？</li></ol><blockquote><p>基本思路是，把IO操作（通常是写操作）通过BlockingQueue交给别的线程去做，自己不必等待。</p></blockquote><ol start="6"><li>为什么第三方库往往要用自己的线程？</li></ol><blockquote><p>event loop模型没有标准实现。如果自己写代码，尽可以按所用Reactor的推荐方式来编程。但是第三方库不一定能很好地适应并融入这个event loop framework，有时需要用线程来做一些串并转换。</p><p>比方说检测串口上的数据到达可以用文件描述符的可读事件，因此可以方便地融入event loop。但是检测串口上的某些控制信号只能用轮询或阻塞等待，要想融入event loop，需要单独起一个线程来查询串口信号翻转，再转换为文件描述符的读写事件。</p></blockquote><ol start="7"><li>什么是线程池大小的阻抗匹配原则？</li></ol><blockquote><p>如果线程在执行任务时密集计算所占的时间比重为P，而系统一共有C个CPU，为了让这C个CPU跑满而又不过载，线程池大小的经验公式T＝C&#x2F;P，但是P小于0.2时则不适用了，T可以取项目所需的固定值</p></blockquote><ol start="8"><li>除了你推荐的Reactor＋thread poll，还有别的non-trivial多线程编程模型吗？</li></ol><blockquote><p>Proactor。如果一次请求响应中要和别的进程打多次交道，那么Proactor模型往往能做到更高的并发度。当然，代价是代码变得支离破碎，难以理解。</p><p>Proactor模式依赖操作系统或库来高效地调度这些子任务，每个子任务都不会阻塞，因此能用比较少的线程达到很高的IO并发度。</p><p>Proactor能提高吞吐，但不能降低延迟</p><p>书中有个案例</p></blockquote><ol start="9"><li>模式2和模式3a该如何取舍？</li></ol><blockquote><p>模式2是一个多线程的进程，模式3a是多个相同的单线程进程</p><p>在其他条件相同的情况下，可以根据工作集（work set）的大小来取舍。工作集是指服务程序响应一次请求所访问的内存大小。如果工作集较大，那么就用多线程，避免CPU cache换入换出，影响性能；否则，就用单线程多进程，享受单线程编程的便利。</p><p>举例来说如果程序有一个较大的本地cache，用于缓存一些基础参考数据，几乎每次请求都会访问cache，那么多线程更适合一些，因为可以避免每个进程都自己保留一份cache，增加内存使用。</p></blockquote><h1 id="第4章-C-多线程系统编程精要"><a href="#第4章-C-多线程系统编程精要" class="headerlink" title="第4章 C++多线程系统编程精要"></a>第4章 C++多线程系统编程精要</h1><p>学习多线程编程思维方式的转变有两点：</p><ul><li>当前线程可能随时会被切换出去，或者说被抢占了</li><li>多线程程序中事件的发生顺序不再有全局统一的先后关系</li></ul><h2 id="4-1-基本线程原语的选用"><a href="#4-1-基本线程原语的选用" class="headerlink" title="4.1 基本线程原语的选用"></a>4.1 基本线程原语的选用</h2><p>11个最基本的Pthreads函数是：</p><ul><li>2个：线程的创建和等待结束（join）。封装为muduo::Thread</li><li>4个：mutex的创建、销毁、加锁、解锁。封装为muduo::MutexLock</li><li>5个：条件变量的创建、销毁、等待、通知、广播。封装为muduo::Condition。</li></ul><p>可以酌情使用的有：</p><ul><li>pthread_once，封装为muduo::Singleton<T>。其实不如直接用全局变量。</li><li>pthread_key*，封装为muduo::ThreadLocal<T>。可以考虑用_thread替换之。不建议使用</li><li>pthread_rwlock，读写锁通常应慎用。muduo没有封装读写锁，这是有意的。</li><li>sem_*，避免用信号量（semaphore）。它的功能与条件变量重合，但容易用错。</li><li>pthread{cancel, kill}。程序中出现了它们，则通常意味着设计出了问题。</li></ul><h2 id="4-2-C-x2F-C-系统库的线程安全性"><a href="#4-2-C-x2F-C-系统库的线程安全性" class="headerlink" title="4.2 C&#x2F;C++系统库的线程安全性"></a>4.2 C&#x2F;C++系统库的线程安全性</h2><p>编写线程安全程序的一个难点在于线程安全是不可组合的（两个函数是线程安全的，但组合调用则不一定线程安全）</p><p>设计线程安全的接口基本思路是尽量把class设计成immutable的</p><p>C++系统库：</p><ul><li><p>C++的标准库容器和std::string都不是线程安全的</p></li><li><p>C++标准库中的绝大多数泛型算法是线程安全的12，因为这些都是无状态纯函数。只要输入区间是线程安全的，那么泛型函数就是线程安全的。</p></li><li><p>C++的iostream不是线程安全的，因为流式输出多个数据相当于调用了多个函数（可以改用printf，但不高效）</p></li></ul><h2 id="4-3-Linux上的线程标识"><a href="#4-3-Linux上的线程标识" class="headerlink" title="4.3 Linux上的线程标识"></a>4.3 Linux上的线程标识</h2><blockquote><p>threads库提供了pthread_self函数用于返回当前进程的标识符，其类型为pthread_t，不一定是一个数值类型，也有可能是一个结构体。专门提供了pthread_equal函数用于对比两个线程标识符是否相等。这就带来一系列问题，包括：</p><ul><li>无法打印输出pthread_t，因为不知道其确切类型</li><li>无法比较pthread_t的大小或计算其hash值，因此无法用作关联容器的key</li><li>无法定义一个非法的pthread_t值，用来表示绝对不可能存在的线程id，因此MutexLock class没有办法有效判断当前线程是否已经持有本锁</li><li>pthread_t值只在进程内有意义，与操作系统的任务调度之间无法建立有效关联。比方说在&#x2F;proc文件系统中找不到pthread_t对应的task。</li></ul><p>glibc的Pthreads实现实际上把pthread_t用作一个结构体指针，指向一块动态分配的内存，而且这块内存是反复使用的。这就造成pthread_t的值很容易重复。Pthreads只保证同一进程之内，同一时刻的各个线程的id不同；不能保证同一进程先后多个线程具有不同的id，更不要说一台机器上多个进程之间的id唯一性了。</p></blockquote><p>在Linux上，建议使用gettid()系统调用的返回值作为线程id，这么做的好处有：</p><ul><li>它的类型是pid_t，其值通常是一个小整数，便于在日志中输出。</li><li>在现代Linux中，它直接表示内核的任务调度id，因此在&#x2F;proc文件系统中可以轻易找到对应项</li><li>在其他系统工具中也容易定位到具体某一个线程，例如在top()中我们可以按线程列出任务，然后找出CPU使用率最高的线程id，再根据程序日志判断到底哪一个线程在耗用CPU。</li><li>任何时刻都是全局唯一的，并且由于Linux分配新pid采用递增轮回办法，短时间内启动的多个线程也会具有不同的线程id。</li><li>0是非法值，因为操作系统第一个进程init的pid是1。</li></ul><p>每次都执行一次gettid()系统调用效率不高，解决办法是缓存第一次请求返回的值。</p><h2 id="4-4-线程的创建与销毁的守则"><a href="#4-4-线程的创建与销毁的守则" class="headerlink" title="4.4 线程的创建与销毁的守则"></a>4.4 线程的创建与销毁的守则</h2><p><strong>线程的创建遵循原则：</strong></p><ul><li><p>程序库不应该在未提前告知的情况下创建自己的“背景线程”</p><blockquote><p>否则会导致资源规划漏算且不能安全fork</p></blockquote></li><li><p>尽量用相同的方式创建线程，例如muduo::Thread</p></li><li><p>在进入main()函数之前不应该启动线程</p><blockquote><p>也就是别在全局对象中创建线程，这会影响其他全局对象的安全构造，C++保证在进入main()之前完成全局对象16的构造</p></blockquote></li><li><p>程序中线程的创建最好能在初始化阶段全部完成</p><blockquote><p>一个服务程序的线程数目应该与当前负载无关，而应该与机器的CPU数目有关，即应该规划好线程个数</p></blockquote></li></ul><p><strong>线程的销毁方式：</strong></p><ul><li>自然死亡。从线程主函数返回，线程正常退出。</li><li>非正常死亡。从线程主函数抛出异常或线程触发segfault信号等非法操作18。</li><li>自杀。在线程中调用pthread_exit()来立刻退出线程。</li><li>他杀。其他线程调用pthread_cancel()来强制终止某个线程。</li></ul><p>线程正常退出的方式只有一种，即自然死亡。任何从外部强行终止线程的做法和想法都是错的</p><blockquote><p>如果确实需要强行终止一个耗时很长的计算任务，而又不想在计算期间周期性地检查某个全局退出标志，那么可以考虑把那一部分计算任务代码fork()，以一个新进程启动，杀一个进程比杀本进程内的线程要安全得多</p><p>新进程与本进程的通信方式最好用文件描述符</p></blockquote><h3 id="4-4-1-pthread-cancel与C"><a href="#4-4-1-pthread-cancel与C" class="headerlink" title="4.4.1 pthread_cancel与C++"></a>4.4.1 pthread_cancel与C++</h3><p>POSIX threads有cancellation point这个概念，意思是线程执行到这里有可能会被终止（cancel）</p><p>在C++中，cancellation point的实现与C语言有所不同，线程不是执行到此函数就立刻终止，而是该函数会抛出异常。这样可以有机会执行stack unwind，析构栈上对象（特别是释放持有的锁）</p><h3 id="4-4-2-exit-3-在C-中不是线程安全的"><a href="#4-4-2-exit-3-在C-中不是线程安全的" class="headerlink" title="4.4.2　exit(3)在C++中不是线程安全的"></a>4.4.2　exit(3)在C++中不是线程安全的</h3><p>exit(3)函数在C++中的作用除了终止进程，还会析构全局对象和已经构造完的函数静态对象。这有潜在的死锁可能</p><blockquote><p>例子如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220917173424329.png"></p><p>书中还有个exit推出例子，意思是一个全局对象被多个线程调用，在一个线程中调用了exit(3)，那么这个全局对象被析构，另一个线程调用此全局对象则会发生崩溃</p></blockquote><p>如果确实需要主动结束线程，则可以考虑用_exit(2)系统调用。它不会试图析构全局对象，但是也不会执行其他任何清理工作，比如flush标准输出。</p><h2 id="4-5-善用-thread关键字"><a href="#4-5-善用-thread关键字" class="headerlink" title="4.5 善用__thread关键字"></a>4.5 善用__thread关键字</h2><p>__thread是<a href="https://so.csdn.net/so/search?q=GCC&spm=1001.2101.3001.7020">GCC</a>内置的线程局部存储设施。thread变量每一个线程有一份独立实体，各个线程的值互不干扰。</p><p>__thread变量的存取效率可与全局变量相比</p><p><strong>thread使用规则</strong>：</p><ul><li>只能用于修饰POD类型，不能修饰class类型，因为无法自动调用构造函数和析构函数。</li><li>thread可以用于修饰全局变量、函数内的静态变量，但是不能用于修饰函数的局部变量或者class的普通成员变量。</li><li>__thread变量的初始化只能用编译期常量。</li><li>可以用来修饰那些带有全局性且值可能变，但是又不值得用全局变量保护的变量。</li></ul><h2 id="4-6-多线程与IO"><a href="#4-6-多线程与IO" class="headerlink" title="4.6 多线程与IO"></a>4.6 多线程与IO</h2><blockquote><p>操作文件描述符的系统调用本身是线程安全的，不用担心多个线程同时操作文件描述符会造成进程崩溃或内核崩溃</p></blockquote><p><strong>多线程程序应该遵循的原则</strong>是：每个文件描述符只由一个线程操作，从而轻松解决消息收发的顺序性问题，也避免了关闭文件描述符的各种race condition。一个线程可以操作多个文件描述符，但一个线程不能操作别的线程拥有的文件描述符。epoll也遵循相同的原则。</p><p><strong>两个例外</strong>：对于磁盘文件，在必要的时候多个线程可以同时调用pread(2)&#x2F;pwrite(2)来读写同一个文件；对于UDP，由于协议本身保证消息的原子性，在适当的条件下（比如消息之间彼此独立）可以多个线程同时读写同一个UDP文件描述符。</p><h2 id="4-7-用RAII包装文件描述符"><a href="#4-7-用RAII包装文件描述符" class="headerlink" title="4.7 用RAII包装文件描述符"></a>4.7 用RAII包装文件描述符</h2><blockquote><p>Linux的文件描述符（file descriptor）是小整数，在程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这时如果我们新打开一个文件，它的文件描述符会是3，因为POSIX标准要求每次新打开文件（含socket）的时候必须使用当前最小可用的文件描述符号码。</p><p>这种分配文件描述符的方式稍不注意就会造成串话，比如一个线程正准备read()某个socket，而第二个线程几乎同时close()了此socket；第三个线程又恰好open()了另一个文件描述符，其号码正好与前面的socket相同</p></blockquote><p><strong>使用RAII来解决文件描述符串话问题</strong>：用Socket对象包装文件描述符，所有对此文件描述符的读写操作都通过此对象进行，在对象的析构函数里关闭文件描述符。这样一来，只要Socket对象还活着，就不会有其他Socket对象跟它有一样的文件描述符，也就不可能串话。剩下的问题就是做好多线程中的对象生命期管理。</p><p>为什么服务端程序不应该关闭标准输出（fd＝1）和标准错误（fd＝2）？</p><blockquote><p>因为有些第三方库在特殊紧急情况下会往stdout或stderr打印出错信息，如果我们的程序关闭了标准输出（fd＝1）和标准错误（fd＝2），这两个文件描述符有可能被网络连接占用，结果造成对方收到莫名其妙的数据。</p><p>正确的做法是把stdout或stderr重定向到磁盘文件（最好不要是&#x2F;dev&#x2F;null），这样我们不至于丢失关键的诊断信息。</p></blockquote><p>在非阻塞网络编程中，也有可能发生socket串话，解决方法仍然是使用一个类封装socket，然后使用shared_ptr来管理其声明周期。</p><h2 id="4-8-RAII与fork"><a href="#4-8-RAII与fork" class="headerlink" title="4.8 RAII与fork()"></a>4.8 RAII与fork()</h2><blockquote><p>在编写C++程序的时候，设法保证对象的构造和析构是成对出现的，否则就几乎一定会有内存泄漏。用对象来包装资源，把资源管理与对象生命期管理统一起来（RAII）。但是，假如程序会fork()，这一假设就会被破坏了。</p></blockquote><p>fork()之后，子进程继承了父进程的几乎全部状态，但也有少数例外。子进程会继承地址空间和文件描述符，因此用于管理动态内存和文件描述符的RAII class都能正常工作。但是子进程不会继承：</p><ul><li>父进程的内存锁，mlock(2)、mlockall(2)。</li><li>父进程的文件锁，fcntl(2)。</li><li>父进程的某些定时器，setitimer(2)、alarm(2)、timer_create(2)等等。</li></ul><p>通常我们会用RAII手法来管理以上种类的资源（加锁解锁、创建销毁定时器等等），但是在fork()出来的子进程中不一定正常工作，因为资源在fork()时已经被释放了。</p><h2 id="4-9-多线程与fork"><a href="#4-9-多线程与fork" class="headerlink" title="4.9 多线程与fork()"></a>4.9 多线程与fork()</h2><p>fork()一般不能在多线程程序中调用，因为Linux的fork()只克隆当前线程的thread of control，不克隆其他线程。fork()之后，除了当前线程之外，其他线程都消失了。也就是说不能一下子fork()出一个和父进程一样的多线程子进程。</p><blockquote><p>Linux没有forkall()这样的系统调用，forkall()其实也是很难办的（从语意上），因为其他线程可能等在condition variable上，可能阻塞在系统调用上，可能等着mutex以跨入临界区，还可能在密集的计算中，这些都不好全盘搬到子进程里。</p></blockquote><p>fork()之后子进程中只有一个线程，其他线程都消失了，这就造成一个危险的局面。其他线程可能正好位于临界区之内，持有了某个锁，而它突然死亡，再也没有机会去解锁了。如果子进程试图再对同一个mutex加锁，就会立刻死锁。</p><p>在fork()之后，子进程就相当于处于signal handler之中，你不能调用线程安全的函数（除非它是可重入的），而只能调用异步信号安全（async-signal-safe）的函数。比方说，fork()之后，子进程不能调用：</p><ul><li>malloc(3)。因为malloc()在访问全局状态时几乎肯定会加锁。</li><li>任何可能分配或释放内存的函数，包括new、map::insert()、snprintf33……</li><li>任何Pthreads函数。你不能用pthread_cond_signal()去通知父进程，只能通过读写pipe(2)来同步。</li><li>printf()系列函数，因为其他线程可能恰好持有stdout&#x2F;stderr的锁。</li><li>除了man 7 signal中明确列出的“signal安全”函数之外的任何函数。</li></ul><p>唯一安全的做法是在fork()之后立即调用exec()执行另一个程序，彻底隔断子进程与父进程的联系。</p><h2 id="4-10-多线程与signal"><a href="#4-10-多线程与signal" class="headerlink" title="4.10 多线程与signal"></a>4.10 多线程与signal</h2><p>在多线程程序中，使用signal的第一原则是<strong>不要使用signal</strong>：</p><ul><li>不要用signal作为IPC的手段，包括不要用SIGUSR1等信号来触发服务端的行为。如果确实需要，可以用§9.5介绍的增加监听端口的方式来实现双向的、可远程访问的进程控制。</li><li>不要使用基于signal实现的定时函数，包括alarm&#x2F;ualarm&#x2F;setitimer&#x2F;timer_create、sleep&#x2F;usleep等等。</li><li>不主动处理各种异常信号（SIGTERM、SIGINT等等），只用默认语义：结束进程。有一个例外：SIGPIPE，服务器程序通常的做法是忽略此信号40，否则如果对方断开连接，而本机继续write的话，会导致程序意外终止。</li><li>在没有别的替代方法的情况下（比方说需要处理SIGCHLD信号），把异步信号转换为同步的文件描述符事件。</li></ul><h2 id="4-11-Linux新增系统调用的启示"><a href="#4-11-Linux新增系统调用的启示" class="headerlink" title="4.11 Linux新增系统调用的启示"></a>4.11 Linux新增系统调用的启示</h2><p>Linux服务器开发的主流模型正在由fork()＋worker processes模型转变为第3章推荐的多线程模型。fork()的使用频度会大大降低，将来或许只有专门负责启动别的进程的“看门狗程序”才会调用fork()，而一般的网络服务器程序不会再fork()出子进程了。原因之一是，fork()一般不能在多线程程序中调用（§4.9）。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>编写多线程C++程序的原则如下：</p><ul><li>线程是宝贵的，一个程序可以使用几个或十几个线程。一台机器上不应该同时运行几百个、几千个用户线程，这会大大增加内核scheduler的负担，降低整体性能。</li><li>线程的创建和销毁是有代价的，一个程序最好在一开始创建所需的线程，并一直反复使用。不要在运行期间反复创建、销毁线程，如果必须这么做，其频度最好能降到1分钟1次（或更低）。</li><li>每个线程应该有明确的职责，例如IO线程（运行EventLoop::loop()，处理IO事件）、计算线程（位于ThreadPool中，负责计算）等等。</li><li>线程之间的交互应该尽量简单，理想情况下，线程之间只用消息传递（例如BlockingQueue）方式交互。如果必须用锁，那么最好避免一个线程同时持有两把或更多的锁，这样可彻底防止死锁。</li><li>要预先考虑清楚一个mutable shared对象将会暴露给哪些线程，每个线程是读还是写，读写有无可能并发进行。</li></ul><h1 id="第5章-高效的多线程日志"><a href="#第5章-高效的多线程日志" class="headerlink" title="第5章 高效的多线程日志"></a>第5章 高效的多线程日志</h1><blockquote><p>“日志（logging）”有两个意思：</p><ul><li>诊断日志（diagnostic log）：常用日志库提供的日志功能。</li><li>交易日志（transaction log）：即数据库的write-ahead log、文件系统的journaling等，用于记录状态变更，通过回放日志可以逐步恢复每一次修改之后的状态。</li></ul></blockquote><p><strong>对于关键进程，日志通常要记录</strong>：</p><ul><li>1．收到的每条内部消息的id（还可以包括关键字段、长度、hash等）；</li><li>2．收到的每条外部消息的全文；</li><li>3．发出的每条消息的全文，每条消息都有全局唯一的id；</li><li>4．关键内部状态的变更，等等。</li></ul><p>一个日志库大体可分为前端和后端两部分。前端是供应用程序使用的接口，并生成日志消息；后端则负责把日志消息写到目的地</p><h2 id="5-1-功能需求"><a href="#5-1-功能需求" class="headerlink" title="5.1 功能需求"></a>5.1 功能需求</h2><blockquote><p>常规的通用日志库如log4j13&#x2F;logback14通常会提供丰富的功能，但这些功能不一定全都是必需的：</p><ul><li>1．日志消息有多种级别（level），如TRACE、DEBUG、INFO、WARN、ERROR、FATAL等。</li><li>2．日志消息可能有多个目的地（appender），如文件、socket、SMTP等。</li><li>3．日志消息的格式可配置（layout），例如org.apache.log4j.PatternLayout。</li><li>4．可以设置运行时过滤器（filter），控制不同组件的日志消息的级别和目的地。</li></ul><p>作者认为除了第一项之外，其余三项都是非必需的功能</p></blockquote><p>日志的输出级别在运行时可调，这样同一个可执行文件可以分别在QA测试环境的时候输出DEBUG级别的日志，在生产环境输出INFO级别的日志</p><p>对于分布式系统中的服务进程而言，日志的目的地只有一个：本地文件。往网络写日志消息是不靠谱的，因为诊断日志的功能之一正是诊断网络故障，比如连接断开。</p><p><strong>一个典型的日志文件的文件名</strong>如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220921103201748.png"></p><ul><li>第1部分logfile_test是进程的名字。通常是main()函数参数中argv[0]的basename(3)，这样容易区分究竟是哪个服务程序的日志。必要时还可以把程序版本加进去。</li><li>第2部分是文件的创建时间（GMT时区）。这样很容易通过文件名来选择某一时间范围内的日志，例如用通配符</li><li>第3部分是机器名称。这样即便把日志文件拷贝到别的机器上也能追溯其来源。</li><li>第4部分是进程id。如果一个程序一秒之内反复重启，那么每次都会生成不同的日志文件。</li><li>第5部分是统一的后缀名.log。同样是为了便于周边配套脚本的编写。</li></ul><p><strong>往文件写日志的一个常见问题是，万一程序崩溃，那么最后若干条日志往往就丢失了</strong>，因为日志库不能每条消息都flush硬盘，更不能每条日志都open&#x2F;close文件，这样性能开销太大。</p><blockquote><p>muduo日志库用两个办法来应对这一点：</p><ul><li>其一是定期（默认3秒）将缓冲区内的日志消息flush到硬盘</li><li>其二是每条内存中的日志消息都带有cookie（或者叫哨兵值&#x2F;sentry），其值为某个函数的地址，这样通过在core dump文件中查找cookie就能找到尚未来得及写入磁盘的消息。</li></ul></blockquote><p><strong>日志消息格式有几个要点</strong>：</p><ul><li>尽量每条日志占一行。这样很容易用awk、sed、grep等命令行工具来快速联机分析日志</li><li>时间戳精确到微秒。每条消息都通过gettimeofday(2)获得当前时间，这么做不会有什么性能损失。因为在x86-64 Linux上，gettimeofday(2)不是系统调用，不会陷入内核</li><li>始终使用GMT时区（Z）。对于跨洲的分布式系统而言，可省去本地时区转换的麻烦，更易于追查事件的顺序</li><li>打印线程id。便于分析多线程程序的时序，也可以检测死锁</li><li>打印日志级别。在线查错的时候先看看有无ERROR日志，通常可加速定位问题。</li><li>打印源文件名和行号。修复bug的时候不至于搞错对象。</li></ul><h2 id="5-2-性能需求"><a href="#5-2-性能需求" class="headerlink" title="5.2 性能需求"></a>5.2 性能需求</h2><p>高效性体现在几方面：</p><ul><li>每秒写几千上万条日志的时候没有明显的性能损失。</li><li>能应对一个进程产生大量日志数据的场景，例如1GB&#x2F;min。</li><li>不阻塞正常的执行流程。</li><li>在多线程程序中，不造成争用。这里列举一些具体的性能指标，考虑往普通7200rpm SATA硬盘写日志文件的情况：<ul><li>磁盘带宽约是110MB&#x2F;s，日志库应该能瞬时写满这个带宽（不必持续太久）。</li><li>假如每条日志消息的平均长度是110字节，这意味着1秒要写100万条日志。</li></ul></li></ul><p><strong>muduo日志库的几点优化措施</strong>：</p><ul><li>时间戳字符串中的日期和时间两部分是缓存的，一秒之内的多条日志只需重新格式化微秒部分</li><li>日志消息的前4个字段是定长的，因此可以避免在运行期求字符串长度（不会反复调用strlen）。因为编译器认识memcpy()函数，对于定长的内存复制，会在编译期把它inline展开为高效的目标代码</li><li>线程id是预先格式化为字符串，在输出日志消息时只需简单拷贝几个字节</li><li>每行日志消息的源文件名部分采用了编译期计算来获得basename，避免运行期strrchr(3)开销。见SourceFile class，这里利用了gcc的内置函数。</li></ul><h2 id="5-3-多线程异步日志"><a href="#5-3-多线程异步日志" class="headerlink" title="5.3 多线程异步日志"></a>5.3 多线程异步日志</h2><blockquote><p>多线程程序对日志库提出了新的需求：线程安全，即多个线程可以并发写日志，两个线程的日志消息不会出现交织。线程安全不难办到，简单的办法是用一个全局mutex保护IO，或者每个线程单独写一个日志文件，但这两种做法的高效性就堪忧了。前者会造成全部线程抢一个锁，后者有可能让业务线程阻塞在写磁盘操作上。</p><p>在多线程服务程序中，异步日志（叫“非阻塞日志”似乎更准确）是必需的，因为如果在网络IO线程或业务线程中直接往磁盘写数据的话，写操作偶尔可能阻塞长达数秒之久（原因很复杂，可能是磁盘或磁盘控制器复位）。这可能导致请求方超时，或者耽误发送心跳消息，在分布式系统中更可能造成多米诺骨牌效应，例如误报死锁引发自动failover等</p></blockquote><p>muduo日志库采用的是双缓冲技术，基本思路是准备两块buffer：A和B，前端负责往buffer A填数据（日志消息），后端负责将buffer B的数据写入文件。当buffer A写满之后，交换A和B，让后端将buffer A的数据写入文件，而前端则往buffer B填入新的日志消息，如此往复。</p><blockquote><p>用两个buffer的好处是在新建日志消息的时候不必等待磁盘文件操作，也避免每条新日志消息都触发（唤醒）后端日志线程。</p><p>换言之，前端不是将一条条日志消息分别传送给后端，而是将多条日志消息拼成一个大的buffer传送给后端，相当于批处理，减少了线程唤醒的频度，降低开销。</p><p>另外，为了及时将日志消息写入文件，即便buffer A未满，日志库也会每3秒执行一次上述交换写入操作。</p></blockquote><p><strong>代码实现</strong></p><p>实际实现采用了四个缓冲区，这样可以进一步减少或避免日志前端的等待。数据结构如下</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220921113405077.png"></p><p>前端发送消息函数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220921113439416.png"></p><p>后端写接收消息函数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220921113508976.png"></p><p>书中还分析了四种运行时的情况，详细见书中此章节</p><p>使用四个缓冲还是可能不够用，导致消息多的时候需要新分配内存，改进措施就是使用一个缓冲池</p><p><strong>如果日志消息堆积怎么办</strong></p><p>muduo日志库处理日志堆积的方法很简单：直接丢掉多余的日志buffer，以腾出内存。这样可以防止日志库本身引起程序故障，是一种自我保护措施</p><h2 id="5-4-其他方案"><a href="#5-4-其他方案" class="headerlink" title="5.4 其他方案"></a>5.4 其他方案</h2><p>使用常规的muduo::BlockingQueue<a href="std::string">std::string</a>或muduo::BoundedBlockingQueue<a href="std::string">std::string</a>在前后端之间传递日志消息，其中每个std::string是一条消息。</p><ul><li>这种做法每条日志消息都要分配内存，特别是在前端线程分配的内存要由后端线程释放，因此对malloc的实现要求较高，需要针对多线程特别优化</li><li>相比前面展示的直接拷贝日志消息的做法，这个传递指针的方案似乎会更高效，但是据测试，直接拷贝日志数据的做法比传递指针快3倍（在每条日志消息不大于4kB的时候），估计是内存分配的开销所致</li></ul><p>muduo现在的异步日志实现用了一个全局锁。尽管临界区很小，但是如果线程数目较多，锁争用（lock contention）也可能影响性能。一种解决办法是像Java的ConcurrentHashMap那样用多个桶子（bucket），前端写日志的时候再按线程id哈希到不同的bucket中，以减少contention。</p><h1 id="第6章-muduo网络库简介"><a href="#第6章-muduo网络库简介" class="headerlink" title="第6章 muduo网络库简介"></a>第6章 muduo网络库简介</h1><p>为什么需要网络库？</p><blockquote><p>网络库能降低开发难度，能方便地处理并发连接</p></blockquote><h2 id="6-3-目录结构"><a href="#6-3-目录结构" class="headerlink" title="6.3 目录结构"></a>6.3 目录结构</h2><p>muduo的目录结构如下</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922104903753.png"></p><p><strong>基础库</strong></p><p>muduo&#x2F;base目录是一些基础库，都是用户可见的类，内容包括：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922104942922.png"></p><p><strong>网络核心库</strong></p><blockquote><p>muduo是基于Reactor模式的网络库，其核心是个事件循环EventLoop，用于响应计时器和IO事件。muduo采用基于对象（object-based）而非面向对象（objectoriented）的设计风格，其事件回调接口多以boost::function＋boost::bind表达，用户在使用muduo的时候不需要继承其中的class。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922105015431.png"></p><p><strong>网络附属库</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922105049130.png"></p><p><strong>代码结构</strong></p><p>muduo的头文件明确分为客户可见和客户不可见两类。以下是安装之后暴露的头文件和库文件。对于使用muduo库而言，只需要掌握5个关键类：Buffer、EventLoop、TcpConnection、TcpClient、TcpServer。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922105401035.png"></p><p>muduo的网络核心库的头文件包含关系，用户可见的为白底，用户不可见的为灰底</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922105429605.png"></p><p><strong>公开接口</strong></p><ul><li>Buffer仿Netty ChannelBuffer的buffer class，数据的读写通过buffer进行。用户代码不需要调用read(2)&#x2F;write(2)，只需要处理收到的数据和准备好要发送的数据（§7.4）。</li><li>InetAddress封装IPv4地址（end point），注意，它不能解析域名，只认IP地址。因为直接用gethostbyname(3)解析域名会阻塞IO线程。</li><li>EventLoop事件循环（反应器Reactor），每个线程只能有一个EventLoop实体，它负责IO和定时器事件的分派。它用eventfd(2)来异步唤醒，这有别于传统的用一对pipe(2)的办法。它用TimerQueue作为计时器管理，用Poller作为IO multiplexing。</li><li>EventLoopThread启动一个线程，在其中运行EventLoop::loop()。</li><li>TcpConnection整个网络库的核心，封装一次TCP连接，注意它不能发起连接。</li><li>TcpClient用于编写网络客户端，能发起连接，并且有重试功能。·TcpServer用于编写网络服务器，接受客户的连接。</li></ul><blockquote><p>在这些类中，TcpConnection的生命期依靠shared_ptr管理（即用户和库共同控制）。Buffer的生命期由TcpConnection控制。其余类的生命期由用户控制。Buffer和InetAddress具有值语义，可以拷贝；其他class都是对象语义，不可以拷贝。</p></blockquote><p><strong>内部实现</strong></p><ul><li>Channel是selectable IO channel，负责注册与响应IO事件，注意它不拥有file descriptor。它是Acceptor、Connector、EventLoop、TimerQueue、TcpConnection的成员，生命期由后者控制。</li><li>Socket是一个RAIIhandle，封装一个filedescriptor，并在析构时关闭fd。它是Acceptor、TcpConnection的成员，生命期由后者控制。EventLoop、TimerQueue也拥有fd，但是不封装为Socket class。</li><li>SocketsOps封装各种Sockets系统调用。</li><li>Poller是PollPoller和EPollPoller的基类，采用“电平触发”的语意。它是EventLoop的成员，生命期由后者控制。</li><li>PollPoller和EPollPoller封装poll(2)和epoll(4)两种IO multiplexing后端。poll的存在价值是便于调试，因为poll(2)调用是上下文无关的，用strace(1)很容易知道库的行为是否正确。</li><li>Connector用于发起TCP连接，它是TcpClient的成员，生命期由后者控制。</li><li>Acceptor用于接受TCP连接，它是TcpServer的成员，生命期由后者控制。</li><li>TimerQueue用timerfd实现定时，这有别于传统的设置poll&#x2F;epoll_wait的等待时长的办法。TimerQueue用std::map来管理Timer，常用操作的复杂度是O(logN)，N为定时器数目。它是EventLoop的成员，生命期由后者控制。</li><li>EventLoopThreadPool用于创建IO线程池，用于把TcpConnection分派到某个EventLoop线程上。它是TcpServer的成员，生命期由后者控制。</li></ul><p><strong>muduo的简化类图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922111701453.png"></p><p><strong>线程模型</strong></p><ul><li><p>muduo的线程模型符合主张的one loop per thread＋thread pool模型。每个线程最多有一个EventLoop，每个TcpConnection必须归某个EventLoop管理，所有的IO会转移到这个线程。</p></li><li><p>TcpConnection和EventLoop是线程安全的，可以跨线程调用</p></li><li><p>TcpServer直接支持多线程，它有两种模式：</p><ul><li>单线程，accept(2)与TcpConnection用同一个线程做IO。</li><li>多线程，accept(2)与EventLoop在同一个线程，另外创建一个EventLoopThreadPool，新到的连接会按round-robin方式分配到线程池中。</li></ul></li></ul><h2 id="6-4-使用教程"><a href="#6-4-使用教程" class="headerlink" title="6.4 使用教程"></a>6.4 使用教程</h2><h3 id="6-4-1-TCP网络编程本质论"><a href="#6-4-1-TCP网络编程本质论" class="headerlink" title="6.4.1 TCP网络编程本质论"></a>6.4.1 TCP网络编程本质论</h3><p><strong>基于事件的非阻塞网络编程思路</strong>：注册一个收数据的回调，网络库收到数据会调用我，直接把数据提供给我，供我消费。注册一个接受连接的回调，网络库接受了新连接会回调我，直接把新的连接对象传给我，供我使用。需要发送数据的时候，只管往连接中写，网络库会负责无阻塞地发送</p><p><strong>TCP网络编程最本质的是处理三个半事件</strong>：</p><ul><li>1．连接的建立，包括服务端接受（accept）新连接和客户端成功发起（connect）连接。TCP连接一旦建立，客户端和服务端是平等的，可以各自收发数据。</li><li>2．连接的断开，包括主动断开（close、shutdown）和被动断开（read(2)返回0）。</li><li>3．消息到达，文件描述符可读。这是最为重要的一个事件，对它的处理方式决定了网络编程的风格（阻塞还是非阻塞，如何处理分包，应用层的缓冲如何设计，等等）。</li><li>3.5　消息发送完毕，这算半个。对于低流量的服务，可以不必关心这个事件；另外，这里的“发送完毕”是指将数据写入操作系统的缓冲区，将由TCP协议栈负责数据的发送与重传，不代表对方已经收到数据。</li></ul><p>假设应用程序需要发送40kB数据，但是操作系统的TCP发送缓冲区只有25kB剩余空间，那么剩下的15kB数据怎么办？</p><blockquote><p>如果等待OS缓冲区可用，会阻塞当前线程，因为不知道对方什么时候收到并读取数据。</p><p>因此网络库应该把这15kB数据缓存起来，放到这个TCP链接的应用层发送缓冲区中，等socket变得可写的时候立刻发送数据，这样“发送”操作不会阻塞。</p><p>如果应用程序随后又要发送50kB数据，而此时发送缓冲区中尚有未发送的数据（若干kB），那么网络库应该将这50kB数据追加到发送缓冲区的末尾，而不能立刻尝试write()，因为这样有可能打乱数据的顺序。</p></blockquote><p>在非阻塞网络编程中，为什么要使用应用层接收缓冲区？</p><blockquote><p>假如一次读到的数据不够一个完整的数据包，那么这些已经读到的数据应该先暂存在某个地方，等剩余的数据收到之后再一并处理</p></blockquote><p><strong>常见几种方案对比</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220924161855858.png"></p><h1 id="第7章-muduo编程示例"><a href="#第7章-muduo编程示例" class="headerlink" title="第7章 muduo编程示例"></a>第7章 muduo编程示例</h1><h2 id="7-3-Boost-Asio的聊天服务器"><a href="#7-3-Boost-Asio的聊天服务器" class="headerlink" title="7.3 Boost.Asio的聊天服务器"></a>7.3 Boost.Asio的聊天服务器</h2><h3 id="7-3-1-TCP分包"><a href="#7-3-1-TCP分包" class="headerlink" title="7.3.1 TCP分包"></a>7.3.1 TCP分包</h3><blockquote><p>分包指的是在发生一个消息（message）或一帧（frame）数据时，通过一定的处理，让接收方能从字节流中识别并截取（还原）出一个个消息</p></blockquote><p>对于短连接的TCP服务，分包不是一个问题，只要发送方主动关闭连接，就表示一条消息发送完毕，接收方read()返回0，从而知道消息的结尾。</p><p>对于长连接的TCP服务，分包有四种方法：</p><ul><li>1．消息长度固定，比如muduo的roundtrip示例就采用了固定的16字节消息。</li><li>2．使用特殊的字符或字符串作为消息的边界，例如HTTP协议的headers以“\r\n”为字段的分隔符。</li><li>3．在每条消息的头部加一个长度字段，这恐怕是最常见的做法，本文的聊天协议也采用这一办法。</li><li>4．利用消息本身的格式来分包，例如XML格式的消息中<root>…</root>的配对，或者JSON格式中的{ … }的配对。解析这种消息格式通常会用到状态机（state machine）。</li></ul><p><strong>聊天服务</strong></p><p>由服务端程序和客户端程序组成，协议如下：</p><ul><li>服务端程序在某个端口侦听（listen）新的连接。·客户端向服务端发起连接。</li><li>连接建立之后，客户端随时准备接收服务端的消息并在屏幕上显示出来。</li><li>客户端接受键盘输入，以回车为界，把消息发送给服务端。</li><li>服务端接收到消息之后，依次发送给每个连接到它的客户端；原来发送消息的客户端进程也会收到这条消息。</li><li>一个服务端进程可以同时服务多个客户端进程。当有消息到达服务端后，每个客户端进程都会收到同一条消息，服务端广播发送消息的顺序是任意的，不一定哪个客户端会先收到这条消息。</li><li>（可选）如果消息A先于消息B到达服务端，那么每个客户端都会先收到A再收到B。</li></ul><p><strong>需要解决的问题</strong></p><p>聊天服务的特点是“连接之间的数据有交流，从a连接收到的数据要发给b连接。这样对连接管理提出了更高的要求：</p><ul><li>如何用一个程序同时处理多个连接？fork()-per-connection似乎是不行的。</li><li>如何防止串话？b有可能随时断开连接，而新建立的连接c可能恰好复用了b的文件描述符，那么a会不会错误地把消息发给c？”</li></ul><h2 id="7-4-muduo-Buffer类的设计与使用"><a href="#7-4-muduo-Buffer类的设计与使用" class="headerlink" title="7.4 muduo Buffer类的设计与使用"></a>7.4 muduo Buffer类的设计与使用</h2><h3 id="7-4-2-为什么non-blocking网络编程中应用层buffer是必需的"><a href="#7-4-2-为什么non-blocking网络编程中应用层buffer是必需的" class="headerlink" title="7.4.2　为什么non-blocking网络编程中应用层buffer是必需的"></a>7.4.2　为什么non-blocking网络编程中应用层buffer是必需的</h3><blockquote><p>non-blocking IO的核心思想是避免阻塞在read()或write()或其他IO系统调用上，这样可以最大限度地复用thread-of-control，让一个线程能服务于多个socket连接。IO线程只能阻塞在IO multiplexing函数上，如select&#x2F;poll&#x2F;epoll_wait。这样一来，应用层的缓冲是必需的，每个TCP socket都要有stateful的input buffer和output buffer。</p></blockquote><p><strong>TcpConnection必须要有output buffer</strong></p><blockquote><p>程序想通过TCP连接发送100kB的数据，但是在write()调用中，操作系统只接受了80kB，你肯定不想在原地等待，因为不知道会等多久（取决于对方什么时候接收数据，然后滑动TCP窗口）。程序应该尽快交出控制权，返回event loop。在这种情况下，剩余的20kB数据只能暂时存在buffer中。</p></blockquote><p><strong>TcpConnection必须要有input buffer</strong></p><blockquote><p>TCP是一个无边界的字节流协议，接收方必须要处理“收到的数据尚不构成一条完整的消息”和“一次收到两条消息的数据”等情况。一个常见的场景是，发送方send()了两条1kB的消息（共2kB），接收方收到数据的情况可能是一次收到或分多次收到。</p><p>网络库在处理“socket可读”事件的时候，必须一次性把socket里的数据读完（从操作系统buffer搬到应用层buffer），否则会反复触发POLLIN事件，造成busy-loop。那么网络库必然要应对“数据不完整”的情况，收到的数据先放到input buffer里，等构成一条完整的消息再通知程序的业务逻辑。</p></blockquote><h3 id="7-4-3-Buffer的功能需求"><a href="#7-4-3-Buffer的功能需求" class="headerlink" title="7.4.3　Buffer的功能需求"></a>7.4.3　Buffer的功能需求</h3><p>muduo Buffer的设计要点：</p><ul><li>对外表现为一块连续的内存(char* p, int len)，以方便客户代码的编写。</li><li>其size()可以自动增长，以适应不同大小的消息。它不是一个fixed size array（例如char buf[8192]）。</li><li>内部以std::vector<char>来保存数据，并提供相应的访问函数。</li></ul><p>muduo::net::Buffer的类图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014111142399.png"></p><p><strong>Buffer::readFd()</strong> </p><p>如果有10000个并发连接，每个连接一建立就分配各50kB的读写缓冲区的话，将占用1GB内存，而大多数时候这些缓冲区的使用率很低。muduo用readv(2)结合栈上空间巧妙地解决了这个问题。</p><blockquote><p>具体做法是，在栈上准备一个65536字节的extrabuf，然后利用readv()来读取数据，iovec有两块，第一块指向muduo Buffer中的writable字节，另一块指向栈上的extrabuf。这样如果读入的数据不多，那么全部都读到Buffer中去了；如果长度超过Buffer的writable字节数，就会读到栈上的extrabuf里，然后程序再把extrabuf里的数据append()到Buffer中</p><p>这么做利用了临时栈上空间14，避免每个连接的初始Buffer过大造成的内存浪费，也避免反复调用read()的系统开销（由于缓冲区足够大，通常一次readv()系统调用就能读完全部数据）。由于muduo的事件触发采用level trigger，因此这个函数并不会反复调用read()直到其返回EAGAIN，从而可以降低消息处理的延迟。</p><p>我的理解是如果不使用extrabuf而在read时让buffer增长的话，read时可能很耗时，降低了效率。（待验证）</p></blockquote><p><strong>线程安全？</strong></p><p>muduo::net::Buffer不是线程安全的（其安全性跟std::vector相同）</p><p>，这么设计的原因是buffer使用通常是在TcpConnection所在的IO线程中，而TcpConnection是线程安全的。</p><blockquote><p>如果TcpConnection::send()调用发生在该TcpConnection所属的那个IO线程，那么它会转而调用TcpConnection::sendInLoop()，sendInLoop()会在当前线程（也就是IO线程）操作output buffer</p><p>如果TcpConnection::send()调用发生在别的线程，它不会在当前线程调用sendInLoop()，而是通过EventLoop::runInLoop()把sendInLoop()函数调用转移到IO线程</p><ul><li>跨线程的函数转移调用涉及函数参数的跨线程传递，一种简单的做法是把数据拷贝一份，绝对安全。</li><li>另一种更为高效的做法是用swap()。这就是为什么TcpConnection::send()的某个重载以Buffer*为参数，而不是const Buffer&amp;，这样可以避免拷贝，而用Buffer::swap()实现高效的线程间数据转移。（作者还未实现）</li></ul></blockquote><h3 id="7-4-4-Buffer的数据结构"><a href="#7-4-4-Buffer的数据结构" class="headerlink" title="7.4.4　Buffer的数据结构"></a>7.4.4　Buffer的数据结构</h3><p>Buffer的内部是一个std::vector<char>，它是一块连续的内存。此外，Buffer有两个data member，即readIndex和writeIndex，指向该vector中的可读的位置和可写的位置。这两个index的类型是int，不是char*，目的是应对迭代器失效。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112018159.png"></p><p>prependable是预留的空间，初始时</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112127653.png"></p><h3 id="7-4-5-Buffer的操作"><a href="#7-4-5-Buffer的操作" class="headerlink" title="7.4.5　Buffer的操作"></a>7.4.5　Buffer的操作</h3><p>如果向Buffer写入了200字节，那么其布局如图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112218728.png"></p><p>如果从Buffer read() &amp; retrieve()（下称“读入”）了50字节</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112235569.png"></p><p>然后又写入了200字节</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112303651.png"></p><p>接下来，一次性读入350字节，请注意，由于全部数据读完了，readIndex和writeIndex返回原位以备新一轮使用</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112323734.png"></p><p><strong>自动增长</strong></p><p>假设当前的状态如图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112355413.png"></p><p>客户代码一次性写入1000字节，而当前可写的字节数只有624，那么buffer会自动增长以容纳全部数据，得到的结果如图。<strong>由于vector重新分配了内存，原来指向其元素的指针会失效，这就是为什么readIndex和writeIndex是整数下标而不是指针。</strong>（注意：在目前的实现中prependable会保持58字节，留待将来修正。）</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112415262.png"></p><p>注意buffer不会缩小大小，只要增长了就不会减少其size</p><p><strong>为什么我们不需要调用reserve()来预先分配空间？</strong></p><p>因为Buffer在构造函数里把初始size()设为1KiB，这样当size()超过1KiB的时候vector会把capacity()加倍，等于说resize()替我们做了reserve()的事。</p><blockquote><p>resize会有点性能浪费，因为其初始化时会将容器中的元素进行初始化</p></blockquote><p><strong>内部腾挪</strong></p><p>有时候，经过若干次读写，readIndex移到了比较靠后的位置，留下了巨大的prependable空间，这时候，如果我们想写入300字节，而writable只有200字节，怎么办？</p><blockquote><p>muduo Buffer在这种情况下不会重新分配内存，而是先把已有的数据移到前面去，腾出writable空间。</p><p>这么做的原因是，如果重新分配内存，反正也是要把数据拷贝到新分配的内存区域，代价只会更大。</p></blockquote><p><strong>前方添加（prepend）</strong></p><p>muduo Buffer有个小小的创新，即提供prependable空间，让程序能以很低的代价在数据前面添加几个字节，也就是预留一段空间用于后面存储消息长度。</p><h3 id="7-4-6-其他设计方案"><a href="#7-4-6-其他设计方案" class="headerlink" title="7.4.6　其他设计方案"></a>7.4.6　其他设计方案</h3><p><strong>zero copy</strong></p><p>如果对性能有极高的要求，受不了copy()与resize()，那么可以考虑实现分段连续的zero copy buffer再配合gather scatter IO，数据结构如图。<strong>基本思路都是不要求数据在内存中连续，而是用链表把数据块链接到一起。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014193804231.png"></p><h2 id="7-5-一种自动反射消息类型的Google-Protobuf网络传输方案"><a href="#7-5-一种自动反射消息类型的Google-Protobuf网络传输方案" class="headerlink" title="7.5　一种自动反射消息类型的Google Protobuf网络传输方案"></a>7.5　一种自动反射消息类型的Google Protobuf网络传输方案</h2><blockquote><p>1.protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于通信协议、数据存储等。</p><p>2.protocol buffers是一种灵活，高效，自动化机制的结构化数据序列化方法，可以类比XML，但是比XML更小、更快、更为简单。</p><p>3.你可以定义数据的结构，然后使用特殊生成的源代码轻松的在各种数据流中使用各种语言进行编写和读取结构数据。你甚至可以更新数据结构，而不破坏旧数据结构编译而成并且已经部署的程序。</p></blockquote><p>本节要解决的问题是：通信双方在编译时就共享proto文件的情况下，接收方在收到Protobuf二进制数据流之后，如何自动创建具体类型的Protobuf Message对象，并用收到的数据填充该Message对象（即反序列化）。</p><blockquote><p>“自动”的意思是：当程序中新增一个Protobuf Message类型时，这部分代码不需要修改，不需要自己去注册消息类型。其实，Google Protobuf本身具有很强的反射（reflection）功能，可以根据type name创建具体类型的Message对象。</p></blockquote><h3 id="7-5-1-网络编程中使用Protobuf的两个先决条件"><a href="#7-5-1-网络编程中使用Protobuf的两个先决条件" class="headerlink" title="7.5.1　网络编程中使用Protobuf的两个先决条件"></a>7.5.1　网络编程中使用Protobuf的两个先决条件</h3><p>在网络编程中使用Protobuf需要解决以下两个问题：</p><ul><li>1．长度，Protobuf打包的数据没有自带长度信息或终结符，需要由应用程序自己在发生和接收的时候做正确的切分。</li><li>2．类型，Protobuf打包的数据没有自带类型信息，需要由发送方把类型信息传给给接收方，接收方创建具体的Protobuf Message对象，再做反序列化。</li></ul><p>第一个问题很好解决，通常的做法是在每个消息前面加个固定长度的lengthheader</p><p>第二个问题其实也很好解决，Protobuf对此有内建的支持</p><h3 id="7-5-2-根据type-name反射自动创建Message对象"><a href="#7-5-2-根据type-name反射自动创建Message对象" class="headerlink" title="7.5.2　根据type name反射自动创建Message对象"></a>7.5.2　根据type name反射自动创建Message对象</h3><p><strong>原理简述</strong></p><blockquote><p>Protobuf Message class采用了Prototype pattern18，Message class定义了New()虚函数，用以返回本对象的一份新实体，类型与本对象的真实类型相同。也就是说，拿到Message*指针，不用知道它的具体类型，就能创建和其类型一样的具体Message type的对象。</p><p>每个具体Message type都有一个default instance，可以通过ConcreteMessage::default_instance()获得，也可以通过MessageFactory::GetPrototype(const Descriptor*)来获得。所以，现在问题转变为：1．如何拿到MessageFactory；2．如何拿到Descriptor*。</p><p>使用DescriptorPool，它可以根据type name查到Descriptor*，只要找到合适的DescriptorPool，再调用DescriptorPool::FindMessageTypeByName(const string&amp; type_name)即可</p></blockquote><p><strong>根据type name自动创建Messagee的关键代码</strong></p><p>创建步骤：</p><ul><li>1．用DescriptorPool::generated_pool()找到一个DescriptorPool对象，它包含了程序编译的时候所链接的全部Protobuf Message types。</li><li>2．根据type name用DescriptorPool::FindMessageTypeByName()查找Descriptor。</li><li>3．再用MessageFactory::generated_factory()找到MessageFactory对象，它能创建程序编译的时候所链接的全部Protobuf Message types。</li><li>4．然后，用MessageFactory::GetPrototype()找到具体Message type的default instance。</li><li>5．最后，用prototype-&gt;New()创建对象。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221015202643723.png"></p><p>注意，createMessage()返回的是动态创建的对象的指针，调用方有责任释放它，不然就会使内存泄漏。在muduo里，用shared_ptr<Message>来自动管理Message对象的生命期。</p><p><strong>线程安全性</strong></p><p>Google的文档说，用到的那几个MessageFactory和DescriptorPool都是线程安全的，Message::New()也是线程安全的。并且它们都是const member function。</p><h3 id="7-5-3-Protobuf传输格式"><a href="#7-5-3-Protobuf传输格式" class="headerlink" title="7.5.3　Protobuf传输格式"></a>7.5.3　Protobuf传输格式</h3><p>设计了一个简单的格式，包含Protobuf data和其对应的长度与类型信息，消息的末尾还有一个check sum</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221015203509467.png"></p><p>用C struct伪代码描述：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221015203533090.png"></p><p><strong>例子</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221015203637476.png"></p><p><strong>设计决策</strong></p><ul><li>signed int。消息中的长度字段只使用了signed 32-bit int，而没有使用unsigned int，这是为了跨语言移植性，因为Java语言没有unsigned类型。另外，Protobuf一般用于打包小于1MB的数据，unsigned int也没用。</li><li>check sum。虽然TCP是可靠传输协议，虽然Ethernet有CRC-32校验，但是网络传输必须要考虑数据损坏的情况，对于关键的网络应用，check sum是必不可少的。对于Protobuf这种紧凑的二进制格式而言，肉眼看不出数据有没有问题，需要用check sum。</li><li>adler32算法。我没有选用常见的CRC-32，而是选用了adler32，因为它的计算量小、速度比较快，强度和CRC-32差不多。另外，zlib和java.unit.zip都直接支持这个算法。</li><li>type name以’\0’结束。这是为了方便troubleshooting，比如通过tcpdump抓下来的包可以用肉眼很容易看出type name，而不用根据nameLen去一个个数字节。同时，为了方便接收方处理，加入了nameLen，节省了strlen()，这是以空间换时间的做法。</li><li>没有版本号。Protobuf Message的一个突出优点是用optional fields来避免协议的版本号（凡是在Protobuf Message里放版本号的人都没有理解Protobuf的设计，甚至可能没有仔细阅读Protobuf的文档），让通信双方的程序能各自升级，便于系统演化。</li></ul><h2 id="7-6-在muduo中实现Protobuf编解码器与消息分发器"><a href="#7-6-在muduo中实现Protobuf编解码器与消息分发器" class="headerlink" title="7.6　在muduo中实现Protobuf编解码器与消息分发器"></a>7.6　在muduo中实现Protobuf编解码器与消息分发器</h2><p><strong>为什么Protobuf的默认序列化格式没有包含消息的长度与类型</strong></p><p>哪些情况下不需要在Protobuf序列化得到的字节流中包含消息的长度和（或）类型？</p><blockquote><ul><li>如果把消息写入文件，一个文件存一个消息，那么序列化结果中不需要包含长度和类型，因为从文件名和文件长度中可以得知消息的类型与长度。</li><li>如果把消息写入文件，一个文件存多个消息，那么序列化结果中不需要包含类型，因为文件名就代表了消息的类型。</li><li>如果把消息存入数据库（或者NoSQL），以VARBINARY字段保存，那么序列化结果中不需要包含长度和类型，因为从字段名和字段长度中可以得知消息的类型与长度。</li><li>如果把消息以UDP方式发送给对方，而且对方一个UDP port只接收一种消息类型，那么序列化结果中不需要包含长度和类型，因为从port和UDP packet长度中可以得知消息的类型与长度。</li><li>如果把消息以TCP短连接方式发给对方，而且对方一个TCP port只接收一种消息类型，那么序列化结果中不需要包含长度和类型，因为从port和TCP字节流长度中可以得知消息的类型与长度。</li><li>如果把消息以TCP长连接方式发给对方，但是对方一个TCP port只接收一种消息类型，那么序列化结果中不需要包含类型，因为port代表了消息的类型。</li><li>如果采用RPC方式通信，那么只需要告诉对方method name，对方自然能推断出Request和Response的消息类型，这些可以由protoc生成的RPC stubs自动搞定。<ul><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221015204519514.png"></li><li>那么RPC method SudokuService.Solve对应的请求和响应分别是SudokuRequest和SudokuResponse。在发送RPC请求的时候，不需要包含SudokuRequest的类型，只需要发送method name SudokuService.Solve，对方自然知道应该按照SudokuRequest来解析（parse）请求。</li></ul></li></ul></blockquote><p>对于上述这些情况，如果Protobuf无条件地把长度和类型放到序列化的字节串中，只会浪费网络带宽和存储。</p><p>只有在使用TCP长连接，且在一个连接上传递不止一种消息的情况下（比方同时发Heartbeat和Request&#x2F;Response），才需要前文提到的那种打包方案。这时候需要一个分发器dispatcher，把不同类型的消息分给各个消息处理函数。</p><p><strong>7.6.1　什么是编解码器（codec）</strong></p><blockquote><p>编解码器（codec）是encoder和decoder的缩写</p></blockquote><p>codec的基本功能之一是做TCP分包：确定每条消息的长度，为消息划分界限。</p><p>Protobuf codec与asio中chat的codec十分相似，只不过编解码消息类型从std::string变成了protobuf::Message。</p><ul><li><p>对于只接收处理Query消息的QueryServer来说，用ProtobufCodec非常方便，收到protobuf::Message之后向下转型成Query来用就行，如图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221015205343127.png"></p></li><li><p>如果要接收处理不止一种消息，ProtobufCodec还不能单独完成工作</p></li></ul><h3 id="7-6-2-实现ProtobufCodec"><a href="#7-6-2-实现ProtobufCodec" class="headerlink" title="7.6.2　实现ProtobufCodec"></a>7.6.2　实现ProtobufCodec</h3><p>解码算法有几个要点：</p><ul><li>protobuf::Message是new出来的对象，它的生命期如何管理？muduo采用shared_ptr<Message>来自动管理对象生命期，与整体风格保持一致。</li><li>出错如何处理？比方说长度超出范围、check sum不正确、message type name不能识别、message parse出错等等。ProtobufCodec定义了ErrorCallback，用户代码可以注册这个回调。如果不注册，默认的处理是断开连接，让客户重连重试。codec的单元测试里模拟了各种出错情况。</li><li>如何处理一次收到半条消息、一条消息、一条半消息、两条消息等等情况？这是每个non-blocking网络程序中的codec都要面对的问题。在分包处理中已经解决了这个问题。</li></ul><p>目前ProtobufCodec的实现非常初级，它没有充分利用ZeroCopyInputStream和ZeroCopyOutputStream，而是把收到的数据作为byte array交给Protobuf Message去解析，这给性能优化留下了空间。</p><p>Protobuf Message不要求数据连续（像vector那样），只要求数据分段连续（像deque那样），这给buffer管理带来了性能上的好处（避免重新分配内存，减少内存碎片），当然也使得代码变得更为复杂。</p><h3 id="7-6-3-消息分发器（dispatcher）有什么用"><a href="#7-6-3-消息分发器（dispatcher）有什么用" class="headerlink" title="7.6.3　消息分发器（dispatcher）有什么用"></a>7.6.3　消息分发器（dispatcher）有什么用</h3><p>ProtobufCodec拦截了TcpConnection的数据，把它转换为Message，ProtobufDispatcher拦截了ProtobufCodec的callback，按消息具体类型把它分派给多个callbacks</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017191310880.png"></p><h3 id="7-6-4-ProtobufCodec与ProtobufDispatcher的综合运用"><a href="#7-6-4-ProtobufCodec与ProtobufDispatcher的综合运用" class="headerlink" title="7.6.4　ProtobufCodec与ProtobufDispatcher的综合运用"></a>7.6.4　ProtobufCodec与ProtobufDispatcher的综合运用</h3><p>示例代码中client和server，把ProtobufCodec和ProtobufDispatcher串联起来使用。server响应Query消息，发送回Answer消息，如果收到未知消息类型，则断开连接。client可以选择发送Query或Empty消息，由命令行控制。</p><h3 id="7-6-5-ProtobufDispatcher的两种实现"><a href="#7-6-5-ProtobufDispatcher的两种实现" class="headerlink" title="7.6.5　ProtobufDispatcher的两种实现"></a>7.6.5　ProtobufDispatcher的两种实现</h3><p><strong>要完成消息分发，其实就是对消息做type-switch</strong></p><p>先定义ProtobufMessageCallback回调：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017192112693.png"></p><p>ProtobufDispatcherLite有一个map&lt;Descriptor* ,ProtobufMessageCallback&gt;成员，客户代码可以以Descriptor*为key注册回调（回想：每个具体消息类型都有一个全局的Descriptor对象，其地址是不变的，可以用来当key）。在收到Protobuf Message之后，在map中找到对应的ProtobufMessageCallback，然后调用之。如果找不到，就调用defaultCallback。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017192123255.png"></p><p>但是，这样设计有个缺陷，注册消息处理函数类型就被写死了，消息处理函数参数为Message* 指针，而在消息处理函数中还需要对Message* 指针转换类型，但却不知道转换成何种类型。</p><p>解决办法是：<strong>多态与模板结合</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017201206625.png"></p><p>ProtobufDispatcher的消息注册函数改为模板成员函数，接受注册任意消息类型T的回调，然后它创建一个模板化的派生类CallbackT<T>，这样消息的类型信息就保存在了CallbackT<T>中，做down cast就简单了</p><p>注册回调示例</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017201622002.png"></p><h3 id="7-6-6-ProtobufCodec和ProtobufDispatcher有何意义"><a href="#7-6-6-ProtobufCodec和ProtobufDispatcher有何意义" class="headerlink" title="7.6.6　ProtobufCodec和ProtobufDispatcher有何意义"></a>7.6.6　ProtobufCodec和ProtobufDispatcher有何意义</h3><p>ProtobufCodec和ProtobufDispatcher把每个直接收发Protobuf Message的网络程序都会用到的功能提炼出来做成了公用的utility，这样以后新写Protobuf网络程序就不必为打包分包和消息分发劳神</p><h2 id="7-7-限制服务器的最大并发连接数"><a href="#7-7-限制服务器的最大并发连接数" class="headerlink" title="7.7　限制服务器的最大并发连接数"></a>7.7　限制服务器的最大并发连接数</h2><p>“并发连接数”是指一个服务端程序能同时支持的客户端连接数，连接由客户端主动发起，服务端被动接受（accept(2)）连接。</p><h3 id="7-7-1-为什么要限制并发连接数"><a href="#7-7-1-为什么要限制并发连接数" class="headerlink" title="7.7.1　为什么要限制并发连接数"></a>7.7.1　为什么要限制并发连接数</h3><p>一方面，我们不希望服务程序超载；另一方面，更因为filedescriptor是稀缺资源，如果出现filedescriptor耗尽，很棘手</p><blockquote><p>当使用Reactor模式，epoll_wait返回EMFILE时，意味着本进程的文件描述符已经达到上限，无法为新连接创建socket文件描述符。</p><p>但是，既然没有socket文件描述符来表示这个连接，我们就无法close(2)它。程序继续运行，回到L11再一次调用epoll_wait。这时候epoll_wait会立刻返回，因为新连接还等待处理，listening fd还是可读的。这样程序立刻就陷入了busy loop，CPU占用率接近100％</p></blockquote><p><strong>几种做法：</strong></p><ul><li>1．调高进程的文件描述符数目。治标不治本，因为只要有足够多的客户端，就一定能把一个服务进程的文件描述符用完。</li><li>2．死等。鸵鸟算法。</li><li>3．退出程序。似乎小题大做，为了这种暂时的错误而中断现有的服务似乎不值得。</li><li>4．关闭listening fd。那么什么时候重新打开呢？</li><li>5．改用edge trigger。如果漏掉了一次accept(2)，程序再也不会收到新连接。</li><li>6．准备一个空闲的文件描述符。遇到这种情况，先关闭这个空闲文件，获得一个文件描述符的名额；再accept(2)拿到新socket连接的描述符；随后立刻close(2)它，这样就优雅地断开了客户端连接；最后重新打开一个空闲文件，把“坑”占住，以备再次出现这种情况时使用。</li></ul><p>muduo的Acceptor正是用第6种方案实现的，但这个做法在多线程下不能保证正确，会有race condition</p><p>有另外一种比较简单的办法：file descriptor是hard limit，我们可以自己设一个稍低一点的soft limit，如果超过soft limit就主动关闭新连接，这样就可避免触及“file descriptor耗尽”这种边界条件</p><h3 id="7-7-2-在muduo中限制并发连接数"><a href="#7-7-2-在muduo中限制并发连接数" class="headerlink" title="7.7.2　在muduo中限制并发连接数"></a>7.7.2　在muduo中限制并发连接数</h3><p>在muduo中限制并发连接数的做法简单得出奇。只需要为它增加一个int成员，表示当前的活动连接数。</p><p>然后，在EchoServer::onConnection()中判断当前活动连接数。如果超过最大允许数，则踢掉连接。（muduo库中已经使用第6种方案解决了死等状态，因此能收到连接）</p><h2 id="7-8-定时器"><a href="#7-8-定时器" class="headerlink" title="7.8　定时器"></a>7.8　定时器</h2><h3 id="7-8-1-程序中的时间"><a href="#7-8-1-程序中的时间" class="headerlink" title="7.8.1　程序中的时间"></a>7.8.1　程序中的时间</h3><blockquote><p>在一般的服务端程序设计中，与时间有关的常见任务有：</p><ul><li>1．获取当前时间，计算时间间隔。</li><li>2．时区转换与日期计算；把纽约当地时间转换为上海当地时间；2011-02-05之后第100天是几月几号星期几；等等。</li><li>3．定时操作，比如在预定的时间执行任务，或者在一段延时之后执行任务。</li></ul></blockquote><p>其中第2项看起来比较复杂，但其实最简单。日期计算用Julian Day Number30，时区转换用tz database31；唯一麻烦一点的是夏令时，但也可以用tz database解决。需要特别注意的是，用tzset&#x2F;localtime_r来做时区转换在多线程环境下可能会有问题；对此解决办法是写一个TimeZone class，以避免影响全局。</p><p>真正麻烦的是第1项和第3项。一方面，Linux有一大把令人眼花缭乱的与时间相关的函数和结构体，在程序中该如何选用？另一方面，计算机中的时钟不是理想的计时器，它可能会漂移或跳变。最后，民用的UTC时间与闰秒的关系也让定时任务变得复杂和微妙。当然，与系统当前时间有关的操作也让单元测试变得困难。</p><h2 id="7-8-2-Linux时间函数"><a href="#7-8-2-Linux时间函数" class="headerlink" title="7.8.2　Linux时间函数"></a>7.8.2　Linux时间函数</h2><ul><li>（计时）只使用gettimeofday(2)来获取当前时间。</li><li>（定时）只使用timerfd_*系列函数来处理定时任务。</li></ul><blockquote><p>gettimeofday(2)入选原因（这也是muduo::Timestamp class的主要设计考虑）：</p><ul><li>1．time(2)的精度太低，ftime(3)已被废弃；clock_gettime(2)精度最高，但是其系统调用的开销比gettimeofday(2)大。</li><li>2．在x86-64平台上，gettimeofday(2)不是系统调用，而是在用户态实现的，没有上下文切换和陷入内核的开销32。</li><li>3．gettimeofday(2)的分辨率（resolution）是1微秒，现在的实现确实能达到这个计时精度，足以满足日常计时的需要。muduo::Timestamp用一个int64_t来表示从Unix Epoch到现在的微秒数，其范围可达上下30万年。</li></ul><p>timerfd_*入选的原因：</p><ul><li>1．sleep(3) &#x2F; alarm(2) &#x2F; usleep(3)在实现时有可能用了SIGALRM信号，在多线程程序中处理信号是个相当麻烦的事情，应当尽量避免，</li><li>2．nanosleep(2)和clock_nanosleep(2)是线程安全的，但是在非阻塞网络编程中，绝对不能用让线程挂起的方式来等待一段时间，这样一来程序会失去响应。正确的做法是注册一个时间回调函数。</li><li>3．getitimer(2)和timer_create(2)也是用信号来deliver超时，在多线程程序中也会有麻烦。timer_create(2)可以指定信号的接收方是进程还是线程，算是一个进步，不过信号处理函数（signal handler）能做的事情实在很受限。</li><li>4．timerfd_create(2)把时间变成了一个文件描述符，该“文件”在定时器超时的那一刻变得可读，这样就能很方便地融入select(2)&#x2F;poll(2)框架中，用统一的方式来处理IO事件和超时事件，这也正是Reactor模式的长处。</li><li>5．传统的Reactor利用select(2)&#x2F;poll(2)&#x2F;epoll(4)的timeout来实现定时功能，但poll(2)和epoll_wait(2)的定时精度只有毫秒，远低于timerfd_ settime(2)的定时精度。</li></ul></blockquote><h3 id="7-8-3-muduo的定时器接口"><a href="#7-8-3-muduo的定时器接口" class="headerlink" title="7.8.3　muduo的定时器接口"></a>7.8.3　muduo的定时器接口</h3><p>muduo EventLoop有三个定时器函数：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017205027209.png"></p><h3 id="7-8-4-Boost-Asio-Timer示例"><a href="#7-8-4-Boost-Asio-Timer示例" class="headerlink" title="7.8.4　Boost.Asio Timer示例"></a>7.8.4　Boost.Asio Timer示例</h3><blockquote><p>1．阻塞式的定时，muduo不支持这种用法，无代码。</p><p>2．非阻塞定时。</p><p>3．在TimerCallback里传递参数</p><p>4．以成员函数为TimerCallback</p><p>5．在多线程中回调，用mutex保护共享变量</p><p>6．在多线程中回调，缩小临界区，把不需要互斥执行的代码移出来</p><p>代码都在examples&#x2F;asio&#x2F;tutorial&#x2F;</p></blockquote><p><strong>在非阻塞服务端编程中，绝对不能用sleep()或类似的办法来让程序原地停留等待，这会让程序失去响应，因为主事件循环被挂起了，无法处理IO事件。</strong></p><h3 id="7-8-5-Java-Netty示例"><a href="#7-8-5-Java-Netty示例" class="headerlink" title="7.8.5　Java Netty示例"></a>7.8.5　Java Netty示例</h3><p>Netty版的echo和discard服务端有流量统计功能，这需要用到固定间隔的定时器（EventLoop::runEvery）。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017212754487.png"></p><p>构造函数注册了一个间隔为3秒的定时器，调用DiscardServer::printThroughput()打印出吞吐量</p><p>消息回调统计收到的数据长度和消息次数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017212848962.png"></p><h2 id="7-9-测量两台机器的网络延迟和时间差"><a href="#7-9-测量两台机器的网络延迟和时间差" class="headerlink" title="7.9　测量两台机器的网络延迟和时间差"></a>7.9　测量两台机器的网络延迟和时间差</h2><p>测量round trip time的办法：</p><ul><li>host A发一条消息给host B，其中包含host A发送消息的本地时间。</li><li>host B收到之后立刻把消息echo回host A。</li><li>host A收到消息之后，用当前时间减去消息中的时间就得到了round trip time。</li></ul><p>协议如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018110740747.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018110816658.png"></p><p>消息格式如下，T1 和T2 都是muduo::Timestamp，成员是一个int64_t，表示从Unix Epoch到现在的微秒数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018111304630.png"></p><p>实例如图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018111534885.png"></p><h2 id="7-10-用timing-wheel踢掉空闲连接"><a href="#7-10-用timing-wheel踢掉空闲连接" class="headerlink" title="7.10　用timing wheel踢掉空闲连接"></a>7.10　用timing wheel踢掉空闲连接</h2><blockquote><p>一个连接如果若干秒没有收到数据，就被认为是空闲连接。</p><p>在严肃的网络程序中，应用层的心跳协议是必不可少的。应该用心跳消息来判断对方进程是否能正常工作，“踢掉空闲连接”只是一时的权宜之计。</p></blockquote><p>如果一个连接连续几秒内没有收到数据，就把它断开，为此有两种简单、粗暴的做法：</p><ul><li>每个连接保存“最后收到数据的时间lastReceiveTime”，然后用一个定时器，每秒遍历一遍所有连接，断开那些(now - connection.lastReceiveTime)＞8s的connection。这种做法全局只有一个repeated timer，不过每次timeout都要检查全部连接，如果连接数目比较大（几千上万），这一步可能会比较费时。</li><li>每个连接设置一个one-shot timer，超时定为8s，在超时的时候就断开本连接。当然，每次收到数据要去更新timer。这种做法需要很多个one-shot timer，会频繁地更新timers。如果连接数目比较大，可能对EventLoop的TimerQueue造成压力。</li></ul><h3 id="7-10-1-timing-wheel原理"><a href="#7-10-1-timing-wheel原理" class="headerlink" title="7.10.1　timing wheel原理"></a>7.10.1　timing wheel原理</h3><p>使用timing wheel能避免上述两种做法的缺点。</p><p>处理连接超时可用一个简单的数据结构：8个桶组成的循环队列。</p><p>第1个桶放1秒之后将要超时的连接，第2个桶放2秒之后将要超时的连接。每个连接一收到数据就把自己放到第8个桶，然后在每秒的timer里把第一个桶里的连接断开，把这个空桶挪到队尾。这样大致可以做到8秒没有数据就超时断开连接。更重要的是，每次不用检查全部的连接，只要检查第一个桶里的连接，相当于把任务分散了。</p><h3 id="7-10-2-代码实现与改进"><a href="#7-10-2-代码实现与改进" class="headerlink" title="7.10.2　代码实现与改进"></a>7.10.2　代码实现与改进</h3><p>在具体实现中，格子里放的不是连接，而是一个特制的Entry struct，每个Entry包含TcpConnection的weak_ptr。Entry的析构函数会判断连接是否还存在（用weak_ptr），如果还存在则断开连接。</p><p><strong>数据结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018161739059.png"></p><p>在实现中，为了简单起见，采用引用计数的办法，用shared_ptr来管理Entry。</p><ul><li>如果从连接收到数据，就把对应的EntryPtr放到这个格子里，这样它的引用计数就递增了（只有每个格子中都没有对应的entryptr，才会被自动销毁）。</li><li>当Entry的引用计数递减到零时，说明它没有在任何一个格子里出现，那么连接超时，Entry的析构函数会断开连接。</li></ul><blockquote><p>直到Boost 1.47.0之前，unordered_set&lt;shared_ptr<T> &gt;虽然可以编译通过，但是其hash_value是shared_ptr隐式转换为bool的结果。也就是说，如果不自定义hash函数，那么unordered_{set&#x2F;map}会退化为链表。</p></blockquote><p><strong>改进</strong></p><ul><li>每次收到消息都会往队尾添加EntryPtr（hash set会帮我们去重（deduplication））。一个简单的改进措施是，在TcpConnection里保存“最后一次往队尾添加引用时的tail位置”，收到消息时先检查tail是否变化，若无变化则不重复添加EntryPtr，若有变化则把EntryPtr从旧的Bucket移到当前队尾Bucket。</li><li>另外一个思路是“选择排序”：使用链表将TcpConnection串起来，TcpConnection每次收到消息就把自己移到链表末尾，这样链表是按接收时间先后排序的。再用一个定时器定期从链表前端查找并踢掉超时的连接。代码示例位于同一目录。</li></ul><h2 id="7-11-简单的消息广播服务"><a href="#7-11-简单的消息广播服务" class="headerlink" title="7.11　简单的消息广播服务"></a>7.11　简单的消息广播服务</h2><p>muduo示例中的Hub分为几个部分：</p><ul><li>Hub服务程序，负责一对多的消息分发。它会记住每个client订阅了哪些topic，只把消息发给特定的订阅者。</li><li>pubsub库，为了方便编写使用Hub服务的应用程序，我写了一个简单的client library，用来和Hub打交道。这个library可以订阅topic、退订topic、往指定的topic发布消息。</li><li>sub示例程序，这个命令行程序订阅一个或多个topic，然后等待Hub的数据。</li><li>pub示例程序，这个命令行程序往某个topic发布一条消息，消息内容由命令行参数指定</li></ul><p><strong>多线程的高效广播</strong></p><p>假如有一条消息要广播给1000个订阅者，那么只能一个一个地发，第1个订阅者收到消息和第1000个订阅者收到消息的时差可以长达若干毫秒。那么，有没有办法提高速度、降低延迟呢？</p><blockquote><p>但是简单的办法并不一定能奏效，因为一个全局锁就把多线程程序退化为单线程执行（为啥需要加全局锁，是发送消息时必须加锁？？）。为了真正提速，我想到了用thread local（设置的订阅者变量？？）的办法，比如把1000个订阅者分给4个线程，每个线程的操作基本都是无锁的，这样可以做到并行地发送消息。</p></blockquote><h2 id="7-12-“串并转换”连接服务器及其自动化测试"><a href="#7-12-“串并转换”连接服务器及其自动化测试" class="headerlink" title="7.12　“串并转换”连接服务器及其自动化测试"></a>7.12　“串并转换”连接服务器及其自动化测试</h2><p><strong>功能需求</strong></p><p>连接服务器把多个客户连接汇聚为一个内部TCP连接，起到“数据串并转换”的作用，让backend的逻辑服务器专心处理业务，而无须顾及多连接的并发性。系统的框图如图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018195046299.png"></p><p><strong>实现</strong></p><p>对每个新client connection分配一个新的整数id，如果id用完了，则断开新连接（这样通过控制id的数目就能控制最大连接数）。另外，<strong>为了避免id过快地被复用（有可能造成backend串话），multiplexer采用queue来管理free id，每次从队列的头部取id，用完之后放回queue的尾部</strong></p><p>主要是处理四种事件：</p><ul><li>当client connection到达或断开时，向backend发出通知。</li><li>当从client connection收到数据时，把数据连同connection id一同发给backend。</li><li>当从backend connection收到数据时，辨别数据是发给哪个client connection，并执行相应的转发操作。</li><li>如果backend connection断开连接，则断开所有client connections（假设client会自动重试）</li></ul><p><strong>TcpConnection的id如何存放？</strong></p><p>当从backend收到数据，如何根据id找到对应的client connection？当从client connection收到数据，如何得知其id？</p><blockquote><p>第一个问题比较好解决，用std::map&lt;int, TcpConnectionPtr&gt; clientConns_保存从id到client connection的映射就行。</p><p>第二个问题固然可以用类似的办法解决，借此介绍一下muduo::net:: TcpConnection的context功能。每个TcpConnection都有一个boost::any成员，可由客户代码自由支配（get&#x2F;set）。这个boost::any是TcpConnection的context，可以用于保存与connection绑定的任意数据（比方说connectionid、connection的最后数据到达时间、connection所代表的用户的名字等等）。这样客户代码不必继承TcpConnection就能attach自己的状态，而且也用不着TcpConnectionFactory了（如果允许继承，那么必然要向TcpServer注入此factory）。</p></blockquote><h2 id="7-13-socks4a代理服务器"><a href="#7-13-socks4a代理服务器" class="headerlink" title="7.13　socks4a代理服务器"></a>7.13　socks4a代理服务器</h2><h3 id="7-13-1-TCP中继器"><a href="#7-13-1-TCP中继器" class="headerlink" title="7.13.1　TCP中继器"></a>7.13.1　TCP中继器</h3><blockquote><p>有时候，我们想在client和server之间放一个中继器（relay），把client与server之间的通信内容记录下来。这时用tcpdump是最方便省事的，但是tcpdump需要root权限，万一拿不到权限呢？穷人有穷人的办法，自己写一个TcpRelay，让client连接TcpRelay，再让TcpRelay连接server</p></blockquote><p>TcpRelay需要考虑以下问题：</p><ul><li>1．建立连接。为了真实模拟client，TcpRelay在accept连接C之后才向server发起连接S，那么在S建立起来之前，从C收到数据怎么办？要不要暂存起来？</li><li>2．并发连接的管理。图7-54中只画出了一个client，实际上TcpRelay可以服务多个client，左右两边这些并发连接如何管理，如何防止串话（cross talk）？</li><li>3．连接断开。client和server都可能主动断开连接。当client主动断开连接C时，TcpRelay应该立刻断开S。当server主动断开连接S时，TcpRelay应立刻断开C。这样才能比较精确地模拟client和server的行为。在关闭连接的一刹那，又有新的client连接进来，复用了刚刚close的fd号码，会不会造成串话？万一client和server几乎同时主动断开连接，TcpRelay如何应对？</li><li>4．速度不匹配。如果连接C的带宽是100kB&#x2F;s，而连接S的带宽是10MB&#x2F;s，不巧server是个chargen服务，会全速发送数据，那么会不会撑爆TcpRelay的buffer？如何限速？特别是在使用non-blocking IO和level-trigger polling的时候如何限制读取数据的速度？</li></ul><p>前三个问题的解决见示例代码，第四个问题的解法比较粗暴，用的是HighWaterMarkCallback，如果发送缓冲区堆积的数据大于10MiB就断开连接（更好的办法见§8.9.3）</p><h3 id="7-13-2-socks4a代理服务器"><a href="#7-13-2-socks4a代理服务器" class="headerlink" title="7.13.2　socks4a代理服务器"></a>7.13.2　socks4a代理服务器</h3><p>socks4a的功能与TcpRelay非常相似，它与TcpRelay的区别在于，TcpRelay固定连到某个server地址，而socks4a允许client指定要连哪个server。在accept连接C之后，socks4a server会读几个字节，以了解server的地址，再发起连接S。</p><h3 id="7-13-3-N∶1与1∶N连接转发"><a href="#7-13-3-N∶1与1∶N连接转发" class="headerlink" title="7.13.3　N∶1与1∶N连接转发"></a>7.13.3　N∶1与1∶N连接转发</h3><p>云风在《写了一个proxy用途你懂的》41中写了一个TCP隧道tunnel，程序由三部分组成：N∶1连接转发服务，1∶N连接转发服务，socks代理服务。</p><h2 id="7-14-短址服务"><a href="#7-14-短址服务" class="headerlink" title="7.14　短址服务"></a>7.14　短址服务</h2><p>muduo内置了一个简陋的HTTP服务器，可以处理简单的HTTP请求。这个HTTP服务器是面向内网的暴露进程状态的监控端口，不是面向公网的功能完善且健壮的httpd</p><p>使用方法</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018202416051.png"></p><h2 id="7-15-与其他库集成"><a href="#7-15-与其他库集成" class="headerlink" title="7.15　与其他库集成"></a>7.15　与其他库集成</h2><blockquote><p>Channel class是IO事件回调的分发器（dispatcher），它在handleEvent()中根据事件的具体类型分别回调ReadCallback、WriteCallback等，代码见§8.1.1。每个Channel对象服务于一个文件描述符，但并不拥有fd，在析构函数中也不会close(fd)。Channel也使用muduo一贯的boost::function来表示函数回调，它不是基类43。这样用户代码不必继承Channel，也无须override虚函数。</p></blockquote><p>通过Channel class可以把其他一些现成的网络库融入muduo的event loop中。</p><h3 id="7-15-1-UDNS"><a href="#7-15-1-UDNS" class="headerlink" title="7.15.1　UDNS"></a>7.15.1　UDNS</h3><p>UDNS44是一个stub45DNS解析器，它能够异步地发起DNS查询，再通过回调函数通知结果。</p><h3 id="7-15-2-c-ares-DNS"><a href="#7-15-2-c-ares-DNS" class="headerlink" title="7.15.2　c-ares DNS"></a>7.15.2　c-ares DNS</h3><p>c-ares DNS48是一款常用的异步DNS解析库</p><h3 id="7-15-3-curl"><a href="#7-15-3-curl" class="headerlink" title="7.15.3　curl"></a>7.15.3　curl</h3><p>libcurl是一个常用的HTTP客户端库53，可以方便地下载HTTP和HTTPS数据。libcurl有两套接口，easy和multi，本节介绍的是使用其multi接口54以达到单线程并发访问多个URL的效果。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Modern C++</title>
      <link href="/2023/02/15/c++/Effective_Modern_C++/"/>
      <url>/2023/02/15/c++/Effective_Modern_C++/</url>
      
        <content type="html"><![CDATA[<p>记录<a href="https://github.com/CnTransGroup/EffectiveModernCppChinese">《**Effective Modern C++**》</a>阅读笔记</p><hr><hr><h1 id="CHAPTER1-Deducing-Types"><a href="#CHAPTER1-Deducing-Types" class="headerlink" title="CHAPTER1 Deducing Types"></a><strong>CHAPTER1 Deducing Types</strong></h1><p>C++98有⼀套⽤于模板类型推导的规则，C++11修改了其中的⼀些规则并为<strong>auto</strong>和<strong>decltype</strong>添加了新的规则。</p><h2 id="1-理解模板类型推导"><a href="#1-理解模板类型推导" class="headerlink" title="1. 理解模板类型推导"></a>1. 理解模板类型推导</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//从expr中推导T和ParamType</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基于上述模板，有三种情况：</p><p><strong>(1)ParamType是一个指针或引用，但不是通用引用</strong></p><p>推导规则：</p><ul><li>如果expr的类型是⼀个引⽤，忽略引⽤（包括右值引用）</li><li>然后剩下的部分决定T，然后T与形参匹配得出最终ParamType</li></ul><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//param是⼀个引⽤</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">;</span> <span class="token comment">//x是int</span><span class="token keyword">const</span> <span class="token keyword">int</span> cx<span class="token operator">=</span>x<span class="token punctuation">;</span> <span class="token comment">//cx是const int</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> rx<span class="token operator">=</span>cx<span class="token punctuation">;</span> <span class="token comment">//rx是指向const int的引⽤</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T是int，param的类型是int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T是const int，param的类型是const int &amp;</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T是const int，param的类型是const int &amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此类情况右值和左值同等对待</p><p><strong>(2)ParamType是⼀个通⽤引⽤</strong></p><p>推导规则：</p><ul><li>如果<strong>expr</strong>是左值，T和ParamType都会被推导为左值引⽤。这⾮常不寻常：<ul><li>第⼀，这是模板类型推导中<strong>唯⼀⼀种T和ParamType都被推导为引⽤</strong>的情况。（&amp; &amp;&amp;会折叠为&amp;）</li><li>第⼆，虽然ParamType被声明为右值引⽤类型，但是最后推导的结果它是左值引⽤。</li></ul></li><li>如果<strong>expr</strong>是右值，就使⽤（1）的推导规则</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//param现在是⼀个通⽤引⽤类型</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">;</span> <span class="token comment">//如之前⼀样</span><span class="token keyword">const</span> <span class="token keyword">int</span> cx<span class="token operator">=</span>x<span class="token punctuation">;</span> <span class="token comment">//如之前⼀样</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> rx<span class="token operator">=</span>cx<span class="token punctuation">;</span> <span class="token comment">//如之前⼀样</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//x是左值，所以T是int&amp; //param类型也是int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//cx是左值，所以T是const int &amp; //param类型也是const int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//rx是左值，所以T是const int &amp; //param类型也是const int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//27是右值，所以T是int //param类型就是int&amp;&amp;      ！！！！！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(3)ParamType既不是指针也不是引⽤</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//以传值的⽅式处理param</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这意味着⽆论传递什么param都会成为它的⼀份拷⻉——⼀个完整的新对象！！此性质决定了可以舍弃自身的const属性，因为<strong>expr</strong>不可修改并不意味着他的拷⻉也不能被修改。</p><p>推导规则：</p><ul><li>如果expr的类型是⼀个引⽤，忽略这个引⽤部分（如果是指针则不会被忽略）</li><li>如果忽略引⽤之后expr是⼀个const，那就再忽略const。如果它是volatile，也会被忽略（注意！const int* const 类型只会舍弃自身const属性，即第二个const）</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">;</span> <span class="token comment">//如之前⼀样</span><span class="token keyword">const</span> <span class="token keyword">int</span> cx<span class="token operator">=</span>x<span class="token punctuation">;</span> <span class="token comment">//如之前⼀样</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> rx<span class="token operator">=</span>cx<span class="token punctuation">;</span> <span class="token comment">//如之前⼀样</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T和param都是int</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T和param都是int</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T和param都是int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常量指针常量情况，最终T会被推导为<strong>const char*</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传值</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr <span class="token operator">=</span> <span class="token string">" Fun with pointers"</span><span class="token punctuation">;</span><span class="token comment">//ptr是⼀个常量指针，指向常量对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>解引⽤符号（*）的右边的const表⽰ptr本⾝是⼀个const：ptr不能被修改为指向其它地址，也不能被设置为null</p><p>解引⽤符号左边的const表⽰ptr指向⼀个字符串，这个字符串是const，因此字符串不能被修改</p></blockquote><p><strong>数组</strong></p><p>c++中数组和指针并非一种类型，只是有数组退化为指针的规则。</p><p>当ParamType既不是指针也不是引⽤时，数组推导时会被视为指针，如果是个常量数组，推导出来的类型会是一个常量指针</p><p>注意！虽然函数不能接受真正的数组，但是可以接受指向数组的引⽤！下述示例中param被推导为为<strong>const char(&amp;)[13]</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"J. P. Briggs"</span><span class="token punctuation">;</span> <span class="token comment">//name的类型是const char[13]</span><span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传数组 param被推导为为**const char(&amp;)[13]**</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数实参</strong></p><p>在C++中不⽌是数组会退化为指针，函数类型也会退化为⼀个函数指针，因此函数规则和数组类似</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">someFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//someFunc是⼀个函数，类型是void(int,double)</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传值</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传引⽤</span><span class="token function">f1</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//param被推导为指向函数的指针，类型是void(*)(int, double)</span><span class="token function">f2</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//param被推导为指向函数的引⽤，类型为void(&amp;)(int, bouel)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>在模板类型推导时，有引用的实参会被视为无引用，他们的引用会被忽略（包括右值引用），使用忽略后的值推导T</li><li>对于通用引用的推导，左值实参会被特殊对待</li><li>对于传值类型推导，<code>const</code>和&#x2F;或<code>volatile</code>实参会被认为是non-<code>const</code>的和non-<code>volatile</code>的</li><li>在模板类型推导时，数组名或者函数名实参会退化为指针，除非它们被用于初始化引用</li></ul></blockquote><h2 id="2-理解auto类型推导"><a href="#2-理解auto类型推导" class="headerlink" title="2. 理解auto类型推导"></a>2. 理解<code>auto</code>类型推导</h2><p><strong>auto</strong>是建⽴在模板类型推导的基础上的，<strong>auto和模板类型推导唯一不同之处在于花括号初始化的推导。</strong></p><p>auto推导其实就是使用模板类型来进行推导，当一个变量使用<code>auto</code>进行声明时，<code>auto</code>扮演了模板中<code>T</code>的角色，变量的类型说明符扮演了<code>ParamType</code>的角色。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParmaType param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span> <span class="token comment">//类型说明符是auto</span><span class="token keyword">const</span> <span class="token keyword">auto</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">//类型说明符是const auto</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span> rx<span class="token operator">=</span>cx<span class="token punctuation">;</span><span class="token comment">//类型说明符是const auto&amp;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token comment">//理想化的模板⽤来推导x的类型</span><span class="token keyword">void</span> <span class="token function">func_for_x</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func_for_x</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token comment">//理想化的模板⽤来推导cx 的类型</span><span class="token keyword">void</span> <span class="token function">func_for_cx</span><span class="token punctuation">(</span><span class="token keyword">const</span> T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func_for_cx</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token comment">//理想化的模板⽤来推导rx的类型</span><span class="token keyword">void</span> <span class="token function">func_for_rx</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func_for_rx</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>auto推导结果和模板类型推导结果规则相同，只有在花括号初始化时推导不同。</p><p>当使⽤auto的变量使⽤花括号的语法进⾏初始化的时候，会推导出<strong>std::initializer_list</strong>的实例化，但是对于模板类型推导这样就⾏不通</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> x3<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">27</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//推导为std::initializer_list&lt;int></span><span class="token keyword">auto</span> x4<span class="token punctuation">&#123;</span><span class="token number">27</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//推导为std::initializer_list&lt;int></span><span class="token keyword">auto</span> x<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//x的类型是std::initializer_list&lt;int></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//错误！不能推导出T</span><span class="token comment">//然而如果指定T是std::initializer而留下未知T,模板类型推导就能正常⼯作：</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">></span> initList<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++14中<code>auto</code>用于函数返回值和lambda时，实际上使用模板类型推导的那一套规则在工作，而不是<code>auto</code>类型推导，如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">createInitList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>         <span class="token comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span><span class="token punctuation">&#125;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span><span class="token keyword">auto</span> resetV <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>v<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> newValue<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> v <span class="token operator">=</span> newValue<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token comment">//C++14</span><span class="token function">resetV</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结：</strong></p><ul><li><code>auto</code>类型推导通常和模板类型推导相同，但是<code>auto</code>类型推导假定花括号初始化代表<code>std::initializer_list</code>，而模板类型推导不这样做</li><li>在C++14中<code>auto</code>允许出现在函数返回值或者<em>lambda</em>函数形参中，但是它的工作机制是模板类型推导那一套方案，而不是<code>auto</code>类型推导</li></ul></blockquote><h2 id="3-理解decltype"><a href="#3-理解decltype" class="headerlink" title="3. 理解decltype"></a>3. 理解<code>decltype</code></h2><p>提供名字或者表达式，decltype能推导出其类型</p><p>decltype最主要用于声明函数模板，而这个函数返回类型依赖于形参类型，即使用尾置返回类型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Container</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Index</span><span class="token operator">></span>    <span class="token comment">//可以工作，</span><span class="token keyword">auto</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span>       <span class="token comment">//但是需要改良</span>    <span class="token operator">-></span><span class="token keyword">decltype</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lambda表达式能忽略尾置返回类型，只留下auto。<strong>但是当返回值是一个int&amp;类型时，模板类型推导会去除引用部分，最后推导出int类型</strong>，这会导致当赋值时出现意料外错误。</p><ul><li><p>解决办法：使用decltype(auto)，<code>auto</code>说明符表示这个类型将会被推导，<code>decltype</code>说明<code>decltype</code>的规则将会被用到这个推导过程中</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Container</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Index</span><span class="token operator">></span>    <span class="token comment">//C++14版本，</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span>                                  <span class="token comment">//可以工作，</span><span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>           <span class="token comment">//但是还需要</span><span class="token comment">//传左值正常，但传右值可能会出现意料外的结果，解决方法是使用通用引用+完美转发</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果想对初始化表达式使用<code>decltype</code>推导的规则，也可以使用decltype(auto)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> myWidget2 <span class="token operator">=</span> cw<span class="token punctuation">;</span>          <span class="token comment">//decltype类型推导，会推导出引用类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>将<code>decltype</code>应用于变量名会产生该变量名的声明类型。</p><p>然而，<strong>对于比单纯的变量名更复杂的左值表达式，<code>decltype</code>可以确保报告的类型始终是左值引用</strong>。C++11定义了表达式<code>(x)</code>也是一个左值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>b<span class="token punctuation">;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//推导为int</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>b<span class="token operator">=</span>x<span class="token punctuation">)</span>   <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//推导为int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li><code>decltype</code>总是不加修改的产生变量或者表达式的类型。</li><li>对于<code>T</code>类型的不是单纯的变量名的左值表达式，<code>decltype</code>总是产出<code>T</code>的引用即<code>T&amp;</code>。</li><li>C++14支持<code>decltype(auto)</code>，就像<code>auto</code>一样，推导出类型，但是它使用<code>decltype</code>的规则进行推导。</li></ul></blockquote><h2 id="4-学会查看类型推导结果"><a href="#4-学会查看类型推导结果" class="headerlink" title="4. 学会查看类型推导结果"></a>4. 学会查看类型推导结果</h2><p>三种方法：</p><ul><li>IDE编辑器：代码编写时使用IDE查看</li><li>编译器诊断：使用编译器出错时提供的错误消息</li><li>运行时输出：打印typeid(x).name()信息，但是其不一定返回有意义的信息，且不一定准确（因为<code>std::type_info::name</code>规范批准像传值形参一样来对待这些类型，因此可能丢失自身的引用属性或const属性）</li></ul><blockquote><p><strong>总结</strong></p><ul><li>类型推断可以从IDE看出，从编译器报错看出，从Boost TypeIndex库的使用看出</li><li>这些工具可能既不准确也无帮助，所以理解C++类型推导规则才是最重要的</li></ul></blockquote><h1 id="CHAPTER2-auto"><a href="#CHAPTER2-auto" class="headerlink" title="CHAPTER2 auto"></a><strong>CHAPTER2 auto</strong></h1><p>介绍auto的使用及坑</p><h2 id="5-优先考虑auto而⾮显式类型声明"><a href="#5-优先考虑auto而⾮显式类型声明" class="headerlink" title="5. 优先考虑auto而⾮显式类型声明"></a>5. 优先考虑auto而⾮显式类型声明</h2><p>auto会强制初始化，避免出现意料之外的初始值。auto能在修改代码后自动重构代码，且避免一些平台兼容导致的问题。</p><p>定义lambda函数变量时，<code>std::function</code>方法比<code>auto</code>方法要更耗空间且调用更慢，还可能有<em>out-of-memory</em>异常。（更耗空间是因为如果std::function声明的对象空间不足以存储闭包，则需要重新申请堆内存来存储）</p><p>遍历<code>std::unordered_map</code>时，其key是const，如果遍历方法如下则会导致每个元素生成一个非const的临时对象，然后将p绑定在临时对象上，从而出现意料之外的结果。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> p <span class="token operator">:</span> m<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li><code>auto</code>变量必须初始化，它可以避免一些移植性和效率性的问题，也使得重构更方便</li><li><code>auto</code>类型的变量可能会踩到一些陷阱。</li></ul></blockquote><h2 id="6-auto推导若非己愿，使用显式类型初始化惯用法"><a href="#6-auto推导若非己愿，使用显式类型初始化惯用法" class="headerlink" title="6. auto推导若非己愿，使用显式类型初始化惯用法"></a>6. <code>auto</code>推导若非己愿，使用显式类型初始化惯用法</h2><p>一些类的取值返回结果并未原始结果，而是代理类，其内部实现未知从而导致出现错误。如vector<bool>，其如果是临时对象时，可能会存在访问时已被释放的问题（其细节可以详见原书）。</p><p>auto有时会推导为代理类的类型，可以使用<strong>显式类型初始器惯用法</strong>强制指定推导类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> highPriority <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>不可见的代理类可能会使<code>auto</code>从表达式中推导出“错误的”类型</li><li>显式类型初始器惯用法强制<code>auto</code>推导出你想要的结果</li></ul></blockquote><h1 id="CHAPTER3-Moving-to-Modern-C"><a href="#CHAPTER3-Moving-to-Modern-C" class="headerlink" title="CHAPTER3 Moving to Modern C++"></a><strong>CHAPTER3 Moving to Modern C++</strong></h1><h2 id="7-区别使用-和-创建对象"><a href="#7-区别使用-和-创建对象" class="headerlink" title="7. 区别使用()和{}创建对象"></a>7. 区别使用<code>()</code>和<code>&#123;&#125;</code>创建对象</h2><p>C++11基于花括号来统一初始化。</p><p>花括号初始化能被用于：</p><ul><li>初始化容器元素，</li><li>为非静态数据成员指定默认初始值（也能用小括号初始化）</li><li>不可拷贝的对象（例如<code>std::atomic</code>）初始化（也能用小括号初始化）</li></ul><p><strong>注意</strong></p><ul><li><p>花括号表达式有一个异常的特性，它不允许内置类型间隐式的变窄转换（变化为更高类型允许）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span><span class="token keyword">int</span> sum1<span class="token punctuation">&#123;</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>          <span class="token comment">//错误！double的和可能不能表示为int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>花括号表达式能很好创建一个使用默认构造函数构造的对象</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget <span class="token function">w2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//最令人头疼的解析！声明一个函数w2，返回Widget</span>Widget w3<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                    <span class="token comment">//调用没有参数的构造函数构造对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p><strong>缺陷</strong></p><ul><li><p>使用花括号初始化时会优先调用声明有<code>std::initializer_list</code>形参的（移动）构造函数（即使直观上其他构造函数更适合），编译器热衷于把花括号初始化与使<code>std::initializer_list</code>构造函数匹配（如果花括号里面是空集则不会优先，除非里面再加一个花括号）</p></li><li><p>容器定义时使用花括号和小括号意义完全不同</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//使用非std::initializer_list构造函数</span>                                <span class="token comment">//创建一个包含10个元素的std::vector，所有的元素的值都是20</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v2<span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//使用std::initializer_list构造函数</span>                                <span class="token comment">//创建包含两个元素的std::vector，元素的值为10和20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p><strong>总结</strong></p><ul><li>括号初始化是最广泛使用的初始化语法，它防止变窄转换，并且对于C++最令人头疼的解析有天生的免疫性</li><li>在构造函数重载决议中，括号初始化尽最大可能与<code>std::initializer_list</code>参数匹配，即便其他构造函数看起来是更好的选择</li><li>对于数值类型的<code>std::vector</code>来说使用花括号初始化和小括号初始化会造成巨大的不同</li><li>在模板类选择使用小括号初始化或使用花括号初始化创建对象是一个挑战。</li></ul></blockquote><h2 id="8-优先考虑nullptr而非0和NULL"><a href="#8-优先考虑nullptr而非0和NULL" class="headerlink" title="8. 优先考虑nullptr而非0和NULL"></a>8. 优先考虑<code>nullptr</code>而非<code>0</code>和<code>NULL</code></h2><p>字面量0和NULL是int型，而非指针</p><p>当函数重载时，如果传递NULL，会优先与int型形参匹配</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//三个f的重载函数</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//调用f(int)而不是f(void*)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//一般来说调用f(int)，绝对不会调用f(void*)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>nullptr</code>的优点是它不是整型，是<strong>所有</strong>类型的指针，其真正类型是<code>std::nullptr_t</code>，<code>std::nullptr_t</code>可以隐式转换为指向任何内置类型的指针</p><p>使用nullptr而非NULL可以避免使用模板时将NULL指针推导为int型。</p><blockquote><p><strong>总结</strong></p><ul><li>优先考虑<code>nullptr</code>而非<code>0</code>和<code>NULL</code></li><li>避免重载指针和整型</li></ul></blockquote><h2 id="9-优先考虑别名声明而非typedefs"><a href="#9-优先考虑别名声明而非typedefs" class="headerlink" title="9. 优先考虑别名声明而非typedefs"></a>9. 优先考虑别名声明而非<code>typedef</code>s</h2><p>当声明一个函数指针时别名声明using更容易理解：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//typedef</span><span class="token keyword">using</span> FP <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//别名声明</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>using相比typedef最大一个特点是可以被模板化</strong>，而typedef定义模板别名只能嵌套进模板化的struct（其如果用来定义对象时又使用了模板形参，则定义对象时需要加typename）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                            <span class="token comment">//MyAllocList&lt;T>是</span><span class="token keyword">using</span> MyAllocList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">;</span>   <span class="token comment">//std::list&lt;T, MyAlloc&lt;T>>的同义词</span>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span> lw<span class="token punctuation">;</span>                         <span class="token comment">//用户代码</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                            <span class="token comment">//MyAllocList&lt;T>是</span><span class="token keyword">struct</span> <span class="token class-name">MyAllocList</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">//std::list&lt;T, MyAlloc&lt;T>></span>    <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span> type<span class="token punctuation">;</span>      <span class="token comment">//的同义词  </span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token double-colon punctuation">::</span>type lw<span class="token punctuation">;</span>                   <span class="token comment">//用户代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li><code>typedef</code>不支持模板化，但是别名声明支持。</li><li>别名模板避免了使用“<code>::type</code>”后缀，而且在模板中使用<code>typedef</code>还需要在前面加上<code>typename</code></li><li>C++14提供了C++11所有<em>type traits</em>转换的别名声明版本</li></ul></blockquote><h2 id="10-优先考虑限域enum而非未限域enum"><a href="#10-优先考虑限域enum而非未限域enum" class="headerlink" title="10. 优先考虑限域enum而非未限域enum"></a>10. 优先考虑限域<code>enum</code>而非未限域<code>enum</code></h2><p>未限域<code>enum</code>，枚举名的名字属于包含这个<code>enum</code>的作用域，这意味着作用域内不能含有相同名字的其他东西</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Color</span> <span class="token punctuation">&#123;</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">//black, white, red在Color所在的作用域</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>限域<code>enum</code>，枚举名的名字属于<code>enum</code>作用域</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color</span> <span class="token punctuation">&#123;</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//black, white, red//限制在Color域内</span><span class="token comment">//默认情况下，限域枚举的底层类型是int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>限域<code>enum</code>优点：</p><ul><li><p>减少命名空间污染</p></li><li><p>在作用域中，枚举名是强类型。未限域<code>enum</code>中的枚举名会隐式转换为整型</p></li><li><p>可以被前置声明，而非限域不行（除非指定底层类型，但编译器实现时需要知道所有枚举值从而选择一个最小的底层类型）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Color</span><span class="token operator">:</span> std<span class="token double-colon punctuation">::</span><span class="token keyword">uint8_t</span><span class="token punctuation">;</span>   <span class="token comment">//非限域enum前向声明 底层类型为std::uint8_t</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>未限域<code>enum</code>由于可隐式转换为整形，因此可有以下用法，限域要实现以下用法只能增加一个模板函数来转换，较为麻烦。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">UserInfoFields</span> <span class="token punctuation">&#123;</span> uiName<span class="token punctuation">,</span> uiEmail<span class="token punctuation">,</span> uiReputation <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>UserInfo uInfo<span class="token punctuation">;</span>                         <span class="token comment">//有三个字段</span><span class="token keyword">auto</span> val <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>uiEmail<span class="token operator">></span></span></span><span class="token punctuation">(</span>uInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//想获取用户email字段的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>C++98的<code>enum</code>即非限域<code>enum</code>。</li><li>限域<code>enum</code>的枚举名仅在<code>enum</code>内可见。要转换为其它类型只能使用<em>static_cast</em>。</li><li>非限域&#x2F;限域<code>enum</code>都支持底层类型说明语法，限域<code>enum</code>底层类型默认是<code>int</code>。非限域<code>enum</code>没有默认底层类型。</li><li>限域<code>enum</code>总是可以前置声明。非限域<code>enum</code>仅当指定它们的底层类型时才能前置。</li></ul></blockquote><h2 id="11-优先考虑使用deleted函数而非使用未定义的私有声明"><a href="#11-优先考虑使用deleted函数而非使用未定义的私有声明" class="headerlink" title="11. 优先考虑使用deleted函数而非使用未定义的私有声明"></a>11. 优先考虑使用deleted函数而非使用未定义的私有声明</h2><p>在C++98中防止调用函数的方法是将它们声明为私有（<code>private</code>）成员函数并且不定义，C++11中用“<code>= delete</code>”可将标记为<strong>deleted函数</strong></p><p><strong>deleted优点</strong></p><ul><li><p><em>deleted</em>函数不能以任何方式被调用，即使你在成员函数或者友元函数里面调用<em>deleted</em>函数也不能通过编译（声明为私有且不定义方法只有在链接时才被诊断出来）</p></li><li><p><em>deleted</em>函数应被声明为<code>public</code>而不是<code>private</code>（否则，编译器只会给出该函数是<code>private</code>的错误）</p></li><li><p><strong>任何</strong>函数（包括普通函数、模板示例函数）都可以标记为<em>deleted</em></p></li><li><p>禁止一些模板的实例化（在类中，无法使用private禁止函数模板实例化，因为模板特例化必须位于一个命名空间作用域，而不是类作用域）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token generic-function"><span class="token function">processPointer</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>比起声明函数为<code>private</code>但不定义，使用<em>deleted</em>函数更好</li><li>任何函数都能被删除（be deleted），包括非成员函数和模板实例（译注：实例化的函数）</li></ul></blockquote></li></ul><h2 id="12-使用override声明重载函数"><a href="#12-使用override声明重载函数" class="headerlink" title="12. 使用override声明重载函数"></a>12. 使用override声明重载函数</h2><p>要想重写一个函数，必须满足下列要求：</p><ul><li><p>基类函数必须是<code>virtual</code></p></li><li><p>基类和派生类函数名必须完全一样（除非是析构函数)</p></li><li><p>基类和派生类函数形参类型必须完全一样</p></li><li><p>基类和派生类函数常量性<code>const</code>ness必须完全一样</p></li><li><p>基类和派生类函数的返回值和异常说明（<em>exception specifications</em>）必须兼容</p></li><li><p>函数的引用限定符（<em>reference qualifiers</em>）必须完全一样。（c++11添加，它可以限定成员函数只能用于左值或者右值）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>    <span class="token comment">//只有*this为左值的时候才能被调用</span>    <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//只有*this为右值的时候才能被调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>重写要求过于多，因此需要使用override来显性让编译器检查是否是重写函数。</p><blockquote><p><strong>总结</strong></p><ul><li>为重写函数加上<code>override</code></li><li>成员函数引用限定让我们可以区别对待左值对象和右值对象（即<code>*this</code>)</li></ul></blockquote><h2 id="13-优先考虑const-iterator而非iterator"><a href="#13-优先考虑const-iterator而非iterator" class="headerlink" title="13. 优先考虑const_iterator而非iterator"></a>13. 优先考虑<code>const_iterator</code>而非<code>iterator</code></h2><p> <code>const_iterator</code>等价于指向常量的指针，指向不能被修改的值。</p><p>C++98使用 <code>const_iterator</code>存在诸多不便，但C++11使用 <code>const_iterator</code>变得容器使用，例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">find</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1983</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cbegin和cend</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>C++11唯一支持不足在于不支持非成员函数<code>cbegin</code>，<code>cend</code>，<code>rbegin</code>，<code>rend</code>等，只提供<code>begin</code>、<code>end</code>（C++14中都已提供）。但可以通过以下方式自己支持：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span><span class="token operator">-></span><span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//解释见下</span><span class="token punctuation">&#125;</span><span class="token comment">//对const容器调用非成员函数begin（由C++11提供）将产出const_iterator，</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>优先考虑<code>const_iterator</code>而非<code>iterator</code></li><li>在最大程度通用的代码中，优先考虑非成员函数版本的<code>begin</code>，<code>end</code>，<code>rbegin</code>等，而非同名成员函数</li></ul></blockquote><h2 id="14-如果函数不抛出异常请使用noexcept"><a href="#14-如果函数不抛出异常请使用noexcept" class="headerlink" title="14. 如果函数不抛出异常请使用noexcept"></a>14. 如果函数不抛出异常请使用<code>noexcept</code></h2><blockquote><p>有些细节还是没咋看懂（原理、移动构造），后面再看</p></blockquote><p>在C++11中，<code>noexcept</code>保证函数不会抛出任何异常。</p><p>加入<code>noexcept</code>后编译器能更好的优化代码，在一个<code>noexcept</code>函数中，当异常可能传播到函数外时，优化器不需要保证运行时栈处于可展开状态</p><p>默认情况下，内存释放函数和析构函数——不管是用户定义的还是编译器生成的——都是默认<code>noexcept</code>。</p><blockquote><p><strong>总结</strong></p><ul><li><code>noexcept</code>是函数接口的一部分，这意味着调用者可能会依赖它</li><li><code>noexcept</code>函数较之于non-<code>noexcept</code>函数更容易优化</li><li><code>noexcept</code>对于移动语义，<code>swap</code>，内存释放函数和析构函数非常有用</li><li>大多数函数是异常中立的（译注：可能抛也可能不抛异常）而不是<code>noexcept</code></li></ul></blockquote><h2 id="15-尽可能的使用constexpr"><a href="#15-尽可能的使用constexpr" class="headerlink" title="15. 尽可能的使用constexpr"></a>15. 尽可能的使用<code>constexpr</code></h2><blockquote><p>const有两重语义：变量只读，修饰常量</p><p>变量只读：定义函数时，形参前有const修饰，此时表示此形参只读</p><p>修饰常量：定义常量</p></blockquote><p>当<code>constexpr</code>用于对象上面</p><ul><li>它本质上就是<code>const</code>的加强形式。声明为<code>constexpr</code>的变量，编译器会确保它们是编译期可知的（const不保证编译期可知）</li><li>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，定义的是一个常量指针（int* const ptr），是顶层const</li></ul><p>当<code>constexpr</code>用于函数时</p><ul><li><p>不表明函数返回一个<code>const</code>值，<strong>如果实参是编译期常量，这些函数将产出编译期常量；如果实参是运行时才能知道的值，它们就将产出运行时值</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token keyword">int</span> base<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//constexpr函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>C++11中，<code>constexpr</code>函数的代码不超过一行语句：一个<code>return</code>（可使用<code>:? </code>运算符和递归），在C++14中，<code>constexpr</code>函数不再限制一行语句。</p></li><li><p><code>constexpr</code>函数限制为只能获取和返回<strong>字面值类型</strong>，在C++11中，除了<code>void</code>外的所有内置类型，以及一些用户定义类型都可以是字面值类型，因为构造函数和其他成员函数可能是<code>constexpr</code></p><ul><li>当构造函数可被声明为<code>constexpr</code>，如果传入的参数在编译期可知，其数据成员也能在编译器可知，此时这样定义的<code>constexpr</code>类变量会在编译期就构造完成。</li><li>当成员函数被声明为<code>constexpr</code>，则调用此函数的代码也能被编译期构造完成。在C++11中， 成员函数以下情况不能被声明为<code>constexpr</code>，在C++14中无此限制。<ul><li>成员函数中修改操作的对象的状态</li><li>成员函数有<code>void</code>返回类型</li></ul></li></ul></li></ul><blockquote><p>算数类型、引用和指针都属于<strong>字面值类型</strong>。但他们的初始值受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是储存于某个固定地址中的对象。</p></blockquote><blockquote><p><strong>总结</strong></p><ul><li><code>constexpr</code>对象是<code>const</code>，它被在编译期可知的值初始化</li><li>当传递编译期可知的值时，<code>constexpr</code>函数可以产出编译期可知的结果</li><li><code>constexpr</code>对象和函数可以使用的范围比non-<code>constexpr</code>对象和函数要大</li><li><code>constexpr</code>是对象和函数接口的一部分</li></ul></blockquote><h2 id="16-让const成员函数线程安全"><a href="#16-让const成员函数线程安全" class="headerlink" title="16. 让const成员函数线程安全"></a>16. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/3.MovingToModernCpp/item16.md">让const成员函数线程安全</a></h2><p><code>const</code>成员函数应支持并发执行，确保<code>const</code>成员函数是线程安全的，但是mutable定义的变量在const成员函数中仍能被修改，从而导致线程不安全。</p><p>当const成员函数中需要修改mutable变量时，需保证互斥访问：</p><ul><li>对于需要同步的是单个的变量或者内存位置，使用<code>std::atomic</code>就足够</li><li>对两个以上的变量或内存位置作为一个单元来操作的话，就应该使用互斥量</li></ul><h2 id="17-理解特殊成员函数函数的生成"><a href="#17-理解特殊成员函数函数的生成" class="headerlink" title="17. 理解特殊成员函数函数的生成"></a>17. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/3.MovingToModernCpp/item17.md">理解特殊成员函数函数的生成</a></h2><p><strong>特殊成员函数</strong>是指C++自己生成的函数。</p><p><strong>C++98</strong></p><ul><li><p>有四个特殊成员函数：默认构造函数，析构函数，拷贝构造函数，拷贝赋值运算符，这些函数仅在需要的时候才生成</p></li><li><p>默认构造函数仅在类完全没有构造函数的时候才生成，生成的特殊成员函数是隐式public且<code>inline</code>。它们是非虚的，除非相关函数是在派生类中的析构函数，派生类继承了有虚析构函数的基类。</p></li></ul><p><strong>C++11</strong></p><ul><li><p>新增两个特殊成员函数：移动构造函数和移动赋值运算符</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//移动构造函数</span>Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//移动赋值运算符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>使用移动构造或者移动赋值时，如果支持移动就会逐成员移动类成员和基类成员，如果不支持移动就执行拷贝操作</li></ul></li><li><p>两个拷贝操作是独立的：声明一个不会限制编译器生成另一个；两个移动操作不是相互独立的。如果你声明了其中一个，编译器就不再生成另一个（如果逐成员移动构造有些问题，那么逐成员移动赋值同样也可能有问题）</p></li><li><p>如果一个类显式声明了拷贝操作，编译器就不会生成移动操作</p></li><li><p>如果一个类显式声明了移动操作，编译器就不会生成拷贝操作</p></li><li><p>C++11仅当下面条件成立时才会生成移动操作（当需要时）：</p><ul><li>类中没有拷贝操作</li><li>类中没有移动操作</li><li>类中没有用户定义的析构（有自定义析构就说明资源需要自己管理，自动生成移动操作可能出错）</li></ul></li><li><p>用户声明的析构函数会抑制编译器生成移动操作，所以如果该类需要具有移动性，就为移动操作加上<code>= default</code>。声明移动会抑制拷贝生成，所以如果拷贝性也需要支持，再为拷贝操作加上<code>= default</code></p></li></ul><p>Rule of Three规则：如果声明了拷贝构造函数，拷贝赋值运算符，或者析构函数三者之一，应该也声明其余两个</p><p>C++11对于特殊成员函数处理的规则如下：</p><ul><li><strong>默认构造函数</strong>：和C++98规则相同。仅当类不存在用户声明的构造函数时才自动生成。</li><li><strong>析构函数</strong>：基本上和C++98相同；稍微不同的是现在析构默认<code>noexcept</code>（参见<a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/3.MovingToModernCpp/item14.md">Item14</a>）。和C++98一样，仅当基类析构为虚函数时该类析构才为虚函数。</li><li><strong>拷贝构造函数</strong>：和C++98运行时行为一样：逐成员拷贝non-static数据。仅当类没有用户定义的拷贝构造时才生成。如果类声明了移动操作它就是<em>delete</em>的。当用户声明了拷贝赋值或者析构，该函数自动生成已被废弃。</li><li><strong>拷贝赋值运算符</strong>：和C++98运行时行为一样：逐成员拷贝赋值non-static数据。仅当类没有用户定义的拷贝赋值时才生成。如果类声明了移动操作它就是<em>delete</em>的。当用户声明了拷贝构造或者析构，该函数自动生成已被废弃。</li><li><strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>：都对非static数据执行逐成员移动。仅当类没有用户定义的拷贝操作，移动操作或析构时才自动生成。</li></ul><p>成员函数<strong>模版</strong>不会阻止编译器生成特殊成员函数</p><blockquote><p><strong>总结</strong></p><ul><li>特殊成员函数是编译器可能自动生成的函数：默认构造函数，析构函数，拷贝操作，移动操作。</li><li>移动操作仅当类没有显式声明移动操作，拷贝操作，析构函数时才自动生成。</li><li>拷贝构造函数仅当类没有显式声明拷贝构造函数时才自动生成，并且如果用户声明了移动操作，拷贝构造就是<em>delete</em>。拷贝赋值运算符仅当类没有显式声明拷贝赋值运算符时才自动生成，并且如果用户声明了移动操作，拷贝赋值运算符就是<em>delete</em>。当用户声明了析构函数，拷贝操作的自动生成已被废弃。</li><li>成员函数模板不抑制特殊成员函数的生成。</li></ul></blockquote><h1 id="CHAPTER4-Smart-Pointers"><a href="#CHAPTER4-Smart-Pointers" class="headerlink" title="CHAPTER4 Smart Pointers"></a><strong>CHAPTER4 Smart Pointers</strong></h1><p>原始指针缺点：</p><ol><li>它的声明不能指示所指到底是单个对象还是数组。</li><li>它的声明没有告诉你用完后是否应该销毁它，即指针是否拥有所指之物。</li><li>如果你决定你应该销毁指针所指对象，没人告诉你该用<code>delete</code>还是其他析构机制（比如将指针传给专门的销毁函数）。</li><li>如果你发现该用<code>delete</code>。 原因1说了可能不知道该用单个对象形式（“<code>delete</code>”）还是数组形式（“<code>delete[]</code>”）。如果用错了结果是未定义的。</li><li>假设你确定了指针所指，知道销毁机制，也很难确定你在所有执行路径上都执行了<strong>恰为一次</strong>销毁操作（包括异常产生后的路径）。少一条路径就会产生资源泄漏，销毁多次还会导致未定义行为。</li><li>一般来说没有办法告诉你指针是否变成了悬空指针（dangling pointers），即内存中不再存在指针所指之物。在对象销毁后指针仍指向它们就会产生悬空指针。</li></ol><p>C++11中存在四种智能指针：<code>std::auto_ptr</code>，<code>std::unique_ptr</code>，<code>std::shared_ptr</code>，<code> std::weak_ptr</code></p><h2 id="18-对于独占资源使用std-unique-ptr"><a href="#18-对于独占资源使用std-unique-ptr" class="headerlink" title="18. 对于独占资源使用std::unique_ptr"></a>18. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/4.SmartPointers/item18.md">对于独占资源使用std::unique_ptr</a></h2><p>默认情况下，<code>std::unique_ptr</code>大小等同于原始指针，且大多数操作执行的指令完全相同</p><p>一个non-null <code>std::unique_ptr</code>始终拥有其指向的内容。移动一个<code>std::unique_ptr</code>将所有权从源指针转移到目的指针（源指针被设为null）。拷贝一个<code>std::unique_ptr</code>是不允许的。</p><p>默认情况下，销毁将通过<code>delete</code>进行，但是在构造过程中，<code>std::unique_ptr</code>对象可以被设置为使用自定义删除器：当资源需要销毁时可调用的任意函数（或者函数对象，包括<em>lambda</em>表达式），参数就是智能指针管理的内存的地址。</p><p>当自定义删除器时，<code>std::unique_ptr</code>的内存消耗可能会变大：</p><ul><li>函数指针形式的删除器，通常会使<code>std::unique_ptr</code>的从一个字（<em>word</em>）大小增加到两个</li><li>对于函数对象形式的删除器来说，变化的大小取决于函数对象中存储的状态多少<ul><li>无状态函数（stateless function）对象（比如不捕获变量的<em>lambda</em>表达式）对大小没有影响，这意味当自定义删除器可以实现为函数或者<em>lambda</em>时，尽量使用<em>lambda</em></li><li>这是通过空基类优化完成，其原理是通过继承函数对象类</li></ul></li></ul><p><code>std::unique_ptr</code>有两种形式，一种用于单个对象（<code>std::unique_ptr&lt;T&gt;</code>），一种用于数组（<code>std::unique_ptr&lt;T[]&gt;</code>）。指向哪种形式都没有歧义，<code>std::unique_ptr</code>的API设计会自动匹配你的用法。</p><p>数组的<code>std::unique_ptr</code>相比vector等容器的唯一有用情况是使用类似C的API返回一个指向堆数组的原始指针，而你想接管这个数组的所有权。</p><blockquote><p><strong>总结</strong></p><ul><li><code>std::unique_ptr</code>是轻量级、快速的、只可移动（<em>move-only</em>）的管理专有所有权语义资源的智能指针</li><li>默认情况，资源销毁通过<code>delete</code>实现，但是支持自定义删除器。有状态的删除器和函数指针会增加<code>std::unique_ptr</code>对象的大小</li><li>将<code>std::unique_ptr</code>转化为<code>std::shared_ptr</code>非常简单</li></ul></blockquote><h2 id="19-对于共享资源使用std-shared-ptr"><a href="#19-对于共享资源使用std-shared-ptr" class="headerlink" title="19. 对于共享资源使用std::shared_ptr"></a>19. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/4.SmartPointers/item19.md">对于共享资源使用std::shared_ptr</a></h2><p><code>std::shared_ptr</code>通过引用计数（<em>reference count</em>）来确保它是否是最后一个指向某种资源的指针，引用计数关联资源并跟踪有多少<code>std::shared_ptr</code>指向该资源</p><p><code>std::shared_ptr</code>构造函数递增引用计数值（注意是通常，移动构造就不会增加），析构函数递减值。如果<code>std::shared_ptr</code>在计数值递减后发现引用计数值为零，没有其他<code>std::shared_ptr</code>指向该资源，它就会销毁资源。</p><p>引用计数暗示着性能问题：</p><ul><li><strong><code>std::shared_ptr</code>大小是原始指针的两倍</strong>，因为它内部包含一个指向资源的原始指针，还包含一个指向资源的控制块的原始指针（控制块中包含引用计数值）。</li><li><strong>引用计数的内存必须动态分配</strong>。<code>std::make_shared</code>创建<code>std::shared_ptr</code>可以避免引用计数的动态分配，但是还存在一些<code>std::make_shared</code>不能使用的场景</li><li><strong>递增递减引用计数必须是原子性的</strong>，原子操作通常比非原子操作要慢</li></ul><p><code>std::shared_ptr</code>使用<code>delete</code>作为资源的默认销毁机制，也支持自定义的删除器。对于<code>std::unique_ptr</code>来说，删除器类型是智能指针类型的一部分。对于<code>std::shared_ptr</code>则不是：</p><ul><li>导致自带不同的删除器的两个<code>std::shared_ptr</code>，可以放到同一个类型的容器中，且能互相赋值。<code>std::unique_ptr</code>不行，因为删除器是其类型一部分。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>loggingDel<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">upw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 删除器类型是指针类型的一部分</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span>loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 删除器类型不是指针类型的一部分</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>std::shared_ptr</code>指定自定义删除器不会改变对象的大小，总是只有两个指针大小。</p><ul><li>有一个指向控制块的指针，控制块中包含：引用计数值、自定义删除器的拷贝、分配器的拷贝、次级引用计数<em>weak count</em>等（使用继承实现，里面还有一个虚函数用来确保指向的对象被正确销毁）</li><li>控制块的创建会遵循下面几条规则：<ul><li><code>std::make_shared</code>总是创建一个控制块</li><li>当从独占指针（<code>std::unique_ptr</code>或者<code>std::auto_ptr</code>）上构造出<code>std::shared_ptr</code>时会创建控制块</li><li>当从原始指针上构造出<code>std::shared_ptr</code>时会创建控制块</li></ul></li></ul><p>禁止从同一个原始指针中构造超过一个<code>std::shared_ptr</code>，会导致多个控制块存在，为避免此类情况：</p><ul><li>使用<code>std::make_shared</code>构造</li><li>使用new出来的结果构造</li></ul><p>使用<code>std::shared_ptr</code>管理类对象时，避免传递出this指针，如果需要从对象中得到shared指针，可将类继承<code>std::enable_shared_from_this</code>，其定义了一个成员函数，成员函数会创建指向当前对象的<code>std::shared_ptr</code>却不创建多余控制块。</p><p><code>std::shared_ptr</code>不适用于处理数组，因为没提供<code>operator[]</code>，且转换为原始指针会存在安全问题。可使用vector替代。</p><blockquote><p><strong>总结</strong></p><ul><li>较之于<code>std::unique_ptr</code>，<code>std::shared_ptr</code>对象通常大两倍，控制块会产生开销，需要原子性的引用计数修改操作。</li><li>默认资源销毁是通过<code>delete</code>，但是也支持自定义删除器。删除器的类型是什么对于<code>std::shared_ptr</code>的类型没有影响。</li><li>避免从原始指针变量上创建<code>std::shared_ptr</code>。</li></ul></blockquote><h2 id="20-当std-shared-ptr可能悬空时使用std-weak-ptr"><a href="#20-当std-shared-ptr可能悬空时使用std-weak-ptr" class="headerlink" title="20. 当std::shared_ptr可能悬空时使用std::weak_ptr"></a>20. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/4.SmartPointers/item20.md">当std::shared_ptr可能悬空时使用std::weak_ptr</a></h2><p><code>std::weak_ptr</code>是一种类似<code>std::shared_ptr</code>但不影响对象引用计数的指针，通常从<code>std::shared_ptr</code>上创建（不会影响所指对象的引用计数），其主要用于解决shared指针可能指向已经销毁的对象问题。</p><p>使用expired函数+解引用组合会存在竟态问题，但可以通过从<code>std::weak_ptr</code>上创建<code>std::shared_ptr</code>指针是否成功来判断所指对象是否已过期，有两种方法：</p><ol><li><p>使用lock函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw1 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//如果wpw过期，spw1就为空</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>以<code>std::weak_ptr</code>为实参构造<code>std::shared_ptr</code>，这种情况中，如果<code>std::weak_ptr</code>过期，会抛出一个异常：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw3</span><span class="token punctuation">(</span>wpw<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//如果wpw过期，抛出std::bad_weak_ptr异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p><code>std::weak_ptr</code>可以解决指针循环持有问题，假如有三个对象<code>A</code>、<code>B</code>、<code>C</code>，每个对象中都有一个指针指向资源，<code>A</code>和<code>C</code>指针指向<code>B</code>，因此持有<code>std::shared_ptr</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230208212020138.png"></p><p>假定从B指向A的指针也很有用。应该使用哪种指针，有三种选择：</p><ul><li><strong>原始指针</strong>。如果<code>A</code>被销毁，但是<code>C</code>继续指向<code>B</code>，<code>B</code>就会有一个指向<code>A</code>的悬空指针。而且<code>B</code>不知道指针已经悬空，所以<code>B</code>可能会继续访问，就会导致未定义行为。</li><li>**<code>std::shared_ptr</code>**。<code>A</code>和<code>B</code>都互相持有对方的<code>std::shared_ptr</code>，导致的<code>std::shared_ptr</code>环状结构（<code>A</code>指向<code>B</code>，<code>B</code>指向<code>A</code>）阻止<code>A</code>和<code>B</code>的销毁。甚至<code>A</code>和<code>B</code>无法从其他数据结构访问了（比如，<code>C</code>不再指向<code>B</code>），每个的引用计数都还是1。这种情况会导致<code>A</code>和<code>B</code>都被泄漏。</li><li>**<code>std::weak_ptr</code>**。避免了上述两个问题。如果<code>A</code>被销毁，<code>B</code>指向它的指针悬空，但是<code>B</code>可以检测到这件事。尽管<code>A</code>和<code>B</code>互相指向对方，<code>B</code>的指针不会影响<code>A</code>的引用计数，因此在没有<code>std::shared_ptr</code>指向<code>A</code>时不会导致<code>A</code>无法被销毁。</li></ul><p>在严格分层的数据结构比如树中，子节点只被父节点持有。当父节点被销毁时，子节点就被销毁。从父到子的链接关系可以使用<code>std::unique_ptr</code>很好的表征。从子到父的反向连接可以使用原始指针安全实现，因为子节点的生命周期肯定短于父节点</p><p><code>std::weak_ptr</code>与<code>std::shared_ptr</code>的大小是相同的，使用相同的控制块，构造、析构、赋值操作涉及引用计数的原子操作。</p><blockquote><p><strong>总结</strong></p><ul><li>用<code>std::weak_ptr</code>替代可能会悬空的<code>std::shared_ptr</code>。</li><li><code>std::weak_ptr</code>的潜在使用场景包括：缓存、观察者列表、打破<code>std::shared_ptr</code>环状结构。</li></ul></blockquote><h2 id="21-优先考虑使用std-make-unique和std-make-shared，而非直接使用new"><a href="#21-优先考虑使用std-make-unique和std-make-shared，而非直接使用new" class="headerlink" title="21. 优先考虑使用std::make_unique和std::make_shared，而非直接使用new"></a>21. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/4.SmartPointers/item21.md">优先考虑使用std::make_unique和std::make_shared，而非直接使用new</a></h2><p><code>std::make_shared</code>是C++11标准的一部分，但很可惜的是，<code>std::make_unique</code>不是。它从C++14开始加入标准库，自己实现如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_unique</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Ts<span class="token operator">></span></span></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为何使用<code>make</code>函数更好的原因：</p><ul><li>无需重复写两次类型，避免重复代码</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">upw1</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//使用make函数 还能如此初始化？</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">upw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//不使用make函数</span><span class="token keyword">auto</span> <span class="token function">spw1</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//使用make函数</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//不使用make函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>避免函数调用时发生异常导致资源泄露</p><ul><li><p>假设调用一个函数如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">//潜在的资源泄漏！</span>              <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在函数调用前，会有“<code>new Widget</code>”、<code>std::shared_ptr&lt;Widget&gt;</code>构造、<code>computePriority</code>三个步骤需要执行，但是编译器执行顺序不一定，如果先执行“<code>new Widget</code>”，然后执行<code>computePriority</code>时发生异常则会导致shared指针不会构造，从而造成资源泄露</p></li></ul></li><li><p><code>std::make_shared</code>效率更高，使用原始下面代码时，会申请两次内存：new申请一次+控制块再申请一次。而使用<code>make_shared</code>只会进行一次内存分配。</p></li></ul><p><code>make</code>函数限制：</p><ul><li>不允许指定自定义删除器，而有些指针构造需要自定义删除器</li><li>在<code>make</code>函数初始化时，完美转发使用小括号，而不是花括号。如果想用花括号初始化指向的对象，你必须直接使用<code>new</code>。</li><li><code>shared_ptr</code>独有的限制（上述两个限制是<code>unique_ptr</code>使用make的限制）：<ul><li>重载了new和delete运算符的类不适合使用make函数，因为重载了new和delete的类只会精确的分配或释放对象大小，而控制块内存也需要申请和释放。</li><li>因为控制块和对象被放在同一块分配的内存块中，直到控制块的内存也被销毁，对象占用的内存才被释放。而控制块中不仅包括引用计数，还包括次引用计数(weak count)，只要存在weak_ptr引用控制块，则对象内存就不会被释放。</li></ul></li></ul><blockquote><p><strong>总结</strong></p><ul><li>和直接使用<code>new</code>相比，<code>make</code>函数消除了代码重复，提高了异常安全性。对于<code>std::make_shared</code>和<code>std::allocate_shared</code>，生成的代码更小更快。</li><li>不适合使用<code>make</code>函数的情况包括需要指定自定义删除器和希望用花括号初始化。</li><li>对于<code>std::shared_ptr</code>s，其他不建议使用<code>make</code>函数的情况包括(1)有自定义内存管理的类；(2)特别关注内存的系统，非常大的对象，以及<code>std::weak_ptr</code>s比对应的<code>std::shared_ptr</code>s活得更久。</li></ul></blockquote><h2 id="22-当使用Pimpl惯用法，请在实现文件中定义特殊成员函数"><a href="#22-当使用Pimpl惯用法，请在实现文件中定义特殊成员函数" class="headerlink" title="22. 当使用Pimpl惯用法，请在实现文件中定义特殊成员函数"></a>22. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/4.SmartPointers/item22.md">当使用Pimpl惯用法，请在实现文件中定义特殊成员函数</a></h2><p><strong>Pimpl</strong>（<em>pointer to implementation</em>）：将类数据成员替换成一个指向包含具体实现的类（或结构体）的指针，并将放在主类（primary class）的数据成员们移动到实现类（implementation class）去，而这些数据成员的访问将通过指针间接访问</p><p>假设有一个类使用Pimpl惯用法，但<strong>使用的是一个unique_ptr指针</strong>，类定义和类实现如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>                      <span class="token comment">//在“widget.h”中</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> <span class="token class-name">Impl</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span>    <span class="token comment">//使用智能指针而不是原始指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//实现文件cpp</span><span class="token keyword">struct</span> <span class="token class-name">Widget</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">Impl</span></span> <span class="token punctuation">&#123;</span>               <span class="token comment">//跟之前一样</span>    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span>    Gadget g1<span class="token punctuation">,</span>g2<span class="token punctuation">,</span>g3<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment">//根据条款21，通过std::make_unique</span><span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Impl<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">//来创建std::unique_ptr</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上的代码能编译，但是最普通的<code>Widget</code>用法却会导致编译出错：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span>                           <span class="token comment">//错误！</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是因为对象<code>w</code>被析构时，编译器会自动生成一个析构函数，在这个析构函数里，编译器会插入一些代码来调用类<code>Widget</code>的数据成员<code>pImpl</code>的析构函数。<code>pImpl</code>的默认删除器会使用<code>delete</code>来销毁内置于<code>std::unique_ptr</code>的原始指针，然而在使用<code>delete</code>之前通常会使用<code>static_assert</code>来确保原始指针指向的类型不是一个未完成类型。</p><ul><li>解决此问题关键在于让编译器在看到析构函数前先看到Impl定义即可，只需要在头文件中先声明析构函数，在实现文件中先定义Impl然后定义析构即可（可使用default)。</li><li>使用编译器默认生成的移动操作同样会出现上述问题：<ul><li>移动赋值操作符，在重新赋值之前，需要先销毁指针<code>pImpl</code>指向的对象； </li><li>移动构造函数的问题是编译器自动生成的代码里，包含有抛出异常的事件，在这个事件里会生成销毁<code>pImpl</code>的代码。</li><li>然而，销毁<code>pImpl</code>需要<code>Impl</code>是一个完成类型。</li><li>解决方法仍一样，先声明后定义，只是不能使用default来定义函数，需要自己定义。因为：<ul><li>对包含有只可移动（<em>move-only</em>）类型，如<code>std::unique_ptr</code>的类，编译器不会生成复制操作</li><li>即使编译器帮我们生成了，生成的复制操作也只会复制<code>std::unique_ptr</code>（浅拷贝），而实际上我们需要复制指针所指向的对象（深拷贝）。</li></ul></li></ul></li></ul><p><strong>注意，声明shared指针不存在上述问题</strong>，因为 对<code>std::unique_ptr</code>而言，删除器的类型是这个智能指针的一部分，而对<code>std::shared_ptr</code>而言，删除器的类型不是该智能指针的一部分。</p><blockquote><p><strong>总结</strong></p><ul><li>Pimpl惯用法通过减少在类实现和类使用者之间的编译依赖来减少编译时间。</li><li>对于<code>std::unique_ptr</code>类型的<code>pImpl</code>指针，需要在头文件的类里声明特殊的成员函数，然后在实现文件里先实现Impl定义然后实现他们。即使是编译器自动生成的代码可以工作，也要这么做。</li><li>以上的建议只适用于<code>std::unique_ptr</code>，不适用于<code>std::shared_ptr</code>。</li></ul></blockquote><h1 id="CHAPTER5-RValue-References-Move-Semantics-and-Perfect-Forwarding"><a href="#CHAPTER5-RValue-References-Move-Semantics-and-Perfect-Forwarding" class="headerlink" title="CHAPTER5 RValue References, Move Semantics and Perfect Forwarding"></a>CHAPTER5 RValue References, Move Semantics and Perfect Forwarding</h1><ul><li><strong>移动语义</strong>使编译器有可能用廉价的移动操作来代替昂贵的拷贝操作。</li><li><strong>完美转发</strong>使接收任意数量实参的函数模板成为可能，它可以将实参转发到其他的函数，使目标函数接收到的实参与被传递给转发函数的实参保持一致。</li><li><strong>右值引用</strong>是连接这两个截然不同的概念的胶合剂。它是使移动语义和完美转发变得可能的基础语言机制。</li></ul><h2 id="23-理解std-move和std-forward"><a href="#23-理解std-move和std-forward" class="headerlink" title="23. 理解std::move和std::forward"></a>23. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item23.md">理解std::move和std::forward</a></h2><p><code>std::move</code>不移动（move）任何东西，<code>std::forward</code>也不转发（forward）任何东西。在运行时，它们不做任何事情，不产生任何可执行代码。</p><p><code>std::move</code>和<code>std::forward</code>仅仅是执行转换（cast）的函数（事实上是函数模板）。<code>std::move</code>无条件的将它的实参转换为右值，而<code>std::forward</code>只在特定情况满足时下进行转换。</p><p><code>std::move</code>的实现只是做了一个类型转换，注意返回类型是先去除引用再添加右值引用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                            <span class="token comment">//在std命名空间</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span><span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">using</span> ReturnType <span class="token operator">=</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>                             <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>ReturnType<span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>std::move</code>注意</strong></p><ul><li>不要将希望能移动的对象声明为<code>const</code>。对<code>const</code>对象的移动请求会悄无声息的被转化为拷贝操作</li><li><code>std::move</code>不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动，能确保的是得到一个右值</li></ul><p><code>std::forward</code>和<code>std::move</code>很相似，不同之处在于<code>std::move</code>总是<strong>无条件</strong>的将它的实参为右值不同，<code>std::forward</code>只对绑定了右值的引用进行到右值转换</p><blockquote><p><strong>总结</strong></p><ul><li><code>std::move</code>执行右值的无条件的转换，但它不移动任何东西。</li><li><code>std::forward</code>只有当它的参数被绑定到一个右值时，才将参数转换为右值。</li><li><code>std::move</code>和<code>std::forward</code>在运行期什么也不做，编译期就已经完成了转换。</li></ul></blockquote><h2 id="24-区别通用引用和右值引用"><a href="#24-区别通用引用和右值引用" class="headerlink" title="24. 区别通用引用和右值引用"></a>24. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item24.md">区别通用引用和右值引用</a></h2><p>“<code>T&amp;&amp;</code>”有两种不同的意思：</p><ul><li>右值引用，只绑定到右值上。</li><li>通用引用，可以绑定到几乎任何东西。</li></ul><p>观察是否存在类型推导来区分是否为通用引用，一般有以下两种通用引用类型：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">//param是一个通用引用</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> var2 <span class="token operator">=</span> var1<span class="token punctuation">;</span>                 <span class="token comment">//var2是一个通用引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li><p>通用引用的格式必须为“<code>T&amp;&amp;</code>”（T可以是其他名字），无论是加const还是其他格式皆非通用引用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//param是一个右值引用！！</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//param是一个右值引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>模板内的函数即使有“<code>T&amp;&amp;</code>”形参，但也不一定是通用引用，因为其类型可能在模板推导时就被推导出来了，只有在函数调用时进行推导的“<code>T&amp;&amp;</code>”形参才是通用引用</p></li></ul><blockquote><p><strong>总结</strong></p><ul><li>如果一个函数模板形参的类型为<code>T&amp;&amp;</code>，并且<code>T</code>需要被推导得知，或者如果一个对象被声明为<code>auto&amp;&amp;</code>，这个形参或者对象就是一个通用引用。</li><li>如果类型声明的形式不是标准的<code>type&amp;&amp;</code>，或者如果类型推导没有发生，那么<code>type&amp;&amp;</code>代表一个右值引用。</li><li>通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用。</li></ul></blockquote><h2 id="25-对于右值引用使用std-move，对于通用引用使用std-forward"><a href="#25-对于右值引用使用std-move，对于通用引用使用std-forward" class="headerlink" title="25. 对于右值引用使用std::move，对于通用引用使用std::forward"></a>25. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item25.md">对于右值引用使用std::move，对于通用引用使用std::forward</a></h2><p>如果函数的形参是右值引用，当把右值引用转发给其他函数时，右值引用应该被<strong>无条件转换</strong>为右值（通过<code>std::move</code>），因为它们<strong>总是</strong>绑定到右值</p><p>如果函数的形参是通用引用，当转发通用引用时，通用引用应该<strong>有条件地转换</strong>为右值（通过<code>std::forward</code>），因为它们只是<strong>有时</strong>绑定到右值。</p><ul><li>如果此时转发使用move，则调用函数可能导致实参变成未定义。如果将模板函数改为重载两个函数，虽然能运行，但效率很低，且当参数变多时，需要重载的函数个数呈指数级上升。</li></ul><p>如果在<strong>按值</strong>返回的函数中，返回值绑定到右值引用或者通用引用上（必须这条件，否则RVO优化效率更高），需要对返回的引用使用<code>std::move</code>或者<code>std::forward</code>。</p><p>RVO（<em>return value optimization</em>）优化条件：</p><ul><li>局部对象与函数返回值的类型相同</li><li>局部对象就是要返回的东西</li><li>当函数不同控制路径返回不同局部变量时，不进行RVO优化，很难让编译器实现RVO</li></ul><blockquote><p><strong>总结</strong></p><ul><li>最后一次使用形参时，在右值引用上使用<code>std::move</code>，在通用引用上使用<code>std::forward</code>。</li><li>对按值返回的函数要返回的右值引用和通用引用，执行相同的操作。</li><li>如果局部对象可以被返回值优化消除，就绝不使用<code>std::move</code>或者<code>std::forward</code>。</li></ul></blockquote><h2 id="26-避免重载通用引用"><a href="#26-避免重载通用引用" class="headerlink" title="26. 避免重载通用引用"></a>26. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item26.md">避免重载通用引用</a></h2><p>把重载和通用引用组合在一块是糟糕主意的原因：</p><ul><li><p>使用通用引用的函数在C++中是最贪婪的函数，它们几乎可以精确匹配任何类型的实参</p></li><li><p>通用引用的实现会匹配比开发者预期要多得多的实参类型，而精确匹配优先于类型提升的匹配，所以被调用的是通用引用的重载。</p></li></ul><p>重载规则规定当模板实例化函数和非模板函数（或者称为“正常”函数）匹配优先级相当时，优先使用“正常”函数</p><p>注意：</p><ul><li>使用通用引用的模板构造函数可能会导致拷贝构造函数等即使被声明也不会调用，因为模板构造函数会生成更匹配的构造函数。</li><li>当继承纳入考虑范围时，使用通用引用的模板构造函数与编译器生成的拷贝、移动操作之间的交互会更加复杂</li></ul><blockquote><p><strong>总结</strong></p><ul><li>对通用引用形参的函数进行重载，通用引用函数的调用机会几乎总会比你期望的多得多。</li><li>完美转发构造函数是糟糕的实现，因为对于non-<code>const</code>左值，它们比拷贝构造函数而更匹配，而且会劫持派生类对于基类的拷贝和移动构造函数的调用。</li></ul></blockquote><h2 id="27-熟悉重载通用引用的替代品"><a href="#27-熟悉重载通用引用的替代品" class="headerlink" title="27. 熟悉重载通用引用的替代品"></a>27. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item27.md">熟悉重载通用引用的替代品</a></h2><p>通用引用重载的替代方法：</p><ul><li><strong>放弃重载</strong>。通过更改函数名来放弃重载，但这种方法不能用在构造函数上。</li><li>**传递const T&amp;**。将传递通用引用替换为传递lvalue-refrence-to-<code>const</code>，缺点是效率不高。</li><li><strong>传值</strong>。将按传引用形参替换为按值传递，即在你知道要拷贝时就按值传递，这是违反直觉的。</li><li><strong>使用tag dispatch</strong>。通用引用通常提供了最优匹配，但是如果形参列表中除了通用引用还包含其他<strong>非</strong>通用引用形参，则非通用引用形参的较差匹配会使有一个通用引用的重载版本不被运行（其实将相当于在形参中增加一个标签）。</li><li><strong>约束使用通用引用的模板</strong>。使用<code>std::enable_if</code>可以使得仅在<code>std::enable_if</code>指定的条件满足时模板才启用。</li></ul><blockquote><p><strong>总结</strong></p><ul><li>通用引用和重载的组合替代方案包括使用不同的函数名，通过lvalue-reference-to-<code>const</code>传递形参，按值传递形参，使用<em>tag dispatch</em>。</li><li>通过<code>std::enable_if</code>约束模板，允许组合通用引用和重载使用，但它也控制了编译器在哪种条件下才使用通用引用重载。</li><li>通用引用参数通常具有高效率的优势，但是可用性就值得斟酌。</li></ul></blockquote><h2 id="28-理解引用折叠"><a href="#28-理解引用折叠" class="headerlink" title="28. 理解引用折叠"></a>28. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item28.md">理解引用折叠</a></h2><p><strong>引用折叠</strong></p><ul><li>如果一个上下文中允许引用的引用存在（比如，模板的实例化），引用根据规则<strong>折叠</strong>为单个引用</li><li><strong>如果任一引用为左值引用，则结果为左值引用。否则（即，如果引用都是右值引用），结果为右值引用</strong>。</li></ul><p>std::forward实现也利用了引用折叠原理：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                                <span class="token comment">//在std命名空间</span>T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>有四种情况会发生引用折叠：</p><ul><li>模板实例化</li><li><code>auto</code>的类型生成</li><li><code>typedef</code>和别名声明的产生和使用中</li><li><code>decltype</code>推导时</li></ul><p>通用引用不是一种新的引用，它实际上是满足以下两个条件下的右值引用：</p><ul><li><strong>类型推导区分左值和右值</strong>。<code>T</code>类型的左值被推导为<code>T&amp;</code>类型，<code>T</code>类型的右值被推导为<code>T</code>。</li><li><strong>发生引用折叠</strong>。</li></ul><blockquote><p><strong>总结</strong></p><ul><li>引用折叠发生在四种情况下：模板实例化，<code>auto</code>类型推导，<code>typedef</code>与别名声明的创建和使用，<code>decltype</code>。</li><li>当编译器在引用折叠环境中生成了引用的引用时，结果就是单个引用。有左值引用折叠结果就是左值引用，否则就是右值引用。</li><li>通用引用就是在特定上下文的右值引用，上下文是通过类型推导区分左值还是右值，并且发生引用折叠的那些地方。</li></ul></blockquote><h2 id="29-认识移动操作的缺点"><a href="#29-认识移动操作的缺点" class="headerlink" title="29. 认识移动操作的缺点"></a>29. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item29.md">认识移动操作的缺点</a></h2><p>存储具体数据在堆内存的容器使用移动操作会更快，如vector。使用array的移动操作时，需要存储的类移动比复制更快，才会使得array的移动比复制快。</p><p><code>std::string</code>提供了常数时间的移动操作和线性时间的复制操作，但移动不一定比复制快。许多字符串的实现采用了小字符串优化（<em>small string optimization</em>，SSO）。“小”字符串（比如长度小于15个字符的）存储在了<code>std::string</code>的缓冲区中，并没有存储在堆内存，移动这种存储的字符串并不必复制操作更快。</p><blockquote><p>SSO的动机是大量证据表明，短字符串是大量应用使用的习惯。使用内存缓冲区存储而不分配堆内存空间，是为了更好的效率。然而这种内存管理的效率导致移动的效率并不必复制操作高。</p></blockquote><p>标准库中的某些容器操作提供了强大的异常安全保证（item14），导致即使类提供了更具效率的移动操作，而且即使移动操作更合适（比如源对象是右值），编译器仍可能被迫使用复制操作，因为移动操作没有声明<code>noexcept</code>。</p><p>以下几种情况，C++11的移动语义并无优势：</p><ul><li><strong>没有移动操作</strong>：要移动的对象没有提供移动操作，所以移动的写法也会变成复制操作。</li><li><strong>移动不会更快</strong>：要移动的对象提供的移动操作并不比复制速度更快。</li><li><strong>移动不可用</strong>：进行移动的上下文要求移动操作不会抛出异常，但是该操作没有被声明为<code>noexcept</code>。</li><li><strong>源对象是左值</strong>：除了极少数的情况外（如<a href="https://kgithub.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item25.md">Item25</a>），只有右值可以作为移动操作的来源。</li></ul><blockquote><p><strong>总结</strong></p><ul><li>假定移动操作不存在，成本高，未被使用。</li><li>在已知的类型或者支持移动语义的代码中，就不需要上面的假设。</li></ul></blockquote><h2 id="30-熟悉完美转发失败的情况"><a href="#30-熟悉完美转发失败的情况" class="headerlink" title="30. 熟悉完美转发失败的情况"></a>30. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item30.md">熟悉完美转发失败的情况</a></h2><p><strong>完美转发</strong>意味着不仅转发对象，还转发特征：它们的类型，是左值还是右值，是<code>const</code>还是<code>volatile</code>。</p><p>当下面情况任何一个发生时，完美转发就会失败：</p><ul><li>编译器不能推导出完美转发模板的一个或者多个形参类型</li><li>编译器推导“错”了完美转发模板的一个或者多个形参类型，这里的错是指推导出的类型无法编译或推导出的类型与直接调用函数表现出不一样的行为</li></ul><p><strong>完美转发失败情形</strong>：</p><ul><li>花括号初始化器：其会被推导为<code>std::initializer_list</code>对象</li><li>0或者NULL作为空指针：会被推导为int型而不是指针类型</li><li>仅有声明的整型static const数据成员：因为编译器会直接用值替换其变量所在的地方，而不会存储在内存空间中，当取地址或推导类型时就会出错</li><li>重载函数的名称和模板名称：当函数被重载后，如果传递函数给完美转发模板则无法类型推导（因为不知道用哪个函数进行推导）。同理，函数模板作为传递参数时也无法被推导。</li><li>位域：完美转发模板形参是引用，而位域通常是non-<code>const</code>，C++中non-<code>const</code>引用不应该绑定到位域，因为位域可能指向int的3-5位，而C++最小指向单位是char（没有函数可以绑定引用到位域，也没有函数可以接受指向位域的指针，因此只能值传递）</li></ul><blockquote><p><strong>总结</strong></p><ul><li>当模板类型推导失败或者推导出错误类型，完美转发会失败。</li><li>导致完美转发失败的实参种类有花括号初始化，作为空指针的<code>0</code>或者<code>NULL</code>，仅有声明的整型<code>static const</code>数据成员，模板和重载函数的名字，位域。</li></ul></blockquote><h1 id="CHAPTER6-Lambda-Expressions"><a href="#CHAPTER6-Lambda-Expressions" class="headerlink" title="CHAPTER6 Lambda Expressions"></a><strong>CHAPTER6 Lambda Expressions</strong></h1><p><em>lambda</em>通常被用来创建闭包，该闭包仅用作函数的实参。闭包通常可以拷贝，所以可能有多个闭包对应于一个<em>lambda</em>。</p><p><strong>闭包</strong>（<em>enclosure</em>）是<em>lambda</em>创建的运行时对象。依赖捕获模式，闭包持有被捕获数据的副本或者引用。</p><p><strong>闭包类</strong>（<em>closure class</em>）是从中实例化闭包的类。每个<em>lambda</em>都会使编译器生成唯一的闭包类。<em>lambda</em>中的语句成为其闭包类的成员函数中的可执行指令。</p><h2 id="31-避免使用默认捕获模式"><a href="#31-避免使用默认捕获模式" class="headerlink" title="31. 避免使用默认捕获模式"></a>31. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/6.LambdaExpressions/item31.md">避免使用默认捕获模式</a></h2><p>C++11中有两种默认的捕获模式：</p><ul><li>按引用捕获：默认按引用捕获模式可能会带来悬空引用的问题<ul><li>显式列出<em>lambda</em>依赖的局部变量和形参，是更加符合软件工程规范的做法</li></ul></li><li>按值捕获：默认按值捕获模式可能会诱骗你让你以为能解决悬空引用的问题（实际上并没有），还会让你以为你的闭包是独立的（事实上也不是独立的）。<ul><li>如果按值捕获的是一个指针（如this指针），该指针拷贝到<em>lambda</em>对应的闭包里，并不能避免指针悬空问题</li><li>捕获只能应用于<em>lambda</em>被创建时所在作用域里的non-<code>static</code>局部变量（包括形参），不能捕获类的成员变量，因为真正捕获的是this，然后使用的this访问成员变量</li><li>一些静态成员在lambda中也能被使用，但其并未被捕获</li></ul></li></ul><blockquote><p><strong>总结</strong></p><ul><li>默认的按引用捕获可能会导致悬空引用。</li><li>默认的按值捕获对于悬空指针很敏感（尤其是<code>this</code>指针），并且它会误导人产生<em>lambda</em>是独立的想法。</li></ul></blockquote><h2 id="32-使用初始化捕获来移动对象到闭包中"><a href="#32-使用初始化捕获来移动对象到闭包中" class="headerlink" title="32. 使用初始化捕获来移动对象到闭包中"></a>32. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/6.LambdaExpressions/item32.md">使用初始化捕获来移动对象到闭包中</a></h2><p>C++11只能将对象复制到闭包中而不能移动到lambda闭包中，初始化捕获是C++14提供的一种新捕获机制，可以让你指定：</p><ol><li>从lambda生成的闭包类中的<strong>数据成员名称</strong>；</li><li>初始化该成员的<strong>表达式</strong>；</li></ol><p>初始化捕获示例如下，“<code>=</code>”的左侧是指定的闭包类中数据成员的名称，右侧则是初始化表达式。“<code>=</code>”左侧的作用域不同于右侧的作用域，“<code>=</code>”左侧的名称<code>pw</code>表示闭包类中的数据成员，而右侧的名称<code>pw</code>表示在<em>lambda</em>上方声明的对象</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment">//使用std::move(pw)初始化闭包数据成员</span>            <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> pw<span class="token operator">-></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span> pw<span class="token operator">-></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>移动捕获可以在C++11中这样模拟：</p><ol><li>将要捕获的对象移动到由<code>std::bind</code>产生的函数对象中；</li><li>将“被捕获的”对象的引用赋予给lambda。</li></ol><p>由于bind对象的生命周期与闭包对象的生命周期相同，因此可以将bind对象中的对象视为闭包中的对象。</p><p>模拟示例代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span>    std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>                              <span class="token comment">//C++11模拟初始化捕获</span>        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span> <span class="token comment">/*使用data*/</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>                         <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="33-对auto-amp-amp-形参使用decltype以std-forward它们"><a href="#33-对auto-amp-amp-形参使用decltype以std-forward它们" class="headerlink" title="33. 对auto&amp;&amp;形参使用decltype以std::forward它们"></a>33. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/6.LambdaExpressions/item33.md">对<code>auto&amp;&amp;</code>形参使用<code>decltype</code>以<code>std::forward</code>它们</a></h2><p><strong>泛型lambda</strong>的实现很简洁，即在闭包类中的<code>operator()</code>函数是一个函数模版</p><p>如果需要进行完美转发，则需要将lambda表达式形参定义为auto&amp;&amp;，但是这会导致std::forward的模板类型无法填写。解决方法是使用<code>decltype(x)</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="34-优先考虑lambda表达式而非std-bind"><a href="#34-优先考虑lambda表达式而非std-bind" class="headerlink" title="34. 优先考虑lambda表达式而非std::bind"></a>34. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/6.LambdaExpressions/item34.md">优先考虑lambda表达式而非std::bind</a></h2><p>优先<em>lambda</em>而不是<code>std::bind</code>的最重要原因是<em>lambda</em>更易读</p><p>使用std::bind时，如果传递给绑定函数的实参是一个函数，则此函数会在bind定义时就被计算，而非在绑定函数调用时计算。</p><ul><li>一个解决方法是将实参函数也使用bind函数绑定。</li><li>但是此方法面对函数重载时会编译失败，除非将函数名静态转换为函数指针，但编译器通常不会对函数指针进行内联。因此，使用<em>lambda</em>可能会比使用<code>std::bind</code>能生成更快的代码。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> setSoundB <span class="token operator">=</span>                            <span class="token comment">//“B”代表“bind”</span>    std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">,</span> steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>h<span class="token punctuation">,</span>     <span class="token comment">//不正确！见下</span>              _1<span class="token punctuation">,</span><span class="token number">30</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解决方法</span><span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">,</span>              std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">plus</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>steady_clock<span class="token double-colon punctuation">::</span>now<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span>              _1<span class="token punctuation">,</span><span class="token number">30</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::bind总是拷贝它的实参，但是可以使用引用来存储实参，这要通过应用<code>std::ref</code>到实参上实现。<code>auto compressRateB = std::bind(compress, std::ref(w), _1)</code>;</p><p>在C++14中，没有<code>std::bind</code>的合理用例。 但在C++11中，两个受约束的情况下证明使用<code>std::bind</code>是合理的：</p><ul><li><strong>移动捕获</strong>。C++11的<em>lambda</em>不提供移动捕获，但是可以通过结合<em>lambda</em>和<code>std::bind</code>来模拟。 </li><li><strong>多态函数对象</strong>。因为bind对象上的函数调用运算符使用完美转发，所以它可以接受任何类型的实参。当你要绑定带有模板化函数调用运算符的对象时，此功能很有用。</li></ul><blockquote><p><strong>总结</strong></p><ul><li>与使用<code>std::bind</code>相比，<em>lambda</em>更易读，更具表达力并且可能更高效。</li><li>只有在C++11中，<code>std::bind</code>可能对实现移动捕获或绑定带有模板化函数调用运算符的对象时会很有用。</li></ul></blockquote><h1 id="CHAPTER7-The-Concurrency-API"><a href="#CHAPTER7-The-Concurrency-API" class="headerlink" title="CHAPTER7 The Concurrency API"></a><strong>CHAPTER7 The Concurrency API</strong></h1><h2 id="35-优先考虑基于任务的编程而非基于线程的编程"><a href="#35-优先考虑基于任务的编程而非基于线程的编程" class="headerlink" title="35. 优先考虑基于任务的编程而非基于线程的编程"></a>35. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/7.TheConcurrencyAPI/Item35.md">优先考虑基于任务的编程而非基于线程的编程</a></h2><p>异步执行<code>doAsyncWork</code>函数，通常有两种方式：</p><ul><li><p>创建<code>std::thread</code>执行<code>doAsyncWork</code>，这是应用了<strong>基于线程</strong>（<em>thread-based</em>）的方式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>将<code>doAsyncWork</code>传递给<code>std::async</code>，一种<strong>基于任务</strong>（<em>task-based</em>）的策略（传递给<code>std::async</code>的函数对象被称为一个<strong>任务</strong>）：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//“fut”表示“future”</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>基于任务的方法通常比基于线程的方法更优，原因：</p><ul><li><code>std::async</code>返回的<em>future</em>提供了<code>get</code>函数（从而可以获取返回值）</li><li>如果<code>doAsycnWork</code>发生了异常，<code>get</code>函数就显得更为重要，因为<code>get</code>函数可以提供抛出异常的访问，而基于线程的方法，如果<code>doAsyncWork</code>抛出了异常，程序会直接终止</li><li>软件线程是有限的资源。如果开发者试图创建大于系统支持的线程数量，会抛出<code>std::system_error</code>异常。避免此异常的方法就是使用<code>std::async</code></li><li>当遇见资源超频（准备运行的软件线程大于硬件线程的数量的情况）时，由于std::async能自动决定是开启一个新线程还是将其插入等待运行结果的线程上，因此能有效减少线程切换消耗</li></ul><blockquote><p>基于线程与基于任务最根本的区别在于，基于任务的抽象层次更高。基于任务的方式使得开发者从线程管理的细节中解放出来，“<em>thread</em>”的三种含义：</p><ul><li><strong>硬件线程</strong>（hardware threads）是真实执行计算的线程。每个CPU核心提供一个或者多个硬件线程。</li><li><strong>软件线程</strong>（software threads）（也被称为系统线程）是操作系统管理的在硬件线程上执行的线程。通常存在比硬件线程更多数量的软件线程，因为当软件线程被阻塞的时候可以调度其他未阻塞的软件线程执行。</li><li><strong><code>std::thread</code></strong> 是C++执行过程的对象，并作为软件线程的句柄。有些<code>std::thread</code>对象代表“空”句柄，即没有对应软件线程，因为它们处在默认构造状态（即没有函数要执行）；有些被移动走（移动到的<code>std::thread</code>就作为这个软件线程的句柄）；有些被<code>join</code>（它们要运行的函数已经运行完）；有些被<code>detach</code>（它们和对应的软件线程之间的连接关系被打断）。</li></ul></blockquote><p>使用<code>std::thread</code>有优势的场景：</p><ul><li>需要访问非常基础的线程API为了提供对底层系统级线程API的访问，<code>std::thread</code>对象提供了<code>native_handle</code>的成员函数，而<code>std::future</code>（即<code>std::async</code>返回的东西）没有这种能力。</li><li>你需要且能够优化应用的线程使用。例如要开发一款已知执行概况的服务器软件，部署在有固定硬件特性的机器上，作为唯一的关键进程。</li><li>你需要实现C++并发API之外的线程技术，比如，C++实现中未支持的平台的线程池。</li></ul><blockquote><p><strong>总结</strong></p><ul><li><code>std::thread</code> API不能直接访问异步执行的结果，如果执行函数有异常抛出，代码会终止执行。</li><li>基于线程的编程方式需要手动的线程耗尽、资源超额、负责均衡、平台适配性管理。</li><li>通过带有默认启动策略的<code>std::async</code>进行基于任务的编程方式会解决大部分问题。</li></ul></blockquote><h2 id="36-如果有异步的必要请指定std-launch-async"><a href="#36-如果有异步的必要请指定std-launch-async" class="headerlink" title="36. 如果有异步的必要请指定std::launch::async"></a>36. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/7.TheConcurrencyAPI/item36.md">如果有异步的必要请指定std::launch::async</a></h2><p><code>std::async</code>有两种启动策略：</p><ul><li><code>std::launch::async</code>启动策略意味着<code>f</code>必须异步执行，即在不同的线程。</li><li><strong><code>std::launch::deferred</code>启动策略</strong>意味着<code>f</code>仅当在<code>std::async</code>返回的<em>future</em>上调用<code>get</code>或者<code>wait</code>时才执行，且调用方会被阻塞，直到被调用函数运行结束。</li></ul><p><code>std::async</code>默认启动策略是两个策略求或得到，因此默认策略允许<code>f</code>异步或者同步执行，也就导致无法预测函数f是否会并发执行，也无法预测函数f是否会执行（可能不被调用）。</p><ul><li>默认启动策略的调度灵活性导致使用<code>thread_local</code>变量比较麻烦，因为无法确认线程局部变量是新创建线程的还是调用方所在线程的</li><li>会影响到基于<code>wait</code>的循环使用超时机制，因为在一个延时的任务上调用<code>wait_for</code>或者<code>wait_until</code>会产生<code>std::launch::deferred</code>值</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async <span class="token operator">|</span>     <span class="token comment">//使用async或者deferred运行f</span>                       std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>deferred<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>只要满足以下条件，<code>std::async</code>的默认启动策略就可以使用：</p><ul><li>任务不需要和执行<code>get</code>或<code>wait</code>的线程并行执行。</li><li>读写哪个线程的<code>thread_local</code>变量没什么问题。</li><li>可以保证会在<code>std::async</code>返回的<em>future</em>上调用<code>get</code>或<code>wait</code>，或者该任务可能永远不会执行也可以接受。</li><li>使用<code>wait_for</code>或<code>wait_until</code>编码时考虑到了延迟状态。</li></ul><blockquote><p><strong>总结</strong></p><ul><li><code>std::async</code>的默认启动策略是异步和同步执行兼有的。</li><li>这个灵活性导致访问<code>thread_local</code>s的不确定性，隐含了任务可能不会被执行的意思，会影响调用基于超时的<code>wait</code>的程序逻辑。</li><li>如果异步执行任务非常关键，则指定<code>std::launch::async</code>。</li></ul></blockquote><h2 id="37-使std-thread在所有路径最后都不可结合"><a href="#37-使std-thread在所有路径最后都不可结合" class="headerlink" title="37. 使std::thread在所有路径最后都不可结合"></a>37. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/7.TheConcurrencyAPI/item37.md">使<code>std::thread</code>在所有路径最后都不可结合</a></h2><p>每个<code>std::thread</code>对象处于两个状态之一：</p><ul><li><strong>可结合的</strong>（<em>joinable</em>）：正在运行或者可能要运行或运行结束的异步执行线程</li><li><strong>不可结合的</strong>（<em>unjoinable</em>）：主要包括：<ul><li>默认构造的<code>std::thread</code>。没有函数执行，因此没有对应到底层执行线程上。</li><li>已经被移动走的<code>std::thread</code>对象。移动的结果就是一个<code>std::thread</code>原来对应的执行线程现在对应于另一个<code>std::thread</code>。</li><li>已经被<code>join</code>的<code>std::thread</code> 。在<code>join</code>之后，<code>std::thread</code>不再对应于已经运行完了的执行线程。</li><li>已经被<code>detach</code>的<code>std::thread</code> 。<code>detach</code>断开了<code>std::thread</code>对象与执行线程之间的连接。</li></ul></li></ul><p><strong><code>std::thread</code>的可结合性如此重要的原因之一</strong>：当可结合的线程的析构函数被调用，程序执行会终止</p><p>为了保证<code>std::thread</code>最后是不可结合的，可使用RALL来管理，即类似智能指针。实现代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ThreadRAII</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">DtorAction</span> <span class="token punctuation">&#123;</span> join<span class="token punctuation">,</span> detach <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// enum class的信息见条款10</span>  <span class="token function">ThreadRAII</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">,</span> DtorAction a<span class="token punctuation">)</span>  <span class="token comment">// 析构函数中对t实行a动作</span>      <span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token operator">~</span><span class="token function">ThreadRAII</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 可结合性测试见下</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>action <span class="token operator">==</span> DtorAction<span class="token double-colon punctuation">::</span>join<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 见下</span> <span class="token keyword">private</span><span class="token operator">:</span>  DtorAction action<span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>thread t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>在所有路径上保证<code>thread</code>最终是不可结合的。</li><li>析构时<code>join</code>会导致难以调试的表现异常问题。</li><li>析构时<code>detach</code>会导致难以调试的未定义行为。</li><li>声明类数据成员时，最后声明<code>std::thread</code>对象（因为线程构建完成就可能开始执行）。</li></ul></blockquote><h2 id="38-关注不同线程句柄析构行为"><a href="#38-关注不同线程句柄析构行为" class="headerlink" title="38. 关注不同线程句柄析构行为"></a>38. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/7.TheConcurrencyAPI/item38.md">关注不同线程句柄析构行为</a></h2><p>可结合的<code>std::thread</code>对应于执行的系统线程。未延迟（non-deferred）任务的<em>future</em>与系统线程有相似的关系。因此，可以将<code>std::thread</code>对象和<em>future</em>对象都视作系统线程的<strong>句柄</strong>（<em>handles</em>）</p><ul><li>可结合的<code>std::thread</code>析构会终止你的程序</li><li><em>future</em>的析构表现有时就像执行了隐式<code>join</code>，有时又像是隐式执行了<code>detach</code>，有时又没有执行这两个选择。它永远不会造成程序终止<ul><li>执行结果不能存储在调用者和被调用上，因此引入了一个共享状态存储结果。共享状态通常是基于堆的对象。<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230214110431271.png"></li><li>共享状态的存在非常重要，因为<em>future</em>的析构函数取决于与<em>future</em>关联的共享状态。特别地，<ul><li>引用了共享状态——使用<code>std::async</code>启动的未延迟任务建立的那个——的最后一个future的析构函数会阻塞住，直到任务完成。本质上，这种<em>future</em>的析构函数对执行异步任务的线程执行了隐式的<code>join</code>。</li><li>其他所有*future*的析构函数简单地销毁future对象。对于异步执行的任务，就像对底层的线程执行<code>detach</code>。对于延迟任务来说如果这是最后一个<em>future</em>，意味着这个延迟任务永远不会执行了。</li></ul></li><li>正常行为是<em>future</em>析构函数销毁<em>future</em>。不<code>join</code>也不<code>detach</code>，也不运行什么，只销毁<em>future</em>的数据成员。正常行为的例外情况仅在某个<code>future</code>同时满足下列所有情况下才会出现：<ul><li>它关联到由于调用<code>std::async</code>而创建出的共享状态。</li><li>任务的启动策略是<code>std::launch::async</code>，原因是运行时系统选择了该策略，或者在对<code>std::async</code>的调用中指定了该策略。</li><li>这个future是关联共享状态的最后一个future。对于<code>std::future</code>，情况总是如此，对于<code>std::shared_future</code>，如果还有其他的<code>std::shared_future</code>，与要被销毁的<em>future</em>引用相同的共享状态，则要被销毁的<em>future</em>遵循正常行为（即简单地销毁它的数据成员）。</li></ul></li></ul></li></ul><blockquote><p><strong>总结</strong></p><ul><li><em>future</em>的正常析构行为就是销毁<em>future</em>本身的数据成员。</li><li>引用了共享状态——使用<code>std::async</code>启动的未延迟任务建立的那个——的最后一个<em>future</em>的析构函数会阻塞住，直到任务完成。</li></ul></blockquote><h2 id="39-考虑对于单次事件通信使用void的future"><a href="#39-考虑对于单次事件通信使用void的future" class="headerlink" title="39. 考虑对于单次事件通信使用void的future"></a>39. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/7.TheConcurrencyAPI/item39.md">考虑对于单次事件通信使用void的future</a></h2><p>有时，一个任务（检测任务）通知另一个异步执行的任务（反应任务）发生了特定的事件很有用，这种情况下，线程间通信的最佳方案是什么？</p><p><strong>条件变量方案缺点</strong>：</p><ul><li>如果在反应任务<code>wait</code>之前检测任务通知了条件变量，反应任务会挂起。</li><li><code>wait</code>语句虚假唤醒。即在条件变量没有被通知时，也可能被唤醒。</li></ul><p><strong>原子类型flag方案缺点</strong>：</p><ul><li>会不断轮询，任务不会被阻塞</li></ul><p><strong>条件变量+flag方案缺点</strong>：</p><ul><li>通信机制不直接，不优雅</li></ul><p><strong>promise+futures方案</strong>：</p><ul><li>不需要互斥锁，无论在反应线程调用<code>wait</code>之前检测线程是否设置了<code>std::promise</code>都可以工作，并且不受虚假唤醒的影响。与基于条件变量的方法一样，反应任务在调用<code>wait</code>之后是真被阻塞住的，不会一直占用系统资源。</li><li>缺点：<ul><li>可能会产生基于堆的分配和释放开销</li><li><code>std::promise</code>只能设置一次。<code>std::promise</code>和<em>future</em>之间的通信是一次性的：不能重复使用</li></ul></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> p<span class="token punctuation">;</span>                   <span class="token comment">//通信信道的promise</span><span class="token comment">//检测任务</span>…                                       <span class="token comment">//检测某个事件</span>p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//通知反应任务</span><span class="token comment">//反应任务</span>…                                       <span class="token comment">//准备作出反应</span>p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">//等待对应于p的那个future</span>…                                       <span class="token comment">//对事件作出反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>对于简单的事件通信，基于条件变量的设计需要一个多余的互斥锁，对检测和反应任务的相对进度有约束，并且需要反应任务来验证事件是否已发生。</li><li>基于flag的设计避免的上一条的问题，但是是基于轮询，而不是阻塞。</li><li>条件变量和flag可以组合使用，但是产生的通信机制很不自然。</li><li>使用<code>std::promise</code>和<em>future</em>的方案避开了这些问题，但是这个方法使用了堆内存存储共享状态，同时有只能使用一次通信的限制。</li></ul></blockquote><h2 id="40-对于并发使用std-atomic，volatile用于特殊内存区"><a href="#40-对于并发使用std-atomic，volatile用于特殊内存区" class="headerlink" title="40. 对于并发使用std::atomic，volatile用于特殊内存区"></a>40. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/7.TheConcurrencyAPI/item40.md">对于并发使用std::atomic，volatile用于特殊内存区</a></h2><p><code>std::atomic</code>类型的最优的特性之一：一旦<code>std::atomic</code>对象被构建，所有成员函数，包括读-改-写（RMW）操作，从其他线程来看都是原子性的。</p><ul><li>一旦<code>std::atomic</code>对象被构建，在其上的操作表现得像操作是在互斥锁保护的关键区内，但是通常这些操作是使用特定的机器指令实现，这比锁的实现更高效。</li><li>编译器可能会对代码进行重排序，从而可能导致错误的结果，而<code>std::atomic</code>会限制这种重排序</li><li>使用了<code>std::atomic</code>，编译器仍可能对一些冗余操作进行优化（例如连续赋值两次）</li></ul><p><code>volatile</code>在多线程中实际上不保证任何事情，其主要用来告诉编译器现在处理的内存是不正常的（如处理外设内存）</p><ul><li>声明了<code>volatile</code>的变量，编译器不会对其进行优化重复读写（冗余访问和无用存储）的代码，</li></ul><p>因此：</p><ul><li><p><code>std::atomic</code>用在并发编程中，对访问特殊内存没用。</p></li><li><p><code>volatile</code>用于访问特殊内存，对并发编程没用。</p></li><li><p>因为<code>std::atomic</code>和<code>volatile</code>用于不同的目的，所以可以结合起来使用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">volatile</span> std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vai<span class="token punctuation">;</span>          <span class="token comment">//对vai的操作是原子性的，且不能被优化掉</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><blockquote><p><strong>总结</strong></p><ul><li><code>std::atomic</code>用于在不使用互斥锁情况下，来使变量被多个线程访问的情况。是用来编写并发程序的一个工具。</li><li><code>volatile</code>用在读取和写入不应被优化掉的内存上。是用来处理特殊内存的一个工具。</li></ul></blockquote><h1 id="CHAPTER8-Tweaks"><a href="#CHAPTER8-Tweaks" class="headerlink" title="CHAPTER8 Tweaks"></a><strong>CHAPTER8 Tweaks</strong></h1><h2 id="41-对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递"><a href="#41-对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递" class="headerlink" title="41. 对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递"></a>41. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/8.Tweaks/item41.md">对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递</a></h2><p>假设需要拷贝一个形参到私有容器，</p><ul><li><p>为了提高效率，应该设计以下两个函数，但会导致维护十分麻烦。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> newName<span class="token punctuation">)</span>    <span class="token comment">//接受左值；拷贝它</span>    <span class="token punctuation">&#123;</span> names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span>         <span class="token comment">//接受右值；移动它；std::move</span>    <span class="token punctuation">&#123;</span> names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>或使<code>addName</code>函数成为具有通用引用的函数模板，但是通用引用会导致实现必须放置在头文件、实例化等复杂性</p></li><li><p>一个可行的方式就是直接使用传值的方式，在C++11中，只有在左值实参情况下，<code>addName</code>被拷贝构造出来；对于右值，它会被移动构造（应该是编译器优化实现）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string newName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">//接受左值或右值；移动它</span>        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>考虑以上三种方法的开销：</p><ul><li><strong>重载</strong>：左值一次拷贝，右值一次移动。</li><li><strong>使用通用引用</strong>：左值一次拷贝，右值一次移动。</li><li><strong>按值传递</strong>：左值实参，一次拷贝一次移动，右值实参两次移动。对比按引用传递的方法，对于左值或者右值，均多出一次移动操作。</li></ul><p><strong>对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递</strong>。如此描述有以下原因：</p><ol><li>应该仅<strong>考虑</strong>使用传值方式。。按值传递方式只需要编写一个函数，避免了通用引用的种种问题</li><li>仅考虑对于可拷贝形参使用按值传递。如果不可拷贝，副本就必须通过移动构造函数创建，那就需要重载。</li><li>按值传递应该仅考虑那些<strong>移动开销小</strong>的形参。</li><li>你应该只对<strong>总是被拷贝</strong>的形参考虑按值传递。如果拷贝前有个判断语句，从而导致可能不拷贝，这会导致必然创建一个对象然后销毁，比基于引用的开销大。</li></ol><p>即使你编写的函数对可拷贝类型执行无条件的复制，且这个类型移动开销小，有时也可能不适合按值传递。</p><ul><li>使用通过赋值拷贝一个形参进行按值传递的函数的额外开销，取决于传递的类型，左值和右值的比例，这个类型是否需要动态分配内存</li></ul><blockquote><p><strong>总结</strong></p><ul><li>对于可拷贝，移动开销低，而且无条件被拷贝的形参，按值传递效率基本与按引用传递效率一致，而且易于实现，还生成更少的目标代码。</li><li>通过构造拷贝形参可能比通过赋值拷贝形参开销大的多。</li><li>按值传递会引起切片问题，所说不适合基类形参类型。</li></ul></blockquote><h2 id="42-考虑置入而非插入"><a href="#42-考虑置入而非插入" class="headerlink" title="42. 考虑置入而非插入"></a>42. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/8.Tweaks/item42.md">考虑置入而非插入</a></h2><p>考虑如下代码，push_back会发生以下操作：</p><ul><li>从”xyzzy”创建一个临时对象，然后传递给push_back的右值重载函数，然后此临时对象会被拷贝（移动）构造在vector内部创建一个新的对象，最后将临时对象销毁</li><li>上述操作多了一组不必要的构造和析构操作，造成了性能开销</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> vs<span class="token punctuation">;</span>        <span class="token comment">//std::string的容器</span>vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//添加字符串字面量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用emplace_back会直接在vector内部构造一个string，不会有临时变量生成和销毁。emplace_back是使用完美转发实现。可用于支持push_back的标准容器。</p><ul><li>插入函数接受<strong>对象</strong>去插入，而置入函数接受<strong>对象的构造函数接受的实参</strong>去插入。</li></ul><p>emplace并不一定比push快，<strong>emplace通常比push快的情况：</strong></p><ul><li>值是通过构造函数添加到容器，而不是直接赋值。此时使用emplace就无需生成临时变量。</li><li>传递的实参类型与容器的初始化类型不同。同样使用emplace就无需生成临时变量。</li><li>容器不拒绝重复项作为新值。置入实现通常会创建一个具有新值的对象，如果拒绝重复值插入则会导致这个对象的构造和析构被浪费。</li></ul><p><strong>注意</strong></p><ul><li>在对存储资源管理类对象的容器（比如<code>list&lt;shared_ptr&lt;Widget&gt;&gt;</code>）调用置入函数时，完美转发推迟了资源管理对象的创建，直到可以在容器的内存中构造它们为止，这给“异常导致资源泄漏”提供了可能。</li><li>置入函数使用直接初始化，这意味着可能使用<code>explicit</code>的构造函数。插入函数使用拷贝初始化，所以不能用<code>explicit</code>的构造函数。因此，置入函数可能执行插入函数拒绝的类型转换。</li></ul><blockquote><p><strong>总结</strong></p><ul><li>原则上，置入函数有时会比插入函数高效，并且不会更差。</li><li>实际上，当以下条件满足时，置入函数更快：（1）值被构造到容器中，而不是直接赋值；（2）传入的类型与容器的元素类型不一致；（3）容器不拒绝已经存在的重复值。</li><li>置入函数可能执行插入函数拒绝的类型转换。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码剖析笔记</title>
      <link href="/2023/02/15/c++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2023/02/15/c++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>学习侯捷《STL源码剖析》笔记</p><hr><hr><h1 id="一、基础介绍"><a href="#一、基础介绍" class="headerlink" title="一、基础介绍"></a>一、基础介绍</h1><p>STL六大部件：</p><ul><li><strong>容器 Containers</strong>：各种数据结构，如vector、list、deque、set、map，用来存放数据。从实现来看，STL容器是一种 class template。</li><li><strong>分配器 Allocator</strong>：负责空间配置与管理，从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的 class template。</li><li><strong>算法 Algorithm</strong>：各种常用算法如 sort、search、copy、erase，从实现的角度来看，STL算法是一种 function template。</li><li><strong>迭代器 Iterators</strong>：扮演容器与算法之间的胶合剂，是所谓的“泛型指针”，共有五种类型，以及其它衍生变化，从实现的角度来看，迭代器是一种将：operators*、Operator-&gt;、Operator++、Operator– 等指针相关操作予以重载的class template。所有STL容器都附带有自己专属的迭代器——只有容器设计者才知道如何遍历自己的元素，原生指针（native pointer）也是一种迭代器。</li><li><strong>适配器 Adapters</strong>：一种用来修饰容器（containers）或仿函数（functors）或迭代器（iterators）接口的东西，例如：STL提供的 queue 和 stack，虽然看似容器，其实只能算是一种容器配接器，因为 它们的底部完全借助 deque，所有操作由底层的 deque 供应。改变 functor 接口者，称为 function adapter；改变 container 接口者，称为 container adapter；改变 iterator 接口者，称为 iterator adapter。配接器的实现技术很难一言蔽之，必须逐一分析。</li><li><strong>仿函数 Functors</strong>：行为类似函数，可作为算法的某种策略（policy），从实现的角度来看，仿函数是一种重载了 operator () 的 class 或 class template。一般函数指针可视为狭义的仿函数。</li></ul><p>容器存储数据，容器通过分配器来获得内存分配，算法通过迭代器来操作容器中的数据，仿函数可以为算法提供类函数似实体，适配器可对仿函数、容器等进行包装。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221220190021504.png"></p><p>六大部件使用</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221220190856969.png"></p><h1 id="二、空间配置器"><a href="#二、空间配置器" class="headerlink" title="二、空间配置器"></a>二、空间配置器</h1><blockquote><p>为什么不说allocator是内存配置器而说它是空间配置器呢？因为，空间不一定是内存，空间也可以是磁盘或其它辅助储存媒体。</p></blockquote><h2 id="2-1-空间配置器的标准接口"><a href="#2-1-空间配置器的标准接口" class="headerlink" title="2.1 空间配置器的标准接口"></a>2.1 空间配置器的标准接口</h2><p><strong>成员类型</strong></p><table><thead><tr><th>value_type</th><th>T</th></tr></thead><tbody><tr><td>pointer (C++17 中弃用)(C++20 中移除)</td><td>T*</td></tr><tr><td>const_pointer (C++17 中弃用)(C++20 中移除)</td><td>const T*</td></tr><tr><td>reference (C++17 中弃用)(C++20 中移除)</td><td>T&amp;</td></tr><tr><td>const_reference (C++17 中弃用)(C++20 中移除)</td><td>const T&amp;</td></tr><tr><td>size_type</td><td>std::size_t</td></tr><tr><td>difference_type</td><td>std::ptrdiff_t （<strong>是两个指针相减的结果类型，是一种有符号整数类型</strong>）</td></tr><tr><td>propagate_on_container_move_assignment(C++14)</td><td>std::true_type</td></tr><tr><td>rebind (C++17 中弃用)(C++20 中移除)</td><td>template&lt; class U &gt; struct rebind { typedef allocator other; };</td></tr><tr><td>is_always_equal(C++17)</td><td>std::true_type</td></tr></tbody></table><p><strong>成员函数</strong></p><table><thead><tr><th>(构造函数)</th><th>创建新的 allocator 实例(公开成员函数)</th></tr></thead><tbody><tr><td>(析构函数)</td><td>析构 allocator 实例(公开成员函数)</td></tr><tr><td>address(C++17 中弃用)(C++20 中移除)</td><td>获得对象的地址，即使重载了 operator&amp;(公开成员函数)</td></tr><tr><td>allocate</td><td>分配未初始化的存储(公开成员函数)</td></tr><tr><td>deallocate</td><td>解分配存储(公开成员函数)</td></tr><tr><td>max_size(C++17 中弃用)(C++20 中移除)</td><td>返回最大的受支持分配大小(公开成员函数)</td></tr><tr><td>construct(C++17 中弃用)(C++20 中移除)</td><td>在分配的存储构造对象(公开成员函数)</td></tr><tr><td>destroy</td><td>(C++17 中弃用)(C++20 中移除)析构在已分配存储中的对象(公开成员函数)</td></tr></tbody></table><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//以下各种 type 的设计原由，第三章详述。</span>allocator<span class="token double-colon punctuation">::</span>value_type allocator<span class="token double-colon punctuation">::</span>pointer allocator<span class="token double-colon punctuation">::</span>const_pointer allocator<span class="token double-colon punctuation">::</span>reference allocator<span class="token double-colon punctuation">::</span>const_reference allocator<span class="token double-colon punctuation">::</span>size_type allocator<span class="token double-colon punctuation">::</span>difference_type    allocator<span class="token double-colon punctuation">::</span>rebind 一个巢状的（nested）<span class="token keyword">class</span> <span class="token keyword">template</span>。<span class="token keyword">class</span> <span class="token class-name">rebind</span><span class="token operator">&lt;</span>U<span class="token operator">></span>拥有唯一成员other，那是一个 <span class="token keyword">typedef</span>，代表allocator<span class="token operator">&lt;</span>U<span class="token operator">></span>。allocator<span class="token double-colon punctuation">::</span><span class="token function">allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> constructor。allocator<span class="token double-colon punctuation">::</span><span class="token function">allocator</span><span class="token punctuation">(</span><span class="token keyword">const</span> allocator<span class="token operator">&amp;</span><span class="token punctuation">)</span> copy constructor。<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span>allocator<span class="token double-colon punctuation">::</span><span class="token function">allocator</span><span class="token punctuation">(</span><span class="token keyword">const</span> allocator<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span> 泛化的copy constructor。<span class="token class-name">allocator</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> constructor。pointer allocator<span class="token double-colon punctuation">::</span><span class="token function">address</span><span class="token punctuation">(</span>reference x<span class="token punctuation">)</span> <span class="token keyword">const</span> 传回某个对象的地址。算式a<span class="token punctuation">.</span><span class="token function">address</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>等同于<span class="token operator">&amp;</span>x。const_pointer allocator<span class="token double-colon punctuation">::</span><span class="token function">address</span><span class="token punctuation">(</span>const_reference x<span class="token punctuation">)</span> <span class="token keyword">const</span> 传回某个<span class="token keyword">const</span>对象的地址。算式a<span class="token punctuation">.</span><span class="token function">address</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>等同于<span class="token operator">&amp;</span>x。pointer allocator<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>size_type n<span class="token punctuation">,</span> cosnt <span class="token keyword">void</span><span class="token operator">*</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> 配置空间，足以储存n个T对象。第二自变量是个提示。实作上可能会利用它来增进区域性（locality），或完全忽略之。<span class="token keyword">void</span> allocator<span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>pointer p<span class="token punctuation">,</span> size_type n<span class="token punctuation">)</span> 归还先前配置的空间。size_type allocator<span class="token double-colon punctuation">::</span><span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> 传回可成功配置的最大量。<span class="token keyword">void</span> allocator<span class="token double-colon punctuation">::</span><span class="token function">construct</span><span class="token punctuation">(</span>pointer p<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> 等同于<span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> p<span class="token punctuation">)</span> <span class="token function">T</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>。<span class="token keyword">void</span> allocator<span class="token double-colon punctuation">::</span><span class="token function">destroy</span><span class="token punctuation">(</span>pointer p<span class="token punctuation">)</span> 等同于p<span class="token operator">-></span><span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span>。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-SGI-空间配置器"><a href="#2-2-SGI-空间配置器" class="headerlink" title="2.2 SGI 空间配置器"></a>2.2 SGI 空间配置器</h2><p>SGI STL 的分配器与众不同，也与标准规范不同，其名称是 alloc 而非 allocator，而且不接受任何参数。具体来说，想在程序中明确使用 SGI 分配器，不能写<code>std::allocator&lt;int&gt;</code>，而要写成<code>std::alloc</code></p><h3 id="2-2-1-std-alloc"><a href="#2-2-1-std-alloc" class="headerlink" title="2.2.1 std::alloc"></a>2.2.1 std::alloc</h3><p>一般而言，我们所习惯的 C++ 内存配置动作和释放动作是这样：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> Foo<span class="token operator">*</span> pf <span class="token operator">=</span> <span class="token keyword">new</span> Foo<span class="token punctuation">;</span><span class="token comment">//配置内存，然后建构对象</span><span class="token keyword">delete</span> pf<span class="token punctuation">;</span> <span class="token comment">//将对象解构，然后释放内存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>new算式内含两阶段动作：</p><ul><li><p>(1)呼叫::operator new配置内存</p></li><li><p>(2) 呼叫Foo::Foo()建构对象内容</p></li></ul></li><li><p>delete算式也内含两阶段动作：</p><ul><li><p>(1)呼 叫Foo::~Foo()将对象解构</p></li><li><p>(2)呼叫::operator delete释放内存</p></li></ul></li></ul><p>为了精密分工，STL allocator决定将这两阶段动作区分开来：</p><ul><li>内存配置动作由alloc:allocate()负责</li><li>内存释放动作由alloc::deallocate()负责</li><li>对象建构动作由::construct()负责</li><li>对象解构动作由::destroy()负责</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103153350320.png"></p><h3 id="2-2-2-construct-和destroy"><a href="#2-2-2-construct-和destroy" class="headerlink" title="2.2.2 construct()和destroy()"></a>2.2.2 construct()和destroy()</h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103154204124.png"></p><p>construct()定义</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">></span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">construct</span><span class="token punctuation">(</span>T1<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">const</span> T2<span class="token operator">&amp;</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token function">T1</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//placement new;唤起 T1::T1(value); </span>    <span class="token comment">//placement new 是使用已有的内存空间进行初始化，这里是使用p指向的内存进行T1对象的初始化</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>destroy()定义</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//以下是 destroy()第一版ᴀ，接受一个指标。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span>T<span class="token operator">*</span> pointer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     pointer<span class="token operator">-></span><span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//唤起 dtor ~T() </span><span class="token punctuation">&#125;</span> <span class="token comment">//以下是 destroy()第二版ᴀ，接受两个迭代器。此函式设法找出元素的数值型别，</span><span class="token comment">//进而利用 __type_traits&lt;>求取最适当措施。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">></span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">__destroy</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> <span class="token function">value_type</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//判断元素的数值型别（value type）是否有trivial destructor </span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__destroy</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">__type_traits</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>has_trivial_destructor trivial_destructor<span class="token punctuation">;</span> <span class="token function">__destroy_aux</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> <span class="token function">trivial_destructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//如果元素的数值型别（value type）有non-trivial destructor…</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">></span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__destroy_aux</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span> __false_type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> first <span class="token operator">&lt;</span> last<span class="token punctuation">;</span> <span class="token operator">++</span>first<span class="token punctuation">)</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token operator">*</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//如果元素的数值型别（value type）有trivial destructor…</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">></span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__destroy_aux</span><span class="token punctuation">(</span>ForwardIterator<span class="token punctuation">,</span> ForwardIterator<span class="token punctuation">,</span> __true_type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//以下是 destroy()第二版ᴀ针对迭代器为 char*和 wchar_t*的特化版</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token keyword">wchar_t</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-3-空间的配置与释放"><a href="#2-2-3-空间的配置与释放" class="headerlink" title="2.2.3 空间的配置与释放"></a>2.2.3 空间的配置与释放</h3><p>设计思路如下：</p><ul><li>向 system heap要求空间</li><li>考虑多绪（multi-threads）状态</li><li>考虑内存不足时的应变措施</li><li>考虑过多「小型区块」可能造成的内存破碎（fragment）问题</li></ul><blockquote><p>C++的内存配置动作是::operator new() ， 内存释放动作是::operator delete()。这两个全域函式相当于 C 的 malloc()和 free() 函式。SGI 正是以malloc() 和free() 完成内存的配置与释放。</p></blockquote><p>考虑到小型区块可能造成的内存破碎问题，SGI设计了双层级配置器,第一级配置器直接使用<code>malloc()</code>和<code>free()</code>；第二级配置器则视情况采用不同的策略。当配置区块超过128byte时，视之为足够大，使用第一级配置器，当小于128byte时，视之为过小，采用复杂的memory pool整理方式。而不再求助于第一级适配器。使用哪一级适配器取决于<code>__USE_MALLOC</code>是否被定义。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103155652288.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103155711848.png"></p><h3 id="2-2-4-第一级配置器-malloc-alloc-template"><a href="#2-2-4-第一级配置器-malloc-alloc-template" class="headerlink" title="2.2.4 第一级配置器 __malloc_alloc_template"></a>2.2.4 第一级配置器 __malloc_alloc_template</h3><p>第一级配置器以malloc(), free(), realloc()等 C函式执行实际的内存配置、释放、重配置动作，并实作出类似 C++ new-handler的机制。它不能直接运用 C++ new-handler机制，因为并非使用::operatornew来配置记忆体。</p><blockquote><p>C++ new handler 机制是，你可以要求系统在内存配置需求无法被满足时，唤起一个你所指定的函式。换句话说一旦::operator new无法达成任务，在丢出<em>std::bad_alloc</em>异常状态之前，会先呼叫由客端指定的处理例程。</p></blockquote><p>注意，SGI 第一级配置器的allocate() 和realloc()都是在呼叫malloc() 和realloc()不成功后，改呼叫oom_malloc()和oom_realloc()。后两者都有内循环，不断呼叫「内存不足处理例程」，期望在某次呼叫之后，获得足够的内存而圆满达成任务。但如果「内存不足处理例程」并᳾被客端设定，oom_malloc()和oom_realloc() 便老实不客气地呼叫__THROW_BAD_ALLOC，丢出<em>bad_alloc</em>异常讯息，或利用exit(1)硬生生中止程序。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//一级适配器</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">__malloc_alloc_template</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment">//函数指针，所代表的函数将用来处理内存不足的情况</span>    <span class="token comment">//oom: out of memory</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">oom_malloc</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">oom_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>__malloc_alloc_oom_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">allocate</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//一级配置器必须使用malloc()</span>        <span class="token keyword">void</span> <span class="token operator">*</span>result<span class="token operator">=</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//当无法满足需求时，改用oom_malloc()</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">==</span>result<span class="token punctuation">)</span> result<span class="token operator">=</span><span class="token function">oom_malloc</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>size_t<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//第一级配置器直接使用free()</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//输入旧size和新size</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>size_t<span class="token punctuation">,</span>size_t new_sz<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">void</span><span class="token operator">*</span> result<span class="token operator">=</span><span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>new_sz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">==</span>result<span class="token punctuation">)</span> result<span class="token operator">=</span><span class="token function">oom_realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>new_sz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">//指定自己的out-of-memory handler</span>        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token function">set_malloc_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//获取函数指针</span>        <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> old<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span>__malloc_alloc_oom_handler<span class="token punctuation">;</span>        __malloc_alloc_oom_handler<span class="token operator">=</span>f<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">(</span>old<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//下面是用户提供的malloc_alloc函数</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>__malloc_alloc_template<span class="token operator">&lt;</span>inst<span class="token operator">></span><span class="token double-colon punctuation">::</span>__malloc_alloc_oom_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token class-name">__malloc_alloc_template</span><span class="token operator">&lt;</span>inst<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">oom_malloc</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//获取内存分配句柄函数指针</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>result<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//指针指向分配函数</span>        my_malloc_handler<span class="token operator">=</span>__malloc_alloc_oom_handler<span class="token punctuation">;</span>        <span class="token comment">//分配失败抛出异常</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">==</span>my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>__THROW_BAD_ALLOC<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token comment">//调用处理例程，企图释放内存</span>        <span class="token punctuation">(</span><span class="token operator">*</span>my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//再次尝试分配内存</span>        result<span class="token operator">=</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//内存调用分配不成功时，进行二次调用</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token class-name">__malloc_alloc_template</span><span class="token operator">&lt;</span>inst<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">oom_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>size_t n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>result<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        my_malloc_handler<span class="token operator">=</span>__malloc_alloc_oom_handler<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">==</span>my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>__THROW_BAD_ALLOC<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token comment">//尝试调用处理例程</span>        <span class="token punctuation">(</span><span class="token operator">*</span>my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//尝试分配内存</span>        result<span class="token operator">=</span><span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//注意,以下参数直接将inst指定为0</span><span class="token keyword">typedef</span> __malloc_alloc_template<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span> malloc_alloc<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-5-第二级配置器-default-alloc-template"><a href="#2-2-5-第二级配置器-default-alloc-template" class="headerlink" title="2.2.5 第二级配置器__default_alloc_template"></a>2.2.5 第二级配置器__default_alloc_template</h3><p>因为对于操作系统而言，需要块分配一定的内存来存储块的位置信息，因此当内存过小时，单独开辟块反而是得不偿失的。因此在此时，C++使用内存池机制来对数据进行管理。由配置器负责内存的管理和回收，通常SGI配置其会将小额区块的内存需求量上调至8的倍数(例如30B-32B),并唯独16个free-list,各自管理大小分别为8,16,24,32,40,48,56,64…128 bytes的小额区块。结构如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">union</span> obj<span class="token punctuation">&#123;</span>    <span class="token keyword">union</span> obj<span class="token operator">*</span> free_list_link<span class="token punctuation">;</span>    <span class="token keyword">char</span> client_data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于使用了union，节省了额外的指针内存消耗，free-list连接如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103164634110.png"></p><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span> __ALIGN <span class="token operator">=</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                           <span class="token comment">// 小型区块的上调边界</span><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span> __MAX_BYTES <span class="token operator">=</span> <span class="token number">128</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                     <span class="token comment">// 小型区块的上限</span><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span> __NFREELISTS <span class="token operator">=</span> __MAX_BYTES <span class="token operator">/</span> __ALIGN <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// free-lists个数</span><span class="token comment">// 以下是第二级配置器。</span><span class="token comment">// 注意，无「template 型别参数」，且第二参数完全没派上用场。</span><span class="token comment">// 第一参数用于多绪环境下。ᴀ书不讨论多绪环境。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> threads<span class="token punctuation">,</span> <span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">__default_alloc_template</span> <span class="token punctuation">&#123;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token comment">// ROUND_UP() 将 bytes上调至 8的倍数。</span>  <span class="token keyword">static</span> size_t <span class="token function">ROUND_UP</span><span class="token punctuation">(</span>size_t bytes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span> <span class="token operator">+</span> __ALIGN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>__ALIGN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token number">61</span> unionobj <span class="token punctuation">&#123;</span>  <span class="token comment">// free-lists 的节点构造</span>    <span class="token keyword">union</span> obj <span class="token operator">*</span>free_list_link<span class="token punctuation">;</span>    <span class="token keyword">char</span> client_data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* The client sees this. */</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token comment">// 16 个 free-lists</span>  <span class="token keyword">static</span> obj <span class="token operator">*</span>volatilefree_list<span class="token punctuation">[</span>__NFREELISTS<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 以下函式根据区块大小，决定使用第 n号 free-list。n 从 1 起算。</span>  <span class="token keyword">static</span> size_t <span class="token function">FREELIST_INDEX</span><span class="token punctuation">(</span>size_t bytes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span> <span class="token operator">+</span> __ALIGN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> __ALIGN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 传回一个大小为 n的对象，并可能加入大小为 n的其它区块到free list.</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">refill</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 配置一大块空间，可容纳 nobjs 个大小为 "size" 的区块。</span>  <span class="token comment">// 如果配置 nobjs个区块有所不便，nobjs可能会降低。</span>  <span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">chunk_alloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>nobjs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Chunk allocation state.</span>  <span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span>start_free<span class="token punctuation">;</span>  <span class="token comment">// 记忆池起始位置。只在 chunk_alloc()中变化</span>  <span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span>end_free<span class="token punctuation">;</span>  <span class="token comment">// 记忆池结束位置。只在 chunk_alloc()中变化</span>  <span class="token keyword">static</span> size_t heap_size<span class="token punctuation">;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">allocate</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 详述于后 */</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 详述于后 */</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> size_t old_sz<span class="token punctuation">,</span> size_t new_sz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 以下是 static data member 的定义与初值设定</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> threads<span class="token punctuation">,</span> <span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">char</span> <span class="token operator">*</span>__default_alloc_template<span class="token operator">&lt;</span>threads<span class="token punctuation">,</span> inst<span class="token operator">></span><span class="token double-colon punctuation">::</span>start_free <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> threads<span class="token punctuation">,</span> <span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">char</span> <span class="token operator">*</span>__default_alloc_template<span class="token operator">&lt;</span>threads<span class="token punctuation">,</span> inst<span class="token operator">></span><span class="token double-colon punctuation">::</span>end_free <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> threads<span class="token punctuation">,</span> <span class="token keyword">int</span> inst<span class="token operator">></span>size_t__default_alloc_template<span class="token operator">&lt;</span>threads<span class="token punctuation">,</span> inst<span class="token operator">></span><span class="token double-colon punctuation">::</span>heap_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> threads<span class="token punctuation">,</span> <span class="token keyword">int</span> inst<span class="token operator">></span>__default_alloc_template<span class="token operator">&lt;</span>threads<span class="token punctuation">,</span> inst<span class="token operator">></span><span class="token double-colon punctuation">::</span>obj <span class="token operator">*</span><span class="token keyword">volatile</span> __default_alloc_template<span class="token operator">&lt;</span>    threads<span class="token punctuation">,</span> inst<span class="token operator">></span><span class="token double-colon punctuation">::</span>free_list<span class="token punctuation">[</span>__NFREELISTS<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-6-空间配置函数-allocate"><a href="#2-2-6-空间配置函数-allocate" class="headerlink" title="2.2.6 空间配置函数 allocate()"></a>2.2.6 空间配置函数 allocate()</h3><p>__default_alloc_template拥有配置器的标准接口函数allocate()。此函数首先判断区块大小，大于128bytes就调用第一级配置器，小于128bytes就检查对应的free list。如果有可用区块就直接拿来用，没有就将区块的大小上调至8倍数边界，然后调用<code>refill()</code>准备为<code>free list</code>重新填充空间。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// n must be > 0</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">allocate</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  obj <span class="token operator">*</span><span class="token keyword">volatile</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">;</span>  obj <span class="token operator">*</span>result<span class="token punctuation">;</span>  <span class="token comment">// 大于 128 就呼叫第一级配置器</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>__MAX_BYTES<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>malloc_alloc<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 寻找 16 个 free lists 中适当的一个</span>  my_free_list <span class="token operator">=</span> free_list <span class="token operator">+</span> <span class="token function">FREELIST_INDEX</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  result <span class="token operator">=</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 没找到可用的 free list，准备重新填充 free list</span>    <span class="token number">63</span> <span class="token keyword">void</span> <span class="token operator">*</span>r <span class="token operator">=</span> <span class="token function">refill</span><span class="token punctuation">(</span><span class="token function">ROUND_UP</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> r<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 调整 free list</span>  <span class="token comment">// 下节详述</span>  <span class="token operator">*</span>my_free_list <span class="token operator">=</span> result<span class="token operator">-></span>free_list_link<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103170646960.png"></p><h3 id="2-2-7-空间释放函数deallocate"><a href="#2-2-7-空间释放函数deallocate" class="headerlink" title="2.2.7 空间释放函数deallocate()"></a>2.2.7 空间释放函数deallocate()</h3><p>判断区块大小，大于 128 bytes 就呼叫第一级配置器，小于 128 bytes 就找出对应的 <em>free list</em>，将区块回收。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// p 不可以是 0</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  obj <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span>obj <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>  obj <span class="token operator">*</span><span class="token keyword">volatile</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">;</span>  <span class="token comment">// 大于 128 就呼叫第一级配置器</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>__MAX_BYTES<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    malloc_alloc<span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 寻找对应的 free list</span>  my_free_list <span class="token operator">=</span> free_list <span class="token operator">+</span> <span class="token function">FREELIST_INDEX</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调整 free list，回收区块</span>  q<span class="token operator">-></span>free_list_link <span class="token operator">=</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">;</span>  <span class="token operator">*</span>my_free_list <span class="token operator">=</span> q<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103171300725.png"></p><h3 id="2-2-8-重新充填-free-lists"><a href="#2-2-8-重新充填-free-lists" class="headerlink" title="2.2.8 重新充填 free lists"></a>2.2.8 重新充填 <em>free list</em>s</h3><p>当内存池中没有可用区块的时候，就调用<code>refill()</code>准备为free-list重新分配空间。新的空间将取自内存池，缺省取得20个新节点(新区块)，但万一内存池空间不足，获得的节点数(区块数)可能小于20。</p><h3 id="2-2-9-内存池"><a href="#2-2-9-内存池" class="headerlink" title="2.2.9 内存池"></a>2.2.9 内存池</h3><p>使用chunk_alloc()从内存池中取出空间给free list使用。</p><p>以end_free - start_free 来判断内存池的水量。如果水量充足，就直接拨出 20 个区块传回给 <em>free list</em>。如果水量不足以提供 20 个区块，但还足够供应一个以上的区块，就拨出这不足20个区块的空间出去。如果内存池连一个区块空间都无法供应，此时便需利用malloc() 从 heap 中配置内存，为内存池注入活水源头以应付需求。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 假设 size 已经适当上调至 8的倍数。</span><span class="token comment">// 注意参数 nobjs是pass by reference。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> threads<span class="token punctuation">,</span> <span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token class-name">__default_alloc_template</span><span class="token operator">&lt;</span>threads<span class="token punctuation">,</span> inst<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">chunk_alloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span>                                                           <span class="token keyword">int</span> <span class="token operator">&amp;</span>nobjs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>result<span class="token punctuation">;</span>  size_t total_bytes <span class="token operator">=</span> size <span class="token operator">*</span> nobjs<span class="token punctuation">;</span>  size_t bytes_left <span class="token operator">=</span> end_free <span class="token operator">-</span> start_free<span class="token punctuation">;</span>  <span class="token comment">// 记忆池剩余空间</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes_left <span class="token operator">>=</span> total_bytes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 记忆池剩余空间完全满足需求量。</span>    result <span class="token operator">=</span> start_free<span class="token punctuation">;</span>    start_free <span class="token operator">+=</span> total_bytes<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes_left <span class="token operator">>=</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token number">67</span>        <span class="token comment">// 记忆池剩余空间不能完全满足需求量，但足够供应一个（含）以上的区块。</span>        nobjs <span class="token operator">=</span> bytes_left <span class="token operator">/</span> size<span class="token punctuation">;</span>    total_bytes <span class="token operator">=</span> size <span class="token operator">*</span> nobjs<span class="token punctuation">;</span>    result <span class="token operator">=</span> start_free<span class="token punctuation">;</span>    start_free <span class="token operator">+=</span> total_bytes<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 记忆池剩余空间连一个区块的大小都无法提供。</span>    size_t bytes_to_get <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> total_bytes <span class="token operator">+</span> <span class="token function">ROUND_UP</span><span class="token punctuation">(</span>heap_size <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 以下试着让记忆池中的残余零头还有利用价值。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes_left <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 记忆池内还有一些零头，先配给适当的 free list。</span>      <span class="token comment">// 首先寻找适当的 free list。</span>      obj <span class="token operator">*</span><span class="token keyword">volatile</span> <span class="token operator">*</span>my_free_list <span class="token operator">=</span> free_list <span class="token operator">+</span> <span class="token function">FREELIST_INDEX</span><span class="token punctuation">(</span>bytes_left<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 调整 free list，将记忆池中的残余空间编入。</span>      <span class="token punctuation">(</span><span class="token punctuation">(</span>obj <span class="token operator">*</span><span class="token punctuation">)</span>start_free<span class="token punctuation">)</span><span class="token operator">-></span>free_list_link <span class="token operator">=</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">;</span>      <span class="token operator">*</span>my_free_list <span class="token operator">=</span> <span class="token punctuation">(</span>obj <span class="token operator">*</span><span class="token punctuation">)</span>start_free<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 配置 heap 空间，用来挹注记忆池。</span>    start_free <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>bytes_to_get<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> start_free<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// heap 空间不足，malloc() 失败。</span>      <span class="token keyword">int</span> i<span class="token punctuation">;</span>      obj <span class="token operator">*</span><span class="token keyword">volatile</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>      <span class="token comment">// 试着检视我们手上拥有的东西。这不会造成伤害。我们不打算尝试配置</span>      <span class="token comment">// 较小的区块，因为那在多行程（multi-process）机器上容易导致灾难</span>      <span class="token comment">// 以下搜寻适当的 free list，</span>      <span class="token comment">// 所谓适当是指「尚有᳾用区块，且区块够大」之 free</span>      <span class="token comment">// list。</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> size<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> __MAX_BYTES<span class="token punctuation">;</span> i <span class="token operator">+=</span> __ALIGN<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        my_free_list <span class="token operator">=</span> free_list <span class="token operator">+</span> <span class="token function">FREELIST_INDEX</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// free list 内尚有᳾用区块。</span>          <span class="token comment">// 调整 free list以释出᳾用区块</span>          <span class="token operator">*</span>my_free_list <span class="token operator">=</span> p<span class="token operator">-></span>free_list_link<span class="token punctuation">;</span>          start_free <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>          end_free <span class="token operator">=</span> start_free <span class="token operator">+</span> i<span class="token punctuation">;</span>          <span class="token comment">// 递归呼叫自己，为了修正 nobjs。</span>          <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">chunk_alloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> nobjs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 注意，任何残余零头终将被编入适当的 free-list中备用。</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      end_free <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 如果出现意外（山穷水尽，到处都没内存可用了）</span>      <span class="token comment">// 呼叫第一级配置器，看看out-of-memory机制能否尽点力</span>      start_free <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>malloc_alloc<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>bytes_to_get<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 这会导致掷出异常（exception），或内存不足的情况获得改善。</span>    <span class="token punctuation">&#125;</span>    heap_size <span class="token operator">+=</span> bytes_to_get<span class="token punctuation">;</span>    end_free <span class="token operator">=</span> start_free <span class="token operator">+</span> bytes_to_get<span class="token punctuation">;</span>    <span class="token comment">// 递归呼叫自己，为了修正 nobjs。</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">chunk_alloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> nobjs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103194425350.png"></p><h2 id="2-3-内存基本处理工具"><a href="#2-3-内存基本处理工具" class="headerlink" title="2.3 内存基本处理工具"></a>2.3 内存基本处理工具</h2><p>STL中定义有5个全局函数，作用于未初始化空间之上。分别是<code>construct()</code>、<code>destroy()</code>、uninitailized_copy()、uninitailized_fill()、uninitialized_fill_n()，后三个分别对应于高层次函数copy()、fill()、fill_n()。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103200321466.png"></p><h3 id="2-3-1-uninitialized-copy"><a href="#2-3-1-uninitialized-copy" class="headerlink" title="2.3.1 uninitialized_copy"></a>2.3.1 uninitialized_copy</h3><p>uninitialized_copy() 能够将内存的配置与对象的建构行为分离开来。如果做为输出目的地的[result, result+(last-first))范围内的每一个迭 代 器 都 指 向未初 始 化 区 域 ， 则uninitialized_copy()会 使 用copy constructor，为身为输入来源之[first,last)范围内的每一个对象产生一份复制品，放进输出范围中。</p><p>具有 “<em>commit</em> or <em>rollback</em>“语意</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">></span>ForwardIterator <span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span>                                   ForwardIterator result<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">__uninitialized_copy</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> result<span class="token punctuation">,</span><span class="token function">value_type</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//迭代器first指向输入端的起始位置</span><span class="token comment">//迭代器last指向输入端的结束位置（前闭后开区间）</span><span class="token comment">//迭代器result指向输出端（欲初始化空间）的起始处</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>uninitialized_copy首先萃取出迭代器 result 的 <em>value type</em>，然后判断该型别是否为 POD型别，如果是POD类型则调用STL的copy算法进行复制，否则使用construct逐个复制。</p><h3 id="2-3-2-uninitialized-fill"><a href="#2-3-2-uninitialized-fill" class="headerlink" title="2.3.2 uninitialized_fill"></a>2.3.2 uninitialized_fill</h3><p>uninitialized_fill() 也能够将内存配置与对象的建构行为分离开来。如果[first,last)范围内的每个迭代器都指向未初始化的内存，那么uninitialized_fill()会在该范围内产生x（上式第三参数）的复制品。</p><p>也具有 “<em>commit</em> or <em>rollback</em>“语意</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">uninitialized_fill</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span>                        <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">__uninitialized_fill</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token function">value_type</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//迭代器first指向输出端（欲初始化空间）的起始处</span><span class="token comment">//迭代器last指向输出端（欲初始化空间）的结束处（前闭后开区间）</span><span class="token comment">//x表示初值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>uninitialized_fill首先萃取出迭代器 result 的 <em>value type</em>，然后判断该型别是否为 POD型别，如果是POD类型则调用STL的fill算法进行复制，否则使用construct逐个复制。</p><h3 id="2-3-3-uninitialized-fill-n"><a href="#2-3-3-uninitialized-fill-n" class="headerlink" title="2.3.3 uninitialized_fill_n"></a>2.3.3 uninitialized_fill_n</h3><p>uninitialized_fill_n()能够将内存配置与对象建构行为分离开来，会为指定范围内的所有元素设定相同的初值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Size</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>ForwardIterator <span class="token function">uninitialized_fill_n</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> Size n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">__uninitialized_fill_n</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> n<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token function">value_type</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//1.迭代器first指向欲初始化空间的起始处</span><span class="token comment">//2.n表示欲初始化空间的大小</span><span class="token comment">//3.x表示初值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>POD</strong>意指 <strong>Plain Old Data</strong>，也就是纯量型别（scalar types）或传统的 C struct型别。POD型别必然拥有 <em>trivial</em> ctor&#x2F;dtor&#x2F;copy&#x2F;assignment函式，因此，我们可以对POD型别采取最有效率的初值填写手法，而对non-POD 型别采取构造函数构造</p></blockquote><p>uninitialized_fill_n首先萃取出迭代器 first 的 value type（详见第三章），然后判断该型别是否为 POD型别，然后对是否未POD类型进行各自处理。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Size</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token operator">></span><span class="token keyword">inline</span> ForwardIterator <span class="token function">__uninitialized_fill_n</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> Size n<span class="token punctuation">,</span>                                              <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> T1<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 以下 __type_traits&lt;> 技法，详见 3.7 节</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">__type_traits</span><span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token double-colon punctuation">::</span>is_POD_typeis_POD<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">__uninitialized_fill_n_aux</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> n<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token function">is_POD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 如果 copy construction 等同于 assignment, 而且</span><span class="token comment">//  destructor 是 trivial，以下就有效。</span><span class="token comment">// 如果是 POD型别，执行流程就会转进到以下函式。这是藉由 function template</span><span class="token comment">// 的自变量推导机制而得。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Size</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">inline</span> ForwardIterator <span class="token function">__uninitialized_fill_n_aux</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> Size n<span class="token punctuation">,</span>                                                  <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> __true_type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">fill_n</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> n<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 交由高阶函式执行。见 6.4.2节。</span><span class="token punctuation">&#125;</span><span class="token comment">// 如果不是 POD 型别，执行流程就会转进到以下函式。这是藉由 function template</span><span class="token comment">// 的自变量推导机制而得。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Size</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>ForwardIterator <span class="token function">__uninitialized_fill_n_aux</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> Size n<span class="token punctuation">,</span>                                           <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> __false_type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  ForwardIterator cur <span class="token operator">=</span> first<span class="token punctuation">;</span>  <span class="token comment">// 为求阅读顺畅，以下将原ᴀ该有的异常处理（exception handling）省略。</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>n<span class="token punctuation">,</span> <span class="token operator">++</span>cur<span class="token punctuation">)</span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token operator">*</span>cur<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、迭代器和traits"><a href="#三、迭代器和traits" class="headerlink" title="三、迭代器和traits"></a>三、迭代器和traits</h1><blockquote><p>STL 的中心思想在于，将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起</p></blockquote><h2 id="3-1-迭代器是一种-smart-pointer"><a href="#3-1-迭代器是一种-smart-pointer" class="headerlink" title="3.1 迭代器是一种 smart pointer"></a>3.1 迭代器是一种 smart pointer</h2><p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见也最重要的便是内容提领（<em>dereference</em>）和成员取用（member access），因此迭代器最重要的编程工作就是对 operator*和operator-&gt;进行重载。</p><p>一个简单迭代器如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Item</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">LisIter</span> <span class="token punctuation">&#123;</span>     Item<span class="token operator">*</span> ptr<span class="token punctuation">;</span>     <span class="token function">ListIter</span><span class="token punctuation">(</span>Item<span class="token operator">*</span> p<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">ptr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>     <span class="token comment">//关键操作</span>     Item<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>     Item<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> ptr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>     ListIter<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        ptr<span class="token operator">=</span>ptr<span class="token operator">-></span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>      ListIter <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        ListIter tmp<span class="token operator">=</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        retrun tmp<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> ListIter<span class="token operator">&amp;</span> i<span class="token punctuation">)</span> <span class="token keyword">const</span>     <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> ptr<span class="token operator">!=</span>i<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-迭代器相应型别"><a href="#3-2-迭代器相应型别" class="headerlink" title="3.2 迭代器相应型别"></a>3.2 迭代器相应型别</h2><blockquote><p>算法之中运用迭代器时，很可能会用到其相应型别，即便动用 RTTI 性质中的typeid()，获得的也只是型别名称，不能拿来做变量宣告之用。</p></blockquote><p>解决办法是：利用 function template 的自变量推导机制</p><p>例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">func_impl</span><span class="token punctuation">(</span>I iter<span class="token punctuation">,</span> T t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  T tmp<span class="token punctuation">;</span>  <span class="token comment">// 这里解决了问题。T就是迭代器所指之物的型别，ᴀ例为 int</span>  <span class="token comment">// ... 这里做原ᴀ func()应该做的全部工作</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>I iter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">func_impl</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> <span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// func 的工作全部移往 func_impl</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-Traits-编程技法"><a href="#3-3-Traits-编程技法" class="headerlink" title="3.3 Traits 编程技法"></a>3.3 Traits 编程技法</h2><blockquote><p>上述的自变量型别推导技巧虽然可用于 <em>value type</em>，却非全面可用：万一<em>value type</em>必须用于函式的传回值，就束手无策了，毕竟函式的「template 自变量推导机制」推而导之的只是自变量，无法推导函式的回返值型别。</p></blockquote><p>因此直接定义类型可以很好解决这个问题</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">MyIter</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span>  <span class="token comment">// 巢状型别宣告（nested type）</span>  T<span class="token operator">*</span> ptr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是并不是所有迭代器都是 class type，如原生指标就不是，无法对其定义类型（如int 不是类），使用偏特化来解决这个问题。</p><blockquote><p><strong>Partial Specialization（偏特化）</strong></p><p>如果 class template拥有一个以上的 template 参数，我们可以针对其中某个（或数个，但非全部）template参数进行特化工作。也就是为模板提供一个特别版本。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 这个泛化版ᴀ允许（接受）T为任何型别</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 这个特化版ᴀ仅适用于「T为原生指标」的情况</span><span class="token comment">// 「T为原生指标」便是「T 为任何型别」的一个更进一步的条件限制</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><strong>trait定义</strong></p><pre class="line-numbers language-none"><code class="language-none">template &lt;class I&gt;struct iterator_traits &#123;  &#x2F;&#x2F; traits 意为「特性」  typedef typename I::value_type value_type;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>traits意义在于，如果I定义有自己的value type,那么通过这个traits的作用，萃取出来的value_type就是I::value_type。trait这样设计在于可以拥有特例化版本，<strong>如为基本类型设计特化版本及为常量对象或指针设计非常量的版本</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103205014421.png"></p><p>最常用到的迭代器相应型别有五种：<em>value type</em>, <em>difference type</em>, <em>pointer</em>, <em>reference</em>,<em>iterator catagoly</em></p><ul><li><em>value type</em>，是指迭代器所指对象的型别</li><li><em>difference type</em> ，用来表示两个迭代器之间的距离，也因此，它可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。</li><li><em>reference type</em>，即所指对象的引用类型</li><li><em>pointer type</em>，即所指对象的指针类型</li><li><em>iterator_category</em>，主要用于大规模的迭代器，当迭代器是继承类型时，基类定义的指针无法知道到底是子类或父类，因此定义此类型进行说明，STL中针对子类或父类的迭代器具有不同优化</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>iterator_category iterator_category<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>value_type value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>difference_type difference_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>pointer pointer<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>reference reference<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>iterator_traits必须针对传入之型别为 pointer 及 pointer-to-const者，设计特化版本</p></blockquote><p>根据移动特性与施行操作，迭代器被分为5类：</p><ul><li>input iterator:这种迭代器所指的对象，不允许外界改变。只读(read only)</li><li>output Iterator:唯写(write only)</li><li>Forward Iterator:允许“写入型”算法(如replace())在此种迭代器所形成的区间上进行读写操作。</li><li>Bidirectional Iterator:可以双向移动。某些算法需要逆向走访某个迭代器区间(例如逆向拷贝某范围内的元素)，可以使用Bidirectional Iterators。</li><li>Random Access Iterator: 前四中迭代器都只提供一部分指针算术能力，第五种则涵盖所有指针和算术能力，包括p+n,p-n,p[n],p1-p2,p1小于p2。</li></ul><p>以 class 来定义迭代器的各种分类标签，不唯可以促成多载化机制的成功运作（使编译器得以正确执行多载程序，且透过继承，我们可以不必再写「单纯只做转呼叫」的函式）</p><h2 id="3-4-std-iterator-的保证"><a href="#3-4-std-iterator-的保证" class="headerlink" title="3.4 std::iterator 的保证"></a>3.4 std::iterator 的保证</h2><p>STL提供了一个iterator class 。每个新设计的迭代器都继承自它，可以保证STL所需之规范</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Category</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span> <span class="token operator">=</span> ptrdiff_t<span class="token punctuation">,</span>          <span class="token keyword">class</span> <span class="token class-name">Pointer</span> <span class="token operator">=</span> T<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Reference</span> <span class="token operator">=</span> T<span class="token operator">&amp;</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">iterator</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> Category iterator_category<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> Distance difference_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> Pointer pointer<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> Reference reference<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 使用</span>std<span class="token double-colon punctuation">::</span>iterator<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>forward_iterator_tag<span class="token punctuation">,</span> Item<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5-type-traits"><a href="#3-5-type-traits" class="headerlink" title="3.5  __type_traits"></a>3.5  __type_traits</h2><p>iterator_traits负责萃取迭代器的特性，__type_traits则负责萃取型别(type)的特性。它提供了一种机制，允许针对不同的型别属性，在编译时期完成函数派送决定。</p><blockquote><p>例如萃取此类型是否具备non-trivial defalt ctor ？是否具备 non-trivial copy ctor？是否具备 non-trivial assignment operator？是否具备 non-trivial dtor？</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">type</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">__type_traits</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> __true_type this_dummy_member_must_be_first<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __false_type has_trivial_default_constructor<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __false_type has_trivial_copy_constructor<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __false_type has_trivial_assignment_operator<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __false_type has_trivial_destructor<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __false_type is_POD_type<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SGI 把所有巢状型别都定义为false _type，然后然后（稍后可见）再针对每一个纯量型别（scalar types）设计适当的type_traits特化版</p><h1 id="四、序列式容器"><a href="#四、序列式容器" class="headerlink" title="四、序列式容器"></a>四、序列式容器</h1><blockquote><p>所谓序列式容器，其中的元素都可序（<em>ordered</em>），但᳾排序（<em>sorted</em>）。C++ 语言本身提供了一个序列式容器array，STL另外再提供vector,list,deque, stack,queue,priority-queue等等序列式容器。其中stack和queue由于只是将deque改头换面而成，技术上被归类为一种配接器（adapter），</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103211215851.png"></p><h2 id="4-1-vector"><a href="#4-1-vector" class="headerlink" title="4.1 vector"></a>4.1 vector</h2><blockquote><p>vector的数据安排以及操作方式，与array非常像似。两者的唯一差别在于空间的运用弹性。array是静态空间，一旦配置了就不能改变，而vector会自行扩充空间以容纳新元素。</p></blockquote><p><strong>vector迭代器</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> classAlloc <span class="token operator">=</span> alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> value_type<span class="token operator">*</span> iterator<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vector维护的是一个连续线性空间，所以不论其元素型别为何，原生指标都可以做为 vector的迭代器而满足所有必要条件，因此其迭代器都是元素类型的对应指针</p><p><strong>vector数据结构</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">&#123;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  <span class="token comment">// 目前使用的空间的头部</span>  iterator start<span class="token punctuation">;</span>  <span class="token comment">// 目前使用的空间的尾部</span>  iterator finish<span class="token punctuation">;</span>  <span class="token comment">// 目前可用空间的尾部</span>  iterator end_of_storage<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>以两个迭代器start和finish分别指向配置得来的连续空间中目前已经被使用的范围，并以迭代器end_of_storage指向整块连续空间(含备用空间)的尾端，</li><li>了方便扩充，vector实际配置的大小(capacity)可能比客户端需求更大一些，以备将来可能的扩充。</li><li>vector的容量永远大于或等于其大小。一旦容量等于大小，便是满载，下次再有新增元素，整个vector就要进行搬移。即capacity&gt;size永远成立</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103215724632.png"></p><p><strong>vector 的建构与内存管理constructor、push_back</strong> </p><p>vector预设使用alloc做为空间配置器，并据此另外定义了一个data_allocator，为的是更方便以元素大小为配置单位</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> classAlloc <span class="token operator">=</span> alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">&#123;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  <span class="token comment">// simple_alloc&lt;> 见 2.2.4 节</span>  <span class="token keyword">typedef</span> simple_alloc<span class="token operator">&lt;</span>value_type<span class="token punctuation">,</span> Alloc<span class="token operator">></span> data_allocator<span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>constructor函数会先调用data_allocator::allocate(n)配置内存，然后调用uninitialized_fill_n填充元素，其会根据第一参数的型别特性，决定使用算法 fill_n()或反复呼叫 construct() 来完成任务</p><p>push_back代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>finish <span class="token operator">!=</span> end_of_storage<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 还有备用空间</span>    <span class="token function">construct</span><span class="token punctuation">(</span>finish<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>finish<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>    <span class="token function">insert_aux</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// vector member function，见以下列表</span><span class="token punctuation">&#125;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">vector</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">insert_aux</span><span class="token punctuation">(</span>iterator position<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>finish <span class="token operator">!=</span> end_of_storage<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 还有备用空间</span>    <span class="token comment">// 在备用空间起始处建构一个元素，并以 vector 最后一个元素值为其初值。</span>    <span class="token function">construct</span><span class="token punctuation">(</span>finish<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>finish <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调整水位。</span>    <span class="token operator">++</span>finish<span class="token punctuation">;</span>    T x_copy <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token function">copy_backward</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> finish <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> finish <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>position <span class="token operator">=</span> x_copy<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 已无备用空间</span>    <span class="token keyword">const</span> size_type old_size <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> size_typelen <span class="token operator">=</span> old_size <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">*</span> old_size <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 以上配置原则：如果原大小为 0，则配置 1（个元素大小）；</span>    <span class="token comment">// 如果原大小不为 0，则配置原大小的两倍，</span>    <span class="token comment">// 前半段用来放置原资料，后半段准备用来放置新资料。</span>    iterator new_start <span class="token operator">=</span> data_allocator<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 实际配置</span>    iterator new_finish <span class="token operator">=</span> new_start<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 将原 vector 的内容拷贝到新 vector。</span>      new_finish <span class="token operator">=</span> <span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> position<span class="token punctuation">,</span> new_start<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 为新元素设定初值 x</span>      <span class="token function">construct</span><span class="token punctuation">(</span>new_finish<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 调整水位</span>      <span class="token operator">++</span>new_finish<span class="token punctuation">;</span>      <span class="token comment">// 将原 vector 的备用空间中的内容也忠实拷贝过来（侯捷疑惑：啥用途？）</span>      new_finish <span class="token operator">=</span> <span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> finish<span class="token punctuation">,</span> new_finish<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// "commit or rollback" semantics.</span>      <span class="token function">destroy</span><span class="token punctuation">(</span>new_start<span class="token punctuation">,</span> new_finish<span class="token punctuation">)</span><span class="token punctuation">;</span>      data_allocator<span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>new_start<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">throw</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 解构并释放原 vector</span>    <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调整迭代器，指向新 vector</span>    start <span class="token operator">=</span> new_start<span class="token punctuation">;</span>    finish <span class="token operator">=</span> new_finish<span class="token punctuation">;</span>    end_of_storage <span class="token operator">=</span> new_start <span class="token operator">+</span> len<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，所谓动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后建构新元素，并释放原空间。</p><p>因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了</p></blockquote><p><strong>vector 的元素操作: pop_back, erase, clear, insert</strong> </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 将尾端元素拿掉，并调整大小。</span><span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token operator">--</span>finish<span class="token punctuation">;</span>  <span class="token function">destroy</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 将尾端标记往前移一格，表示将放弃尾端元素。</span><span class="token comment">//  destroy是全域函式，见第 2 章</span><span class="token comment">//  清除 [first,last) 中的所有元素</span>iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator first<span class="token punctuation">,</span> iterator last<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  iterator i <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>last<span class="token punctuation">,</span> finish<span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// copy 是全域函式，第 6 章</span>  <span class="token function">destroy</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> finish<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// destroy是全域函式，第 2 章</span>  finish <span class="token operator">=</span> finish <span class="token operator">-</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> first<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 清除某个位置上的元素</span>iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator position<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">copy</span><span class="token punctuation">(</span>position <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> finish<span class="token punctuation">,</span> position<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// copy 是全域函式，第 6 章</span>  <span class="token operator">--</span>finish<span class="token punctuation">;</span>  <span class="token function">destroy</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// destroy是全域函式，2.2.3 节</span>  <span class="token keyword">return</span> position<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// erase()就定义在上面</span><span class="token comment">//从 position 开始，安插 n个元素，元素初值为 x</span><span class="token comment">//函数里面分为了三种情况分别讨论，主要逻辑都是先将插入点以后的元素先拷贝到后面，然后再进行插入</span><span class="token keyword">void</span> <span class="token class-name">vector</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">insert</span><span class="token punctuation">(</span>iterator position<span class="token punctuation">,</span> size_type n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-list"><a href="#4-2-list" class="headerlink" title="4.2 list"></a>4.2 list</h2><blockquote><p>相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次安插或删除一个元素，就配置或释放一个元素空间。</p></blockquote><p><strong>list节点数据结构</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">__list_node</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token operator">*</span> void_pointer<span class="token punctuation">;</span>  void_pointer prev<span class="token punctuation">;</span>  <span class="token comment">// 型别为 void*。其实可设为 __list_node&lt;T>*</span>  void_pointer next<span class="token punctuation">;</span>  T data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>list 迭代器</strong></p><ul><li><p>由于STL list是一个双向串行，迭代器必须具备前移、后移的能力。所以list提供的是<em>Bidirectional Iterator</em>s。</p></li><li><p>list有一个重要性质：insert和splice都不会造成原有的list迭代器失效。</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ref</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ptr</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">__list_iterator</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> __list_node<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> link_type<span class="token punctuation">;</span>  link_type node<span class="token punctuation">;</span>  <span class="token comment">// 迭代器内部当然要有一个原生指标，指向 list 的节点</span>      <span class="token comment">// constructor</span>  <span class="token function">__list_iterator</span><span class="token punctuation">(</span>link_type x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token function">__list_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token function">__list_iterator</span><span class="token punctuation">(</span><span class="token keyword">const</span> iterator<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">node</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> node <span class="token operator">==</span> x<span class="token punctuation">.</span>node<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> node <span class="token operator">!=</span> x<span class="token punctuation">.</span>node<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 以下对迭代器取值（dereference），取的是节点的资料值。</span>  referenceoperator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 以下是迭代器的成员存取（member access）运算子的标准作法。</span>  pointeroperator<span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 对迭代器累加 1，就是前进一个节点</span>  self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    node <span class="token operator">=</span> <span class="token punctuation">(</span>link_type<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  self <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    self tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 对迭代器递减 1，就是后退一个节点</span>  self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span> node <span class="token operator">=</span> <span class="token punctuation">(</span>link_type<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  self <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> self tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span> <span class="token punctuation">&#123;</span>    <span class="token operator">--</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>list 数据结构</strong></p><p>SGI list不仅是一个双向串行，而且还是一个环状双向串行。所以它只需要一个指标，便可以完整表现整个串行</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> classAlloc <span class="token operator">=</span> alloc<span class="token operator">></span>  <span class="token comment">// 预设使用 alloc 为配置器</span><span class="token keyword">class</span> <span class="token class-name">list</span> <span class="token punctuation">&#123;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> __list_node<span class="token operator">&lt;</span>T<span class="token operator">></span> list_node<span class="token punctuation">;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> list_node<span class="token operator">*</span> link_type<span class="token punctuation">;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  link_type node<span class="token punctuation">;</span>  <span class="token comment">// 只要一个指标，便可表示整个环状双向串行</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230104194612566.png"></p><p><strong>list 构建与内存管理</strong></p><p>list为了方便空间配置器，额外定义了一个list_node_allocator，为的就是更方便地以节点大小为配置单位；</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">protected</span><span class="token operator">:</span><span class="token comment">// 配置一个节点并传回</span>link_type <span class="token function">get_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> list_node_allocator<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">// 释放一个节点</span><span class="token keyword">void</span> <span class="token function">put_node</span><span class="token punctuation">(</span>link_type p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> list_node_allocator<span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">// 产生(配置并构造)一个节点，带有元素值</span>link_type <span class="token function">create_node</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  link_type p <span class="token operator">=</span> <span class="token function">get_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 全局函数，构造/析构函数</span>  <span class="token function">construct</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>data<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 销毁一个节点</span><span class="token keyword">void</span> <span class="token function">destroy_node</span><span class="token punctuation">(</span>link_type p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 析构函数</span>  <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">put_node</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>list提供多个构造函数，default constructor允许我们不指定任何参数做出一个空的list出来。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230104194844419.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230104195030270.png"></p><p><strong>list 操作函数</strong></p><blockquote><p>提供push_front, push_back, erase, pop_front, pop_back,  clear, remove, unique, splice, merge, reverse, sort 等函数</p></blockquote><p>由于list是一个双向环状串行，只要我们把边际条件处理好，那么，在头部或尾部安插元素或移除元素，动作也几乎是一样的。移除（erase）某个迭代器所指元素，只是做一些指标搬移动作而已。</p><p>list这些操作很多都只是对指针进行操作，源代码太多了，见书上</p><p>list内部提供一个transfer操作；将某个连续范围的元素迁移到某个特定位置之前，迁移的元素可以是同一个list也可以是不同list</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// typedef list_node* link_type;</span><span class="token comment">// 将 [first,last) 内的所有元素搬移到 position 之前。</span><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>iterator position<span class="token punctuation">,</span> iterator first<span class="token punctuation">,</span> iterator last<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">!=</span> last<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">link_type</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>last<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> position<span class="token punctuation">.</span>node<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">link_type</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> last<span class="token punctuation">.</span>node<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">link_type</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>position<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> first<span class="token punctuation">.</span>node<span class="token punctuation">;</span>    link_type tmp <span class="token operator">=</span> <span class="token function">link_type</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>position<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>last<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230104195805857.png"></p><p>splice函数提供了诸多版本，但内部都是都是使用的transfer来进行操作</p><p>merge函数：将另一个list合并到当前list，前提是两个list都必须经过递增排序，内部实现也使用了transfer进行节点变换</p><p>sort函数：list 不能使用 STL 算法 sort()，必须使用自己的 sort() member function。因为 STL 算法 sort() 只接受 RamdonAccessIterator。</p><h2 id="4-3-deque"><a href="#4-3-deque" class="headerlink" title="4.3 deque"></a>4.3 deque</h2><p>deque则是一种双向开口的连续线性空间，可以在头尾两端分别做元素的安插和删除动作</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105205751267.png"></p><p>deque和vector的最大差异：</p><ul><li>于deque允许于常数时间内对起头端进行元素的安插或移除动作</li><li>deque没有所谓容量（capacity）观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来</li></ul><p>应尽可能选择使用vector而非deque。</p><p>对 deque进行的排序动作，为了最高效率，可将deque先完整复制到一个 vector 身上，将vector排序后（利用 STL sort算法），再复制回 deque。</p><p><strong>deque数据结构</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> classAlloc <span class="token operator">=</span> alloc<span class="token punctuation">,</span> size_t BufSiz <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">deque</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment">// Basic types</span>  <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> value_type<span class="token operator">*</span> pointer<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> size_t size_type<span class="token punctuation">;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment">// Iterators</span>  <span class="token keyword">typedef</span> __deque_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token punctuation">,</span> BufSiz<span class="token operator">></span> iterator<span class="token punctuation">;</span> <span class="token keyword">protected</span><span class="token operator">:</span>                      <span class="token keyword">typedef</span> pointer<span class="token operator">*</span> map_pointer<span class="token punctuation">;</span>  <span class="token comment">// 元素的指针的指针（pointer of pointer of T）</span> <span class="token keyword">protected</span><span class="token operator">:</span>         <span class="token comment">// Data members</span>  iterator start<span class="token punctuation">;</span>   <span class="token comment">// 表现第一个节点。</span>  iterator finish<span class="token punctuation">;</span>  <span class="token comment">// 表现最后一个节点。</span>  map_pointer map<span class="token punctuation">;</span>  <span class="token comment">// 指向 map，map 是块连续空间，</span>                    <span class="token comment">// 其每个元素都是个指针，指向一个节点（缓冲区）。</span>  size_type map_size<span class="token punctuation">;</span>  <span class="token comment">// map 内有多少指标。</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>deque 的中控器</strong></p><p>中控器即为数据结构中的map，其是指针的指针。</p><p>deque系由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的界面。</p><p>deque采用一块所谓的<em>map</em>（不是 STL 的map容器）做为主控。map*是一小块连续空间，其中每个元素（node）都是指针，指向另一段连续线性空间，称为缓冲区。缓冲区才是deque的储存空间主体。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105210422569.png"></p><p><strong>deque 的迭代器</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ref</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ptr</span><span class="token punctuation">,</span> size_t BufSiz<span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">__deque_iterator</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 保持与容器的联结</span>  T<span class="token operator">*</span> cur<span class="token punctuation">;</span>    <span class="token comment">// 此迭代器所指之缓冲区中的现行（current）元素</span>  T<span class="token operator">*</span> first<span class="token punctuation">;</span>  <span class="token comment">// 此迭代器所指之缓冲区的头</span>  T<span class="token operator">*</span> last<span class="token punctuation">;</span>   <span class="token comment">// 此迭代器所指之缓冲区的尾（含备用空间）</span>  map_pointer node<span class="token punctuation">;</span>  <span class="token comment">// 指向管控中心</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105211525843.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105211700125.png"></p><p>迭代器关键代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 更换缓冲区</span><span class="token keyword">void</span> <span class="token function">set_node</span><span class="token punctuation">(</span>map_pointer new_node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  node <span class="token operator">=</span> new_node<span class="token punctuation">;</span>  first <span class="token operator">=</span> <span class="token operator">*</span>new_node<span class="token punctuation">;</span>  last <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token function">difference_type</span><span class="token punctuation">(</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>difference_type <span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">difference_type</span><span class="token punctuation">(</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>node <span class="token operator">-</span> x<span class="token punctuation">.</span>node <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>cur <span class="token operator">-</span> first<span class="token punctuation">)</span> <span class="token operator">+</span>         <span class="token punctuation">(</span>x<span class="token punctuation">.</span>last <span class="token operator">-</span> x<span class="token punctuation">.</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token operator">++</span>cur<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> last<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 切换至下一个元素。</span>    <span class="token comment">// 如果已达所在缓冲区的尾端，</span>    <span class="token function">set_node</span><span class="token punctuation">(</span>node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 就切换至下一节点（亦即缓冲区）</span>    cur <span class="token operator">=</span> first<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 的第一个元素。</span>self <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 后置式，标准写法</span>  self tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span>difference_type n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  difference_type offset <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token punctuation">(</span>cur <span class="token operator">-</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> offset <span class="token operator">&lt;</span> <span class="token function">difference_type</span><span class="token punctuation">(</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 标的位置在同一缓冲区内</span>    cur <span class="token operator">+=</span> n<span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 标的位置不在同一缓冲区内</span>    difference_type node_offset <span class="token operator">=</span>        offset <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> offset <span class="token operator">/</span> <span class="token function">difference_type</span><span class="token punctuation">(</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token operator">:</span> <span class="token operator">-</span><span class="token function">difference_type</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-</span>offset <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 切换至正确的节点（亦即缓冲区）</span>    <span class="token function">set_node</span><span class="token punctuation">(</span>node <span class="token operator">+</span> node_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 切换至正确的元素</span>    cur <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token punctuation">(</span>offset <span class="token operator">-</span> node_offset <span class="token operator">*</span> <span class="token function">difference_type</span><span class="token punctuation">(</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>deque 构造与内存管理</strong></p><p>deque构造时，先申请map的空间和最少8个缓存区的空间，然后将start和finish指向map的中间段</p><p>其内存管理示例如下图</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>finish<span class="token punctuation">.</span>cur <span class="token operator">!=</span> finish<span class="token punctuation">.</span>last <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 最后缓冲区尚有一个以上的备用空间</span>    <span class="token function">construct</span><span class="token punctuation">(</span>finish<span class="token punctuation">.</span>cur<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 直接在备用空间上建构元素</span>    <span class="token operator">++</span>finish<span class="token punctuation">.</span>cur<span class="token punctuation">;</span>              <span class="token comment">// 调整最后缓冲区的使用状态</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>  <span class="token comment">// 最后缓冲区已无（或只剩一个）元素备用空间。</span>    <span class="token function">push_back_aux</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先向其添加3个元素：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105213342457.png"></p><p>再向尾部插入一个元素，若当前缓冲区只剩一个空间时，则先申请一个新的缓存区（申请前会判断map是否需要扩容），将需要添加的值置于最后一个空间处，然后将finsh指向新申请的缓冲区</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105214237534.png"></p><p>再向前端插入一个元素，由于此时第一缓冲区无空间，因此申请一个新的缓冲区（申请前会判断map是否需要扩容），然后将start指向新缓冲区，并将strart.cur指向末尾。此时插入一个元素</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105214649662.png"></p><blockquote><p>什么时候需要将map更换空间？</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reserve_map_at_back</span><span class="token punctuation">(</span>size_type nodes_to_add <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>nodes_to_add <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> map_size <span class="token operator">-</span> <span class="token punctuation">(</span>finish<span class="token punctuation">.</span>node <span class="token operator">-</span> map<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 如果 map尾端的节点备用空间不足</span>    <span class="token comment">// 符合以上条件则必须重换一个 map（配置更大的，拷贝原来的，释放原来的）</span>    <span class="token function">reallocate_map</span><span class="token punctuation">(</span>nodes_to_add<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">reserve_map_at_front</span><span class="token punctuation">(</span>size_type nodes_to_add <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>nodes_to_add <span class="token operator">></span> start<span class="token punctuation">.</span>node <span class="token operator">-</span> map<span class="token punctuation">)</span>    <span class="token comment">// 如果 map前端的节点备用空间不足</span>    <span class="token comment">// 符合以上条件则必须重换一个 map（配置更大的，拷贝原来的，释放原来的）</span>    <span class="token function">reallocate_map</span><span class="token punctuation">(</span>nodes_to_add<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//reallocate_map主要是分配一段新的空间，然后将原map拷贝过去，并将start和finish更新</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><strong>deque的操作函数</strong></p><p>pop_back()函数，pop_front类似，都需要判断是否到需要删除当前缓冲区</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>finish<span class="token punctuation">.</span>cur <span class="token operator">!=</span> finish<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 最后缓冲区有一个（或更多）元素</span>    <span class="token operator">--</span>finish<span class="token punctuation">.</span>cur<span class="token punctuation">;</span>  <span class="token comment">// 调整指针，相当于排除了最后元素</span>  <span class="token punctuation">&#125;</span>  <span class="token function">destroy</span><span class="token punctuation">(</span>finish<span class="token punctuation">.</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将最后元素解构</span>  <span class="token keyword">else</span>      <span class="token comment">// 最后缓冲区没有任何元素</span>      <span class="token function">pop_back_aux</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 这里将进行缓冲区的释放工作</span><span class="token comment">// 只有当 finish.cur == finish.first 时才会被呼叫。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token punctuation">,</span> size_t BufSize<span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">deque</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token punctuation">,</span> BufSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">pop_back_aux</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">deallocate_node</span><span class="token punctuation">(</span>finish<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 释放最后一个缓冲区</span>  finish<span class="token punctuation">.</span><span class="token function">set_node</span><span class="token punctuation">(</span>finish<span class="token punctuation">.</span>node <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调整 finish 的状态，使指向</span>  finish<span class="token punctuation">.</span>cur <span class="token operator">=</span> finish<span class="token punctuation">.</span>last <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">destroy</span><span class="token punctuation">(</span>finish<span class="token punctuation">.</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>clear函数会保留一个缓冲区，而将其他缓冲区释放</p><p>erase()：用来清除某个元素或清楚一个范围的元素，为了效率其会比较移动首部还是尾部</p><p>insert()：用来插入元素，为了效率会判断是移动首部还是尾部</p><h2 id="4-4-stack"><a href="#4-4-stack" class="headerlink" title="4.4 stack"></a>4.4 stack</h2><blockquote><p>stack是一种先进后出（First In Last Out，FILO）的数据结构。</p><p>SGI STL以deque做为预设情况下的stack底部结构</p><p>由于stack系以底部容器完成其所有工作，而具有这种「修改某物接口，形成另一种风貌」之性质者，称为adapter（配接器）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106193937615.png"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//stack主要函数</span><span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token function">size_typesize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token function">referencetop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token function">const_referencetop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">// deque是两头可进出，stack是᳿端进，᳿端出（所以后进者先出）。</span><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> c<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>stack 没有迭代器</strong></p><p>stack不提供遍历功能，也不提供迭代器。</p><p><strong>list也可做为stack 的底层容器</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> istack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-5-queue"><a href="#4-5-queue" class="headerlink" title="4.5 queue"></a>4.5 queue</h2><blockquote><p>queue是一种先进先出（First In First Out，FIFO）的数据结构。</p><p>SGI STL 以deque做为预设情况下的queue底部结构</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106194006925.png"></p><p>queue函数主要是对deque的封装</p><p><strong>queue 没有迭代器</strong></p><p><strong>list也可做为queue 的底层容器</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> iqueue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-6-heap"><a href="#4-6-heap" class="headerlink" title="4.6 heap"></a>4.6 heap</h2><blockquote><p>heap并不归属于STL 容器组件，它是priority queue的底层</p><p>binary heap就是一种完全二叉树</p></blockquote><ul><li>max-heap: 每个节点键值都大于或者等于其子节点的键值</li><li>min-heap: 每个节点键值都小于或者等于其子节点的键值</li></ul><p><strong>完全二叉树可以用数组进行存储</strong></p><p>将0保留，使用arry的i表示某一个节点，那么左子节点就必须位于array的2i处，右子节点必须位于array的2i+1处。 </p><p><strong>push_heap 算法</strong></p><p>新元素安插在末尾处，然后不断和父节点比较，从而判断是否需要交换位置</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106194648317.png"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">void__push_heap</span><span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> Distance holeIndex<span class="token punctuation">,</span>                Distance topIndex<span class="token punctuation">,</span> T value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Distance parent <span class="token operator">=</span> <span class="token punctuation">(</span>holeIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 找出父节点</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>holeIndex <span class="token operator">></span> topIndex <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> parent<span class="token punctuation">)</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当尚᳾到达顶端，且父节点小于新值（于是不符合 heap</span>    <span class="token comment">// 的次序特性） 由于以上使用 operator&lt;，可知 STL heap 是一种</span>    <span class="token comment">// max-heap（大者为父）。</span>    <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> holeIndex<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 令洞值为父值</span>    holeIndex <span class="token operator">=</span> parent<span class="token punctuation">;</span>  <span class="token comment">// percolate up：调整洞号，向上提升至父节点。</span>    parent <span class="token operator">=</span> <span class="token punctuation">(</span>holeIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 新洞的父节点</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 持续至顶端，或满足 heap 的次序特性为止。</span>  <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> holeIndex<span class="token punctuation">)</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token comment">// 令洞值为新值，完成安插动作。</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>pop_heap 算法</strong></p><p>先将根节点与最末尾值交换，然后将新的根节点不断进行下沉，由于新根节点一定被放在叶子节点上，因此不断将其左右子节点较大值与其交换即可。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106195126838.png"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token function">void__adjust_heap</span><span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> Distance holeIndex<span class="token punctuation">,</span> Distance len<span class="token punctuation">,</span>                  T value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Distance topIndex <span class="token operator">=</span> holeIndex<span class="token punctuation">;</span>  Distance secondChild <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> holeIndex <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 洞节点之右子节点</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>secondChild <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 比较洞节点之左右两个子值，然后以 secondChild代表较大子节点。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> secondChild<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> <span class="token punctuation">(</span>secondChild <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> secondChild<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token comment">// Percolate down：令较大子值为洞值，再令洞号下移至较大子节点处。</span>    <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> holeIndex<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> secondChild<span class="token punctuation">)</span><span class="token punctuation">;</span>    holeIndex <span class="token operator">=</span> secondChild<span class="token punctuation">;</span>    <span class="token comment">// 找出新洞节点的右子节点</span>    secondChild <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span>secondChild <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>secondChild <span class="token operator">==</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 没有右子节点，只有左子节点</span>    <span class="token comment">// Percolate down：令左子值为洞值，再令洞号下移至左子节点处。</span>    <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> holeIndex<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> <span class="token punctuation">(</span>secondChild <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    holeIndex <span class="token operator">=</span> secondChild <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 将欲调整值填入目前的洞号内。注意，此时肯定满足次序特性。</span>  <span class="token comment">// 依侯捷之见，下面直接改为 *(first + holeIndex) = value; 应该可以。</span>  <span class="token function">__push_heap</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> holeIndex<span class="token punctuation">,</span> topIndex<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，pop_heap之后，最大元素只是被置放于底部容器的最尾端，尚未被取走</p><p><strong>sort_heap 算法</strong></p><p>每次pop_heap可获得 heap之中键值最大的元素，如果持续对整个 heap做pop_heap动作，每次将操作范围从后向前缩减一个元素（因为 pop_heap 会把键值最大的元素放在底部容器的最尾端），当整个程序执行完毕，便得到一个递增序列。</p><p><strong>make_heap 算法</strong></p><p>在需要形成堆的数组中，对前半部分中的每个值都进行下沉，便可形成最大堆或最小堆。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">__make_heap</span><span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token punctuation">,</span>                Distance<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// 如果长度为 0或 1，不必重新排列。</span>  Distance len <span class="token operator">=</span> last <span class="token operator">-</span> first<span class="token punctuation">;</span>  <span class="token comment">// 找出第一个需要重排的子树头部，以 parent 标示出。由于任何叶节点都不需执行</span>  <span class="token comment">// perlocate down，所以有以下计算。parent命名不佳，名为 holeIndex更好。</span>  Distance parent <span class="token operator">=</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 重排以 parent 为首的子树。len 是为了让 __adjust_heap()判断操作范围</span>    <span class="token function">__adjust_heap</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// 走完根节点，就结束。</span>    parent<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>heap 没有迭代器</strong></p><h2 id="4-7-priority-queue"><a href="#4-7-priority-queue" class="headerlink" title="4.7 priority_queue"></a>4.7 priority_queue</h2><blockquote><p>priority_queue是一个拥有权值观念的 queue，只允许在底端加入元素，并从顶端取出元素</p><p>预设情况下priority_queue利用一个max-heap 完成，后者是一个以 vector 为底层的 complete binary tree</p><p>priority_queue是适配器，而非容器</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106195927269.png"></p><p>关键代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Sequence</span> <span class="token operator">=</span> vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span>          <span class="token keyword">class</span> <span class="token class-name">Compare</span> <span class="token operator">=</span> less<span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Sequence</span><span class="token double-colon punctuation">::</span>value_type<span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">priority_queue</span> <span class="token punctuation">&#123;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  Sequence c<span class="token punctuation">;</span>    <span class="token comment">// 底层容器</span>  Compare comp<span class="token punctuation">;</span>  <span class="token comment">// 元素大小比较标准</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">priority_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">explicit</span> <span class="token function">priority_queue</span><span class="token punctuation">(</span><span class="token keyword">const</span> Compare<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">comp</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token comment">// 以下用到的 make_heap(), push_heap(), pop_heap()都是泛型算法</span>  <span class="token comment">// 注意，任一个建构式都立刻于底层容器内产生一个 implicit representation heap。</span>  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token operator">></span>  <span class="token function">priority_queue</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span> <span class="token keyword">const</span> Compare<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>      <span class="token operator">:</span> <span class="token function">c</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">comp</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">make_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token operator">></span>  <span class="token function">priority_queue</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">c</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">make_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token function">size_typesize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token function">const_referencetop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    __STL_TRY <span class="token punctuation">&#123;</span>      c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// push_heap是泛型算法，先利用底层容器的 push_back() 将新元素</span>      <span class="token function">push_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// push_heap是泛型算法，推入末端，再重排 heap</span>    <span class="token punctuation">&#125;</span>    <span class="token function">__STL_UNWIND</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    __STL_TRY <span class="token punctuation">&#123;</span>      <span class="token function">pop_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// pop_heap 是泛型算法，从 heap 内取出一个元素。它并不是真正将元素</span>      c<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 弹出，并重排 heap，然后再以底层容器的 pop_back() 取得被弹出的元素</span>    <span class="token punctuation">&#125;</span>    <span class="token function">__STL_UNWIND</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>priority_queue 没有迭代器</strong></p><h2 id="4-8-slist"><a href="#4-8-slist" class="headerlink" title="4.8 slist"></a>4.8 slist</h2><blockquote><p>slist是一个单向串行链表，并非STL规定</p><p>slist和list的主要差别在于，前者的迭代器属于单向的 <em>Forward Iterator</em>，后者的迭代器属于双向的<em>Bidirectional Iterator</em></p></blockquote><p>除了slist起始处附近的区域之外，在其它位置上采用insert 或erase 操作函式，都是不智之举</p><p>slist不提供 push_back()，只提供 push_front()</p><p><strong>slist 数据结构</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">slist</span> <span class="token punctuation">&#123;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">static</span> list_node<span class="token operator">*</span> <span class="token function">create_node</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    list_node<span class="token operator">*</span> node <span class="token operator">=</span> list_node_allocator<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 配置空间</span>    __STL_TRY <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">construct</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>node<span class="token operator">-></span>data<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 建构元素</span>    <span class="token function">__STL_UNWIND</span><span class="token punctuation">(</span>list_node_allocator<span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">destroy_node</span><span class="token punctuation">(</span>list_node<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>node<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将元素解构</span>  <span class="token punctuation">&#125;</span>  list_node_allocator<span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 释还空间</span> <span class="token keyword">private</span><span class="token operator">:</span>  list_node_base head<span class="token punctuation">;</span>  <span class="token comment">// 头部。注意，它不是指标，是实物。</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">slist</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token operator">~</span><span class="token function">slist</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>slist node</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106200611744.png"></p><p><strong>slist 迭代器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106200709076.png"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">__slist_iterator_base</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> size_t size_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> ptrdiff_t difference_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> forward_iterator _tagiterator_category<span class="token punctuation">;</span>  <span class="token comment">// 注意，单向</span>  __slist_node_base<span class="token operator">*</span> node<span class="token punctuation">;</span>                       <span class="token comment">// 指向节点基ᴀ结构</span>  <span class="token function">__slist_iterator_base</span><span class="token punctuation">(</span>__slist_node_base <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">incr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> node <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 前进一个节点</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> __slist_iterator_base<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> node <span class="token operator">==</span> x<span class="token punctuation">.</span>node<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> __slist_iterator_base<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> node <span class="token operator">!=</span> x<span class="token punctuation">.</span>node<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较两个slist迭代器是否等同时，其实是比较指向的node是否相同</p><p><strong>注意</strong>，调用slist的end()时，会创建一个新的值为0的node</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">typedef</span> __slist_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token operator">></span> iterator<span class="token punctuation">;</span><span class="token generic-function"><span class="token function">__slist_iterator</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//产生一个暂时对象，引发 ctor</span><span class="token function">__slist_iterator</span><span class="token punctuation">(</span>list_node<span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">__slist_iterator_base</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>struct__slist_iterator_base <span class="token punctuation">&#123;</span>  __slist_node_base<span class="token operator">*</span> node<span class="token punctuation">;</span>  <span class="token comment">// 指向节点基ᴀ结构</span>  <span class="token function">__slist_iterator_base</span><span class="token punctuation">(</span>__slist_node_base <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、关联式容器"><a href="#五、关联式容器" class="headerlink" title="五、关联式容器"></a>五、关联式容器</h1><p>当元素被插入到关联式容器中时，容器内部结构(可能是RB-tree或者hash-table)便依照其键值大小，以某种特定规则将这个元素放置于合适的位置，</p><p>关联式容器没有所谓头尾(只有最大元素和最小元素)，所以不会有所谓<code>push_back()</code>、<code>push_front()</code>等行为的操作。 </p><p> 一般而言关联式容器的内部结构是一个二叉平衡树，以便获得良好的搜寻效率。二叉平衡树有许多变形包括：AVL-tree、RB-tree、AA-tree；其中RB-tree被广泛应用于关联式容器。</p><h2 id="5-1-RB-tree"><a href="#5-1-RB-tree" class="headerlink" title="5.1 RB-tree"></a>5.1 RB-tree</h2><p>红黑树定义：</p><ul><li>（1）每个节点不是红色就是黑色(图中深色底纹代表黑色，浅色底纹代表红色，同下)。</li><li>（2）根节点为黑色</li><li>（3）如果节点为红，其子节点必须为黑色</li><li>（4）任一节点至NULL(树尾端)的任何路径，所含之黑节点数木必须相同</li></ul><p>由定义可以推导出：</p><ul><li>由规则4，新增节点必须为红</li><li>由规则3，新增节点的父节点必须为黑（如果为红，则子节点必须为黑，与新增几点为红矛盾）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108193422701.png"></p><h3 id="5-1-1-插入节点"><a href="#5-1-1-插入节点" class="headerlink" title="5.1.1 插入节点"></a>5.1.1 插入节点</h3><p>假设新增节点为X，其父节点为P，祖父节点为G，伯父节点为S，曾祖父节点为GG。有以下四种状况：</p><ul><li>状况1：s为黑色x为外侧插入，对此情况，先对P,G做一次单旋转，再更改P,G颜色，即可重新满足红黑树的规则3。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108193713609.png"></p><ul><li>状况2:S为黑且x为内侧插入，对此情况，我们必须先对P,X做一次单旋转并更改G,X颜色，再将结果对G做一次单旋转，级可再次满足红黑树规则3。（加第二次旋转是为了避免10的父节点是红色）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108193756597.png"></p><ul><li>状况3:S为红色且X为外侧插入，对此情况，先对P和G做一次单旋转，并改变X的颜色。此时如果GG为黑，一切搞定，如果GG为红，则是状况4</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108193919931.png"></p><ul><li>状况4:S为红且X为外侧插入。对此情况，先对P和G做一次单旋转，并改变X的颜色。此时如果GG亦为红，还得持续往上做，直到不再有父子连续为红的情况发生。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108194045969.png"></p><h3 id="5-1-2-一个由上而下的程序"><a href="#5-1-2-一个由上而下的程序" class="headerlink" title="5.1.2 一个由上而下的程序"></a>5.1.2 一个由上而下的程序</h3><p>假设新增节点为A,那么就沿着A的路径，只要看到某个节点X的两个子节点皆为红色，就把X该为红色，并把两个子节点改为黑色。然后在进行旋转变换。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108194413600.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108194539595.png"></p><h3 id="5-1-3-RB-tree节点设计"><a href="#5-1-3-RB-tree节点设计" class="headerlink" title="5.1.3 RB-tree节点设计"></a>5.1.3 RB-tree节点设计</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">bool</span> __rb_tree_color_type<span class="token punctuation">;</span><span class="token comment">//红色为0</span><span class="token keyword">const</span> __rb_tree_color_type __rb_tree_red<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">const</span> __rb_tree_color_type __rb_tree_black<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">__rb_tree_node_base</span><span class="token punctuation">&#123;</span>    <span class="token keyword">typedef</span> __rb_tree_color_type color_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> __rb_tree_node_base<span class="token operator">*</span> base_ptr<span class="token punctuation">;</span>    color_type color<span class="token punctuation">;</span><span class="token comment">//节点颜色，非红即黑</span>    base_ptr parent<span class="token punctuation">;</span>    <span class="token comment">//节点的父节点指针</span>    base_ptr left<span class="token punctuation">;</span>    <span class="token comment">//左节点指针</span>    base_ptr right<span class="token punctuation">;</span>    <span class="token comment">//右节点指针</span>    <span class="token keyword">static</span> base_ptr <span class="token function">minimum</span><span class="token punctuation">(</span>base_ptr x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">-></span>left<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>x<span class="token operator">=</span>x<span class="token operator">-></span>left<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> base_ptr <span class="token function">maximum</span><span class="token punctuation">(</span>base_ptr x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">-></span>right<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>x<span class="token operator">=</span>x<span class="token operator">-></span>right<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token operator">></span><span class="token keyword">struct</span>  <span class="token class-name">_rb_tree_node</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">__rb_tree_node_base</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">typedef</span> __rb_tree_node<span class="token operator">&lt;</span>Value<span class="token operator">></span><span class="token operator">*</span> link_type<span class="token punctuation">;</span>    <span class="token comment">//节点值</span>    Value value_field<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-4-RB-tree迭代器"><a href="#5-1-4-RB-tree迭代器" class="headerlink" title="5.1.4 RB-tree迭代器"></a>5.1.4 RB-tree迭代器</h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108194922205.png"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">__rb_tree_base_iterator</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> __rb_tree_node_base<span class="token double-colon punctuation">::</span>base_ptr base_ptr<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> bidirectional_iterator_tag iterator_category<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> ptrdiff_t difference_type<span class="token punctuation">;</span>  <span class="token comment">// 用来与容器之间产生一个连接关系</span>  base_ptr node<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 存在右节点，就往右节点走</span>      node <span class="token operator">=</span> node<span class="token operator">-></span>right<span class="token punctuation">;</span>      <span class="token comment">// 然后一直往左子树，走到底</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        node <span class="token operator">=</span> node<span class="token operator">-></span>left<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">//状况2</span>      <span class="token comment">// 没有右子节点，先找出父节点</span>      base_ptr y <span class="token operator">=</span> node<span class="token operator">-></span>parent<span class="token punctuation">;</span>      <span class="token comment">// 如果现行节点本身就是个右子节点,就一直上朔，直到"不为右子节点"为止</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> y<span class="token operator">-></span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        node <span class="token operator">=</span> y<span class="token punctuation">;</span>        y <span class="token operator">=</span> y<span class="token operator">-></span>node<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 如果此时右子节点不等于次吃的父节点状况3，此时的父节点即为解答，否则此时的node为解答状况4</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right <span class="token operator">!=</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        node <span class="token operator">=</span> y<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 注意：以上判断"若此时的右子节点不等于次吃的父节点"，是为了应付一种特殊情况：</span>  <span class="token comment">// 我们欲寻找根节点的下一个节点，而恰巧根节点无左右子节点</span>  <span class="token comment">// 以上的特殊做法必须配合RB-tree根节点与特殊之header之间的特殊关系</span>  <span class="token keyword">void</span> <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果是红节点，且父节点的父节点等于自己,即node为head或者end节点的时候</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>color <span class="token operator">==</span> __rb_tree_red <span class="token operator">&amp;&amp;</span> node<span class="token operator">-></span>parent<span class="token operator">-></span>parent <span class="token operator">==</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      node <span class="token operator">=</span> node<span class="token operator">-></span>right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      base_ptr y <span class="token operator">=</span> node<span class="token operator">-></span>left<span class="token punctuation">;</span>      <span class="token comment">// 一直向右循环查找下去，直到没有右子节点</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>y<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        y <span class="token operator">=</span> y<span class="token operator">-></span>right<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      node <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// 即非根节点，亦无左子节点</span>      <span class="token comment">// 先找到符节点</span>      base_ptr y <span class="token operator">=</span> node<span class="token operator">-></span>parent<span class="token punctuation">;</span>      <span class="token comment">// 找寻父节点的左子节点直到node不是左子节点</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> y<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 这里主要是一直上朔</span>        node <span class="token operator">=</span> y<span class="token punctuation">;</span>        y <span class="token operator">=</span> y<span class="token operator">-></span>parent<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// RB-tree的正规迭代器  只是对base的一个封装，和link_type定义</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ref</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ptr</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">__rb_tree_iteraror</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">__rb_tree_base_iterator</span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> Value value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> Ref reference<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> Ptr pointer<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __rb_tree_iterator<span class="token operator">&lt;</span>Value<span class="token punctuation">,</span> Value<span class="token operator">&amp;</span><span class="token punctuation">,</span> Value<span class="token operator">*</span><span class="token operator">></span> iterator<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __rb_tree_iterator<span class="token operator">&lt;</span>Value<span class="token punctuation">,</span> <span class="token keyword">const</span> Value<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Value<span class="token operator">*</span><span class="token operator">></span> const_iterator<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __rb_tree_iterator<span class="token operator">&lt;</span>Value<span class="token punctuation">,</span> Ref<span class="token punctuation">,</span> Ptr<span class="token operator">></span> self<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __rb_tree_node<span class="token operator">&lt;</span>Value<span class="token operator">></span><span class="token operator">*</span> link_type<span class="token punctuation">;</span><span class="token comment">//</span>  <span class="token function">__rb_tree_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token function">__rb_tree_iterator</span><span class="token punctuation">(</span>link_type x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> node <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token function">__rb_tree_iterator</span><span class="token punctuation">(</span><span class="token keyword">const</span> iterator<span class="token operator">&amp;</span> it<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> node <span class="token operator">=</span> it<span class="token punctuation">.</span>node<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  reference <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">link_type</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-></span>value_field<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__SGI_STL_NO_ARROW_OPERATOR pointer <span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> </span><span class="token punctuation">\</span>  <span class="token expression"><span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token expression">self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></span></span>  self <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    self tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108195719894.png"></p><h3 id="5-1-5-RB-tree数据结构"><a href="#5-1-5-RB-tree数据结构" class="headerlink" title="5.1.5 RB-tree数据结构"></a>5.1.5 RB-tree数据结构</h3><p>红黑树实现上有个技巧，使用一个header指向根节点，且header和root互为对方的父节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Key</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyOfValue</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token punctuation">,</span>          <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">rb_tree</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> __rb_tree_iterator<span class="token operator">&lt;</span>value_type<span class="token punctuation">,</span> reference<span class="token punctuation">,</span> pointer<span class="token operator">></span> iterator<span class="token punctuation">;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  size_type node_count<span class="token punctuation">;</span>  <span class="token comment">// 节点数目</span>  link_type header<span class="token punctuation">;</span>  Compare key_compare<span class="token punctuation">;</span>  <span class="token comment">// 节点的键值大小比较准则，应该会是一个function object;</span>  link_type<span class="token operator">&amp;</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>link_type<span class="token operator">&amp;</span><span class="token punctuation">)</span>header<span class="token operator">-></span>parent<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  link_type<span class="token operator">&amp;</span> <span class="token function">leftmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>link_type<span class="token operator">&amp;</span><span class="token punctuation">)</span>header<span class="token operator">-></span>left<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  link_type<span class="token operator">&amp;</span> <span class="token function">rightmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>link_type<span class="token operator">&amp;</span><span class="token punctuation">)</span>header<span class="token operator">-></span>right<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 相关的基本函数</span>  iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">leftmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> header<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> node_count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  size_type <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> node_count<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  size_type <span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">size_type</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-6-构造和内存管理"><a href="#5-1-6-构造和内存管理" class="headerlink" title="5.1.6 构造和内存管理"></a>5.1.6 构造和内存管理</h3><p>RB-tree的构造方式有两种，一种是拷贝构造，一种是空值构造。下面是其init()的关键函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 产生一个节点空间，令header指向它</span>    header <span class="token operator">=</span> <span class="token function">get_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 令header为红色，用来区分header和root</span>    <span class="token function">color</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span> <span class="token operator">=</span> __rb_tree_red<span class="token punctuation">;</span>    <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// header的左右子节点都为自己</span>    <span class="token function">leftmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> header<span class="token punctuation">;</span>    <span class="token function">rightmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> header<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  link_type <span class="token function">create_node</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    link_type tmp <span class="token operator">=</span> <span class="token function">get_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    __STL_TRY <span class="token punctuation">&#123;</span>      <span class="token comment">// 构造内容</span>      <span class="token function">construct</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmp<span class="token operator">-></span>value_field<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">__STL_UNWIND</span><span class="token punctuation">(</span><span class="token function">put_node</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">rb_tree</span><span class="token punctuation">(</span><span class="token keyword">const</span> Compare<span class="token operator">&amp;</span> comp <span class="token operator">=</span> <span class="token function">Compare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">node_count</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">key_compare</span><span class="token punctuation">(</span>comp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token operator">~</span><span class="token function">rb_tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_node</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108204049321.png"></p><h3 id="5-1-7-操作函数"><a href="#5-1-7-操作函数" class="headerlink" title="5.1.7 操作函数"></a>5.1.7 操作函数</h3><p>RB-Tree提供两种插入：</p><ul><li>insert_unique()：如果已存在相同键值，则不进行插入</li><li>insert_equal()：插入的键值可以重复</li></ul><p><strong>insert_equal()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Key</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyOfValue</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">></span><span class="token keyword">typename</span> <span class="token class-name">rb_tree</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> KeyOfValue<span class="token punctuation">,</span> Compare<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator<span class="token class-name">rb_tree</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> KeyOfValue<span class="token punctuation">,</span> Compare<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">insert_equal</span><span class="token punctuation">(</span><span class="token keyword">const</span> Value<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  link_type y <span class="token operator">=</span> header<span class="token punctuation">;</span>  link_type x <span class="token operator">=</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从根节点开始向下寻找适当的传播节点，直到到根节点，注意这里y为x的parent节点</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    y <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment">// 遇大则左，遇小或者等于就右--v&lt;x向左，v>=x向右</span>    x <span class="token operator">=</span> <span class="token function">key_compare</span><span class="token punctuation">(</span><span class="token function">KeyOfValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">key</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">left</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">right</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// x为新值插入点，y为插入点之父节点，v为新值</span>  <span class="token keyword">return</span> <span class="token function">__insert</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>insert_unique()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span>Class Key<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyOfValue</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">></span>pair<span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">rb_tree</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> KeyOfValue<span class="token punctuation">,</span> Compare<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span><span class="token class-name">rb_tree</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> KeyOfValue<span class="token punctuation">,</span> Compare<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">insert_unique</span><span class="token punctuation">(</span><span class="token keyword">const</span> Value<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  link_type y <span class="token operator">=</span> header<span class="token punctuation">;</span>  <span class="token comment">// 从根节点开始</span>  link_type x <span class="token operator">=</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 判断是否相同</span>  <span class="token keyword">bool</span> comp <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 一直遍历到根节点</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    y <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment">// v是否小于目前节点的键值</span>    comp <span class="token operator">=</span> <span class="token function">key_compare</span><span class="token punctuation">(</span><span class="token function">KeyOfValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">key</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 遇“大”向左，否则向右</span>    x <span class="token operator">=</span> comp <span class="token operator">?</span> <span class="token function">left</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">right</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 离开while循环之后，y即插入父节点</span>  <span class="token comment">// 令迭代器j指向插入点的父节点</span>  iterator j <span class="token operator">=</span> <span class="token function">iterator</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果在左边插入</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>comp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果插入节点为最左节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">__insert</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token operator">--</span>j<span class="token punctuation">;</span><span class="token comment">//为了判断比y小1的值是否和v相等，见下</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 如果小于新值，将插入右侧</span>  <span class="token comment">// 比较是否存在重复的值</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">key_compare</span><span class="token punctuation">(</span><span class="token function">key</span><span class="token punctuation">(</span>j<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">KeyOfValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">__insert</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>插入函数__insert()</strong></p><p>通过将父节点和插入值进行比较，从而判断插入点是左节点还是右节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 关键插入程序</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Key</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyOfValue</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">></span><span class="token keyword">typename</span> <span class="token class-name">rb_tree</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> KeyOfValue<span class="token punctuation">,</span> Compare<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator<span class="token class-name">rb_tree</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> KeyOfValue<span class="token punctuation">,</span> Compare<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">__insert</span><span class="token punctuation">(</span>base_ptr x_<span class="token punctuation">,</span>                                                          base_ptr y_<span class="token punctuation">,</span>                                                          <span class="token keyword">const</span> Value<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 将值隐式转换为节点指针，x插入位置，y插入父节点，v插入的值</span>  link_type x <span class="token operator">=</span> <span class="token punctuation">(</span>link_type<span class="token punctuation">)</span>x_<span class="token punctuation">;</span>  link_type y <span class="token operator">=</span> <span class="token punctuation">(</span>link_type<span class="token punctuation">)</span>y_<span class="token punctuation">;</span>  link_type z<span class="token punctuation">;</span>  <span class="token comment">// 判断是否为首节点</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> header <span class="token operator">||</span> x <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">key_compare</span><span class="token punctuation">(</span><span class="token function">KeyOfValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">key</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 产生一个新节点</span>    z <span class="token operator">=</span> <span class="token function">create_node</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">left</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> header<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>      <span class="token function">rightmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> <span class="token function">leftmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 如果y为最左节点</span>      <span class="token comment">// 让最左节点永远指向z</span>      <span class="token function">leftmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 不是head节点或者空节点</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 产生一个新节点</span>    z <span class="token operator">=</span> <span class="token function">create_node</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 令新节点作为插入节点的右兄弟节点</span>    <span class="token function">right</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token comment">// 更新最右指针位置</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> <span class="token function">rightmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">rightmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 设置新节点的父节点,右子节点和左子节点</span>  <span class="token function">parent</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token function">left</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">right</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 调整和设置新节点的颜色</span>  <span class="token function">__rb_tree_rebalance</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> header<span class="token operator">-></span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">++</span>node_count<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>调整RB-tree</strong></p><p>先由上而下的解决父子都为红色的情况，然后进行旋转</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__rb_tree_rebalance</span><span class="token punctuation">(</span>__rb_tree_node_base<span class="token operator">*</span> x<span class="token punctuation">,</span>                                __rb_tree_node_base<span class="token operator">*</span><span class="token operator">&amp;</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 新节点毕为红</span>  x<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_red<span class="token punctuation">;</span>  <span class="token comment">// 假设父节点为红色,按照之前的4种情况进行判断然后调整</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> root <span class="token operator">&amp;&amp;</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">==</span> __rb_tree_red<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断父节点是否为左子节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>parent <span class="token operator">==</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// y指向右伯节点</span>      __rb_tree_node_base<span class="token operator">*</span> y <span class="token operator">=</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>right<span class="token punctuation">;</span>      <span class="token comment">// 如果y存在并且也为红色</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&amp;&amp;</span> y<span class="token operator">-></span>color <span class="token operator">==</span> __rb_tree_red<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 更改父节点为黑色</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span>        <span class="token comment">// 更改父节点为黑色</span>        y<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span>        <span class="token comment">// 更改祖父节点为红</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_red<span class="token punctuation">;</span>        <span class="token comment">// x重新指向祖节点,再次循环迭代更改</span>        x <span class="token operator">=</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token punctuation">;</span>        <span class="token comment">// 无伯父节点，或者伯父节点为黑</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果新节点为右子节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// x重新指向父节点</span>          x <span class="token operator">=</span> x<span class="token operator">-></span>parent<span class="token punctuation">;</span>          <span class="token comment">// 第一参数为左旋点进行左旋</span>          <span class="token function">__rb_tree_rotate_left</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 改变颜色</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_red<span class="token punctuation">;</span>        <span class="token comment">// 第一参数为右旋点</span>        <span class="token function">__rb_tree_rotate_right</span><span class="token punctuation">(</span>x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 父节点为祖父节点之右子节点</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// y为左伯父节点</span>      __rb_tree_node_base<span class="token operator">*</span> y <span class="token operator">=</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>left<span class="token punctuation">;</span>      <span class="token comment">// 左伯父节点存在且为红色</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&amp;&amp;</span> y<span class="token operator">-></span>color <span class="token operator">==</span> __rb_tree_red<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 更改父节点为黑</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span>        <span class="token comment">// 伯父节点为黑色</span>        y<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span>        <span class="token comment">// 更改祖父节点为红色</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_red<span class="token punctuation">;</span>        <span class="token comment">// 移动指针准备继续向上查</span>        x <span class="token operator">=</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token punctuation">;</span>        <span class="token comment">// 无伯父节点或伯父节点为黑</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果新节点为父节点之左子节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          x <span class="token operator">=</span> x<span class="token operator">-></span>parent<span class="token punctuation">;</span>          <span class="token comment">// 第一参数为右旋点</span>          <span class="token function">__rb_tree_rotate_right</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_red<span class="token punctuation">;</span>        <span class="token comment">// 第一参数为左旋点</span>        <span class="token function">__rb_tree_rotate_left</span><span class="token punctuation">(</span>x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// end while</span>  <span class="token comment">// root节点永远为黑</span>  root<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>元素搜索</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109164149767.png"></p><p><strong>插入图例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109164245861.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109164304596.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109164319824.png"></p><h2 id="5-2-set"><a href="#5-2-set" class="headerlink" title="5.2 set"></a>5.2 set</h2><p>set中所有元素都会根据元素的键值自动被排序。set不允许两个元素拥有相同的值。</p><p>set与list拥有相同的某些性质：操作过程中，除了删除元素的迭代器外，其它迭代器不会失效。</p><p>set的compare默认情况下是使用<code>less&lt;Key&gt;</code>缺省情况下采用递增排序。</p><p>set采用红黑树来进行排序和数据存储。</p><p>set的iterator无法改变对应元素值，是一个const iterator</p><p><strong>数据结构</strong></p><p>函数基本上都是对红黑树的包装，注意iterator定义即可</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109171127400.png"></p><h2 id="5-3-map"><a href="#5-3-map" class="headerlink" title="5.3 map"></a>5.3 map</h2><p>map的特性是，所有元素都会根据元素的键值自动被排序。</p><p>map的所有元素都是pair，同时拥有实值(value)和键值(key)。pair的第一元素被视为键值，第二元素被视为实值。</p><p>map不允许两个元素拥有相同的键值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">pair</span><span class="token punctuation">&#123;</span>    <span class="token keyword">typedef</span> T1 first_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> T2 second_type<span class="token punctuation">;</span>    T1 first<span class="token punctuation">;</span>    T2 second<span class="token punctuation">;</span>    <span class="token function">pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token function">T1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">second</span><span class="token punctuation">(</span><span class="token function">T2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">pair</span><span class="token punctuation">(</span><span class="token keyword">const</span> T1<span class="token operator">&amp;</span> a<span class="token punctuation">,</span><span class="token keyword">const</span> T2<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">first</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">second</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109171431165.png"></p><p><strong>数据结构</strong></p><p>函数基本上都是对红黑树的包装</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Key</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Compare</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>less<span class="token operator">&lt;</span>_Key<span class="token operator">></span><span class="token punctuation">,</span>          <span class="token keyword">typename</span> <span class="token class-name">_Alloc</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">></span> <span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">map</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> _Key key_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Tp mapped_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">></span> value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Compare key_compare<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Alloc allocator_type<span class="token punctuation">;</span>  <span class="token comment">// 用于比较大小</span>  <span class="token keyword">class</span> <span class="token class-name">value_compare</span>      <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">binary_function</span><span class="token operator">&lt;</span><span class="token class-name">value_type</span><span class="token punctuation">,</span> <span class="token class-name">value_type</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">map</span><span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Tp<span class="token punctuation">,</span> _Compare<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token punctuation">;</span>   <span class="token keyword">protected</span><span class="token operator">:</span>    _Compare comp<span class="token punctuation">;</span>    <span class="token function">value_compare</span><span class="token punctuation">(</span>_Compare __c<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">comp</span><span class="token punctuation">(</span>__c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>   <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __y<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token function">comp</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span>first<span class="token punctuation">,</span> __y<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> _Rb_tree<span class="token operator">&lt;</span>key_type<span class="token punctuation">,</span> value_type<span class="token punctuation">,</span> _Select1st<span class="token operator">&lt;</span>value_type<span class="token operator">></span><span class="token punctuation">,</span> key_compare<span class="token punctuation">,</span>                   _Pair_alloc_type<span class="token operator">></span>      _Rep_type<span class="token punctuation">;</span>  <span class="token comment">/// The actual tree structure.</span>  _Rep_type _M_t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用关联式容器时，应使用容器提供的find函数来搜寻元素，比STL的find函数更有效率，因为STL算法find只是循序搜索。</p><p>注意，insert函数的返回值</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109192955148.png"></p><p>[]符号的重写：先使用insert插入一个元素，返回一个pair，然后使用first取得iterator，再使用*获得一个map元素pair，取第二元素。由于返回值是引用，因此作为左值还是右值皆可。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109193359053.png"></p><h2 id="5-4-multiset和multimap"><a href="#5-4-multiset和multimap" class="headerlink" title="5.4 multiset和multimap"></a>5.4 multiset和multimap</h2><p>multiset的特性以及用法和set完全相同，唯一的差别在于它允许键值重复。它的底层机制是使用RB-tree的insert_equal()而非insert_unique()；</p><p>multimap与map的用法完全相同，唯一的差别在于，它允许键值重复。它的底层机制是使用RB-tree的insert_equal()而非insert_unique()；</p><h2 id="5-5-hashtable"><a href="#5-5-hashtable" class="headerlink" title="5.5 hashtable"></a>5.5 hashtable</h2><h3 id="5-5-1-概述"><a href="#5-5-1-概述" class="headerlink" title="5.5.1 概述"></a>5.5.1 概述</h3><p>使用哈希函数不可避免会有碰撞情况发生，解决碰撞的三种方法：</p><ul><li>线性探测：当插入位置不可用时，则依次往后寻找空位。删除元素时不能直接删除，只能进行标记，等表格重新整理时删除。因为每个元素不仅表述自己，也关系到其他元素排列、</li><li>二次探测：若插入位置H不可用，则依次尝试H+1^2^、H+2^2^…. 此方法虽然计算平方较耗时，但可进行优化，整体上是得大于失。但缺可能造成次聚集问题，可使用复式散列（double hashing）解决。</li><li>拉链法：在表格每个元素中维护一个list，当碰撞时，在list末尾上进行插入。SGI STL采用此方法。</li></ul><h3 id="5-5-2-hashtable的桶子与节点"><a href="#5-5-2-hashtable的桶子与节点" class="headerlink" title="5.5.2 hashtable的桶子与节点"></a>5.5.2 hashtable的桶子与节点</h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110193310844.png"></p><p><strong>节点数据结构定义：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">__hastable_node</span><span class="token punctuation">&#123;</span>    __hashtable_node<span class="token operator">*</span> next<span class="token punctuation">;</span>    Value val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SGI中，bucket（桶子）维护的linked list未采用STL的list或slist，而是自行维护上述的node，而buckets聚合体则以vector完成。</p><p>bucket只维护指向第一个节点的指针。</p><h3 id="5-5-3-hashtable迭代器"><a href="#5-5-3-hashtable迭代器" class="headerlink" title="5.5.3 hashtable迭代器"></a>5.5.3 hashtable迭代器</h3><p>迭代器数据结构</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">__hashtable_iterator</span><span class="token punctuation">&#123;</span>node<span class="token operator">*</span> cur<span class="token punctuation">;</span><span class="token comment">// 指向节点</span>hashtable <span class="token operator">*</span>ht<span class="token punctuation">;</span><span class="token comment">//指向bucket，因为可能会跳到另一个bucket</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>hashtable的++操作可能会从当前bucket跳到另一个bucket，因此迭代器必须维持对整个vector的关系。</p><p>++操作：如果当前节点是list的尾端，则跳到下一个bucket</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110202103450.png"></p><p><strong>hashtable迭代器没有后退操作（ operator–() )</strong></p><h3 id="5-5-4-hashtable数据结构"><a href="#5-5-4-hashtable数据结构" class="headerlink" title="5.5.4 hashtable数据结构"></a>5.5.4 hashtable数据结构</h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110202321250.png"></p><p>模板说明：</p><ul><li>HashFcn：哈希函数类别</li><li>ExtractKey：从节点去除键值的方法，如identity类</li><li>EqualKey：判断键值是否相同的方法</li></ul><p>SGI以28个质数来设计表格大小，且已将其计算好，提供函数查询最接近某数并大于某数的质数</p><h3 id="5-5-5-hashtable构造和内存管理"><a href="#5-5-5-hashtable构造和内存管理" class="headerlink" title="5.5.5 hashtable构造和内存管理"></a>5.5.5 hashtable构造和内存管理</h3><p><strong>构造函数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110203028686.png"></p><p><strong>判断是否需要重建表格</strong></p><p>若现有元素个数大于vector大小，则需要重建</p><p>重建的方法其实就是将原来的bucket计算在新vector中的位置，然后将整个list插入过去</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110203147482.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110203203283.png"></p><p><strong>插入节点</strong></p><p>insert_unique插入键值不允许重复，注意新插入的节点会在bucket的第一个节点。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110203450355.png"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">HF</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ex</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Eq</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">hashtable</span><span class="token operator">&lt;</span>V<span class="token punctuation">,</span> K<span class="token punctuation">,</span> HF<span class="token punctuation">,</span> Ex<span class="token punctuation">,</span> Eq<span class="token punctuation">,</span> A<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">insert_unique_noresize</span><span class="token punctuation">(</span>    <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 决定obj的桶位置</span>  <span class="token keyword">const</span> size_type n <span class="token operator">=</span> <span class="token function">bkt_num</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// first指向bucket对应之串行头部</span>  node<span class="token operator">*</span> first <span class="token operator">=</span> buckets<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 如果位置已经被占用，即first!=0;循环遍历查找新位置</span>  <span class="token comment">//cur会结束的原因是：第一个插入节点的next会指向first，而此时first是0.</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>node<span class="token operator">*</span> cur <span class="token operator">=</span> first<span class="token punctuation">;</span> cur<span class="token punctuation">;</span> cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token function">get_key</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">get_key</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">iterator</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 离开以上循环，first指向bucket所值链表的头部节点</span>  <span class="token comment">// 产生新节点</span>  node<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token function">new_node</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  tmp<span class="token operator">-></span>next <span class="token operator">=</span> first<span class="token punctuation">;</span>  <span class="token comment">// 令节点成为链表的第一个节点</span>  buckets<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token comment">// 节点个数累加1</span>  <span class="token operator">++</span>num_elements<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">iterator</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>insert_equal允许重复，其逻辑和unique类似，只是如果找到相同键值则就在其前插入值，这就导致新插入值不一定在bucket的第一个节点</p><p><strong>判断元素插入处</strong></p><p>由于有些元素类别无法直接进行哈希运算，如字符串，需要取得其值才能计算（有些类需要指定如何获取键值）</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110205250550.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110205326459.png"></p><p><strong>复制和删除</strong></p><p>删除时需要对bucket中的每个节点进行内存释放</p><p>复制时先设置vector大小并置为null，然后对bucket中的每个节点进行复制</p><h3 id="5-5-6-hash-function"><a href="#5-5-6-hash-function" class="headerlink" title="5.5.6 hash function"></a>5.5.6 hash function</h3><p>SGI的hashtable无法处理char int long char*之外的元素类别，如string就会报错（unordered_set现在能处理string double等类别）</p><p>char int long 等整数类型的哈希函数是直接返回其原值</p><p>字符串哈希函数：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110210424940.png"></p><h2 id="5-6-hash-set、hash-map、hash-multiset、hash-multimap"><a href="#5-6-hash-set、hash-map、hash-multiset、hash-multimap" class="headerlink" title="5.6 hash_set、hash_map、hash_multiset、hash_multimap"></a>5.6 hash_set、hash_map、hash_multiset、hash_multimap</h2><blockquote><p>现在c++都使用unordered开头，如unordered_set，hash_set这四种是SGI提供的</p></blockquote><p>这四种容器以hashtable为底层机制，其无自动排序能力（set会自动排序），其行为操作都是调用hashtable</p><p>hash_map是将元素类别设置pair&lt;const Key, T&gt;，然后提供取key仿函数即可转换为hashtable。</p><p>hash_set调用的hashtable的insert_unique()，而hash_multiset调用的hashtable的insert_equal()。</p><h1 id="六、算法"><a href="#六、算法" class="headerlink" title="六、算法"></a>六、算法</h1><p><strong>算法分类</strong></p><ul><li>质变算法：会改变操作对象之值；如copy、swap、replace、fill、remove、permutation、aprtition、random shuffling、sort等</li><li>非质变算法：不改变操作对象之值：find、search、count、for_each、equal、mismatch、max、min等</li></ul><p>质变算法一半提供两个版本：in-place–就地改变操作对象;copy–将操作对象的内容复制一份副本(通常以_copy结尾)，操作后返回。</p><p><strong>算法的泛型化</strong></p><p>关键在于把操作对象的型别抽象化，把操作对象的标识法和区间目标的移动行为抽象化，真个算法也就在一个抽象层面上工作了。</p><h2 id="6-1-数值算法"><a href="#6-1-数值算法" class="headerlink" title="6.1 数值算法"></a>6.1 数值算法</h2><p>SGI将其都实现于&lt;stl_numeric.h&gt;文件中。</p><h3 id="6-1-1accumulate"><a href="#6-1-1accumulate" class="headerlink" title="6.1.1accumulate"></a>6.1.1accumulate</h3><p>用来计算init和[first, last)内所有元素的总和</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230111194656990.png"></p><h3 id="6-1-2-adjacent-difference"><a href="#6-1-2-adjacent-difference" class="headerlink" title="6.1.2 adjacent_difference"></a>6.1.2 adjacent_difference</h3><p>用来计算[first, last)中相邻元素的差额，即记录没两个相邻值间的差值（后减前），另一版本可以传二元操作函数。</p><p>注意结果的第一个值是first，可以给result传first值，这也是代码中为啥使用tmp临时值的原因。</p><p>如果加法和减法是常规定义，则adjacent_difference和partial_sum是互逆操作。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230111195758986.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230111195808915.png"></p><h3 id="6-1-3-inner-product"><a href="#6-1-3-inner-product" class="headerlink" title="6.1.3 inner_product"></a>6.1.3 inner_product</h3><p>用于计算两组数据对应位置的内积之和，注意必须指定初值</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118195523934.png"></p><h3 id="6-1-4-partial-sum"><a href="#6-1-4-partial-sum" class="headerlink" title="6.1.4 partial_sum"></a>6.1.4 partial_sum</h3><p>用于计算局部总和，最后会使用一组数据记录对应位置之前的和</p><p>如果加法和减法是常规定义，那么partial_sum和adjacent_difference互为逆运算</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118195731956.png"></p><h3 id="6-1-5-power和itoa"><a href="#6-1-5-power和itoa" class="headerlink" title="6.1.5 power和itoa"></a>6.1.5 power和itoa</h3><p><strong>power</strong></p><p>非STL标准算法，用于计算某数的n幂次方。如果指定为乘法，则为乘幂次。</p><p>算法为了效率并非将原始数据乘以n次，而是将n不断除以2，看能除以多少次，然后将原数不断自身相乘多少次。</p><p><strong>itoa</strong></p><p>非STL标准算法，用于设定某个区间的内容</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118200609660.png"></p><h2 id="6-2-标准算法"><a href="#6-2-标准算法" class="headerlink" title="6.2 标准算法"></a>6.2 标准算法</h2><h3 id="6-2-1-equal、fill等"><a href="#6-2-1-equal、fill等" class="headerlink" title="6.2.1 equal、fill等"></a>6.2.1 equal、fill等</h3><p><strong>equal</strong></p><p>如果两个序列在[first, last]相等，则返回true。如果第二个序列元素较多，则多出来的元素不考虑。因此，需要先判断两个序列元素个数是否相等，才能判断其是否完全相等。</p><p><strong>fill</strong></p><p>将[first, last]内所有元素填充新值</p><p><strong>fill_n</strong></p><p>将[first, last]内的前n个元素填充新值，注意需要自己检查范围不可越界，或者使用inserter产生一个具有插入能力的迭代器。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118201348001.png"></p><p><strong>iter_swap</strong></p><p>将两个forwarditerators所指的对象对调。注意value_type返回的是一个T*指针。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118201551163.png"></p><p><strong>lexicographical_compare</strong></p><p>字典排列方式对两个序列，进行比较</p><ul><li>如果第一序列的元素较小，返回true,否则返回false</li><li>如果达到last1而尚未达到last2,返回true</li><li>如果达到last2而尚未达到last1,返回false</li><li>同时达到，返回false</li></ul><p><strong>max和min</strong></p><p>用于取较大值和较小值，都可以指定比较函数，注意比较的两个数类型必须相同。</p><p><strong>mismatch</strong></p><p>找出两个序列之间第一个不匹配点，需要保证第一序列不能比第二序列的元素个数少</p><p><strong>swap</strong></p><p>用于交换两个对象的内容</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118202110458.png"></p><h3 id="6-2-2-copy"><a href="#6-2-2-copy" class="headerlink" title="6.2.2 copy"></a>6.2.2 copy</h3><p>用于将输入区间内的元素复制到输出区间，copy更改的是迭代器所指对象，而非更改迭代器本身</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118202157052.png"></p><p>当复制结果的起点在原始区间内时，可能会发生错误，因为原始数据会被覆盖。copy会根据迭代器类型调用不同版本，可能会调用memmove函数来执行任务，其会将整个输入区间先复制。</p><p>vector的迭代器由于是原始指针，因此会调用memmove函数</p><h3 id="6-2-3-copy-backward"><a href="#6-2-3-copy-backward" class="headerlink" title="6.2.3 copy_backward"></a>6.2.3 copy_backward</h3><p>将[first, last]中的元素，以逆向复制到结果中，其实现和copy十分类似。</p><p>其所接受迭代器必须是bidirectionaliterators。</p><p>当复制结果的终点在原始果区间内时，可能会发生错误。</p><h2 id="6-3-set相关算法"><a href="#6-3-set相关算法" class="headerlink" title="6.3 set相关算法"></a>6.3 set相关算法</h2><p>STL提供了四种set(集合)相关的算法，分别是并集(union),交集(intersection)，差集(difference)、对称集(symmetic difference)</p><p>注意，当集合中存在重复元素时，其结果和直观定义所有不同</p><h3 id="6-3-1-set-union"><a href="#6-3-1-set-union" class="headerlink" title="6.3.1 set_union"></a>6.3.1 set_union</h3><p>用于计算两个集合S1和S2的并集，包含两个集合中的每一个元素，是一个稳定操作函数（元素相对顺序不变）。</p><p>若有重复元素，如果某个值在S1出现n次，在S2出现m次，每个结果中会出现max(m,n)次，其中n个来自S1，其余来自S2。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118210616021.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118210629080.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118210703803.png"></p><h3 id="6-3-2-set-intersection"><a href="#6-3-2-set-intersection" class="headerlink" title="6.3.2 set_intersection"></a>6.3.2 set_intersection</h3><p>求交集，不会改变元素相对顺序。</p><p>若有重复元素，如果某个值在S1出现n次，在S2出现m次，每个结果中会出现min(m,n)次，全部来自S1。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118210947226.png"></p><h3 id="6-3-3-set-difference"><a href="#6-3-3-set-difference" class="headerlink" title="6.3.3 set_difference"></a>6.3.3 set_difference</h3><p>用于求S1-S2，是一种稳定操作。</p><p>若有重复元素，如果某个值在S1出现n次，在S2出现m次，每个结果中会出现max(n-m)次，全部来自S1。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118211345411.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118211433357.png"></p><h3 id="6-3-4-set-symmetric-difference"><a href="#6-3-4-set-symmetric-difference" class="headerlink" title="6.3.4 set_symmetric_difference"></a>6.3.4 set_symmetric_difference</h3><p>用于求对称差集，即(S1-S2)U(S2-S1)，也是一种稳定操作。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118211639815.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118211655928.png"></p><h2 id="6-4-其他算法"><a href="#6-4-其他算法" class="headerlink" title="6.4 其他算法"></a>6.4 其他算法</h2><h3 id="6-4-1-单纯的数据处理"><a href="#6-4-1-单纯的数据处理" class="headerlink" title="6.4.1 单纯的数据处理"></a>6.4.1 单纯的数据处理</h3><h4 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a><strong>adjacent_find</strong></h4><p>找出第一个满足条件的相邻元素，有可指定操作函数版本。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118211953481.png"></p><h4 id="count和count-if"><a href="#count和count-if" class="headerlink" title="count和count_if"></a>count和count_if</h4><p>count将区间中所有元素与指定值比较，返回相等元素个数</p><p>count_if返回比较函数结果为true的元素个数</p><h4 id="find-find-if-find-end-find-first-of"><a href="#find-find-if-find-end-find-first-of" class="headerlink" title="find, find_if, find_end, find_first_of"></a>find, find_if, find_end, find_first_of</h4><p>find返回第一个相等的元素迭代器</p><p>find_if返回第一个令比较函数结果为true的元素迭代器</p><p>find_end在[first1, last1]中，查找[first2, last2]最后一次出现点，若不存在则返回last1。注意，不是查找子序列。</p><p>有两种实现：单向迭代器和双向迭代，以下是双向迭代器实现代码</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118212912369.png"></p><p>find_first_of在[first1, last1]中，以[first2, last2]中的元素为目标查找第一次出现点，若不存在则返回last1。注意，不是查找子序列，也不是增减元素得到的序列。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118213313726.png"></p><h4 id="for-each-transform"><a href="#for-each-transform" class="headerlink" title="for_each, transform"></a>for_each, transform</h4><p>for_each将仿函数f作用于区间中的每一个元素上。f不可以改变元素内容，因为输入迭代器是inputiterator。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118213504474.png"></p><p>transform将仿函数op作用于[first,last)中每个元素，并产生一个新序列。其result结果也可指向源端容器，另有版本可输入两个区间，操作函数操作两个元素。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118230231606.png"></p><h4 id="generate-generate-n"><a href="#generate-generate-n" class="headerlink" title="generate, generate_n"></a>generate, generate_n</h4><p>generate将运算结果填充到区间的所有元素上。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118213607242.png"></p><p>generate_n将运算结果填充到区间的前n个元素上。</p><h4 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h4><p>判断序列S2是否涵盖与序列S1（S2每个元素都出现于S1），两个序列必须是<strong>有序集合</strong>，元素可重复。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118221600461.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118221645407.png"></p><h4 id="max-element，min-element-merge"><a href="#max-element，min-element-merge" class="headerlink" title="max_element，min_element, merge"></a>max_element，min_element, merge</h4><p>max_element返回数值最大元素的迭代器</p><p>min_element返回数值最小元素的迭代器</p><p>merge将两个有序集合合并置于另一段空间</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118221912314.png"></p><h4 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h4><p>将区间中的元素重新排列，操作函数判定为true的放在区间前端，否则放在区间后段。不保证保留元素的原始相对位置，如果需要保留原始相对位置，应该使用stable_partition</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118223423379.png"></p><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>移除区间中与value相等的元素，其并未将相等元素真正删除，而是放于尾端。</p><p>array不适合使用remove和remove_if，因为其无法缩小尺寸导致被删除数据永远存在。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118223629835.png"></p><h4 id="remove-copy-remove-if-remove-copy-if"><a href="#remove-copy-remove-if-remove-copy-if" class="headerlink" title="remove_copy, remove_if, remove_copy_if"></a>remove_copy, remove_if, remove_copy_if</h4><p>remove_copy和remove相比只是将结果复制到一个新容器中，需保证新容器容量足够。</p><p>remove_if是指定一个判定函数，而不是数值。</p><p>remove_copy_if是上述两者结合</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118224023822.png"></p><h4 id="replace-replace-copy-replace-if-replace-copy-if"><a href="#replace-replace-copy-replace-if-replace-copy-if" class="headerlink" title="replace, replace_copy, replace_if, replace_copy_if"></a>replace, replace_copy, replace_if, replace_copy_if</h4><p>replace将区间所有old_value以new_value取代。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118224215390.png"></p><p>replace_copy唯一不同是即将结果输出到新容器中</p><p>replace_if可以设置判定函数</p><p>replace_copy_if是上述两者结合</p><h4 id="reverse-reverse-copy"><a href="#reverse-reverse-copy" class="headerlink" title="reverse, reverse_copy"></a>reverse, reverse_copy</h4><p>reverse将区间中的元素颠倒重排，由于迭代器类型不同，为不同迭代器设置了不同版本（只有随机迭代器才能比较大小）。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118224616548.png"></p><p>reverse_copy只是即将容器保存到新容器</p><h4 id="rotate-rotate-copy-swap-ranges"><a href="#rotate-rotate-copy-swap-ranges" class="headerlink" title="rotate, rotate_copy, swap_ranges"></a>rotate, rotate_copy, swap_ranges</h4><p>rotate将[first, middle)和[middle, last)内的元素互换。如有{1,2,3,4,5,6,7}，对3做旋转，则得到{3,4,5,6,7,1,2}。</p><p>swap_ranges()只能交换两个长度相同区间，而rotate区间长度可以不同，需保证第一区间长度大于等于第二区间长度</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118225150316.png"></p><p>rotate_copy同样也只是将结果保存到新容器中</p><h4 id="search-search-n"><a href="#search-search-n" class="headerlink" title="search, search_n"></a>search, search_n</h4><p>search在序列[first1,last1)中，查找序列[first2,last2)的首次出现点，若不存在则返回last1。</p><blockquote><p>注意这个函数是查找序列，而find_first_of不是找序列，是找存在任意一个元素即可</p></blockquote><p>search_n在序列[first1,last1)中，查找连续n个序列[first2,last2)的首次出现点</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118225654750.png"></p><h4 id="unique-unique-copy"><a href="#unique-unique-copy" class="headerlink" title="unique, unique_copy"></a>unique, unique_copy</h4><p>unique能够移除重复元素，其只会移除相邻重复元素。如果要移除所有重复元素，需要先排序。其是一个稳定算法。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118230522565.png"></p><p>unique_copy也是将结果保存到新容器中</p><h3 id="6-4-2-lower-bound和upper-bound"><a href="#6-4-2-lower-bound和upper-bound" class="headerlink" title="6.4.2 lower_bound和upper_bound"></a>6.4.2 lower_bound和upper_bound</h3><p><strong>lower_bound</strong></p><ul><li><p>利用二分查找在<strong>已排序</strong>的序列中寻找元素value，返回的迭代器指向第一个不小于value的元素。</p></li><li><p>返回值是在不破坏排序状态下，可插入value的第一个位置。</p></li></ul><p><strong>upper_bound</strong></p><ul><li>同样要求序列必须已排序，返回可插入value的最后一个位置</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201170656919.png"></p><p>lower_bound代码实现：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201170727806.png"></p><h3 id="6-4-3-binary-search"><a href="#6-4-3-binary-search" class="headerlink" title="6.4.3 binary_search"></a>6.4.3 binary_search</h3><p>利用二分查找在<strong>已排序</strong>的序列中寻找元素value，若未找到则返回false</p><p>其实现是先使用lower_bound先找到第一value位置，然后判断是否是需要查找的目标</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201171256786.png"></p><h3 id="6-4-4-next-permutation和prev-permutation"><a href="#6-4-4-next-permutation和prev-permutation" class="headerlink" title="6.4.4 next_permutation和prev_permutation"></a>6.4.4 next_permutation和prev_permutation</h3><p><strong>next_permutation</strong>：取得[first,last)所标示的下一个排列组合，有就返回true,否则返回false</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201190857878.png"></p><p><strong>prev_permutation</strong>：取得[first,last)所标示的前一个排列组合</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201191008355.png"></p><h3 id="6-4-5-random-shuffle"><a href="#6-4-5-random-shuffle" class="headerlink" title="6.4.5 random_shuffle"></a>6.4.5 <strong>random_shuffle</strong></h3><p>将序列中的元素随机重排</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201191100622.png"></p><h3 id="6-4-6-paitial-sort"><a href="#6-4-6-paitial-sort" class="headerlink" title="6.4.6 paitial_sort"></a>6.4.6 paitial_sort</h3><p>对序列 [first, last) 的部分进行排序，使得middle-first个最小元素以递增顺序位于首部，其余元素无特定顺序位于尾部。</p><p>paitial_sort相比sort效率更高，只需挑出前N个最小元素进行排序</p><p><strong>实现</strong>：是将[first, middle) 作为一个最大堆，然后后面每个元素皆与第一个元素比较，最后再使用sort_heap()将[first, middle) 进行排序。</p><h3 id="6-4-7-sort"><a href="#6-4-7-sort" class="headerlink" title="6.4.7 sort"></a>6.4.7 sort</h3><p>接受两个RandomAccesslterators，然后将区间内的所有元素以渐增方式重新排列</p><p>vector和dequeue适合使用sort算法</p><p><strong>sort实现</strong>：当数据量较大时采用快速排序，当数据量较小时使用插入排序（SGI阈值是16）。通常都是先使用快速排序完成粗略的排序，此时段间有序，段内无序，然后使用插入排序完成段内排序。</p><p><strong>median-of-Three</strong>：为了避免排序元素不随机，整个序列的头、尾、中央三个元素的中值作为枢纽</p><p>快速排序的分割算法实现：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201192424865.png"></p><p><strong>introsort</strong></p><p>此算法是快速排序的改进，能有效避免算法恶化为O(N^2^)。</p><p>其通过先计算快速排序最大需要递归次数N，然后若当前递归次数达到N时，就使用堆排序进行排序，</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201192916195.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201192923452.png"></p><h3 id="6-4-8-equal-range"><a href="#6-4-8-equal-range" class="headerlink" title="6.4.8 equal_range"></a>6.4.8 equal_range</h3><p>是二分查找法的一个版本。试图在<strong>已排序</strong>的[first,last)中寻找value。它返回一对迭代器i和j,i是在不破坏次序的前提下，value可以插入的第一个位置，j则是最后一个。因此 [i, j) 内都是value。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201193159640.png"></p><p>其实现是先找到value位置，然后在value前部分使用lower_bound找到第一个value值，在value后半部分使用uupper_bound找到最后一个value。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201193430401.png"></p><h3 id="6-4-9-inplace-merge"><a href="#6-4-9-inplace-merge" class="headerlink" title="6.4.9 inplace_merge"></a>6.4.9 inplace_merge</h3><p>将两个连在一起且已排序的序列[first,middle) 和[middle, last) 合并成一个序列，合并结果有序。</p><p>其是一种稳定操作，不会改变相同元素次序。</p><blockquote><p>merge和inplace_merge区别？</p><p>merge：将两个有序但分离的区间合并</p><p>inplace_merge：将两个有序但不分离的区间合并</p></blockquote><p>注意，这个算法会使用额外的内存空间效率会高很多，但没有缓冲区也能运作。</p><p>当缓冲区空间充足时，将其中一个序列复制到缓冲区中，然后使用merge完成剩余工作。当缓冲区空间不足时，则将处理长度减半，看是否能容纳与缓冲区中。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201194411471.png"></p><h3 id="6-4-10-nth-element"><a href="#6-4-10-nth-element" class="headerlink" title="6.4.10 nth_element"></a>6.4.10 nth_element</h3><p>重新排列，使得迭代器nth所指的元素，与整个迭代队列完整排序之后，同一位置的元素同值。同时保证[nth,last)内没有任何一个元素小于[first,nth)；但对于[first,nth)和[nth,last)两个子区间内的元素次序则无任何保证。</p><p>简单来说就是将大于某值的元素置于尾部，小于的置于首部。其做法是不断进行递归，判断nth迭代器落在左子序列中还是右子序列中，然后再对那个序列进行分割。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201203330511.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201203943805.png"></p><h3 id="6-4-11-merge-sort"><a href="#6-4-11-merge-sort" class="headerlink" title="6.4.11 merge sort"></a>6.4.11 merge sort</h3><p>即归并排序，可利用inplace_merge实现。</p><p>其复杂度虽然为O(NlogN)，但由于需要额外空间和不断移动数据，因此效率比不上快速排序</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201204220642.png"></p><h1 id="七、仿函数"><a href="#七、仿函数" class="headerlink" title="七、仿函数"></a>七、仿函数</h1><p>仿函数是一个行为类似函数的对象，需要重载  ()  操作符</p><blockquote><p>有函数指针为啥还需要仿函数？</p><p>函数指针不能满足STL对抽象性的要求，且无法和STL其他组件搭配产生灵活变化</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201205148990.png"></p><p>仿函数的分类：</p><ul><li>按操作数的个数：一元和二元仿函数</li><li>按功能划分：算术运算、关系运算、逻辑运算。</li></ul><h2 id="7-1-可配接-Adaptable-的关键"><a href="#7-1-可配接-Adaptable-的关键" class="headerlink" title="7.1 可配接(Adaptable)的关键"></a>7.1 可配接(Adaptable)的关键</h2><p>仿函数需要定义相应型别才能让配接器取出，从而获得仿函数的某些信息。</p><p>仿函数型别主要有函数参数类型和传回值型别。</p><p>STL定义了两个class，分别代表一元仿函数和二元仿函数（不支持三元仿函数），其中只有型别定义，无任何成员函数或变量。任何仿函数只需继承其一即可拥有配接能力。</p><p><strong>unary_function</strong></p><p>呈现一元函数的参数型别和返回类型</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202103705069.png"></p><p><strong>binary_function</strong></p><p>用来呈现二元函数的参数型别和返回值类型。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202103916695.png"></p><h2 id="7-2-算数类仿函数"><a href="#7-2-算数类仿函数" class="headerlink" title="7.2 算数类仿函数"></a>7.2 算数类仿函数</h2><p>STL提供一些算术类仿函数：</p><ul><li>加法：plus</li><li>减法：minus</li><li>乘法:multiplies</li><li>除法：divides</li><li>膜取(modulus):modulus</li><li>否定(negation):negate</li></ul><p><strong>证同元素（identity_element）</strong></p><p>数值A若与该元素做OP运算，会得到A自己。加法的同证元素为0，因为任何匀速加上0仍为自己。乘法的同证元素为1，因为任何元素乘以1任然为自己</p><h2 id="7-3-关系运算类仿函数"><a href="#7-3-关系运算类仿函数" class="headerlink" title="7.3 关系运算类仿函数"></a>7.3 关系运算类仿函数</h2><p>STL提供一些关系类仿函数：</p><ul><li>等于：equal_to</li><li>不等于：not_equal_to</li><li>大于: greater</li><li>大于或者等于：greater_equal</li><li>小于：less</li><li>小于或者等于:less_equal</li></ul><h2 id="7-4-逻辑运算类仿函数"><a href="#7-4-逻辑运算类仿函数" class="headerlink" title="7.4 逻辑运算类仿函数"></a>7.4 逻辑运算类仿函数</h2><p>其中And和Or为二元运算符，Not为一元运算符</p><ul><li>And: logical_and</li><li>Or: logical_or</li><li>Not: logical_not</li></ul><h2 id="7-5-证同-identity-、选择-select-、投射-project"><a href="#7-5-证同-identity-、选择-select-、投射-project" class="headerlink" title="7.5 证同(identity)、选择(select)、投射(project)"></a>7.5 证同(identity)、选择(select)、投射(project)</h2><p>皆非STL标准，这三个仿函数只是将参数原封不动传回，设计这三个仿函数是为了间接性（抽象）</p><p><strong>证同</strong></p><ul><li>任何数值通过此函数后，不会有任何改变，此式运用于用来指定RB-tree所需要的KeyOfValue op ，因为set元素的键值即实值，所以采用identity</li></ul> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">identity</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">unary_function</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span><span class="token class-name">T</span><span class="token operator">></span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">&#125;</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>选择</strong></p><ul><li>接受一个pair,传回第一元素。此式运用于用来指定RB-tree所需要的KeyOfValue op ，因为map系以pair元素的第一个元素为其键值，所以采用select1st。</li></ul><p><strong>投射</strong></p><ul><li>传回第一参数，忽略第二参数</li></ul><h1 id="八、配接器"><a href="#八、配接器" class="headerlink" title="八、配接器"></a>八、配接器</h1><p>配接器分类</p><ul><li><strong>function adapter</strong>: 改变仿函数(functors)接口</li><li><strong>container adapter</strong>: 改变容器(container)接口</li><li><strong>iterators adapter</strong>: 改变迭代器接口</li></ul><h2 id="8-1-container-adapters"><a href="#8-1-container-adapters" class="headerlink" title="8.1 container adapters"></a>8.1 container adapters</h2><p>stack和queue底层皆由deque构成，其都是封住了deque对外接口，只开放符合原则的几个函数。</p><h2 id="8-2-iterator-adapters"><a href="#8-2-iterator-adapters" class="headerlink" title="8.2 iterator adapters"></a>8.2 iterator adapters</h2><h3 id="8-2-1-insert-iterators"><a href="#8-2-1-insert-iterators" class="headerlink" title="8.2.1 insert iterators"></a>8.2.1 insert iterators</h3><ul><li><p>将一般迭代器的赋值转换为插入操作，主要有back_insert_iterator、front_insert_iterator、insert_iterator。</p></li><li><p>每一个insert iterator内部都维护一个容器，调用其operator&#x3D;操作符时实际是在调用底层容器的push_front()或Push_back()或insert()</p></li><li><p>上述三种配接器使用不直观，提供三个相应函数来操作<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202112047682.png"></p></li></ul><p>back_insert_iterator实现代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202144747631.png"></p><p>back_insert辅助函数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202144819846.png"></p><h3 id="8-2-2-reverse-iterators"><a href="#8-2-2-reverse-iterators" class="headerlink" title="8.2.2 reverse iterators"></a>8.2.2 reverse iterators</h3><p>将一般迭代器的移动方向逆转，如原来的++操作变成后退，–操作变成前进</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator ite<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>id<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reverse_iterator<span class="token operator">&lt;</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator<span class="token operator">></span> <span class="token function">rite</span><span class="token punctuation">(</span>ite<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>STL容器提供的rbegin()和rend()定义都类似如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202145353274.png"></p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202145900054.png"></p><p>由于迭代器区间的“前闭后开”的习惯，当迭代器被逆向方向时，虽然实体位置(真正的地址)不变，但其逻辑位置(迭代器所代表的元素)改变了(必须如此改变)：因此正向和其逆向迭代器所取出的是不同的元素。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202145804973.png"></p><p>reverse iterator实现：</p><p><em>操作符重载是核心，*<em>对逆向迭代器取值，就是将“对应之正向迭代器”后退一格而后取值。</em></em></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202150412826.png"></p><h3 id="8-2-3-stream-iterators"><a href="#8-2-3-stream-iterators" class="headerlink" title="8.2.3 stream iterators"></a>8.2.3 stream iterators</h3><ul><li><p>可以将一个迭代器绑定到一个stream对象上。绑定到istream对象例如(std::cin)，就是istream_iterator拥有输入能力，同理输出对象上有输出能力。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202112612289.png"></p></li><li><p>istream iterator内部会维护一个istream member，对迭代器做的++操作都会调用istream member的输入操作。</p></li></ul><p>istream_iterator代码实现：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202151358555.png"></p><p>注意，只要定义一个istream iterator且绑定某个istream object，程序便会一直停留在read()上，等待输入。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202151633586.png"></p><h2 id="8-3-function-adapters"><a href="#8-3-function-adapters" class="headerlink" title="8.3 function adapters"></a>8.3 function adapters</h2><ul><li><p>所有期望获得配接能力的组件，本身都必须是可配接的。</p></li><li><p>STL提供的函数配接器也能用于一般函数和成员函数，但一般函数需经ptr_fun处理，成员函数需经mem_fun处理。</p></li><li><p><strong>函数配接器内部存在一个member object，只有真正调用某个函数配接器时，才会对其member object进行操作。</strong></p></li><li><p>常见配接器的辅助函数如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202113640598.png"></p></li></ul><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202154222284.png"></p><h3 id="8-3-1-逻辑否定：not1和not2"><a href="#8-3-1-逻辑否定：not1和not2" class="headerlink" title="8.3.1 逻辑否定：not1和not2"></a>8.3.1 逻辑否定：not1和not2</h3><p>not1用于一元操作，not2用于二元操作</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202154754141.png"></p><h3 id="8-3-2-参数绑定：bind1st和bind2nd"><a href="#8-3-2-参数绑定：bind1st和bind2nd" class="headerlink" title="8.3.2 参数绑定：bind1st和bind2nd"></a>8.3.2 参数绑定：bind1st和bind2nd</h3><p>bind1st用于绑定第一个参数，bind2nd用于绑定第二个参数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202154912324.png"></p><h3 id="8-3-3-函数合成：compose1和compose2"><a href="#8-3-3-函数合成：compose1和compose2" class="headerlink" title="8.3.3 函数合成：compose1和compose2"></a>8.3.3 函数合成：compose1和compose2</h3><p>compose1接受两个参数，即调用 op1(op2)</p><p>compose2接受三个参数，即调用 op1(op2, op3)</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202155149637.png"></p><h3 id="8-3-4-用于函数指针：ptr-fun"><a href="#8-3-4-用于函数指针：ptr-fun" class="headerlink" title="8.3.4 用于函数指针：ptr_fun"></a>8.3.4 用于函数指针：ptr_fun</h3><p>这种配接器使得我们能够将一般函数当做仿函数使用，将一般函数当做仿函数传给STL算法。</p><p>其实质就是把一个函数指针包裹成一个函数对象使用。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202155501470.png"></p><h3 id="8-3-5-用于成员函数指针：mem-fun和mem-fun-ref"><a href="#8-3-5-用于成员函数指针：mem-fun和mem-fun-ref" class="headerlink" title="8.3.5 用于成员函数指针：mem_fun和mem_fun_ref"></a>8.3.5 用于成员函数指针：mem_fun和mem_fun_ref</h3><p>这种配接器使得我们能够将成员函数当做仿函数来进行使用，使得成员函数可以搭配各种泛型算法。</p><p>当一个容器中存储 X* 时，可以用virtual成员函数作为仿函数，从而由泛型算法完成多态调用（示例可见p489）。<strong>这是泛型和多态之间的重要接轨。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202155913739.png"></p><p>mem_fun代码实现：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202160345735.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202160416099.png"></p><p>mem_fun_ref代码实现：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202160448092.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202160521723.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性</title>
      <link href="/2023/02/15/c++/C++11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2023/02/15/c++/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p><em><strong>C++11新特性</strong>，<a href="https://www.bilibili.com/video/BV1bX4y1G7ks?p=1&vd_source=7135ae3a4d6506056ac51c05382c2a25">bilibili视频地址</a>, <a href="https://subingwen.cn/cplusplus/#C-11">博客地址</a>。</em></p><hr><hr><h1 id="1-原始字面量"><a href="#1-原始字面量" class="headerlink" title="1. 原始字面量"></a>1. 原始字面量</h1><p>编程过程中，使用的字符串中常带有一些特殊字符，如\t等符号，导致输入路径时输入\需要输入\</p><p>C++11 中提供了定义原始字符串的字面量，定义方式如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">R“<span class="token function">xxx</span><span class="token punctuation">(</span>原始字符串<span class="token punctuation">)</span>xxx”<span class="token comment">//（）两边的字符串用于说明字符串含义，其可以省略，即使（）两边写了字符也不会被打印出来</span>string str2 <span class="token operator">=</span> <span class="token raw-string string">R"(D:\hello\world\test.text)"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li>（1）在R “xxx(raw string)xxx” 中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且加的字符串必须在括号两边同时出现。</li><li>（2）xxx部分不能加 ( 或 )</li></ul><h1 id="2-指针空值类型-nullptr"><a href="#2-指针空值类型-nullptr" class="headerlink" title="2. 指针空值类型 - nullptr"></a>2. 指针空值类型 - nullptr</h1><blockquote><p>C++11以前，给指针赋空置使用的是NULL，但是在C++中，NULL就是0，这有时会使程序出现健壮性问题。</p><p>比如函数重载时，函数调用的是一个空指针，但由于空指针就是0，则编译器会选择调用int型重载函数，而非指针型重载函数。</p></blockquote><p>C++11引入了关键字 nullptr，其专门用于初始化空类型指针。也就是以前给一个指针赋NULL，那么这个指针其实是0，其类型变为了int，但现在给指针赋nullptr，那么这个指针就是真的一个空指针，<strong>其类型是指针，而不是int</strong>。</p><p><strong>注意</strong></p><ul><li>（1）nullptr 无法隐式转换为整形，但是可以隐式匹配指针类型</li></ul><h1 id="3-常量表达式修饰符-constexpr"><a href="#3-常量表达式修饰符-constexpr" class="headerlink" title="3. 常量表达式修饰符 - constexpr"></a>3. 常量表达式修饰符 - constexpr</h1><p>const有两重语义：变量只读，修饰常量</p><p>变量只读：定义函数时，形参前有const修饰，此时表示此形参只读</p><p>修饰常量：定义常量</p><p>C++11 中添加了一个新的关键字 constexpr，其用来修饰常量表达式（也就只有修饰常量这一种语义）。<strong>常量表达式</strong>，指的就是由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式。</p><p>在定义常量时，const 和 constexpr 是等价的</p><p><strong>建议</strong>：凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。</p><h2 id="3-1-常量表达式函数"><a href="#3-1-常量表达式函数" class="headerlink" title="3.1 常量表达式函数"></a>3.1 常量表达式函数</h2><p><strong>修饰函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>constexpr修饰函数时，需满足以下条件（常量表达式函数就表示编译时就能将函数计算出来，因此有以下许多限制）：</p><ul><li>（1）函数必须要有返回值，并且 return 返回的表达式必须是常量表达式。</li><li>（2）函数在使用之前，必须有对应的定义语句。</li><li>（3）整个函数的函数体中，不能出现非常量表达式之外的语句（using 指令、typedef 语句以及 static_assert 断言、return 语句除外）。</li></ul><h2 id="3-2-修饰模板函数"><a href="#3-2-修饰模板函数" class="headerlink" title="3.2 修饰模板函数"></a>3.2 修饰模板函数</h2><p>constexpr 可以修饰函数模板</p><p>如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p><p>如果满足，则模板函数实例化为常量表达式函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 定义函数模板</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">constexpr</span> T <span class="token function">dispaly</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">struct</span> <span class="token class-name">Person</span> ret <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//由于参数 p 是变量，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> ret1 <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-修饰构造函数"><a href="#3-3-修饰构造函数" class="headerlink" title="3.3 修饰构造函数"></a>3.3 修饰构造函数</h2><p>如果想用直接得到一个常量对象，也可以使用 constexpr 修饰一个构造函数，这样就可以得到一个常量构造函数了。</p><p>常量构造函数有一个要求：<strong>构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">constexpr</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>C++构造函数体内初始化与列表初始化的区别</strong></p><ul><li>（1）类成员初始化总在构造函数执行之前</li><li>（2）成员是常量或引用：成员无法赋值，只能被初始化</li><li>（3）如果在类构造函数里赋值：在成员初始化时会调用一次其默认的构造函数，在类构造函数里又会调用一次成员的构造函数再赋值</li><li>（4）如果在类构造函数使用初始化列表：仅在初始化列表里调用一次成员的构造函数并赋值</li><li>（5）如果成员中有的类型没有无参构造函数则必须使用列表初始化；因为不写列表的话会调用默认的无参构造函数；</li><li>（6）初始化列表的初始化顺序与列表顺序无关，只与声明的顺序有关；</li></ul><h1 id="4-自动类型推导：auto和decltype"><a href="#4-自动类型推导：auto和decltype" class="headerlink" title="4. 自动类型推导：auto和decltype"></a>4. 自动类型推导：auto和decltype</h1><h2 id="4-1-auto"><a href="#4-1-auto" class="headerlink" title="4.1 auto"></a>4.1 auto</h2><blockquote><p>在 C++11 之前 auto 和 static 是对应的，表示变量是自动存储的</p><p>在 C++11 中，auto能够自动推导出变量的实际类型</p></blockquote><p>使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在<strong>编译时</strong>将auto占位符替换为真正的类型。</p><p>auto 和指针、引用结合起来使用有以下规则：</p><ul><li>（1）当变量不是指针或者引用类型时，推导的结果中不会保留 const、volatile 关键字</li><li>（2）当变量是指针或者引用类型时，推导的结果中会保留 const、volatile 关键字</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">auto</span> a1 <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token comment">//auto被推导为int</span><span class="token keyword">auto</span> a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span><span class="token comment">//int</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>a3 <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token comment">//int</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>a4 <span class="token operator">=</span> a3<span class="token punctuation">;</span><span class="token comment">//const int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>auto 的限制</strong></p><ul><li><p>（1）不能作为函数参数使用。因为只有在函数调用的时候才会给函数参数传递实参，auto 要求必须要给修饰的变量赋值，因此二者矛盾。（auto是在编译时候就被推导出来）</p></li><li><p>（2）不能用于类的非静态成员变量的初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> v1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token comment">// error</span>    <span class="token keyword">static</span> <span class="token keyword">auto</span> v2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment">// error,类的静态非常量成员不允许在类内部直接初始化</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">auto</span> v3 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token comment">// ok</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>（3）不能使用 auto 关键字定义数组</p></li><li><p>（4）无法使用 auto 推导出模板参数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> t<span class="token punctuation">;</span>    Test<span class="token operator">&lt;</span><span class="token keyword">auto</span><span class="token operator">></span> t1 <span class="token operator">=</span> t<span class="token punctuation">;</span>           <span class="token comment">// error, 无法推导出模板类型</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>auto 的应用</strong></p></li><li><p>（1）用于STL的容器遍历。</p></li><li><p>（2）用于泛型编程，在使用模板的时候，很多情况下我们不知道变量应该定义为什么类型，可以用auto来占位自动推导。</p></li></ul><h2 id="4-2-decltype"><a href="#4-2-decltype" class="headerlink" title="4.2 decltype"></a>4.2 decltype</h2><p>C++提供了decltype关键字，用于推导一个表达式的类型来定义变量。这和打印类名有差别，C++中打印类名用的是 typeid(classname).name()</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">decltype</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>推导规则</strong></p><ul><li>（1）表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用 decltype 推导出的类型和表达式的类型是一致的。</li><li>（2）表达式是函数调用，使用 decltype 推导出的类型和函数返回值一致。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//函数声明</span><span class="token keyword">int</span> <span class="token function">func_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 返回值为 int</span><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">func_int_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 返回值为 int&amp;</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">func_int_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回值为 int&amp;&amp;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token function">func_cint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 返回值为 const int </span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">func_cint_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 返回值为 const int&amp;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">func_cint_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 返回值为 const int&amp;&amp;</span><span class="token keyword">const</span> Test <span class="token function">func_ctest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回值为 const Test</span><span class="token comment">//decltype类型推导</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> b <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  e <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_ctest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> g <span class="token operator">=</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//变量 a 被推导为 int 类型</span><span class="token comment">//变量 b 被推导为 int&amp; 类型</span><span class="token comment">//变量 c 被推导为 int&amp;&amp; 类型</span><span class="token comment">//变量 d 被推导为 int 类型 !!!!!!!!!!!!!!!!</span><span class="token comment">//变量 e 被推导为 const int &amp; 类型</span><span class="token comment">//变量 f 被推导为 const int &amp;&amp; 类型</span><span class="token comment">//变量 g 被推导为 const Test 类型</span>函数 <span class="token function">func_cint</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> 返回的是一个纯右值（在表达式执行结束后不再存在的数据，也就是临时性的数据），对于纯右值而言，只有自定义类类型的推导结果可以携带<span class="token keyword">const</span>、<span class="token keyword">volatile</span>限定符，除此之外（也就是内置类型）需要忽略掉这两个限定符，因此推导出的变量 d 的类型为 <span class="token keyword">int</span> 而不是 <span class="token keyword">const</span> <span class="token keyword">int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>（3）表达式是一个左值，或者被括号 ( ) 包围，使用 decltype 推导出的是表达式类型的引用（如果有 const、volatile 限定符不能忽略）。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> Test obj<span class="token punctuation">;</span>    <span class="token comment">//带有括号的表达式</span>    <span class="token keyword">decltype</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token comment">//加法表达式</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">decltype</span><span class="token punctuation">(</span>n <span class="token operator">+</span> m<span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">decltype</span><span class="token punctuation">(</span>n <span class="token operator">=</span> n <span class="token operator">+</span> m<span class="token punctuation">)</span> d <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//obj.num 为类的成员访问表达式，符合场景 1，因此 a 的类型为 int</span><span class="token comment">//obj.num 带有括号，符合场景 3，因此 b 的类型为 const int&amp;。</span><span class="token comment">//n+m 得到一个右值，符合场景 1，因此 c 的类型为 int</span><span class="token comment">//n=n+m 得到一个左值 n，符合场景 3，因此 d 的类型为 int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>decltype 的应用</strong></p><p>在模板类中，某些变量值的类型由输入决定，此时不能使用auto（因为对于非静态变量不能使用auto推导），则可以使用decltype来推导类型定义变量。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> c<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>m_it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> m_it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>m_it<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>m_it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span> m_it<span class="token punctuation">;</span>  <span class="token comment">// 这里不能确定迭代器类型</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">;</span>    Container<span class="token operator">&lt;</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> obj<span class="token punctuation">;</span>    obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//在问号处可以使用decltype来解决变量类型未知问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在问号处不能使用 T::iterator来定义变量，这是因为编译器不能确定iterator到底时类名还是变量，因此还需要在前面加上typename，typename T::iterator定义正确。</p><blockquote><p><strong>class和typename区别</strong>：</p><ul><li>在定义<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E6%A8%A1%E6%9D%BF&spm=1001.2101.3001.7020">类模板</a>或者函数模板时，<code>typename</code> 和 <code>class</code> 关键字等价</li><li>class不能用来指明某个字符串是类名</li><li>对于用于模板定义的依赖模板参数的名称，只有在实例化的参数中存在这个类型名，或者这个名称前面使用了typename关键字修饰，编译器才会将这个名字当做是类型。除了以上两种情况，编译器不会将它视为类型。</li><li>typename只能用于模板中</li></ul></blockquote><h2 id="4-3-返回类型后置"><a href="#4-3-返回类型后置" class="headerlink" title="4.3 返回类型后置"></a>4.3 返回类型后置</h2><blockquote><p>泛型编程中，返回值类型可能是由输入参数类型来决定，调用函数时由用户来决定类型是不安全的，且不优雅。</p></blockquote><p>c++11提供了一种通过输入参数来推导返回类型的方法：返回类型后置</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 符号 -> 后边跟随的是函数返回值的类型</span><span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">,</span> 参数<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>参数表达式<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如按上述所写，auto 会追踪 decltype() 推导出的类型。（这里不能直接在auto位置直接定义decltype()，这是因为变量还没定义，也就无法推导，可以理解成语法原因）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 返回类型后置语法</span><span class="token comment">//例1    </span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span>  <span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token operator">+</span>u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//例2</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">test</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">test</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-final和override"><a href="#5-final和override" class="headerlink" title="5. final和override"></a>5. final和override</h1><h2 id="5-1-fianl"><a href="#5-1-fianl" class="headerlink" title="5.1 fianl"></a>5.1 fianl</h2><p>final 关键字用来&#x3D;&#x3D;限制某个类不能被继承，或者某个虚函数不能被重写&#x3D;&#x3D;</p><p>如果使用 final 修饰函数，只能修饰虚函数</p><p>final关键字需放到类或者函数的后面</p><ul><li>如果使用 final 修饰函数（只能修饰虚函数），这样就能阻止子类重写父类的这个函数</li><li>使用 final 关键字修饰过的类是不允许被继承的，也就是说这个类不能有派生类。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//修饰函数</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">final</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//修饰类</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5-2-override"><a href="#5-2-override" class="headerlink" title="5.2 override"></a>5.2 override</h2><p>当类实现多态时，子类可以重写父类中的虚函数，override关键字可以确保重写虚函数的正确性和增加代码可读性。</p><p>override不是必须的，可以看成一种错误提示机制，当重写的函数不是虚函数时，如果函数后面有override关键字，则会提示错误。</p><p>override关键字需要写到函数后面</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="6-模板的优化"><a href="#6-模板的优化" class="headerlink" title="6. 模板的优化"></a>6. 模板的优化</h1><h2 id="6-1-模板的右尖括号优化"><a href="#6-1-模板的右尖括号优化" class="headerlink" title="6.1 模板的右尖括号优化"></a>6.1 模板的右尖括号优化</h2><p>c++11以前，模板实例时使用两个右尖括号（&gt;&gt;）会被编译器解析成右移操作符，而不是模板参数表的结束，需要在两个右尖括之间添加空格才能识别为模板结束。</p><p>C++11改进了编译器的解析规则，尽可能地将多个右尖括号（&gt;）解析成模板参数结束符</p><h2 id="6-2-默认模板参数"><a href="#6-2-默认模板参数" class="headerlink" title="6.2 默认模板参数"></a>6.2 默认模板参数</h2><p>在 C++98&#x2F;03 标准中，类模板可以有默认的模板参数，但是不支持函数的默认模板参数</p><p>在C++11中添加了对&#x3D;&#x3D;函数模板默认参数&#x3D;&#x3D;的支持</p><ul><li><p>当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。</p></li><li><p>但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随 &lt;&gt; 来实例化</p></li><li><p>函数模板的默认模板参数没有必须写在参数表最后的限制（不需要一定写在尾部）</p></li><li><p>模板参数类型的自动推导是根据模板函数调用时指定的实参进行推断的，没有实参则无法推导</p></li></ul><p><strong>当默认模板参数和模板参数自动推导同时使用时</strong></p><ul><li>如果可以推导出参数类型则使用推导出的类型</li><li>如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数</li><li>如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错</li><li><em>只要在&lt;&gt;中指定了参数类型，此优先级最高，会使用此参数类型</em></li></ul><p><strong>注意</strong></p><ul><li>当函数模板类型没有默认类型，而其对应的参数有指定默认值，此默认值不能用于反推其类型</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">char</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T arg1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> U arg2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用报错，此时本使用默认值100，但是默认值不能用于反推导变量类型</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//参数 T 被自动推导为 char 类型，U 使用的默认模板参数为 char 类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-using使用"><a href="#7-using使用" class="headerlink" title="7. using使用"></a>7. using使用</h1><p>c++11能使用using和typedef来为类型定义一个别名，被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字</p><p>类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名</p><p>使用typedef定义的别名和使用using定义的别名在语义上是等效的</p><p><strong>using和typedef重定义类型</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> 旧的类型名 新的类型名<span class="token punctuation">;</span><span class="token comment">// 使用举例</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> uint_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>using和typedef重定义函数指针</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 使用typedef定义函数指针</span><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用using定义函数指针</span><span class="token keyword">using</span> func_ptr1 <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>using相比typedef定义函数指针式，可读性更强更清晰</p><p><strong>using相比typedef的优点是能定义模板别名</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span> type<span class="token punctuation">;</span><span class="token comment">// error, 语法错误</span><span class="token comment">//只能使用定义一个类来变相使用</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token comment">// 定义外敷类</span><span class="token keyword">struct</span> <span class="token class-name">MyMap</span><span class="token punctuation">&#123;</span>    <span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span> type<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>using定义模板别名</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">using</span> mymap <span class="token operator">=</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li>using 语法和 typedef 一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名</li><li>using 相较于 typedef 的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名</li></ul><h1 id="8-委托构造函数和继承构造函数"><a href="#8-委托构造函数和继承构造函数" class="headerlink" title="8. 委托构造函数和继承构造函数"></a>8. 委托构造函数和继承构造函数</h1><h2 id="8-1-委托构造函数"><a href="#8-1-委托构造函数" class="headerlink" title="8.1 委托构造函数"></a>8.1 委托构造函数</h2><p> &#x3D;&#x3D;委托构造函数允许使用同一个类中的一个构造函数调用此类中定义的其它构造函数&#x3D;&#x3D;，从而简化相关变量的初始化</p><p><strong>注意</strong></p><ul><li><p>链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常</p></li><li><p><em>如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。</em></p></li><li><p>在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了。</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 错误, 使用了委托构造函数就不能再次m_max初始化了</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">,</span> <span class="token keyword">int</span> min<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Test</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_max</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token operator">-></span>m_min <span class="token operator">=</span> min <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> min <span class="token operator">&lt;</span> max <span class="token operator">?</span> min <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="8-2-继承构造函数"><a href="#8-2-继承构造函数" class="headerlink" title="8.2 继承构造函数"></a>8.2 继承构造函数</h2><p>C++11 中提供的&#x3D;&#x3D;继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数&#x3D;&#x3D;</p><p>在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写</p><p>没有继承构造函数之前的处理方式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>    string m_k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 通过使用  <code>using 类名::构造函数名</code> 来声明使用基类的构造函数,这样子类中可以直接使用基类的构造函数来构造派生类对象（注意所有构造函数都能在子类中使用了，因为构造函数名一样）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>    string m_k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果在子类中隐藏了父类中的同名函数，也可以通过 using 类名:函数名 的方式在子类中使用基类中的这些父类函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base class: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> string str<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base class: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">", str = "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>    string m_k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>func<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"child class: i'am luffy!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="9-列表初始化"><a href="#9-列表初始化" class="headerlink" title="9. 列表初始化"></a>9. 列表初始化</h1><blockquote><p> C++ 中的变量，数组，对象等都有不同的初始化方法，在这些繁琐的初始化方法中没有任何一种方式适用于所有的情况。</p><p>为了统一初始化方式，并且让初始化行为具有确定的效果，在 C++11 中提出了列表初始化的概念</p></blockquote><h2 id="9-1-统一的初始化"><a href="#9-1-统一的初始化" class="headerlink" title="9.1 统一的初始化"></a>9.1 统一的初始化</h2><blockquote><p>在 C++98&#x2F;03 中，对应普通数组和可以直接进行内存拷贝（memcpy ()）的对象是可以使用列表初始化来初始化数据的</p><p>在 C++11 中，列表初始化变得更加灵活</p></blockquote><p><strong>列表初始化即使没有定义构造函数在满足要求情况下也能初始化成功</strong>（其实质并不是一定要调用构造函数，只有不满足要求时才会转为调用构造函数来初始化，是否满足要求在下一节中叙述）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test <span class="token function">t1</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最中规中矩的初始化方式，通过提供的带参构造进行对象的初始化</span>    Test t2 <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span> <span class="token comment">//语法错误，因为提供的拷贝构造函数是私有的。如果拷贝构造函数是公共的，520 会通过隐式类型转换被 Test(int) 构造成一个匿名对象，然后再通过对这个匿名对象进行拷贝构造得到 t2（这个错误在 VS 中不会出现，在 Linux 中使用 g++ 编译会提示描述的这个错误）</span>    Test t3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">520</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//使用了 C++11 的初始化方式来初始化对象，效果和 t1 的方式是相同的</span>    Test t4<span class="token punctuation">&#123;</span> <span class="token number">520</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//使用了 C++11 的初始化方式来初始化对象，效果和 t1 的方式是相同的</span>    <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1314</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a2<span class="token punctuation">&#123;</span> <span class="token number">1314</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// C++11 中新添加的语法格式</span>    <span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// C++11 中新添加的语法格式</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>在初始时，{} 前面的等号是否书写对初始化行为没有任何影响</p></li><li><p>使用 new 操作符创建新对象的时候可以使用列表初始化进行对象的初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">&#123;</span><span class="token number">520</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token keyword">double</span><span class="token punctuation">&#123;</span><span class="token number">52.134</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>列表初始化还可以直接用在函数返回值上</p></li></ul><h2 id="9-2-初始化细节"><a href="#9-2-初始化细节" class="headerlink" title="9.2 初始化细节"></a>9.2 初始化细节</h2><p>对于自定义类型的初始化，会存在两种执行结果，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">T1</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>a <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">321</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">T2</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token function">T2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>b <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">321</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a.x: "</span> <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">", a.y: "</span> <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b.x: "</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">", b.y: "</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">a<span class="token punctuation">.</span>x<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>y<span class="token operator">:</span> <span class="token number">321</span>b<span class="token punctuation">.</span>x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>y<span class="token operator">:</span> <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>执行差异原因如下</strong>：</p><ul><li><p>对象 a 是对一个自定义的聚合类型进行初始化，它将以拷贝的形式使用初始化列表中的数据来初始化 T1 结构体中的成员。</p></li><li><p>在结构体 T2 中自定义了一个构造函数，因此实际的初始化是通过这个构造函数完成的</p></li></ul><p>&#x3D;&#x3D;如果使用列表初始化对对象初始化时，还需要判断这个对象对应的类型是不是一个聚合体，如果是初始化列表中的数据就会拷贝到对象中&#x3D;&#x3D;</p><p>&#x3D;&#x3D;聚合体&#x3D;&#x3D;需要满足以下要求：</p><ul><li><p>无用户自定义的构造函数</p></li><li><p>无私有或保护的非静态数据成员（有私有或保护的静态成员是满足要求的，但不能初始化静态成员）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">T2</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">long</span> y<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span>， <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// error</span><span class="token keyword">struct</span> <span class="token class-name">T2</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">long</span> y<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// ok</span><span class="token comment">// 静态成员的初始化</span><span class="token keyword">int</span> T2<span class="token double-colon punctuation">::</span>z <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>无基类</p></li><li><p>无虚函数</p></li><li><p>类中不能有使用 {} 和 &#x3D; 直接初始化的非静态数据成员（ c++14 开始支持）</p></li></ul><p><strong>非聚合体</strong>：不满足上诉任一条件则为非聚合体</p><p>&#x3D;&#x3D;如果不满足聚合条件使用列表初始化方法：在类的内部自定义一个构造函数, 在构造函数中使用初始化列表对类成员变量进行初始化&#x3D;&#x3D;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">T1</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span>    <span class="token comment">// 在构造函数中使用初始化列表初始化类成员</span>    <span class="token function">T1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", y: "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> <span class="token string">", z: "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    T1 t<span class="token punctuation">&#123;</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token number">1314</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// ok, 基于构造函数使用初始化列表初始化类成员</span>    t<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li><p>聚合类型的定义并非递归的（当一个类的非静态成员是非聚合类型时，这个类也可能是聚合类型）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">T1</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">T2</span><span class="token punctuation">&#123;</span>    T1 t1<span class="token punctuation">;</span>    <span class="token keyword">long</span> x1<span class="token punctuation">;</span>    <span class="token keyword">double</span> y1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    T2 t2<span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//T1 并非一个聚合类型，因为它有一个 Private 的非静态成员。但是尽管 T2 有一个非聚合类型的非静态成员 t1，T2 依然是一个聚合类型，可以直接使用列表初始化的方式进行初始化</span><span class="token comment">//t2 对象的初始化过程，对于非聚合类型的成员 t1 做初始化的时候，可以直接写一对空的大括号 &#123;&#125;，这相当于调用是 T1 的无参构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>对于一个聚合类型，使用列表初始化相当于对其中的每个元素分别赋值，而对于非聚合类型，则需要先自定义一个合适的构造函数，此时使用列表初始化将会调用它对应的构造函数</strong></p></li></ul><h2 id="9-3-std-initializer-list"><a href="#9-3-std-initializer-list" class="headerlink" title="9.3 std::initializer_list"></a>9.3 std::initializer_list</h2><p>std::initializer_list能实现&#x3D;&#x3D;函数只定义一个形参变量，而可以传任意个相同类型的参数&#x3D;&#x3D;</p><p>其和vector来实现传任意个变量十分类似</p><p><strong>std::initializer_list特点</strong>：</p><ul><li>它是一个轻量级的容器类型，内部定义了迭代器 iterator 等容器必须的概念，遍历时得到的迭代器是只读的</li><li>对于 std::initializer_list<T> 而言，它可以接收任意长度的初始化列表，但是要求元素必须是<strong>同种类型 T</strong></li><li>在 std::initializer_list 内部有三个成员接口：size(), begin(), end()</li><li>std::initializer_list 对象只能被整体初始化或者赋值</li></ul><p>使用如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> list<span class="token punctuation">;</span>    list <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current list size: "</span> <span class="token operator">&lt;&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">traversal</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">////////////// 直接通过初始化列表传递数据 //////////////</span>    <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">16</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li>std::initializer_list拥有一个无参构造函数，因此，它可以直接定义实例，此时将得到一个空的</li><li>std::initializer_list，在遍历这种类型的容器的时候得到的是一个只读的迭代器，因此我们不能修改里边的数据，只能通过值覆盖的方式进行容器内部数据的修改（还没搞懂这里的覆盖，都是只读了为啥还能覆盖）</li><li>std::initializer_list的效率是非常高的，它的内部并不负责保存初始化列表中元素的拷贝，仅仅<strong>存储了初始化列表中元素的引用</strong>。</li></ul><h1 id="10-基于范围的for循环"><a href="#10-基于范围的for循环" class="headerlink" title="10. 基于范围的for循环"></a>10. 基于范围的for循环</h1><p>C++11 基于范围的 for 循环，语法格式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>declaration <span class="token operator">:</span> expression<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 循环体</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> value <span class="token operator">:</span> t<span class="token punctuation">)</span><span class="token comment">//t中的值会被拷贝到value中</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>value <span class="token operator">:</span> t<span class="token punctuation">)</span><span class="token comment">//value是t元素的引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>expression 是要遍历的对象，可以是表达式、容器、数组、初始化列表</p><blockquote><p>在遍历过程中，被遍历到的元素会被存储到declaration 中</p><p>在基于范围的for循环中，不需要再传递容器的两端，循环会自动以容器为范围展开，并且循环中也屏蔽掉了迭代器的遍历细节，直接抽取容器中的元素进行运算，使用这种方式进行循环遍历会让编码和维护变得更加简便。</p></blockquote><p><strong>细节</strong></p><ul><li>在关系型容器中<ul><li>使用普通的 for 循环方式（基于迭代器）遍历关联性容器， auto 自动推导出的是一个迭代器类型，需要使用迭代器的方式取出元素中的键值对</li><li>使用基于访问的 for 循环遍历关联性容器，auto 自动推导出的类型是容器中的 value_type，相当于一个对组（std::pair）对象</li></ul></li><li>元素只读型<ul><li>对应 set 容器来说，内部元素都是只读的，这是由容器的特性决定的，因此set 容器在 for 循环中 auto &amp; 会被视为 const auto &amp;</li><li>在遍历关联型容器时也会出现同样的问题，基于范围的for循环中，虽然可以得到一个std::pair引用，但是我们是不能修改里边的first值的，也就是key值。</li></ul></li><li>访问次数<ul><li>基于范围的 for 循环遍历的对象只会被访问一次</li></ul></li></ul><blockquote><p><strong>注意</strong></p><ul><li><p>对应基于范围的 for 循环来说，冒号后边的表达式只会被执行一次。在得到遍历对象之后会先确定好迭代的范围，基于这个范围直接进行遍历。如果是普通的 for 循环，在每次迭代的时候都需要判断是否已经到了结束边界。</p></li><li><p>对容器的遍历过程中，如果只是读数据，不允许修改元素的值，可以使用 const 定义保存元素数据的变量，在定义的时候建议使用 const auto &amp;，这样相对于 const auto 效率要更高一些</p></li></ul></blockquote><h1 id="11-可调用对象包装器、绑定器"><a href="#11-可调用对象包装器、绑定器" class="headerlink" title="11. 可调用对象包装器、绑定器"></a>11. 可调用对象包装器、绑定器</h1><h2 id="11-1可调用对象"><a href="#11-1可调用对象" class="headerlink" title="11.1可调用对象"></a>11.1可调用对象</h2><p><strong>可调用对象定义</strong>有以下几种：</p><ul><li>（1）是一个函数指针</li><li>（2）是一个具有operator()成员函数的类对象（仿函数）</li><li>（3）是一个<strong>可被转换为函数指针的类对象</strong></li><li>（4）是一个类成员函数指针或者类成员指针</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//1 函数指针</span><span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 定义函数指针</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>print<span class="token punctuation">;</span><span class="token comment">//2 具有operator()成员函数的类对象（仿函数）</span><span class="token keyword">struct</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>    <span class="token comment">// ()操作符重载</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>string msg<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"msg: "</span> <span class="token operator">&lt;&lt;</span> msg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test t<span class="token punctuation">;</span>    <span class="token function">t</span><span class="token punctuation">(</span><span class="token string">"我是要成为海贼王的男人!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 仿函数</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//3 可被转换为函数指针的类对象</span><span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> string b<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将类对象转换为函数指针</span>    <span class="token keyword">operator</span> <span class="token function">func_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> print<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//此函数表示将类对象转换为func_ptr类型的函数指针，可以视为仿函数的一层包装，使得仿函数更具有扩展性</span>    <span class="token comment">//调用时是直接使用 类名(参数) 来调用 </span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test t<span class="token punctuation">;</span>    <span class="token comment">// 对象转换为函数指针, 并调用</span>    <span class="token function">t</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"Monkey D. Luffy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//4 类成员函数指针或者类成员指针</span><span class="token keyword">struct</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> string b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> m_num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 定义类成员函数指针指向类成员函数</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span>Test<span class="token double-colon punctuation">::</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>print<span class="token punctuation">;</span><span class="token comment">//这里要不要&amp;符号都可，注意必须加Test::，否则函数指针定义失败</span>    <span class="token comment">//如果是静态成员函数可以不加Test::来定义函数指针   </span>    <span class="token comment">// 类成员指针指向类成员变量</span>    <span class="token keyword">int</span> Test<span class="token double-colon punctuation">::</span><span class="token operator">*</span>obj_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>m_num<span class="token punctuation">;</span>    Test t<span class="token punctuation">;</span>    <span class="token comment">// 通过类成员函数指针调用类成员函数</span>    <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"Monkey D. Luffy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注意这里函数调用形势，必须将前半部分括起来</span>    <span class="token comment">// 通过类成员指针初始化类成员变量</span>    t<span class="token punctuation">.</span><span class="token operator">*</span>obj_ptr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"number is: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述几种方式定义繁杂，且调用方法也不相同，C++11通过提供std::function 和 std::bind统一了可调用对象的各种操作</p><h2 id="11-2-可调用对象包装器"><a href="#11-2-可调用对象包装器" class="headerlink" title="11.2 可调用对象包装器"></a>11.2 可调用对象包装器</h2><p>std::function是可调用对象的包装器。</p><p>是一个类模板，可以容纳&#x3D;&#x3D;除了类成员（函数）指针&#x3D;&#x3D;之外的所有可调用对象。</p><p>通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和<strong>延迟</strong>执行它们。</p><p><strong>可调用对象包装器使用语法</strong>如下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span>返回值类型<span class="token punctuation">(</span>参数类型列表<span class="token punctuation">)</span><span class="token operator">></span> diy_name <span class="token operator">=</span> 可调用对象<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" - "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">-</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" * "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">*</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 绑定以静态类成员函数</span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> T1<span class="token double-colon punctuation">::</span>sub<span class="token punctuation">;</span>    <span class="token comment">// 绑定一个仿函数</span>    T2 t<span class="token punctuation">;</span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f3 <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token comment">//注意这里定义！！！！</span>    <span class="token comment">// 函数调用</span>    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">f3</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;std::function 可以将可调用对象进行包装，得到一个统一的格式&#x3D;&#x3D;，</p><p>包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用</p><p><strong>作为回调函数使用</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 构造函数参数是一个包装器对象</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">&amp;</span> f<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">callback</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token comment">//注意这里不会调用f函数，只是当成一个参数传递赋值</span>    <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用通过构造函数得到的函数指针</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> callback<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    A <span class="token function">a</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仿函数通过包装器对象进行包装</span>    a<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 std::function 作为函数的传入参数，可以将定义方式不相同的可调用对象进行统一的传递，这样大大增加了程序的灵活性。</p><p>注意：传入的函数形式需要与function&lt;&gt;中的函数形式一致才可</p><h2 id="11-3-绑定器"><a href="#11-3-绑定器" class="headerlink" title="11.3 绑定器"></a>11.3 绑定器</h2><p>std::bind用来将&#x3D;&#x3D;可调用对象与其参数一起进行绑定&#x3D;&#x3D;。</p><p>绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候</p><p><strong>作用：</strong></p><ul><li>将可调用对象与其参数一起绑定成一个&#x3D;&#x3D;仿函数&#x3D;&#x3D;。</li><li>将多元（参数个数为n，n&gt;1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数</li></ul><p><strong>绑定器函数使用语法格式如下：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 绑定非类成员函数/变量 </span><span class="token comment">//类静态函数也可使用此方法</span><span class="token keyword">auto</span> f <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>可调用对象地址<span class="token punctuation">,</span> 绑定的参数<span class="token operator">/</span>占位符<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 绑定类成员函/变量。类成员函数都有一个隐藏指针，其实有两个参数，需要指定this为第一个参数</span><span class="token keyword">auto</span> f <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>类函数<span class="token operator">/</span>成员地址<span class="token punctuation">,</span> 类实例对象地址<span class="token punctuation">,</span> 绑定的参数<span class="token operator">/</span>占位符<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function</p><p>在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了</p><p>提供占位符，<code>placeholders::_1</code> 是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代。</p><p><code>placeholders::_2</code>、<code>placeholders::_3</code>同理（&#x3D;&#x3D;注意&#x3D;&#x3D;，占位符是按位置去找的，<code>placeholders::_2</code>只会去找第二个数，即使只有一个数，且没有<code>placeholders::_1</code>也只会去找第二个数，那么就会找不到报错）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数</span>    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// error, 调用时没有第二个参数</span>     <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//！！！占位符是按位置去找的，不是按个数</span>    <span class="token comment">// 调用时第一个参数10被吞掉了，没有被使用</span>    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>绑定类成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", y: "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> m_number <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test t<span class="token punctuation">;</span>    <span class="token comment">// 绑定类成员函数</span>    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span>         <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>output<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 绑定类成员变量(公共) </span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>m_number<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里auto推导出的类型不是包装器类型而是仿函数</span>    <span class="token keyword">auto</span> f3 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>m_number<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用</span>    <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">1314</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2333</span><span class="token punctuation">;</span><span class="token comment">//注意还可这样调用</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t.m_number: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_number <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function&lt;**int&amp;**(void)&gt;的包装器对象f2中</p><p>其中&#x3D;&#x3D;int是绑定的类成员的类型&#x3D;&#x3D;，这里返回值是int&amp;的原因是：定义一个类成员的函数，那么就要能访问和修改它，因此类型为int&amp;</p><p>由于没有参数因此参数列表指定为void</p><p><strong>注意</strong></p><ul><li>函数如果使用绑定器制定了参数，即使后面函数调用时传参，那么也只会使用绑定器绑定时设置的数值。</li><li>绑定类成员变量时，必须是公有变量</li><li>包装器类成员的书写语法为function&lt;类成员类型&amp;(void)&gt;</li><li>使用auto推导出的绑定器类型是反函数，而使用包装器定义的绑定器的变量类型是包装器类型</li></ul><h1 id="12-Lambda表达式"><a href="#12-Lambda表达式" class="headerlink" title="12. Lambda表达式"></a>12. Lambda表达式</h1><blockquote><p>lambda 表达式是 C++11 最重要也是最常用的特性之一</p></blockquote><p>相比传统函数，lambda表达式特点是局部定义然后销毁</p><p><strong>优点</strong>：</p><ul><li>声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象</li><li>简洁：避免了代码膨胀和功能分散，让开发更加高效</li><li>在需要的时间和地点实现功能闭包，使程序更加灵活</li></ul><h2 id="12-1-基本使用"><a href="#12-1-基本使用" class="headerlink" title="12.1 基本使用"></a>12.1 基本使用</h2><p>&#x3D;&#x3D;lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量&#x3D;&#x3D;，语法形式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>capture<span class="token punctuation">]</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> opt <span class="token operator">-></span> ret <span class="token punctuation">&#123;</span>body<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 capture 是捕获列表，params 是参数列表，opt 是函数选项，ret 是返回值类型，body 是函数体。</p><ul><li>捕获列表 []: 捕获一定范围内的变量</li><li>参数列表 (): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写</li><li>opt 选项， 不需要可以省略<ul><li>mutable: 可以&#x3D;&#x3D;修改按值传递进来的拷贝&#x3D;&#x3D;（注意是能修改拷贝，而不是值本身）</li><li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ()</li></ul></li><li>返回值类型：在 C++11 中，lambda 表达式的返回值是通过返回值后置语法来定义的（能自动推导返回类型，可不写，但初始化返回类型时必须写）</li><li>函数体：函数的实现，这部分不能省略，但函数体可以为空</li></ul><h2 id="12-2-捕获列表"><a href="#12-2-捕获列表" class="headerlink" title="12.2 捕获列表"></a>12.2 捕获列表</h2><p>lambda 表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p><ul><li>[] - 不捕捉任何变量</li><li>[&amp;] - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (按引用捕获)</li><li>[&#x3D;] - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (按值捕获)<br>&#x3D;&#x3D;拷贝的副本在匿名函数体内部是只读&#x3D;&#x3D;的</li><li>[&#x3D;, &amp;foo] - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo</li><li>[bar] - &#x3D;&#x3D;按值捕获 bar 变量，同时不捕获其他变量&#x3D;&#x3D;</li><li>[&amp;bar] - 按引用捕获 bar 变量，同时&#x3D;&#x3D;不捕获其他变量&#x3D;&#x3D;</li><li>[this] - 捕获当前类中的 this 指针<ul><li>让 lambda 表达式拥有和当前类成员函数同样的访问权限</li><li>&#x3D;&#x3D;如果已经使用了 &amp; 或者 &#x3D;, 默认添加this指针&#x3D;&#x3D;</li></ul></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                      <span class="token comment">// error 没有捕获外部变量，不能使用类成员 m_number</span>        <span class="token keyword">auto</span> x2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>             <span class="token comment">// ok</span>        <span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>             <span class="token comment">// ok </span>        <span class="token keyword">auto</span> x4 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                  <span class="token comment">// ok</span>        <span class="token keyword">auto</span> x5 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>          <span class="token comment">// error 没有捕获到变量 x，y，因此不能访问</span>        <span class="token keyword">auto</span> x6 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// ok</span>        <span class="token keyword">auto</span> x7 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                <span class="token comment">// ok</span>        <span class="token keyword">auto</span> f8 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//error 显示捕获与默认匹配</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> m_number <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;默认状态下 lambda 表达式无法修改通过复制方式捕获外部变量&#x3D;&#x3D;</p><p>如果希望修改这些外部变量，需要通过引用的方式进行捕获。</p><h2 id="12-3-返回值"><a href="#12-3-返回值" class="headerlink" title="12.3 返回值"></a>12.3 返回值</h2><p>一般情况下，不指定 lambda 表达式的返回值，编译器会根据 return 语句自动推导返回值的类型</p><p>&#x3D;&#x3D;labmda表达式不能通过列表初始化自动推导出返回值类型&#x3D;&#x3D;</p><h2 id="12-4-函数本质"><a href="#12-4-函数本质" class="headerlink" title="12.4 函数本质"></a>12.4 函数本质</h2><p>使用mutable关键字修饰时，可以修改lambda表达式按值捕获的外部变量</p><p>被mutable修改是lambda表达式就算没有参数也要写明参数列表</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>              <span class="token comment">// error, 按值捕获外部变量, a是只读的</span><span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token comment">// ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按值捕获的外部变量是只读的原因：</p><ul><li>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数</li><li>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</li></ul><p><strong>可以使用std::function和std::bind来存储和操作lambda表达式</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 包装可调用函数</span>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 绑定可调用函数</span>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 没有捕获任何外部变量的匿名函数</span>func_ptr f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 函数调用</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1314</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li>包装器和绑定器定义的函数变量也只是个局部变量，一般是在同作用域下使用，此时也就不用关心捕获变量能不能捕捉到</li><li>可以在类函数中也定义lambda表达式。无论是普通函数还是类函数，定义的lambda表达式只能在<strong>定义函数中使用</strong>和<strong>定义函数中调用其他函数使用</strong>，因为此时函数还在栈中，地址已知</li><li>lambda是一个仿函数，但未捕获变量时可以转换为一个普通的函数指针</li><li>若<strong>定义lambda表达式时直接调用，在body后面加 () 即可</strong></li></ul><h1 id="13-右值引用"><a href="#13-右值引用" class="headerlink" title="13. 右值引用"></a>13. 右值引用</h1><blockquote><p>C++11以前，函数变量若想接受右值，则需要声明为const A &amp;，但是如此声明后在函数中A又不能改。如果声明为A&amp;，那么又不能接受右值。因此，右值引用应运而生。</p></blockquote><p>C++11 增加了一个新的类型，称为右值引用（ R-value reference），标记为 &amp;&amp;</p><h2 id="13-1-右值引用"><a href="#13-1-右值引用" class="headerlink" title="13.1 右值引用"></a>13.1 右值引用</h2><blockquote><p>自C++11开始，表达式的值分为<code>左值(lvalue, left value)</code>、<code>将亡值(xvalue, expiring value)</code>、<code>纯右值(pvalue, pure ravlue)</code>以及两种混合类别<code>泛左值(glvalue, generalized lvalue)</code>和<code>右值(rvalue, right value)</code>五种。</p><p>这五种类别的分类基于表达式的两个特征：</p><ul><li>具名(identity):可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的（直接或间接获得的）地址</li><li>可被移动：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式</li></ul><p>结合上述两个特征，对五种表达式值类别进行重新定义：</p><ul><li>lvalue:具名且不可被移动</li><li>xvaue:具名且可被移动</li><li>prvalue:不具名且可被移动</li><li>glvalue:具名，lvalue和xvalue都属于glvalue</li><li>rvalue:可被移动的表达式，prvalue和xvalue都属于rvalue</li></ul></blockquote><p><strong>左值和右值</strong>：</p><ul><li>lvalue 是 loactor value 的缩写，rvalue 是 read value 的缩写</li><li>左值是指存储在内存中、有明确存储地址（可取地址）的数据</li><li>右值是指可以提供数据值的数据（程序员不可取地址，而非编译器）</li></ul><p>区分左值与右值的便捷方法是：&#x3D;&#x3D;可以对表达式取地址（&amp;）就是左值，否则为右值&#x3D;&#x3D;</p><blockquote><p>C++11 中<strong>右值可以分为两种</strong>：一个是<strong>将亡值</strong>（ xvalue, expiring value），另一个则是<strong>纯右值</strong>（ prvalue, PureRvalue）：</p><ul><li>纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等</li><li>将亡值：与右值引用相关的表达式，比如，T&amp;&amp; 类型函数的返回值、 std::move 的返回值等</li></ul></blockquote><p><strong>右值引用</strong>就是对一个右值进行引用的类型</p><ul><li>无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名</li><li>通过右值引用的声明，该右值又“重获新生”，&#x3D;&#x3D;其生命周期与右值引用类型变量的生命周期一样&#x3D;&#x3D;，只要该变量还活着，该右值临时量将会一直存活下去</li><li>使用左值初始化一个右值引用类型是不合法的</li><li>右值不能给普通的左值引用赋值</li><li>&#x3D;&#x3D;常量左值引用是一个万能引用类型，它可以接受左值、右值、常量左值和常量右值&#x3D;&#x3D;。（const Test&amp; t &#x3D;  XXX）</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a1<span class="token punctuation">;</span>    <span class="token comment">//左值引用</span>    <span class="token keyword">int</span><span class="token operator">&amp;</span> b1 <span class="token operator">=</span> a1<span class="token punctuation">;</span>    <span class="token comment">//右值引用</span>    <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> c1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment">//常量左值引用</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> d1 <span class="token operator">=</span> a1<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> d2 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> d3 <span class="token operator">=</span> c1<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> d4 <span class="token operator">=</span> b1<span class="token punctuation">;</span>    <span class="token comment">//常量右值引用</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> e1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> e2 <span class="token operator">=</span> b1<span class="token punctuation">;</span> <span class="token comment">//error</span>    <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span>        <span class="token comment">// error</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>方便记忆</strong></p><ul><li>左值引用实质是一个指针常量，右值很多都是字面量，因此其不能使用右值赋值</li><li>左值引用是个指针常量，那么加上一个const就变为常量指针常量（常量指针常量可以不指向常量），当其指向右值时，编译器会自动创建一个左值绑定此右值，然后将引用指向此左值，因此也就能指向右值了</li><li>无论是左值引用还是右值引用，都表示其能取地址了，相当于左值化了，因此无论是左值引用还是常量左值引用都能使用各种引用来初始化</li><li>右值引用可以理解为一个必须指向右值的指针常量，因此其初始化只能未右值</li></ul></blockquote><p>总结：两种引用都是左值，左值引用可以简单理解为一个指针常量，右值引用可以简单理解为是一个只能指向右值的指针常量</p><h2 id="13-2-性能优化"><a href="#13-2-性能优化" class="headerlink" title="13.2 性能优化"></a>13.2 性能优化</h2><blockquote><p>C++在进行赋值操作时，有时会发生对象之间的深拷贝，但有些对象是临时对象，赋值后就要被销毁，那么可以利用这个临时对象的堆资源避免赋值对象再次申请资源</p><p>解决上述资源浪费的方法就是使用移动构造函数，利用右值引用的移动语义</p></blockquote><p>右值引用<strong>具有移动语义</strong>，移动语义可以将资源（堆、系统对象等）通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建、拷贝以及销毁</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_num</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct: my name is jerry"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_num</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">.</span>m_num<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy construct: my name is tom"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 添加移动构造函数</span>    <span class="token function">Test</span><span class="token punctuation">(</span>Test<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_num</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>m_num<span class="token punctuation">)</span><span class="token comment">//注意！！ 移动构造函数没有const 也不能加const</span>    <span class="token punctuation">&#123;</span>        a<span class="token punctuation">.</span>m_num <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//这里时为了避免临时对象销毁时释放原来堆资源</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"move construct: my name is sunny"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">delete</span> m_num<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destruct Test class ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span><span class="token operator">*</span> m_num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Test <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test t<span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test t <span class="token operator">=</span> <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自动调用移动构造函数</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t.m_num: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>t<span class="token punctuation">.</span>m_num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    Test<span class="token operator">&amp;&amp;</span> t1<span class="token operator">=</span><span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此种方法也会自动调用移动构造函数</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加移动构造函数后，由于返回的是右值（可移动），赋值操作时会优先调用移动构造函数进行赋值</p><p>&#x3D;&#x3D;移动构造函数只会重复利用了临时对象的堆资源，不会也不能利用栈上的变量&#x3D;&#x3D;</p><blockquote><p><strong>注意</strong></p><ul><li>对于需要动态申请大量资源的类，应该设计移动构造函数，以提高程序效率</li><li>一般在提供移动构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成还可以使用拷贝构造函数</li><li>默认调用移动构造函数的方式有两种（调不调用移动构造函数还是看返回值是否可移动）：<ul><li>Test t &#x3D; getObj()</li><li>Test&amp;&amp; t1&#x3D;getObj()</li></ul></li><li>对于一些简单的函数，编译器利用RVO和NRVO技术将其优化，而不使用（移动）拷贝构造函数，比如上述例子如不禁止优化则不会使用移动构造函数</li><li>移动构造函数声明里变量不加const</li><li>如果一个类中的类成员具有移动构造函数，在调用类移动构造函数初始化列表时，不会自动调用类成员的移动构造函数，需要如此初始化：A(A&amp;&amp; t):a(move(t.a))</li></ul></blockquote><h2 id="13-3-编译器优化：RVO和NRVO"><a href="#13-3-编译器优化：RVO和NRVO" class="headerlink" title="13.3 编译器优化：RVO和NRVO"></a>13.3 编译器优化：RVO和NRVO</h2><blockquote><p>当没有移动拷贝构造函数时，编译器有些情况下也会使用RVO和NRVO对代码进行优化。</p><p>此时表现就是返回的右值仍然可以直接用于初始化右值引用，相当于编译器直接将函数部分给省略了，而直接给右值引用那赋值。</p></blockquote><p><strong>RVO</strong></p><blockquote><p>RVO (Return Value Optimization)，是一种编译器优化技术，通过该技术，编译器可以减少函数返回时生成临时对象的个数，从某种程度上可以提高程序的运行效率，对需要分配大量内存的类对象其值复制过程十分友好。</p><ul><li>当一个未具名且未绑定到任何引用的临时变量被移动或复制到一个相同的对象时，拷贝和移动构造可以被省略</li><li>当这个临时对象在被构造的时候，他会直接被构造在将要拷贝&#x2F;移动到的对象</li><li>当未命名临时对象是函数返回值时，发生的省略拷贝的行为被称为RVO(返回值优化)。</li></ul></blockquote><p><strong>NRVO</strong></p><blockquote><p>NRVO，又名具名返回值优化 (Named Return Value Optimization)，为RVO的一个变种，也是一种编译器对于函数返回值优化的方式。此特性从C++11开始支持，也就是说C++98、C++03都是没有将此优化特性写到标准中的，与RVO的不同之处在于函数返回的临时值是具名的。</p><ul><li>NRVO与RVO的区别是返回的对象是具名的</li><li>既然返回的对象是具名的，那么对象是在return语句之前就构造完成。</li></ul></blockquote><p><strong>RVO和NRVO原理都是将返回一个类对象的函数的返回值当做该函数的参数来处理</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Test <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> Test<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//返回的是一个匿名的临时对象 编译器使用RVO技术优化</span>    <span class="token comment">//当没有移动拷贝构造函数时，此种类型应该是调用拷贝构造函数，但编译器会使用RVO技术优化</span><span class="token punctuation">&#125;</span>Test<span class="token operator">&amp;&amp;</span> <span class="token function">getObj1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> Test<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//RVO优化</span><span class="token punctuation">&#125;</span>Test <span class="token function">getObj2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test t<span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token comment">//NRVO优化</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test<span class="token operator">&amp;&amp;</span> t2<span class="token operator">=</span><span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//RVO优化 相当于没有在函数部分创建临时变量了</span>    Test<span class="token operator">&amp;&amp;</span> t1<span class="token operator">=</span><span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//RVO优化 相当于没有在函数部分创建临时变量了</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>RVO和NRVO原理</strong></p><p>RVO优化的原理是消除函数返回时产生的一次临时对象</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Obj <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj <span class="token function">obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当面对上面代码时，编译器RVO会将其优化成：(注意，这种情况其实是适用于NRVO优化的，RVO优化对此没有好处。但是，不是说一段代码可以NRVO就不能RVO。<strong>NRVO相比于RVO，只是一种要求更为严格的优化方式</strong>)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span>Obj <span class="token operator">&amp;</span>_obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj <span class="token function">obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  _obj<span class="token punctuation">.</span><span class="token class-name">Obj</span><span class="token double-colon punctuation">::</span><span class="token function">Obj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝构造函数</span>  <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj<span class="token punctuation">;</span> <span class="token comment">// 仅定义不构造</span>  <span class="token function">fun</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码如果使用NRVO来优化则如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span>Obj <span class="token operator">&amp;</span>_obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   _obj<span class="token punctuation">.</span><span class="token class-name">Obj</span><span class="token double-colon punctuation">::</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj<span class="token punctuation">;</span>  <span class="token function">fun</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RVO适用于不具名的临时对象优化</p><p>面对以下代码时，RVO优化会非常彻底，只剩下一次构造</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Obj <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//RVO优化后</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span>Obj <span class="token operator">&amp;</span>_obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  _obj<span class="token punctuation">.</span><span class="token class-name">Obj</span><span class="token double-colon punctuation">::</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj<span class="token punctuation">;</span>  <span class="token function">fun</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>RVO和NRVO优化失效情况</strong></p><p>编译器并非智能的，对于某些复杂场景或者特殊场景，是不会启用优化的，这个时候就需要开发人员依赖具体的情况，进行具体分析，以达到优化的目的。</p><p>优化失效情况：</p><ul><li><p>运行时依赖(根据不同的条件分支，返回不同变量)</p><ul><li><p>当编译器无法单纯通过函数来决定返回哪个实例对象时，会禁用(N)RVO。</p></li><li><p>但是，下面这种情况例外，虽然其仍然依赖于具体的条件判断。这是因为，<code>对于单个对象以及多个函数出口的情况，编译器将多个出口优化为一个</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Obj <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">bool</span> flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  obj<span class="token punctuation">.</span>n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>返回全局变量(当返回的对象不是在函数内创建的时候，是无法执行返回值优化的。)</p></li><li><p>返回函数参数（与返回全局变量类似，当返回的对象不是在函数内创建的时候，是无法执行返回值优化的。）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Obj <span class="token function">fun</span><span class="token punctuation">(</span>Obj obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj o<span class="token punctuation">;</span>  Obj obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"in main "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>obj <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>返回成员变量（在某些特殊情况下，即使是未具名变量，也不能RVO）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Wraper</span> <span class="token punctuation">&#123;</span>   Obj obj<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Obj <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">Wraper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>obj<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>obj <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>存在赋值行为（(N)RVO只能在从返回值创建对象时发送，在现有对象上使用<code>operator=</code>而不是拷贝&#x2F;移动构造函数，这样是不会进行RVO操作的。）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Obj <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj<span class="token punctuation">;</span>  obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用std::move()返回（在返回值上调用std::move()进行返回是一种错误的方式。它会尝试强制调用移动构造函数，但这样会导致RVO失效。因为即使没有显示调用std::move()，编译器优化中也会执行move操作）</p></li></ul><h2 id="13-4-amp-amp-特性"><a href="#13-4-amp-amp-特性" class="headerlink" title="13.4 &amp;&amp;特性"></a>13.4 &amp;&amp;特性</h2><p>并不是所有情况下 &amp;&amp; 都代表是一个右值引用</p><p>两种场景下 &amp;&amp; 被称作未定的引用类型（也叫&#x3D;&#x3D;万能引用&#x3D;&#x3D;）：</p><ul><li>模板参数时指定为 T&amp;&amp;</li><li>自动类型推导时指定为 auto &amp;&amp;</li></ul><p>&#x3D;&#x3D;const T&amp;&amp; 表示一个右值引用&#x3D;&#x3D;，不是未定引用类型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传入的实参 10 是右值，因此 T&amp;&amp; 表示右值引用</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传入的实参是 x 是左值，因此 T&amp;&amp; 表示左值引用</span><span class="token function">f1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//参数是 const T&amp;&amp; 不是未定引用类型，不需要推导，本身就表示一个右值引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1314</span><span class="token punctuation">;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> v1 <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">//表示一个整形的左值引用</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> v2 <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span><span class="token comment">//表示一个整形的右值引用</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span> v3 <span class="token operator">=</span> y<span class="token punctuation">;</span>   <span class="token comment">// error decltype(x)&amp;&amp; 等价于 int&amp;&amp; 是一个右值引用不是未定引用类型，y 是一个左值，不能使用左值初始化一个右值引用类型。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当面对T&amp;&amp; 或者 auto&amp;&amp; 两种万能引用时时，会发生&#x3D;&#x3D;引用折叠&#x3D;&#x3D;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token operator">&amp;</span>  lref<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> rref<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>lref<span class="token operator">&amp;</span>  r1 <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// type of r1 is int&amp;</span>lref<span class="token operator">&amp;&amp;</span> r2 <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// type of r2 is int&amp;</span>rref<span class="token operator">&amp;</span>  r3 <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// type of r3 is int&amp;</span>rref<span class="token operator">&amp;&amp;</span> r4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// type of r4 is int&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>折叠规则总结</strong></p><ul><li>&#x3D;&#x3D;右值引用的右值引用折叠为右值引用&#x3D;&#x3D;</li><li>&#x3D;&#x3D;其他所有类型折叠为左值引用&#x3D;&#x3D;</li></ul><blockquote><p><strong>万能引用时折叠规则如下</strong>：</p><ul><li>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型（记住这个就可）</li><li>通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个左值引用类型</li></ul></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"l-value: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"r-value: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printValue</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>    <span class="token function">printValue</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token number">1314</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">forward</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//输出结果</span>l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">520</span>r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">250</span><span class="token comment">//k 变成了一个命名对象，编译器会将其当做左值来处理</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当面对上述传递一个右值但仍调用左值引用函数情况时，我们希望的是传入左值就调用左值引用函数，传入右值就调用右值引用函数</p><p>解决上述问题的方法就是&#x3D;&#x3D;完美转发std::forward&#x3D;&#x3D; ，它定义如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">></span>T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;</span> t <span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其原理就是<strong>折叠引用</strong>，其返回值类型是T&amp;&amp;</p><ul><li>当传入左值时，<strong>T&amp;&amp; &#x3D; A&amp; &amp;&amp; &#x3D; A&amp;</strong></li><li>当传入是const左值时，折叠引用后得到const A&amp;</li><li>当传入是右值时，<strong>T&amp;&amp; &#x3D; A&amp;&amp; &amp;&amp; &#x3D; A&amp;&amp;</strong></li></ul><p>使用如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">push</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值（有点歧义，还没搞懂这里）</li><li>auto&amp;&amp;或者函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型（上面有例子）</li><li>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型，其余都是左值引用类型</li><li>万能引用推导使用的是引用折叠规则，完美转发的原理也是使用的引用折叠</li></ul></blockquote><h1 id="14-转移和完美转发"><a href="#14-转移和完美转发" class="headerlink" title="14. 转移和完美转发"></a>14. 转移和完美转发</h1><h2 id="14-1-move"><a href="#14-1-move" class="headerlink" title="14.1 move"></a>14.1 move</h2><blockquote><p>在C++11中，如果想用左值来初始化右值引用是无法完成的，但有时又需要使用左值来初始化右值引用，比如函数返回一个左值</p><p>因此，C++11提供了std::move函数来将一个左值转换为右值</p></blockquote><p>std::move等同于类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue)</p><p>函数原型如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ty</span><span class="token operator">></span>_NODISCARD <span class="token keyword">constexpr</span> remove_reference_t<span class="token operator">&lt;</span>_Ty<span class="token operator">></span><span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>_Ty<span class="token operator">&amp;&amp;</span> _Arg<span class="token punctuation">)</span> _NOEXCEPT<span class="token punctuation">&#123;</span><span class="token comment">// forward _Arg as movable</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>remove_reference_t<span class="token operator">&lt;</span>_Ty<span class="token operator">></span><span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>_Arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用方法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Test t<span class="token punctuation">;</span>Test <span class="token operator">&amp;&amp;</span> v2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ok</span>list<span class="token operator">&lt;</span>string<span class="token operator">></span> ls<span class="token punctuation">;</span>ls<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ls<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token operator">&lt;</span>string<span class="token operator">></span> ls1 <span class="token operator">=</span> ls<span class="token punctuation">;</span>        <span class="token comment">// 需要拷贝, 效率低</span>list<span class="token operator">&lt;</span>string<span class="token operator">></span> ls2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中的move可以使得效率很高而无需拷贝，其根本原因是&#x3D;&#x3D;list容器实现了移动构造函数，move函数只是将ls转换为一个左值，使得自动调用移动构造函数&#x3D;&#x3D;</p><p><strong>注意</strong></p><ul><li>调用move函数赋值后，原来变量不能再使用，其资源已经被转移</li><li>move函数只是将变量类型做了个改变，并没有改变变量</li></ul><h2 id="14-2-forward"><a href="#14-2-forward" class="headerlink" title="14.2 forward"></a>14.2 forward</h2><p>引入forward的原因可见13.3节</p><p>使用std::forward () 函数可以将参数原来的类型转发到另一个函数</p><p>原型如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数原型</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span> <span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span> <span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">// 精简之后的样子</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其原理就是折叠引用，具体可见13.3节</p><h1 id="15-智能指针"><a href="#15-智能指针" class="headerlink" title="15. 智能指针"></a>15. 智能指针</h1><blockquote><p>在 C++ 中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针</p></blockquote><p>&#x3D;&#x3D;智能指针是存储指向动态分配（堆）对象指针的类&#x3D;&#x3D;，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。</p><p>&#x3D;&#x3D;智能指针的核心实现技术是引用计数&#x3D;&#x3D;，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</p><p>C++11 中提供了三种智能指针，使用这些智能指针时需要引用头文件 <memory></p><ul><li>std::shared_ptr：共享的智能指针</li><li>std::unique_ptr：独占的智能指针</li><li>std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视 shared_ptr 的。</li></ul><h2 id="15-1-shared-ptr指针"><a href="#15-1-shared-ptr指针" class="headerlink" title="15.1 shared_ptr指针"></a>15.1 shared_ptr指针</h2><p>&#x3D;&#x3D;共享智能指针是指多个智能指针可以同时管理同一块有效的内存&#x3D;&#x3D;</p><p>共享智能指针是一个变量，但是通过重载<code>-&gt;</code>符号使得其可以直接调用其原始指针的函数，从而看起来像一个指针</p><p>shared_ptr引用计数是线程安全的，但调用其资源并不是线程安全的</p><blockquote><p>共享智能指针 shared_ptr 是一个模板类，如果要进行初始化有四种方式：通过构造函数、（移动）拷贝函数、<code>std::make_shared</code> 辅助函数以及 reset 方法</p><p>共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存</p><p>如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数 use_count，函数原型如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。</span><span class="token keyword">long</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h3 id="15-1-1-shared-ptr原理"><a href="#15-1-1-shared-ptr原理" class="headerlink" title="15.1.1 shared_ptr原理"></a>15.1.1 shared_ptr原理</h3><p>shared_ptr 需要维护的信息有两部分：</p><ul><li>指向共享资源的指针。</li><li>引用计数等共享资源的控制信息——实现上是维护一个指向控制信息的指针（控制信息中包含ref count、weak ref count、deleter、ptr信息（这个ptr类别是共享资源类型，指向共享资源，是为了解决类继承））。</li></ul><p>shared_ptr 的 的 deleter 是保存在控制信息中，是否有自定义 deleter 不影响 shared_ptr 对象的大小。</p><p>shared_ptr中有一个指针指向共享资源，控制信息中也有一个指针指向共享资源，但是并不能减少其中任意一个，原因如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Fruit</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> juice<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Vegetable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fiber<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Tomato</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Fruit</span><span class="token punctuation">,</span> <span class="token class-name">Vegetable</span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sauce<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 由于继承的存在，shared_ptr 可能指向基类对象</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Tomato<span class="token operator">></span> tomato <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Tomato<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Fruit<span class="token operator">></span> fruit <span class="token operator">=</span> tomato<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Vegetable<span class="token operator">></span> vegetable <span class="token operator">=</span> tomato<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，tomato中的原始指针是一个Tomato类型指针，fruit中的原始指针是一个Fruit指针，vegetable中的原始指针是一个Vegetable，而其控制信息中指向资源的指针是一个Tomato类型指针</p><p>如果没有控制信息中指向资源的指针，其资源本来是Tomato类型的，当一个fruit共享指针指向这个Tomato资源时，如果我们拿fruit指针去初始化一个新的Tomato共享指针则会报错（资源是Tomato类型，不应该初始化失败）</p><p>shared_ptr重载了<code>*</code>和<code>-&gt;</code>符号，使得能直接调用原始指针的函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">*</span>m_pointer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> m_pointer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//对于 A->func()</span><span class="token comment">//注意！！->重载后，只有类对象调用->时才会重载，类指针调用->时不会使用此重载</span><span class="token comment">//当A是指针时，则编译直接解释为A->fun()，而不会管是否重载</span><span class="token comment">//当A时对象时，则编译器解释为A.operator->()->func(),这里才是真使用了->重载函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="15-1-2-shared-ptr初始化及使用"><a href="#15-1-2-shared-ptr初始化及使用" class="headerlink" title="15.1.2 shared_ptr初始化及使用"></a>15.1.2 shared_ptr初始化及使用</h3><p><strong>通过构造函数初始化</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// shared_ptr&lt;T> 类模板中，提供了多种实用的构造函数, 语法格式如下:</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> 智能指针名字<span class="token punctuation">(</span>创建堆内存<span class="token punctuation">)</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>如果智能指针被初始化了一块有效内存，那么这块内存的引用计数 + 1</p></li><li><p>如果智能指针没有被初始化或者被初始化为 nullptr 空指针，引用计数不会 + 1</p></li><li><p>&#x3D;&#x3D;不要使用一个原始指针初始化多个 shared_ptr&#x3D;&#x3D;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// error, 编译不会报错, 运行会出错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>通过拷贝和移动构造函数初始化</strong></p><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象</p><p>在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//调用拷贝构造函数</span>   shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr2</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr3 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span>   <span class="token comment">//调用移动构造函数</span>   shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr4</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr5 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加</li><li>如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化</li></ul><p><strong>通过 std::make_shared 初始化</strong></p><p>C++ 提供的 <code>std::make_shared()</code> 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args <span class="token operator">></span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_shared</span><span class="token punctuation">(</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//T：模板参数的数据类型</span><span class="token comment">//Args&amp;&amp;... args ：要初始化的数据，如果是通过 make_shared 创建对象，需按照构造函数的参数列表指定</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用方法</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">   <span class="token comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span>   shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> ptr2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> ptr3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//make_shared后面括号里的值是初始化参数，会自动调用对应的构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用 std::make_shared() 模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理</li><li>如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数</li></ul><p><strong>通过 reset 方法初始化</strong></p><p><code>std::shared_ptr::reset</code> 有两种用处：</p><ul><li>将指针重置，即不再指向原来那块内存</li><li>将指针指向新的内存</li></ul><p><code>std::shared_ptr::reset</code> 方法函数原型如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span> <span class="token operator">></span><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> Y<span class="token operator">*</span> ptr <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Deleter</span> <span class="token operator">></span><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> Y<span class="token operator">*</span> ptr<span class="token punctuation">,</span> Deleter d <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Deleter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">></span><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> Y<span class="token operator">*</span> ptr<span class="token punctuation">,</span> Deleter d<span class="token punctuation">,</span> Alloc alloc <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ptr：指向要取得所有权的对象的指针</span><span class="token comment">//d：指向要取得所有权的对象的指针</span><span class="token comment">//aloc：内部存储所用的分配器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用方法</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr4 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span>ptr4<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr5<span class="token punctuation">;</span>ptr5<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于一个未初始化的共享智能指针，可以通过 reset 方法来初始化</li><li>当智能指针中有值的时候，调用 reset 会使引用计数减 1</li></ul><p><strong>获取原始指针和调用原始指针的函数</strong></p><p>调用共享智能指针类提供的 get () 方法得到原始地址，其函数原型如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 得到指针的原始地址</span><span class="token keyword">char</span><span class="token operator">*</span> add <span class="token operator">=</span> ptr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ptr<span class="token operator">-></span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用原始指针的函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意获得原始指针的函数是用<code>.</code>，而调用原始指针函数是用<code>-&gt;</code></p><p><strong>指定删除器</strong></p><p>当智能指针管理的内存对应的引用计数变为 0 的时候，这块内存就会被智能指针析构掉</p><p>在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为&#x3D;&#x3D;删除器，删除器函数本质是一个回调函数&#x3D;&#x3D;</p><p>删除器函数可以是一个普通函数，也可以是一个lambda表达式</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteIntPtr</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int 型内存被释放了..."</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deleteIntPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>l&#x3D;&#x3D;ambda表达式的参数就是智能指针管理的内存的地址&#x3D;&#x3D;，有了这个地址之后函数体内部就可以完成删除操作</p><p>&#x3D;&#x3D;&#x3D;&#x3D;在 C++11 中使用 shared_ptr 管理动态数组时，需要指定删除器, 因为std::shared_ptr的默认删除器不支持数组对象&#x3D;&#x3D;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span>p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在C++14以后，也支持了shared_ptr管理动态数组</p><pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;int[]&gt; ptr(new int[10]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在删除数组内存时，除了自己编写删除器，也可以使用 C++ 提供的 std::default_delete<T>() 函数作为删除器</p><blockquote><p>这个函数内部的删除功能也是通过调用 delete 来实现的，要释放什么类型的内存就将模板类型 T 指定为什么类型即可。</p></blockquote><p><strong>enable_shared_from_this类</strong></p><blockquote><p>有时需要得到一个类对象的shared_ptr指针，直接定义一个函数来返回this指针初始化的shared_ptr违背了原始指针不能初始化多个智能指针的原则，会造成内存泄漏</p></blockquote><p>C++11 中提供了一个模板类叫做 <code>std::enable_shared_from_this&lt;T&gt;</code>，类中有一个方法叫做 <code>shared_from_this()</code>，通过这个方法可以返回一个共享智能指针，</p><p>在这个函数的内部就是使用 weak_ptr 来监测 this 对象，并通过调用 weak_ptr 的 lock() 方法返回一个 shared_ptr 对象。</p><p>其原理就是在类中定义了一个weak_ptr，在定义一个共享指针初始化时就同时初始化此weak_ptr指针</p><p>&#x3D;&#x3D;必须要定义一个shared_ptr指针，在此指针上调用shared_from_this()&#x3D;&#x3D;，否则会报错</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Test</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">Test</span><span class="token operator">></span></span><span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class Test is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Test<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> sp2 <span class="token operator">=</span> sp1<span class="token operator">-></span><span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在调用 enable_shared_from_this 类的 shared_from_this () 方法之前，必须要先初始化函数内部 weak_ptr 对象，否则该函数无法返回一个有效的 shared_ptr 对象</p><blockquote><p><strong>注意</strong></p><ul><li>原始指针不能初始化多个shared_ptr，否则会造成内存泄漏</li><li>不能返回类的this指针来初始化shared_ptr，原理同上</li><li>构造函数内部不能调用shared_from_this函数</li><li>循环引用问题：不能在两个类中互相定义指向对方的shared_ptr，解决方法是使用weak_ptr，可见weak_ptr章节</li></ul></blockquote><h2 id="15-2-unique-ptr指针"><a href="#15-2-unique-ptr指针" class="headerlink" title="15.2 unique_ptr指针"></a>15.2 unique_ptr指针</h2><p>std::unique_ptr 是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针</p><blockquote><p>无自定义 deleter 的 unique_ptr 只需要将裸指针用 RAII 的手法封装好就行，无需保存其它信息，所以它的开销和裸指针是一样的。</p><p>如果有自定义 deleter，还需要保存 deleter 的信息。</p><p>即使有deleter，也能通过优化使得内存消耗和原始指针相同</p></blockquote><p><strong>std::unique_ptr初始化</strong></p><p>可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个 unique_ptr 赋值给另一个 unique_ptr</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 通过构造函数初始化对象</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// error, 不允许将一个unique_ptr赋值给另一个unique_ptr</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>std::unique_ptr 不允许复制，但是可以通过函数返回给其他的 std::unique_ptr，还可以通过 std::move 来转译给其他的 std::unique_ptr</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 通过构造函数初始化</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 通过转移所有权的方式初始化</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr3 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>reset方法初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//reset原型</span><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> pointer ptr <span class="token operator">=</span> <span class="token function">pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解除对原始内存的管理</span>    ptr2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重新指定智能指针管理的原始内存</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似，调用 get () 方法可以获取独占智能指针管理的原始地址</p><p><strong>删除器</strong></p><blockquote><p>shared_ptr智能指针无需指定删除器类型</p></blockquote><p>unique_ptr 指定删除器的时候需要确定删除器的类型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    <span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> func_ptr<span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里能使用函数指针是因为lambda表达式没捕捉任何变量，其可以被直接转换为函数指针，这里内存消耗为16，两倍于原始指针</span><span class="token comment">//lambda表达式捕捉变量时需要使用包装器函数,但这样写内存开销会很大，测试时占了72字节！！！</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">>></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用decltype推导，这只占用8字节，达到和原始指针相同的内存消耗，这是由于做了EBO空基类优化，缺点就是需要单独定义lambda表达式</span>    <span class="token keyword">auto</span> fun <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Test<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">delete</span> p<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span>Test<span class="token punctuation">,</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>fun<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Test<span class="token punctuation">,</span> fun<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//仿函数优化，这里也是使用的EBO空基类优化，内存占用为8字节，和原始指针相同内存占用</span><span class="token keyword">struct</span> <span class="token class-name">FileCloserStruct</span> <span class="token punctuation">&#123;</span><span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> fp<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>FILE<span class="token punctuation">,</span> FileCloserStruct<span class="token operator">></span> <span class="token function">uptr1</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test_file.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;注意&#x3D;&#x3D;，unique_ptr有deleter定义函数类型时，尽量别使用function包装器，其内存消耗几倍于原始指针</p><p>应尽量使用仿函数和decltype推导lambda方法（<em>这两种方法的内销消耗和原始指针相同，这是因为这两种方式的deleter函数其实是一个空类，unique_ptr低层会直接继承这个空类而不是定义一个函数指针，再使用空基类优化达到原指针相同内存消耗</em>）</p><p>&#x3D;&#x3D;疑惑&#x3D;&#x3D;：空基类优化后是怎么知道deleter函数是哪个呢？？？？</p><p>这是因为这两种优化方法继承的类和deleter函数名字是一样的，调用<code>类名()</code>即为deleter函数</p><blockquote><p>内存消耗：function包装器&gt;普通函数指针&gt;仿函数&#x3D;decltype推导lambda</p></blockquote><h2 id="15-3-weak-ptr指针"><a href="#15-3-weak-ptr指针" class="headerlink" title="15.3 weak_ptr指针"></a>15.3 weak_ptr指针</h2><p><code>std::weak_ptr</code>是 <code>shared_ptr</code> 的助手，它不管理 <code>shared_ptr</code> 内部的指针</p><p>&#x3D;&#x3D;std::weak_ptr 没有重载操作符 * 和 -&gt;，因为它不共享指针，不能操作资源&#x3D;&#x3D;，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视 shared_ptr 中管理的资源是否存在。</p><blockquote><p>weak_ptr是使用的shared_ptr中的控制信息，在其控制信息中的weak ref count加1</p><p>当 shared_ptr 析构并释放共享资源的时候，只要 weak_ptr 对象还存在，控制块就会保留，weak_ptr 可以通过控制块观察到对象是否存活。</p></blockquote><p><strong>初始化</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 默认构造函数</span><span class="token keyword">constexpr</span> <span class="token function">weak_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">// 拷贝构造</span><span class="token function">weak_ptr</span> <span class="token punctuation">(</span><span class="token keyword">const</span> weak_ptr<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span> <span class="token function">weak_ptr</span> <span class="token punctuation">(</span><span class="token keyword">const</span> weak_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">// 通过shared_ptr对象构造</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span> <span class="token function">weak_ptr</span> <span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">//使用</span>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp1<span class="token punctuation">;</span><span class="token comment">//构造了一个空 weak_ptr 对象</span>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp2</span><span class="token punctuation">(</span>wp1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过一个空 weak_ptr 对象构造了另一个空 weak_ptr 对象</span>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp3</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过一个 shared_ptr 对象构造了一个可用的 weak_ptr 实例对象</span>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp4<span class="token punctuation">;</span>    wp4 <span class="token operator">=</span> sp<span class="token punctuation">;</span>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp5<span class="token punctuation">;</span>    wp5 <span class="token operator">=</span> wp3<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**use_count()**：获得当前所观测资源的引用计数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>**expired()**：判断观测的资源是否已经被释放</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>**lock()**：&#x3D;&#x3D;获取管理所监测资源的 shared_ptr 对象&#x3D;&#x3D;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>element_type<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>**reset()**：清空对象，使其不监测任何资源</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="15-3-1-解决循环引用问题"><a href="#15-3-1-解决循环引用问题" class="headerlink" title="15.3.1 解决循环引用问题"></a>15.3.1 解决循环引用问题</h3><p>智能指针如果循环引用会导致内存泄露，例子如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TA</span><span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span>TB<span class="token operator">></span> bptr<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">TA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class TA is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">TB</span><span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span>TA<span class="token operator">></span> aptr<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">TB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class TB is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">testPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span>TA<span class="token operator">></span> <span class="token function">ap</span><span class="token punctuation">(</span><span class="token keyword">new</span> TA<span class="token punctuation">)</span><span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>TB<span class="token operator">></span> <span class="token function">bp</span><span class="token punctuation">(</span><span class="token keyword">new</span> TB<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TA object use_count: "</span> <span class="token operator">&lt;&lt;</span> ap<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TB object use_count: "</span> <span class="token operator">&lt;&lt;</span> bp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    ap<span class="token operator">-></span>bptr <span class="token operator">=</span> bp<span class="token punctuation">;</span>    bp<span class="token operator">-></span>aptr <span class="token operator">=</span> ap<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TA object use_count: "</span> <span class="token operator">&lt;&lt;</span> ap<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TB object use_count: "</span> <span class="token operator">&lt;&lt;</span> bp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">testPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果</span>TA object use_count<span class="token operator">:</span> <span class="token number">1</span>TB object use_count<span class="token operator">:</span> <span class="token number">1</span>TA object use_count<span class="token operator">:</span> <span class="token number">2</span>TB object use_count<span class="token operator">:</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中，共享智能指针 ap、bp 对 TA、TB 实例对象的引用计数变为 2，在共享智能指针离开作用域之后引用计数只能减为1</p><p>&#x3D;&#x3D;使用 weak_ptr 可以解决这个问题&#x3D;&#x3D;，只要将类 TA 或者 TB 的任意一个成员改为 weak_ptr即可</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TA</span><span class="token punctuation">&#123;</span>    weak_ptr<span class="token operator">&lt;</span>TB<span class="token operator">></span> bptr<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">TA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class TA is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">TB</span><span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span>TA<span class="token operator">></span> aptr<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">TB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class TB is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//其余调用代码和上面类似</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面程序中，在对类 TA 成员赋值时 ap-&gt;bptr &#x3D; bp; 由于 bptr 是 weak_ptr 类型，这个赋值操作并不会增加引用计数，所以 bp 的引用计数仍然为 1，在离开作用域之后 bp 的引用计数减为 0，类 TB 的实例对象被析构。</p><p>在类 TB 的实例对象被析构的时候，内部的 aptr 也被析构，其对 TA 对象的管理解除，内存的引用计数减为 1，当共享智能指针 ap 离开作用域之后，对 TA 对象的管理也解除了，内存的引用计数减为 0，类 TA 的实例对象被析构。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>侯捷STL视频笔记</title>
      <link href="/2023/02/15/c++/%E4%BE%AF%E6%8D%B7STL%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/15/c++/%E4%BE%AF%E6%8D%B7STL%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>学习侯捷STL笔记，<a href="https://www.youtube.com/watch?v=Edcwv38c7d4&list=PLTcwR9j5y6W2Bf4S-qi0HBQlHXQVFoJrP">视频地址</a></p><hr><hr><h1 id="1-基础介绍"><a href="#1-基础介绍" class="headerlink" title="1. 基础介绍"></a>1. 基础介绍</h1><p>STL六大部件：</p><ul><li>容器 Containers</li><li>分配器 Allocator</li><li>算法 Algorithm</li><li>迭代器 Iterators</li><li>适配器 Adapters</li><li>仿函数 Functors</li></ul><p>容器存储数据，容器通过分配器来获得内存分配，算法通过迭代器来操作容器中的数据，仿函数可以为算法提供类函数似实体，适配器可对仿函数、容器等进行包装。</p><p><img src="C:\Users\MyPC\AppData\Roaming\Typora\typora-user-images\image-20221220190021504.png" alt="image-20221220190021504"></p><p>六大部件使用</p><p><img src="C:\Users\MyPC\AppData\Roaming\Typora\typora-user-images\image-20221220190856969.png" alt="image-20221220190856969"></p><h1 id="2-容器"><a href="#2-容器" class="headerlink" title="2. 容器"></a>2. 容器</h1><p>容器类型可以大致分为：</p><ul><li><p>序列式容器：</p><ul><li><p>array. 固定大小容器，容量不可增长</p></li><li><p>vector. 可自动增长容器</p></li><li><p>deque. 双向队列</p></li><li><p>List. 双向链表</p></li><li><p>Forward-List. 单向链表</p></li></ul></li><li><p>关联式容器：</p><ul><li><p>set&#x2F;multiset. 底层为红黑树，multiset值可以重复</p></li><li><p>map&#x2F;multimap. 底层为红黑树，multimap的key可以重复</p></li><li><p>unordered set&#x2F;multiset. 底层哈希表（常用拉链法）</p></li><li><p>unordered map&#x2F;multimap. 底层哈希表（常用拉链法）</p></li></ul></li></ul><h2 id="2-1-array"><a href="#2-1-array" class="headerlink" title="2.1 array"></a>2.1 array</h2><p><code>std::array</code> 是封装固定大小数组的容器。</p><p>此容器是一个聚合类型，其语义等同于保有一个 <a href="https://zh.cppreference.com/w/cpp/language/array">C 风格数组</a> T[N] 作为其唯一非静态数据成员的结构体。不同于 C 风格数组，它不会自动退化成 T* 。</p><p>array定义：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>    <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>    std<span class="token double-colon punctuation">::</span>size_t N<span class="token operator">></span> <span class="token keyword">struct</span> <span class="token class-name">array</span><span class="token punctuation">;</span><span class="token comment">// 用聚合初始化构造</span>    std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">></span> a1<span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// CWG 1270 重申前的 C++11 中要求双花括号</span>                                        <span class="token comment">// （ C++11 之后的版本和 C++14 起不要求）</span>    std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">></span> a2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// = 后决不要求双花括号</span>    std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">></span> a3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"b"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token comment">// 支持容器操作</span>    std<span class="token double-colon punctuation">::</span><span class="token function">sort</span><span class="token punctuation">(</span>a1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span><span class="token function">reverse_copy</span><span class="token punctuation">(</span>a2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">ostream_iterator</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>当其长度为零时 <code>array</code> （ <code>N == 0</code> ）有特殊情况。此时， array.begin() &#x3D;&#x3D; array.end() ，并拥有某个唯一值。在零长 <code>array</code> 上调用 front() 或 back() 是未定义的。</p></li><li><p>亦可将 <code>array</code> 当做拥有 <code>N</code> 个同类型元素的元组。</p></li><li><p>注意，在 <a href="https://zh.cppreference.com/w/cpp/container/array/swap">swap</a> 时，迭代器将继续指向同一 <code>array</code> 的元素，并将改变元素的值。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake笔记</title>
      <link href="/2023/02/15/c++/cmake%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/15/c++/cmake%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://www.bilibili.com/video/BV1vR4y1u77h/?p=10&spm_id_from=pageDriver&vd_source=7135ae3a4d6506056ac51c05382c2a25">从零开始详细介绍CMake</a>，笔记也是在up主原笔记上修改</p><hr><hr><p>cmake的定义是什么 ？—–高级编译配置工具</p><p>当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了—–CMake！</p><p>所有操作都是通过编译CMakeLists.txt来完成的—简单</p><h1 id="1-CMake一个HelloWord"><a href="#1-CMake一个HelloWord" class="headerlink" title="1. CMake一个HelloWord"></a>1. CMake一个HelloWord</h1><p>1、步骤一，写一个HelloWord</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">main</span><span class="token expression"><span class="token punctuation">.</span>cpp</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span>  <span class="token string">"hello word"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、步骤二，写CMakeLists.txt</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#CMakeLists.txt</span><span class="token function">PROJECT</span> <span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">SET</span><span class="token punctuation">(</span>SRC_LIST main.cpp<span class="token punctuation">)</span><span class="token function">MESSAGE</span><span class="token punctuation">(</span>STATUS <span class="token string">"This is BINARY dir "</span> <span class="token punctuation">$&#123;</span><span class="token variable">HELLO_BINARY_DIR</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">MESSAGE</span><span class="token punctuation">(</span>STATUS <span class="token string">"This is SOURCE dir "</span><span class="token punctuation">$&#123;</span><span class="token variable">HELLO_SOURCE_DIR</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello <span class="token punctuation">$&#123;</span>SRC_LIST<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、步骤三、使用cmake，生成makefile文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile。</p><p>4、使用make命令编译</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@localhost cmake<span class="token punctuation">]</span><span class="token comment"># make</span>Scanning dependencies of target hello<span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Building CXX object CMakeFiles/hello.dir/main.cpp.oLinking CXX executable hello<span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Built target hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、最终生成了Hello的可执行程序</p><h1 id="2-CMake一个HelloWord-的语法介绍"><a href="#2-CMake一个HelloWord-的语法介绍" class="headerlink" title="2. CMake一个HelloWord-的语法介绍"></a>2. CMake一个HelloWord-的语法介绍</h1><h2 id="2-1-关键字"><a href="#2-1-关键字" class="headerlink" title="2.1 关键字"></a>2.1 关键字</h2><p><strong>PROJECT关键字</strong></p><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p>PROJECT (HELLO)   指定了工程的名字，并且支持所有语言—建议</p><p>PROJECT (HELLO CXX)      指定了工程的名字，并且支持语言是C++</p><p>PROJECT (HELLO C CXX)      指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个CMAKE的变量</p><p><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</p><p><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</p><p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：如果改了工程名，这两个变量名也会改变</p><p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><p><strong>SET关键字</strong></p><p>用来显示的指定变量的</p><p>SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p><p>也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><p><strong>MESSAGE关键字</strong></p><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。</li><li>SATUS，输出前缀为—的信息。</li><li>FATAL_ERROR，立即终止所有 cmake 过程.</li></ul><p><strong>ADD_EXECUTABLE关键字</strong></p><p>生成可执行文件</p><p>ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p><p>也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p><p>上述例子可以简化的写成</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello main.cpp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h2 id="2-2-语法的基本原则"><a href="#2-2-语法的基本原则" class="headerlink" title="2.2 语法的基本原则"></a>2.2 语法的基本原则</h2><ul><li><p>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</p></li><li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p><p>  就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</p></li></ul><h2 id="2-3-语法注意事项"><a href="#2-3-语法注意事项" class="headerlink" title="2.3 语法注意事项"></a>2.3 语法注意事项</h2><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不写，会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul><h1 id="3-内部构建和外部构建"><a href="#3-内部构建和外部构建" class="headerlink" title="3. 内部构建和外部构建"></a>3. 内部构建和外部构建</h1><ul><li>内部构建，产生临时文件特别多，不方便清理</li><li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</li></ul><p><strong>外部构建方式举例</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//例子目录，CMakeLists.txt和上面例子一致<span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span><span class="token comment"># pwd</span>/root/cmake<span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span><span class="token comment"># ll</span>total <span class="token number">8</span>-rw-r--r--. <span class="token number">1</span> root root <span class="token number">198</span> Dec <span class="token number">28</span> <span class="token number">20</span>:59 CMakeLists.txt-rw-r--r--. <span class="token number">1</span> root root  <span class="token number">76</span> Dec <span class="token number">28</span> 00:18 main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p><p>2、进入build，运行cmake ..    当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p><p>3、在build目录下，运行make来构建工程</p><p>注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR  还是工程路径</p><p>2、HELLO_BINARY_DIR   编译路径 也就是 &#x2F;root&#x2F;cmake&#x2F;bulid</p><h1 id="4-让Hello-World看起来更像一个工程"><a href="#4-让Hello-World看起来更像一个工程" class="headerlink" title="4. 让Hello World看起来更像一个工程"></a>4. 让Hello World看起来更像一个工程</h1><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT&#x2F;README 安装到&#x2F;usr&#x2F;share&#x2F;doc&#x2F;cmake&#x2F;</li></ul><h2 id="4-1-将目标文件放入构建目录的-bin-子目录"><a href="#4-1-将目标文件放入构建目录的-bin-子目录" class="headerlink" title="4.1 将目标文件放入构建目录的 bin 子目录"></a>4.1 将目标文件放入构建目录的 bin 子目录</h2><p>每个目录下都要有一个CMakeLists.txt说明</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span><span class="token comment"># tree</span><span class="token builtin class-name">.</span>├── build├── CMakeLists.txt└── src    ├── CMakeLists.txt    └── main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>外层CMakeLists.txt</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>src bin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>src下的CMakeLists.txt</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello main.cpp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>ADD_SUBDIRECTORY 指令</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>source_dir [binary_dir] [<span class="token property">EXCLUDE_FROM_ALL</span>]<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p></li><li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p></li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>  将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>  如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build&#x2F;src 目录</p></li></ul><p><strong>更改二进制的保存路径</strong></p><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">SET</span><span class="token punctuation">(</span><span class="token variable">EXECUTABLE_OUTPUT_PATH</span> <span class="token punctuation">$&#123;</span><span class="token variable">PROJECT_BINARY_DIR</span><span class="token punctuation">&#125;</span>/bin<span class="token punctuation">)</span><span class="token function">SET</span><span class="token punctuation">(</span><span class="token variable">LIBRARY_OUTPUT_PATH</span> <span class="token punctuation">$&#123;</span><span class="token variable">PROJECT_BINARY_DIR</span><span class="token punctuation">&#125;</span>/lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>思考：加载哪个CMakeLists.txt当中</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><h2 id="4-2-安装"><a href="#4-2-安装" class="headerlink" title="4.2 安装"></a>4.2 安装</h2><ul><li>一种是从代码编译后直接 make install 安装</li><li>一种是打包时的指定 目录安装。<ul><li>简单的可以这样指定目录：make install DESTDIR&#x3D;&#x2F;tmp&#x2F;test</li><li>稍微复杂一点可以这样指定目录：.&#x2F;configure –prefix&#x3D;&#x2F;usr</li></ul></li></ul><p><strong>如何安装HelloWord</strong></p><p>使用CMAKE一个新的指令：INSTALL</p><p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 目录树结构<span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span><span class="token comment"># tree</span><span class="token builtin class-name">.</span>├── build├── CMakeLists.txt├── COPYRIGHT├── doc│   └── hello.txt├── README├── runhello.sh└── src    ├── CMakeLists.txt    └── main.cpp<span class="token number">3</span> directories, <span class="token number">7</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>安装文件COPYRIGHT和README</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">INSTALL</span><span class="token punctuation">(</span>FILES COPYRIGHT README DESTINATION share/doc/cmake/<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>FILES：文件</p></li><li><p>DESTINATION：</p><ul><li><p>1、写绝对路径</p></li><li><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}&#x2F;&lt;DESTINATION 定义的路径&gt;</p></li></ul></li></ul><p>CMAKE_INSTALL_PREFIX  默认是在 &#x2F;usr&#x2F;local&#x2F;</p><p>cmake -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><p><strong>安装脚本runhello.sh</strong></p><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">INSTALL</span><span class="token punctuation">(</span>PROGRAMS runhello.sh DESTINATION bin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：实际安装到的是 &#x2F;usr&#x2F;bin</p><p><strong>从零开始详细介绍CMake</strong></p><ul><li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p></li><li><p>二、是直接在工程目录通过</p>   <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">INSTALL</span><span class="token punctuation">(</span>DIRECTORY doc/ DESTINATION share/doc/cmake<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc&#x2F;有很大的区别</p><p>目录名不以&#x2F;结尾：这个目录将被安装为目标路径下的</p><p>目录名以&#x2F;结尾：将这个目录中的内容安装到目标路径</p><p><strong>安装过程</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake <span class="token punctuation">..</span><span class="token function">make</span><span class="token function">make</span> instal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-静态库和动态库的构建"><a href="#5-静态库和动态库的构建" class="headerlink" title="5. 静态库和动态库的构建"></a>5. 静态库和动态库的构建</h1><p>任务：</p><p>１，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 </p><p>２，安装头文件与共享库。</p><p>静态库和动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li></ul><h2 id="5-1构建实例"><a href="#5-1构建实例" class="headerlink" title="5.1构建实例"></a>5.1构建实例</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost cmake2<span class="token punctuation">]</span><span class="token comment"># tree</span><span class="token builtin class-name">.</span>├── build├── CMakeLists.txt└── lib    ├── CMakeLists.txt    ├── hello.cpp    └── hello.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello.h中的内容</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HELLO_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Hello_H</span></span><span class="token keyword">void</span> <span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello.cpp中的内容</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hello.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>项目中的cmake内容</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>lib bin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>lib中CMakeLists.txt中的内容</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">SET</span><span class="token punctuation">(</span>LIBHELLO_SRC hello.cpp<span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>ADD_LIBRARY</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li><li>SHARED，动态库    STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul><h2 id="5-2-同时构建静态和动态库"><a href="#5-2-同时构建静态和动态库" class="headerlink" title="5.2 同时构建静态和动态库"></a>5.2 同时构建静态和动态库</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a<span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello <span class="token namespace">STATIC</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已<span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello_static <span class="token namespace">STATIC</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>SET_TARGET_PROPERTIES</strong></p><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">SET</span><span class="token punctuation">(</span>LIBHELLO_SRC hello.cpp<span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello_static <span class="token namespace">STATIC</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>//对hello_static的重名为hello<span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello_static <span class="token namespace">PROPERTIES</span>  <span class="token property">OUTPUT_NAME</span> <span class="token string">"hello"</span><span class="token punctuation">)</span>//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a<span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello_static <span class="token namespace">PROPERTIES</span> CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello <span class="token namespace">PROPERTIES</span>  <span class="token property">OUTPUT_NAME</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello <span class="token namespace">PROPERTIES</span> CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>动态库的版本号</strong></p><p>一般动态库都有一个版本号的关联</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.2</span>libhello<span class="token punctuation">.</span>so <span class="token operator">-></span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">-></span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h2 id="5-3-安装共享库和头文件"><a href="#5-3-安装共享库和头文件" class="headerlink" title="5.3 安装共享库和头文件"></a>5.3 安装共享库和头文件</h2><p>本例中我们将 hello 的共享库安装到<prefix>&#x2F;lib目录，</p><p>将 hello.h 安装到<prefix>&#x2F;include&#x2F;hello 目录</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">//文件放到该目录下<span class="token function">INSTALL</span><span class="token punctuation">(</span>FILES hello.h DESTINATION include/hello<span class="token punctuation">)</span>//二进制，静态库，动态库安装都用TARGETS//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。<span class="token function">INSTALL</span><span class="token punctuation">(</span>TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h2 id="5-4-使用外部共享库和头文件"><a href="#5-4-使用外部共享库和头文件" class="headerlink" title="5.4 使用外部共享库和头文件"></a>5.4 使用外部共享库和头文件</h2><p>准备工作，新建一个目录来使用外部共享库和头文件</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">[root@MiWiFi-R4CM-srv cmake3]<span class="token comment"># tree</span>.├── build├── CMakeLists.txt└── src    ├── CMakeLists.txt    └── main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;hello.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解决：make后头文件找不到的问题</strong></p><p>PS：include &lt;hello&#x2F;hello.h&gt;  这样include是可以，这么做的话，就没啥好讲的了</p><p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token property">INCLUDE_DIRECTORIES</span><span class="token punctuation">(</span>/usr/include/hello<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>解决：找到引用的函数问题</strong></p><p>报错信息：undefined reference to &#96;HelloFunc()’</p><p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p><p>指定第三方库所在路径</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token property">LINK_DIRECTORIES</span><span class="token punctuation">(</span>/home/myproject/libs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">TARGET_LINK_LIBRARIES</span><span class="token punctuation">(</span>main libhello.a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@MiWiFi-R4CM-srv bin<span class="token punctuation">]</span><span class="token comment"># ldd main </span>linux-vdso.so.1 <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span>0x00007ffedfda4000<span class="token punctuation">)</span>libhello.so <span class="token operator">=</span><span class="token operator">></span> /lib64/libhello.so <span class="token punctuation">(</span>0x00007f41c0d8f000<span class="token punctuation">)</span>libstdc++.so.6 <span class="token operator">=</span><span class="token operator">></span> /lib64/libstdc++.so.6 <span class="token punctuation">(</span>0x00007f41c0874000<span class="token punctuation">)</span>libm.so.6 <span class="token operator">=</span><span class="token operator">></span> /lib64/libm.so.6 <span class="token punctuation">(</span>0x00007f41c0572000<span class="token punctuation">)</span>libgcc_s.so.1 <span class="token operator">=</span><span class="token operator">></span> /lib64/libgcc_s.so.1 <span class="token punctuation">(</span>0x00007f41c035c000<span class="token punctuation">)</span>libc.so.6 <span class="token operator">=</span><span class="token operator">></span> /lib64/libc.so.6 <span class="token punctuation">(</span>0x00007f41bff8e000<span class="token punctuation">)</span>/lib64/ld-linux-x86-64.so.2 <span class="token punctuation">(</span>0x00007f41c0b7c000<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><p><strong>特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</strong></p><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(&#x2F;usr&#x2F;include&#x2F;hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH&#x3D;&#x2F;usr&#x2F;include&#x2F;hello</p><p>补充：生产debug版本的方法：<br>cmake .. -DCMAKE_BUILD_TYPE&#x3D;debug</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><h2 id="6-1-常用命令"><a href="#6-1-常用命令" class="headerlink" title="6.1 常用命令"></a>6.1 常用命令</h2><p>&#x3D;&#x3D;<strong>(1) project命令：</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法:<span class="token keyword">project</span><span class="token punctuation">(</span>&lt;projectname<span class="token punctuation">></span> [languageName1 languageName2 ...]<span class="token punctuation">)</span>命令简述:用于指定项目的名称和支持语言使用范例:<span class="token keyword">project</span><span class="token punctuation">(</span>Main CXX<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(2) cmake_minimum_required命令:</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法:<span class="token function">cmake_minimum_requried</span><span class="token punctuation">(</span><span class="token property">VERSION</span> major[.minor[.patch<span class="token punctuation">)</span>命令简述:用于指定需要的CMake的最低版本使用范例:<span class="token function">cmake_minimum_requried</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">2.8.3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(3) aux_source_directory命令:</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法:<span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>&lt;dir<span class="token punctuation">></span> &lt;variable<span class="token punctuation">></span><span class="token punctuation">)</span>命令简述:用于包含源文件目录，dir目录下的所有源文件的名字保存在变量variable中使用范例：<span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span><span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">&#125;</span>/src  DIR_SRCS<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(4) add_executable命令:</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">add_executable</span><span class="token punctuation">(</span>&lt;name<span class="token punctuation">></span> [<span class="token variable">WIN32</span>] [<span class="token property">MACOSX_BUNDLE</span>][<span class="token property">EXCLUDE_FROM_ALL</span>] source1 source2 … sourceN<span class="token punctuation">)</span>命令简述:用于指定从一组源文件source1 source2 ... sourceN 编译出一个可执行文件且命名为name使用范例:<span class="token keyword">add_executable</span><span class="token punctuation">(</span>Main $<span class="token punctuation">(</span>DIR_SRCS<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(5) add_library命令:</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">add_library</span><span class="token punctuation">(</span>[<span class="token namespace">STATIC</span> | <span class="token namespace">SHARED</span> | MODULE] [<span class="token property">EXCLUDE_FROM_ALL</span>] source1source2 … sourceN<span class="token punctuation">)</span>命令简述：用于指定从一组源文件 source1 source2 ... sourceN编译出一个库文件且命名为name使用范例：<span class="token keyword">add_library</span><span class="token punctuation">(</span>Lib $<span class="token punctuation">(</span>DIR_SRCS<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(6) add_dependencies命令:</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">add_dependencies</span><span class="token punctuation">(</span>target-name depend-target1 depend-target2 …<span class="token punctuation">)</span>命令简述：用于指定某个目标（可执行文件或者库文件）依赖于其他的目标。        这里的目标必须是add_executable、add_library、add_custom_target命令创建的目标<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(7) add_subdirectory命令:</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>source_dir [binary_dir] [<span class="token property">EXCLUDE_FROM_ALL</span>]<span class="token punctuation">)</span>命令简述:用于添加一个需要进行构建的子目录使用范例:<span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>Lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(8) target_link_libraries命令:</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>&lt;target<span class="token punctuation">></span> [item1 [item2 […]]][[debug|optimized|general] ] …<span class="token punctuation">)</span>命令简述:用于指定target需要链接item1 item2 ...。这里target必须已经被创建，链接的item可以是已经存在的target（依赖关系会自动添加）使用范例:<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>Main Lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(9) set命令：</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令简述：用于设定变量 variable 的值为 value。如果指定了 <span class="token variable">CACHE</span> 变量将被放入 Cache（缓存）中。命令语法：<span class="token keyword">set</span><span class="token punctuation">(</span>&lt;variable<span class="token punctuation">></span> &lt;value<span class="token punctuation">></span> [[<span class="token variable">CACHE</span> &lt;type<span class="token punctuation">></span>&lt;docstring<span class="token punctuation">></span> [FORCE]] | PARENT_SCOPE]<span class="token punctuation">)</span>使用范例：<span class="token keyword">set</span><span class="token punctuation">(</span>ProjectName Main<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(10) unset命令：</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">unset</span><span class="token punctuation">(</span>&lt;variable<span class="token punctuation">></span> [<span class="token variable">CACHE</span>]<span class="token punctuation">)</span>命令简述：用于移除变量 variable。如果指定了 <span class="token variable">CACHE</span> 变量将被从 Cache 中移除。使用范例：<span class="token keyword">unset</span><span class="token punctuation">(</span>VAR <span class="token variable">CACHE</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(11) message命令：</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">message</span><span class="token punctuation">(</span>[STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] “message todisplay”…<span class="token punctuation">)</span>命令简述:用于输出信息使用范例:<span class="token keyword">message</span><span class="token punctuation">(</span>“Hello World”<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(12) include_directories命令：</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">include_directories</span><span class="token punctuation">(</span>[AFTER|BEFORE] [SYSTEM] dir1 dir2 …<span class="token punctuation">)</span>命令简述：用于设定目录，这些设定的目录将被编译器用来查找 include 文件使用范例：<span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">$&#123;</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">&#125;</span>/lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(13) find_path命令：</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">find_path</span><span class="token punctuation">(</span>&lt;VAR<span class="token punctuation">></span> name1 [path1 path2 …]<span class="token punctuation">)</span>命令简述：用于查找包含文件name1的路径，如果找到则将路径保存在VAR中（此路径为一个绝对路径），如果没有找到则结果为&lt;VAR<span class="token punctuation">></span>-NOTFOUND.默认情况下，VAR会被保存在Cache中，这时候我们需要清除VAR才可以进行下一次查询（使用unset命令）<span class="token keyword">find_path</span><span class="token punctuation">(</span>LUA_INCLUDE_PATH lua.h <span class="token punctuation">$&#123;</span>LUA_INCLUDE_FIND_PATH<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">NOT</span> LUA_INCLUDE_PATH<span class="token punctuation">)</span>     <span class="token keyword">message</span><span class="token punctuation">(</span>SEND_ERROR <span class="token string">"Header file lua.h not found"</span><span class="token punctuation">)</span><span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(14) find_library命令：</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">find_library</span><span class="token punctuation">(</span>&lt;VAR<span class="token punctuation">></span> name1 [path1 path2 …]<span class="token punctuation">)</span>命令简述：用于查找库文件 name1 的路径，如果找到则将路径保存在 VAR 中（此路径为一个绝对路径），        如果没有找到则结果为 &lt;VAR<span class="token punctuation">></span>-NOTFOUND。        一个类似的命令 link_directories 已经不太建议使用了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(15) add_definitions命令：</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">add_definitions</span><span class="token punctuation">(</span>-DFOO -DBAR …<span class="token punctuation">)</span>命令简述：用于添加编译器命令行标志（选项），通常的情况下我们使用其来添加预处理器定义使用范例：<span class="token keyword">add_definitions</span><span class="token punctuation">(</span>-D_UNICODE -DUNICODE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(16) file命令：</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令简述：此命令提供了丰富的文件和目录的相关操作（这里仅说一下比较常用的）使用范例：<span class="token comment"># 目录的遍历</span><span class="token comment"># GLOB 用于产生一个文件（目录）路径列表并保存在variable 中</span><span class="token comment"># 文件路径列表中的每个文件的文件名都能匹配globbing expressions（非正则表达式，但是类似）</span><span class="token comment"># 如果指定了 RELATIVE 路径，那么返回的文件路径列表中的路径为相对于 RELATIVE 的路径</span><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB variable [RELATIVE path][globbing expressions]...<span class="token punctuation">)</span> <span class="token comment"># 获取当前目录下的所有的文件（目录）的路径并保存到 ALL_FILE_PATH 变量中</span><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB ALL_FILE_PATH ./*<span class="token punctuation">)</span><span class="token comment"># 获取当前目录下的 .h 文件的文件名并保存到ALL_H_FILE 变量中</span><span class="token comment"># 这里的变量CMAKE_CURRENT_LIST_DIR 表示正在处理的 CMakeLists.txt 文件的所在的目录的绝对路径（2.8.3 以及以后版本才支持）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(17) find_package命令：</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">find_package</span><span class="token punctuation">(</span>&lt;Name<span class="token punctuation">></span><span class="token punctuation">)</span>命令简述：用于查找包（通常是使用三方库），并返回关于包的细节（使用包所依赖的头文件、库文件、编译选项、链接选项等）使用范例：<span class="token keyword">find_package</span><span class="token punctuation">(</span>Boost<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(18) link_directories命令 :</strong></p><pre class="line-numbers language-none"><code class="language-none">命令语法：link_directories(&lt;dir&gt;)命令简述：用于指定第三方库所在路径使用范例：link_directories(&#x2F;home&#x2F;myproject&#x2F;libs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="6-2-使用第三方库"><a href="#6-2-使用第三方库" class="headerlink" title="6.2 使用第三方库"></a>6.2 使用第三方库</h2><p><strong>方法一：</strong></p><p>先包含第三方库头文件</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token property">INCLUDE_DIRECTORIES</span><span class="token punctuation">(</span>/usr/include/hello<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定第三方库静态库或动态库文件位置</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token property">LINK_DIRECTORIES</span><span class="token punctuation">(</span>/home/myproject/libs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接第三方库的静态或动态库</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">TARGET_LINK_LIBRARIES</span><span class="token punctuation">(</span>main libhello.a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>方法二：</strong></p><p>使用find_libary</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程和线程同步-C++11</title>
      <link href="/2023/02/15/c++/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5_C++11/"/>
      <url>/2023/02/15/c++/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5_C++11/</url>
      
        <content type="html"><![CDATA[<p><em><strong>C++11多线程编程</strong>。参考爱编程的大丙的C++教程， <a href="https://subingwen.cn/cplusplus/">博客地址</a>。</em></p><hr><hr><h1 id="1-C-11线程类"><a href="#1-C-11线程类" class="headerlink" title="1. C++11线程类"></a>1. C++11线程类</h1><p>C++11提供了一个线程类：std::thread，使得并发编程更加方便</p><h2 id="1-1-常用操作函数"><a href="#1-1-常用操作函数" class="headerlink" title="1.1 常用操作函数"></a>1.1 常用操作函数</h2><p><strong>构造函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//构造函数原型：</span><span class="token comment">// ①默认构造函，构造一个线程对象，在这个线程中不执行任何处理动作</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">// ②移动构造函数，将 other 的线程所有权转移给新的 thread 对象。之后 other 不再表示执行线程。</span><span class="token function">thread</span><span class="token punctuation">(</span> thread<span class="token operator">&amp;&amp;</span> other <span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">// ③创建线程对象，并在该线程中执行函数 f 中的业务逻辑，args 是要传递给函数 f 的参数</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Function</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args <span class="token operator">></span><span class="token keyword">explicit</span> <span class="token function">thread</span><span class="token punctuation">(</span> Function<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ④使用 =delete 显示删除拷贝构造，不允许线程对象之间的拷贝</span><span class="token function">thread</span><span class="token punctuation">(</span> <span class="token keyword">const</span> thread<span class="token operator">&amp;</span> <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//使用方法</span>thread <span class="token function">t</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token string">"i love you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>func1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>获取线程号</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span>id <span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">//此函数是由类对象调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>线程回收</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用此函数的线程会被阻塞，直到子线程执行完才会被唤醒</p><p><strong>线程分离</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此函数的作用是将主线程和子线程关系分离，子线程不再属于主线程，其由系统接管，且其返回值也不能再被主线程使用。</p><p>此函数不会阻塞线程。</p><p>**joinable()**：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">//返回值为 true：主线程和子线程之间有关联（连接）关系</span><span class="token comment">//返回值为 false：主线程和子线程之间没有关联（连接）关系</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>**operator&#x3D;**：</p><pre class="line-numbers language-c+" data-language="c+"><code class="language-c+">&#x2F;&#x2F; move (1)thread&amp; operator&#x3D; (thread&amp;&amp; other) noexcept;&#x2F;&#x2F; copy [deleted] (2)thread&amp; operator&#x3D; (const other&amp;) &#x3D; delete;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果 other 是一个右值，会进行资源所有权的转移</p><p>如果 other 不是右值，禁止拷贝，该函数被显示删除（&#x3D;delete），不可用</p><p><strong>获取核心数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token keyword">int</span> num <span class="token operator">=</span> thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>call_once()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 定义于头文件 &lt;mutex></span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Callable</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args <span class="token operator">></span><span class="token keyword">void</span> <span class="token function">call_once</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>once_flag<span class="token operator">&amp;</span> flag<span class="token punctuation">,</span> Callable<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//flag：once_flag 类型的对象，用于保证只访问一次，要保证这个对象能够被多个线程同时访问到，可设为全局变量</span><span class="token comment">//f：回调函数，可以传递一个有名函数地址，也可以指定一个匿名函数</span><span class="token comment">//args：作为实参传递给回调函数</span><span class="token function">call_once</span><span class="token punctuation">(</span>g_flag<span class="token punctuation">,</span> do_once<span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"luffy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此函数用于保证某个函数在多线程中只被调用一次。在多个调用相同函数的线程中，在此线程中某个位置可能还会调用一个函数，call_once用于保证此函数只会被调用一次，不会被其他线程再调用。</p><h2 id="1-2-this-thread命名空间"><a href="#1-2-this-thread命名空间" class="headerlink" title="1.2 this_thread命名空间"></a>1.2 this_thread命名空间</h2><p>C++11还提供了一个关于线程的命名空间 std::this_thread，其含四个操作函数。</p><p><strong>get_id()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//得到当前线程的线程 ID</span>thread<span class="token double-colon punctuation">::</span>id <span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">//此函数无需在类上操作，直接使用</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"主线程: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>sleep_for()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Rep</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Period</span><span class="token operator">></span>  <span class="token keyword">void</span> <span class="token function">sleep_for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>Rep<span class="token punctuation">,</span>Period<span class="token operator">></span><span class="token operator">&amp;</span> rel_time<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>调用此函数，线程会进入阻塞状态，阻塞特定时间，其必须指定一个阻塞时间</p><p><strong>sleep_until()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//将进程阻塞到某个时间</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Duration</span><span class="token operator">></span>  <span class="token keyword">void</span> <span class="token function">sleep_until</span> <span class="token punctuation">(</span><span class="token keyword">const</span> chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>Clock<span class="token punctuation">,</span>Duration<span class="token operator">></span><span class="token operator">&amp;</span> abs_time<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>相比sleep_for，此函数是将线程阻塞到某个时间</p><p><strong>yield()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此函数是放弃当前线程的cpu使用权，将当前线程转为<strong>就绪态</strong>，当前线程仍然有可能在下一个时间片获得cpu使用权</p><h1 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2. 线程同步"></a>2. 线程同步</h1><p>C++11 中提供了三种同步方式：互斥锁、条件变量、原子变量atomic</p><h2 id="2-1-互斥锁"><a href="#2-1-互斥锁" class="headerlink" title="2.1 互斥锁"></a>2.1 互斥锁</h2><p>C++11中共有四种互斥锁：</p><ul><li>（1）std::mutex：独占的互斥锁，不能递归使用</li><li>（2）std::timed_mutex：带超时的独占互斥锁，不能递归使用</li><li>（3）std::recursive_mutex：递归互斥锁，不带超时功能</li><li>（4）std::recursive_timed_mutex：带超时的递归互斥锁</li></ul><h3 id="2-1-1-std-mutex"><a href="#2-1-1-std-mutex" class="headerlink" title="2.1.1 std::mutex"></a>2.1.1 std::mutex</h3><p><strong>互斥量定义</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span>mutex g_num_mutex<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>lock()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用于mutex对象加锁，并且只能有一个线程获得锁的所有权</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>try_lock()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">try_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//尝试给mutex对象加锁，加锁失败则返回false</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>unlock()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用于给mutex对象解锁，只有加锁的线程才能解锁成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-1-2-std-lock-guard"><a href="#2-1-2-std-lock-guard" class="headerlink" title="2.1.2 std::lock_guard"></a>2.1.2 std::lock_guard</h3><p>lock_guard 是 C++11 新增的一个模板类，使用这个类，可以简化互斥锁 lock() 和 unlock() 的写法，同时也更安全（离开作用域时自动释放锁）</p><p><strong>原型</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 类的定义，定义于头文件 &lt;mutex></span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Mutex</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">lock_guard</span><span class="token punctuation">;</span><span class="token comment">// 常用构造函数</span><span class="token keyword">explicit</span> <span class="token function">lock_guard</span><span class="token punctuation">(</span> mutex_type<span class="token operator">&amp;</span> m <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lock_guard 在使用上面提供的这个构造函数构造对象时，会自动锁定互斥量，而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，避免忘记 unlock() 操作而导致线程死锁。lock_guard 使用了 RAII 技术，就是在类构造函数中分配资源，在析构函数中释放资源，保证资源出了作用域就释放。</p><h3 id="2-1-3-std-recursive-mutex"><a href="#2-1-3-std-recursive-mutex" class="headerlink" title="2.1.3 std::recursive_mutex"></a>2.1.3 std::recursive_mutex</h3><p>递归互斥锁 std::recursive_mutex 允许同一线程多次获得互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题</p><p><strong>定义</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">recursive_mutex m_mutex<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程和线程同步-C-Linux</title>
      <link href="/2023/02/15/c++/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5_C_Linux/"/>
      <url>/2023/02/15/c++/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5_C_Linux/</url>
      
        <content type="html"><![CDATA[<p><em>这是Linux下的多线程编程（基于C），而不是C++11多线程编程。参考爱编程的大丙的多线程和线程同步-C&#x2F;C++，<a href="https://www.bilibili.com/video/BV1sv41177e4?p=8&vd_source=7135ae3a4d6506056ac51c05382c2a25">bilibili视频地址</a>, <a href="https://subingwen.cn/linux/thread/#1-%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0">博客地址</a>。</em></p><hr><hr><h1 id="1-线程概述"><a href="#1-线程概述" class="headerlink" title="1. 线程概述"></a>1. 线程概述</h1><p>​线程是轻量级的进程，在 Linux 环境下线程的本质仍是进程。</p><p>​进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。</p><p>​<strong>线程和进程之间的区别</strong>：</p><ul><li><p>进程有自己独立的地址空间，多个线程共用同一个地址空间</p><ul><li>线程更加节省系统资源，效率不仅可以保持的，而且能够更高</li><li>在一个地址空间中多个线程独享：<em><strong>每个线程都有属于自己的栈区，寄存器 (内核中管理的)</strong></em></li><li>在一个地址空间中多个线程共享：代码段，堆区，全局数据区，打开的文件 (文件描述符表) 都是线程共享的</li></ul></li><li><p>线程是程序的最小执行单位，进程是操作系统中最小的资源分配单位</p></li><li><p>CPU 的调度和切换：线程的上下文切换比进程要快的多</p></li><li><p>线程更加廉价，启动速度更快，退出也快，对系统资源的冲击小。</p></li></ul><hr><hr><h1 id="2-多线程基础功能函数"><a href="#2-多线程基础功能函数" class="headerlink" title="2. 多线程基础功能函数"></a>2. 多线程基础功能函数</h1><h2 id="2-1-创建线程函数"><a href="#2-1-创建线程函数" class="headerlink" title="2.1 创建线程函数"></a>2.1 创建线程函数</h2><p>​每一个线程都有唯一的线程 ID，类型为 pthread_t，在Linux下也就是一个无符号长整形数，得到当前线程的线程 ID函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pthread_t <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 返回当前线程的线程ID</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​在一个进程中调用线程创建函数，就可得到一个子线程，注意，一个进程创建子线程后，进程就变为主线程+一个子线程，子线程创建函数如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span>pthread_t <span class="token operator">*</span>thread<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span>                   <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Compile and link with -pthread, 线程库的名字叫pthread, 全名: libpthread.so libptread.a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>参数</p><ul><li>thread: 传出参数，是无符号长整形数，线程创建成功，会将线程 ID 写入到这个指针指向的内存中</li><li>attr: 线程的属性，一般情况下使用默认属性即可，写 NULL</li><li>start_routine: 函数指针，创建出的子线程的处理动作，也就是该函数在子线程中执行。</li><li>arg: 作为实参传递到 start_routine 指针指向的函数内部（<strong>如需传递多个数据，可定义一个结构体</strong>）</li></ul></li><li><p>返回值：线程创建成功返回 0，创建失败返回对应的错误号</p></li></ul><p>​如果主线程退出了, 虚拟地址空间就被释放了, 子线程就一并被销毁了。但是如果某一个子线程退出了, 主线程仍在运行, 虚拟地址空间依旧存在。</p><h2 id="2-2-线程退出"><a href="#2-2-线程退出" class="headerlink" title="2.2 线程退出"></a>2.2 线程退出</h2><p>​只要调用线程退出函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。但是主线程退出结束后，子线程也会退出结束。线程退出函数如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token keyword">void</span> <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>参数：线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为 NULL（<strong>如需返回多个数据，可定义一个结构体</strong>）</li></ul><h2 id="2-3-线程回收"><a href="#2-3-线程回收" class="headerlink" title="2.3 线程回收"></a>2.3 线程回收</h2><p>​线程和进程一样，子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做 pthread_join()，这个函数是一个阻塞函数。</p><p>​如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</p><p>​<strong>线程回收函数</strong>如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token comment">// 这是一个阻塞函数, 子线程在运行这个函数就阻塞</span><span class="token comment">// 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()</span><span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>thread: 要被回收的子线程的线程 ID</p><ul><li>retval: 二级指针，指向一级指针的地址，是一个传出参数，这个地址中存储了 pthread_exit () 传递出的数据，如果不需要这个参数，可以指定为 NULL</li></ul></li><li><p>返回值：线程回收成功返回 0，回收失败返回错误号。</p></li></ul><p>​<strong>僵尸进程（僵尸线程）</strong>：主进程没有回收子进程的资源，导致子进程即使结束后还有一些资源未被释放，如进程号等</p><p>​<strong>回收子线程数据</strong>: 在子线程退出的时候可以使用 pthread_exit() 的参数将数据传出，在回收这个子线程的时候可以通过 phread_join() 的第二个参数来接收子线程传递出的数据。</p><p>​<strong>接受子线程数据方式</strong>：</p><ul><li>（1）使用子线程栈：使用子线程栈区传递数据（<em>虽然每个线程都有属于自己的栈区空间，但是位于同一个地址空间的多个线程是可以相互访问对方的栈空间上的数据的</em>）</li><li>（2）使用全局变量</li><li>（3）使用主线程栈：使用主线程栈区传递数据</li></ul><h2 id="2-4-线程分离"><a href="#2-4-线程分离" class="headerlink" title="2.4 线程分离"></a>2.4 线程分离</h2><p>​在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用 pthread_join() 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。</p><p>​调用线程分离函数后，子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。</p><p>​线程分离之后在主线程中使用 pthread_join() 就回收不到子线程资源了。</p><p>​<strong>线程分离函数</strong>如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了</span><span class="token keyword">int</span> <span class="token function">pthread_detach</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-5-其他线程函数"><a href="#2-5-其他线程函数" class="headerlink" title="2.5 其他线程函数"></a>2.5 其他线程函数</h2><h3 id="2-5-1-线程取消"><a href="#2-5-1-线程取消" class="headerlink" title="2.5.1 线程取消"></a>2.5.1 线程取消</h3><p>​线程取消也就是杀死另外一个线程。</p><p>​杀死一个线程分为两步：</p><ul><li>（1）先调用函数pthread_cancel()杀死线程B，线程不是立即死亡</li><li>（2）当线程进行一次系统调用时（切换到内核态）时，线程才会死亡，否则一直存活</li></ul><p>​<strong>线程取消函数</strong>如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 参数是子线程的线程ID</span><span class="token keyword">int</span> <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回值：函数调用成功返回 0，调用失败返回非 0 错误号。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-5-2-线程-ID-比较"><a href="#2-5-2-线程-ID-比较" class="headerlink" title="2.5.2 线程 ID 比较"></a>2.5.2 线程 ID 比较</h3><p>​此函数也就是比较是否是一个线程</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_equal</span><span class="token punctuation">(</span>pthread_t t1<span class="token punctuation">,</span> pthread_t t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>参数：t1 和 t2 是要比较的线程的线程 ID</li><li>返回值：如果两个线程 ID 相等返回非 0 值，如果不相等返回 0</li></ul><hr><hr><h1 id="3-线程同步"><a href="#3-线程同步" class="headerlink" title="3. 线程同步"></a>3. 线程同步</h1><p>线程同步以我的理解就是对多个线程的临界资源进行线性化访问</p><p>常用的线程同步方式有四种：<strong>互斥锁、读写锁、条件变量、信号量</strong></p><p><strong>死锁</strong>：两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p><h2 id="3-1-互斥锁"><a href="#3-1-互斥锁" class="headerlink" title="3.1 互斥锁"></a>3.1 互斥锁</h2><p>Linux 中互斥锁的类型为 pthread_mutex_t，定义互斥锁方法如下，变量保存了锁的<strong>状态信息</strong>和打开其的线程</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pthread_mutex_t  mutex<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>初始化锁和销毁锁</strong>函数如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 初始化互斥锁</span><span class="token comment">// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的</span><span class="token keyword">int</span> <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">,</span>           <span class="token keyword">const</span> pthread_mutexattr_t <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 释放互斥锁资源            </span><span class="token keyword">int</span> <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>参数<ul><li>mutex: 互斥锁变量的地址</li><li>attr: 互斥锁的属性，一般使用默认属性即 NULL</li></ul></li></ul><p><strong>线程加锁函数</strong>如下，其工作流程是：先判断mutex是否被锁定，如果没有则加锁成功，否则，线程被阻塞，当锁被解除锁定后，阻塞线程则被唤醒。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 修改互斥锁的状态, 将其设定为锁定状态, 这个状态被写入到参数 mutex 中</span><span class="token keyword">int</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>线程解锁函数</strong>如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>互斥锁造成死锁场景</strong>：</p><ul><li>（1）加锁之后忘记解锁</li><li>（2）重复加锁，造成死锁</li><li>（3）在程序中有多个共享资源，因此有很多把锁，随意加锁，导致相互被阻塞</li></ul><p>使用互斥锁避免死锁方法：</p><ul><li>（1）避免多次锁定，多检查</li><li>（2）对共享资源访问完毕之后，一定要解锁</li></ul><h2 id="3-2-读写锁"><a href="#3-2-读写锁" class="headerlink" title="3.2 读写锁"></a>3.2 读写锁</h2><p>相比起互斥锁不区分读写权限，读写锁对读写权限进行了细分控制。读写锁的读操作是可以并行的，但写操作必须是串行的。</p><p>使用读写锁分别对两个临界区加了读锁和写锁，访问数据时，访问写锁临界区的线程继续运行，访问读锁临界区的线程阻塞，因为<strong>写锁比读锁的优先级高</strong>。</p><p>读写锁类型为pthread_rwlock_t，定义：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pthread_rwlock_t rwlock<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>读写锁初始化函数和销毁函数</strong>如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pthread_rwlock_t rwlock<span class="token punctuation">;</span><span class="token comment">// 初始化读写锁</span><span class="token keyword">int</span> <span class="token function">pthread_rwlock_init</span><span class="token punctuation">(</span>pthread_rwlock_t <span class="token operator">*</span>restrict rwlock<span class="token punctuation">,</span>           <span class="token keyword">const</span> pthread_rwlockattr_t <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 释放读写锁占用的系统资源</span><span class="token keyword">int</span> <span class="token function">pthread_rwlock_destroy</span><span class="token punctuation">(</span>pthread_rwlock_t <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//rwlock: 读写锁的地址，传出参数</span><span class="token comment">//attr: 读写锁属性，一般使用默认属性即NULL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>读写锁加读锁</strong>，其只有在已经被加写锁时才被阻塞</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_rwlock_rdlock</span><span class="token punctuation">(</span>pthread_rwlock_t <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>读写锁加写锁</strong>，和互斥锁类似</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_rwlock_wrlock</span><span class="token punctuation">(</span>pthread_rwlock_t <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>读写锁尝试加写锁</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 这个函数可以有效的避免死锁</span><span class="token comment">// 如果加写锁失败, 不会阻塞当前线程, 直接返回错误号</span><span class="token keyword">int</span> <span class="token function">pthread_rwlock_trywrlock</span><span class="token punctuation">(</span>pthread_rwlock_t <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>读写锁解锁，读锁和解锁都用此函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_rwlock_unlock</span><span class="token punctuation">(</span>pthread_rwlock_t <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-3-条件变量"><a href="#3-3-条件变量" class="headerlink" title="3.3 条件变量"></a>3.3 条件变量</h2><p>条件变量以我的理解是不带资源计数，只记录阻塞线程信息，调用条件变量阻塞函数则直接阻塞线程，需要自己写是否阻塞判定语句。</p><p>条件变量能直接唤醒所有阻塞线程，当唤醒所有阻塞线程时，代码中应该判定是否满足需要条件，否则继续等待（通常用while来写）</p><p><strong>条件变量定义</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pthread_cond_t cond<span class="token punctuation">;</span><span class="token comment">//条件变量阻塞的线程的线程信息会被记录到变量中</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>条件变量初始化函数和销毁函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span>      <span class="token keyword">const</span> pthread_condattr_t <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//attr: 条件变量属性，一般使用默认属性，指定为 NULL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>线程阻塞函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数在阻塞线程的时候，需要一个互斥锁参数，<strong>这个互斥锁主要功能是保护条件变量</strong>进行线程同步。该函数会对这个互斥锁做以下几件事情：</p><ul><li>（1）在调用函数之前需要锁定互斥对象，然后再调用pthread_cond_wait。</li><li>（2）pthread_cond_wait所做的第一件事就是阻塞然后对互斥锁解锁，然后等到条件变量发生</li><li>（3） pthread_cond_wait()被唤醒时解除阻塞，并且尝试获取锁（不一定拿到锁）。因此，一般在使用的时候都是在一个循环里使用pthread_cond_wait()函数，因为它在返回的时候不一定能拿到锁（这里应该唤醒全部进程时需要使用循环。这可能会发生饿死情形，当然这取决于操作系统的调度策略，是否需要循环还需要验证，）。</li></ul><p>理解：在多线程中也需要对条件变量进行互斥访问，因此在使用函数前需要对互斥锁进行加锁，而在阻塞函数开始阻塞后，则立即将互斥锁释放掉。当满足条件变量时，会立即对互斥锁进行加锁，这是因为条件变量满足后，通常会有个临界区代码需要执行，为保证访问不混乱，则需要对这段代码开始加锁。</p><p>简单来说就是pthread_cond_wait函数里在包含一个解锁函数和加锁函数，如下代码中的2345，其中23是一个原子操作。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span> <span class="token function">lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">2</span> judge condition<span class="token punctuation">;</span><span class="token number">3</span> <span class="token function">unlock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">4</span> condition is met<span class="token punctuation">;</span><span class="token number">5</span> <span class="token function">trylock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">6</span> <span class="token function">unlock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>带时间的线程阻塞函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token punctuation">&#123;</span>time_t tv_sec<span class="token punctuation">;</span>      <span class="token comment">/* Seconds */</span><span class="token keyword">long</span>   tv_nsec<span class="token punctuation">;</span>     <span class="token comment">/* Nanoseconds [0 .. 999999999] */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了</span><span class="token keyword">int</span> <span class="token function">pthread_cond_timedwait</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span>           pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>restrict abstime<span class="token punctuation">)</span><span class="token punctuation">;</span>time_t mytim <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1970.1.1 0:0:0 到当前的总秒数</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> tmsp<span class="token punctuation">;</span>tmsp<span class="token punctuation">.</span>tv_nsec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>tmsp<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">// 线程阻塞100s</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>条件变量唤醒函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span><span class="token keyword">int</span> <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span><span class="token keyword">int</span> <span class="token function">pthread_cond_broadcast</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>条件变量和信号量区别</strong></p><ul><li>（1）使用条件变量可以一次唤醒所有等待者，而信号量不能</li><li>（2）信号量始终有一个值（状态），而条件变量是没有值的，没有地方记录发送信号的次数，也没有地方记录wait返回的次数</li><li>（3）信号量的意图在于进程间同步（也可以线程同步），条件变量意图在于线程间同步。</li><li>（4）互斥量是信号量的一种特例</li></ul><h2 id="3-4-信号量"><a href="#3-4-信号量" class="headerlink" title="3.4 信号量"></a>3.4 信号量</h2><p>这里信号量的信号量和操作系统中学的信号量概念相同，用于表示资源个数且附带阻塞唤醒</p><p>信号量不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用（存疑）</p><p>信号量时互斥量的扩展</p><p><strong>信号量声明</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span>sem_t sem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>信号量初始化和销毁</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 初始化信号量/信号灯</span><span class="token keyword">int</span> <span class="token function">sem_init</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 资源释放, 线程销毁之后调用这个函数即可         </span><span class="token keyword">int</span> <span class="token function">sem_destroy</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//sem：信号量变量地址</span><span class="token comment">//pshared  0：线程同步 非 0：进程同步</span><span class="token comment">//value：初始化当前信号量拥有的资源数（>=0），如果资源数为 0，线程就会被阻塞了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>wait函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span><span class="token keyword">int</span> <span class="token function">sem_trywait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>资源数大于0时，调用此函数，资源数-1，当资源数&lt;&#x3D;0时，则被阻塞</p><p><strong>trywait函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sem_trywait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理，和sem_trywait相比差别就是，资源数&lt;&#x3D;0时，线程不是被阻塞而是返回一个错误信号</p><p><strong>wait+time函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// abs_timeout: 阻塞的时间长度, 单位是s, 是从1970.1.1开始计算的,和前面计算时间类似</span><span class="token keyword">int</span> <span class="token function">sem_timedwait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>abs_timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>post函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 调用该函数给sem中的资源数+1</span><span class="token keyword">int</span> <span class="token function">sem_post</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当有线程被阻塞时，调用此函数后有一个阻塞线程会被唤醒</p><p><strong>查询资源个数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 查看信号量 sem 中的整形数的当前值, 这个值会被写入到sval指针对应的内存中</span><span class="token comment">// sval是一个传出参数</span><span class="token keyword">int</span> <span class="token function">sem_getvalue</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>sval<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-C++打包依赖</title>
      <link href="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96/"/>
      <url>/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<p>参考 <a href="https://blog.csdn.net/lovelyaiq/article/details/119191665">Linux 下打包可执行程序所有依赖的so 库</a></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul><li><p>通过ldd 可以查询一个执行程序的依赖的所有so库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ldd 程序<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>拷贝ldd 的查询结果到指定目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ldd 程序 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;print $3&#125;'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token parameter variable">-i</span> <span class="token function">cp</span> <span class="token parameter variable">-L</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> ./lib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置环境变量，加载动态库时会去LD_LIBRARY_PATH下加载</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:<span class="token punctuation">(</span>./lib的绝对目录<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若需永久设置，则将此命令复制到bashrc中</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小林coding-操作系统-笔记</title>
      <link href="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>总结知识点，以便以后快速复习。</p><p><em>参考小林coding操作系统</em>, <a href="https://www.xiaolincoding.com/os/">地址</a></p><h1 id="一、硬件结构"><a href="#一、硬件结构" class="headerlink" title="一、硬件结构"></a>一、硬件结构</h1><h2 id="1-1-CPU-是如何执行程序的？"><a href="#1-1-CPU-是如何执行程序的？" class="headerlink" title="1.1 CPU 是如何执行程序的？"></a>1.1 CPU 是如何执行程序的？</h2><h2 id="1-2-磁盘比内存慢几万倍？"><a href="#1-2-磁盘比内存慢几万倍？" class="headerlink" title="1.2 磁盘比内存慢几万倍？"></a>1.2 磁盘比内存慢几万倍？</h2><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317105246779.png" style="zoom:67%;" /><hr><h3 id="存储器级别划分"><a href="#存储器级别划分" class="headerlink" title="存储器级别划分"></a><strong>存储器级别划分</strong></h3><ul><li><p>寄存器：寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写。寄存器的数量通常在几十到几百之间，每个寄存器可以用来存储一定的字节（byte）的数据</p></li><li><p>CPU Cache：用的是一种叫 SRAM（静态随机存储器） 的芯片，存储密度不高。只要有电，数据就可以保持存在。</p><ol><li>L1-Cache：每个 CPU 核心都有一块属于自己的 L1 高速缓存，访问速度通常只需要 <code>2~4</code> 个时钟周期，而大小在几十 KB 到几百 KB 不等。通常分成<strong>指令缓存</strong>和<strong>数据缓存</strong>（分开存放）。</li><li>L2-Cache：每个 CPU 核心都有，通常大小在几百 KB 到几 MB 不等，速度在 <code>10~20</code> 个时钟周期。</li><li>L3-Cahce：多个 CPU 核心共用，通常大小在几 MB 到几十 MB 不等，速度在 <code>20~60</code>个时钟周期</li></ol></li><li><p>内存：使用的是DRAM （动态随机存取存储器） 的芯片，内存速度大概在 <code>200~300</code> 个 时钟周期之间</p><blockquote><p>相比 SRAM，DRAM 的密度更高，功耗更低。</p><p>因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因</p></blockquote></li><li><p>SSD&#x2F;HDD 硬盘</p><ul><li>SSD结构和内存类似，断电后数据还是存在的，内存的读写速度比 SSD 大概快 <code>10~1000</code> 倍</li><li>机械硬盘（*, HDD*）是通过物理读写的方式来访问数据的，它的速度比内存慢 <code>10W</code> 倍左右。</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317105537831.png" style="zoom:50%;" /><blockquote><p>注意：</p><ul><li><p>CPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。</p></li><li><p>当 CPU 需要访问内存中某个数据的时候，会不断层级访问判断是否有该数据，如果没有则访问下一层级存储器</p></li><li><p>分级的目的是要构造<strong>缓存</strong>体系</p></li></ul></blockquote><h2 id="1-3-如何写出让-CPU-跑得更快的代码？"><a href="#1-3-如何写出让-CPU-跑得更快的代码？" class="headerlink" title="1.3 如何写出让 CPU 跑得更快的代码？"></a>1.3 如何写出让 CPU 跑得更快的代码？</h2><h3 id="CPU-Cache-的数据结构和读取过程"><a href="#CPU-Cache-的数据结构和读取过程" class="headerlink" title="CPU Cache 的数据结构和读取过程"></a><strong>CPU Cache 的数据结构和读取过程</strong></h3><ol><li>根据内存地址中索引信息，计算在 CPU Cache 中的索引，也就是找出对应的 CPU Cache Line 的地址；</li><li>找到对应 CPU Cache Line 后，判断 CPU Cache Line 中的有效位，确认 CPU Cache Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；</li><li>对比内存地址中组标记和 CPU Cache Line 中的组标记，确认 CPU Cache Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；</li><li>根据内存地址中偏移量信息，从 CPU Cache Line 的数据块中，读取对应的字。</li></ol><blockquote><p>上述过程是Cache直接映射计算方法，其使用的取模运算计算映射地址。</p><p>组标记是为了区分不同地址映射到相同位置，其实就是拿地址的前部分来判断。</p></blockquote><p><strong>注意，Cache每次读内存都是一块一块的读，也就是读取目标地址附近一个cache line大小的数据，可以利用此特性加快代码运行</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317114717676.png" style="zoom:80%;" /><hr><h3 id="如何写出让-CPU-跑得更快的代码？"><a href="#如何写出让-CPU-跑得更快的代码？" class="headerlink" title="如何写出让 CPU 跑得更快的代码？"></a><strong>如何写出让 CPU 跑得更快的代码？</strong></h3><ol><li><strong>提升数据缓存的命中率</strong><ul><li>按照内存布局顺序访问，将可以有效的利用 CPU Cache 带来的好处，这样我们代码的性能就会得到很大的提升</li><li>例如遍历二维数组的情况时，先遍历水平比先遍历竖直方向更快</li></ul></li><li><strong>提升指令缓存的命中率</strong><ul><li>对于 if 条件语句，会使用 CPU 的分支预测器预测跳转哪部分。如果分支预测可以预测到接下来要执行 的指令，就可以提前把这些指令放在指令缓存中，这样 CPU 可以直接从 Cache 读取到指令，于是执行速度就会很快。</li><li>例如先排序再用if判断比直接if判断分支预测更准确</li></ul></li><li><strong>提升多核 CPU 的缓存命中率</strong><ul><li>如果一个线程在不同核心来回切换，各个核心的缓存命中率就会受到影响，相反如果线程都在同一个核心上执行，那么其数据的 L1 和 L2 Cache 的缓存命中率可以得到有效提高，可以减少访问 内存的频率。</li><li>在 Linux 上提供了 <code>sched_setaffinity</code> 方法，来实现将线程绑定到某个 CPU 核心这一功能</li></ul></li></ol><h2 id="1-4-CPU-缓存一致性"><a href="#1-4-CPU-缓存一致性" class="headerlink" title="1.4 CPU 缓存一致性"></a>1.4 CPU 缓存一致性</h2><h3 id="CPU-Cache-的数据写入"><a href="#CPU-Cache-的数据写入" class="headerlink" title="CPU Cache 的数据写入"></a>CPU Cache 的数据写入</h3><p><strong>写直达</strong></p><p>保持内存与 Cache 一致性最简单的方式是，<strong>把数据同时写入内存和 Cache 中</strong>，这种方法称为<strong>写直达</strong></p><ul><li>写入前会先判断数据是否已经在 CPU Cache 里面了：<ul><li>如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面；</li><li>如果数据没有在 Cache 里面，就直接把数据更新到内存里面。</li></ul></li><li>缺点：每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响</li></ul><p><strong>写回</strong></p><p><strong>当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中</strong>，减少了数据写回内存的频率。</p><ul><li>如果当发生写操作时，数据已经在 CPU Cache 里的话，则把数据更新到 CPU Cache 里，同时标记 CPU Cache 里的这个 Cache Block 为脏的，代表这这个 Cache Block 的数据和内存是不一致的，这种情况是不用把数据写到内存里的；</li><li>如果当发生写操作时，数据所对应的 Cache Block 里存放的是「别的内存地址的数据」的话，就要检查这个 Cache Block 里的数据有没有被标记为脏的：<ul><li>如果是脏的话，我们就要把这个 Cache Block 里的数据<strong>写回到内存</strong>，然后再把当前要写入的数据从内存读入到 Cache Block 里，然后再把当前要写入的数据写入到 Cache Block，最后也把它标记为脏的；</li><li>如果不是脏的话，把当前要写入的数据先从内存读入到 Cache Block 里，接着将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的。</li></ul></li></ul><blockquote><p><strong>为什么缓存没命中时需要先从内存读取数据再写缓存？</strong></p><p>应该是为了配合下面的MESI协议保持多核之间的缓存一致性，MESI协议中一个cache从失效到独占状态都需要从内存读数据。</p><p>如果其他核心中存在已修改的数据，则需要写入到内存，然后当前核心从内存中读取。而如果其他核心无数据或数据为共享、独占状态，这样做的原因可能是为了统一操作。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317162141317.png" style="zoom:80%;" /><hr><h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>由于 L1&#x2F;L2 Cache 是多个核心各自独有的，那么会带来多核心的<strong>缓存一致性</strong></p><p>通常使用以下两点来同步两个不同核心里面的缓存数据：</p><ul><li>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播</strong><ul><li>当某个核心在 Cache 更新了数据，就需要同步到其他核心的 Cache 里</li></ul></li><li>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串行化</strong><ul><li>串行化是指其他核心要看到相同的数据变化顺序，否则即使有写传播也会造成混乱</li></ul></li></ul><p><strong>MESI 协议</strong></p><p>MESI 协议是写传播和事务串行化的实现，其通过总线来传播消息，每个核心都会监听总线上的广播事件。</p><p>可分为四种状态：</p><ul><li><em>Modified</em>，已修改：代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里</li><li><em>Exclusive</em>，独占：代表 Cache Block 里的数据和内存里面的数据是一致性的，但只存储在一个 CPU 核心的 Cache 里。<ul><li>如果要向独占的 Cache 写数据，就可以直接自由地写入，而不需要通知其他 CPU 核心</li><li>当核心读取了数据时，其会向其他核心发送通知，如果在其他核心是独占状态，则会将其改为共享状态。</li></ul></li><li><em>Shared</em>，共享：代表 Cache Block 里的数据和内存里面的数据是一致性的，但相同的数据在多个 CPU 核心的 Cache 里都有。<ul><li>要更新 Cache 里面的共享状态数据时，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。</li></ul></li><li><em>Invalidated</em>，已失效：表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据</li></ul><p>注意！这几个状态都是标记的一整个cache line。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317165044798.png" style="zoom:80%;" /><h2 id="1-5-CPU-是如何执行任务的？"><a href="#1-5-CPU-是如何执行任务的？" class="headerlink" title="1.5 CPU 是如何执行任务的？"></a>1.5 CPU 是如何执行任务的？</h2><h3 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h3><p>因为多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为<strong>伪共享</strong></p><ul><li>例如AB两个变量属于同一个cache line，A只会被1核心读写，B只会被2核心读写。如当1核心读取A时会将整个cache line读取，而其中又包括变量B，那么当改变变量A时，2核心的cache line也会通过MESI协议进行状态改变。同理2核心写B也会影响A。其实际并没有共享任何变量，从而造成性能影响。</li></ul><p><strong>避免伪共享的方法</strong></p><ul><li>在 Linux 内核中存在 <code>__cacheline_aligned_in_smp</code> 宏定义，是用于解决伪共享的问题。<ul><li>例如定义结构体时将其中的变量附上<code>__cacheline_aligned_in_smp</code>，就会使得变量分属于不同cache line，这其实是一种空间换时间的方法。</li></ul></li><li>Java 并发框架 Disruptor 使用「字节填充 + 继承」的方式，来避免伪共享的问题。</li></ul><hr><h3 id="CPU-如何选择线程的？"><a href="#CPU-如何选择线程的？" class="headerlink" title="CPU 如何选择线程的？"></a>CPU 如何选择线程的？</h3><blockquote><p>在 Linux 内核中，进程和线程都是用 <code>task_struct</code> 结构体表示的，区别在于线程的 task_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程</p></blockquote><p>在 Linux 系统中，根据任务的优先级以及响应要求，主要分为两种，其中优先级的数值越小，优先级越高：</p><ul><li>实时任务，对系统的响应时间要求很高，也就是要尽可能快的执行实时任务，优先级在 <code>0~99</code> 范围内的就算实时任务；</li><li>普通任务，响应时间没有很高的要求，优先级在 <code>100~139</code> 范围内都是普通任务级别</li></ul><p><strong>Linux 系统调度类</strong></p><ul><li>Deadline 和 Realtime 这两个调度类，都是应用于实时任务<ul><li><em>SCHED_DEADLINE</em>：距离当前时间点最近的 deadline 的任务会被优先调度；</li><li><em>SCHED_FIFO</em>：对于相同优先级的任务，按先来先服务的原则，但是优先级更高的任务，可以抢占低优先级的任务；</li><li><em>SCHED_RR</em>：对于相同优先级的任务，轮流着运行，每个任务都有一定的时间片，当用完时间片的任务会被放到队列尾部，以保证相同优先级任务的公平性，但是高优先级的任务依然可以抢占低优先级的任务；</li></ul></li><li>Fair 调度类是应用于普通任务，都是由 CFS 调度器管理的<ul><li><em>SCHED_NORMAL</em>：普通任务使用的调度策略；</li><li><em>SCHED_BATCH</em>：后台任务的调度策略，不和终端进行交互，因此在不影响其他需要交互的任务，可以适当降低它的优先级。</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317172758100.png" style="zoom:67%;" /><p><strong>完全公平调度</strong></p><ul><li>为每个任务安排一个虚拟运行时间 vruntime，如果一个任务在运行，其运行的越久，该任务的 vruntime 自然就会越大，而没有被运行的任务，vruntime 是不会变化的。<strong>在 CFS 算法调度的时候，会优先选择 vruntime 少的任务</strong></li><li>当考虑任务权重时，存在以下公式进行计算vruntime，NICE_0_LOAD 是一个常量<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317173136791.png" style="zoom:80%;" /></li></ul><p><strong>CPU 运行队列</strong></p><p>每个 CPU 都有自己的<strong>运行队列</strong>，用于描述在此 CPU 上所运行的所有进程，其队列包含三个运行队列：</p><ul><li>Deadline 运行队列 dl_rq</li><li>实时任务运行队列 rt_rq </li><li>CFS 运行队列 cfs_rq，其中 cfs_rq 是用红黑树来描述的，按 vruntime 大小来排序的，最左侧的叶子节点，就是下次会被调度的任务。</li></ul><p>调度类是有优先级的，优先级如下：Deadline &gt; Realtime &gt; Fair，会优先调度优先级高的调度类，因此<strong>实时任务总是会比普通任务优先被执行</strong></p><p><strong>调整优先级</strong></p><p>Linux默认情况下都是普通任务，普通任务的调度类是 Fair，由 CFS 调度器来进行管理。</p><p>可以调整任务的 <code>nice</code> 值，来间接影响任务优先级，其范围是 <code>-20～19</code>（nice值可以看成对任务优先级的修正，priority(new) &#x3D; priority(old) + nice）</p><h2 id="1-6-什么是软中断？"><a href="#1-6-什么是软中断？" class="headerlink" title="1.6 什么是软中断？"></a>1.6 什么是软中断？</h2><blockquote><p>中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。</p></blockquote><p>Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」。</p><ul><li>上半部用来快速处理中断，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。<ul><li>上半部直接处理硬件请求，也就是<strong>硬中断</strong>，主要是负责耗时短的工作，特点是快速执行</li></ul></li><li>下半部用来延迟处理上半部未完成的工作，一般以「内核线程」的方式运行。<ul><li>下半部是由内核触发，也就是<strong>软中断</strong>，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；</li><li>软中断不只是包括硬件设备中断处理程序的下半部，一些内核自定义事件也属于软中断，比如内核调度等</li><li>每一个 CPU 都对应一个软中断内核线程，名字通常为「ksoftirqd&#x2F;CPU 编号」</li></ul></li></ul><h2 id="1-7-为什么-0-1-0-2-不等于-0-3-？"><a href="#1-7-为什么-0-1-0-2-不等于-0-3-？" class="headerlink" title="1.7 为什么 0.1 + 0.2 不等于 0.3 ？"></a>1.7 为什么 0.1 + 0.2 不等于 0.3 ？</h2><h3 id="为什么负数要用补码表示？"><a href="#为什么负数要用补码表示？" class="headerlink" title="为什么负数要用补码表示？"></a>为什么负数要用补码表示？</h3><ul><li>正数存储：最高位是作为「符号标志位」，剩余的 31 位则表示二进制数据。正数的符号位是 <code>0</code>，负数的符号位是 <code>1</code>。</li><li>负数存储：最高位是作为「符号标志位」，剩余的以「补码」表示的，所谓的补码就是把正数的二进制全部取反再加 1</li></ul><p>负数之所以用补码的方式来表示，主要是为了统一和正数的加减法，使得不必根据是否为负数来调整操作。</p><hr><h3 id="十进制小数怎么转成二进制？"><a href="#十进制小数怎么转成二进制？" class="headerlink" title="十进制小数怎么转成二进制？"></a>十进制小数怎么转成二进制？</h3><p>十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317202013256.png" style="zoom:50%;" /><h3 id="计算机是怎么存小数的？"><a href="#计算机是怎么存小数的？" class="headerlink" title="计算机是怎么存小数的？"></a>计算机是怎么存小数的？</h3><p>计算机是以浮点数的形式存储小数的，包含三个部分：</p><ul><li>符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li><li>指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；</li><li>尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li></ul><p><strong>转换成二进制浮点数</strong></p><ul><li><p>先将数整体部分和小数部分都转换为二进制</p></li><li><p>然后把小数点，移动到第一个1后面，计算移动位数，小数点向左移为+，右移为减。然后小数点后的即为尾数。</p></li><li><p>指数位&#x3D;移动位数+偏移量，float 的话偏移量是 127。</p><blockquote><p>指数可能是正数，也可能是负数，为了减少不必要的麻烦，在实际存储指数的时候，需要把指数转换成<strong>无符号整数</strong>。</p><p>float 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 <code>-126 ~ +127</code>，于是为了把指数转换成无符号整数，就要加个<strong>偏移量</strong>，比如 float 的指数偏移量是 <code>127</code>，这样指数就不会出现负数了。</p></blockquote></li></ul><p> <strong>float 的二进制浮点数转换成十进制</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317202908467.png"></p><h3 id="0-1-0-2-x3D-x3D-0-3-吗？"><a href="#0-1-0-2-x3D-x3D-0-3-吗？" class="headerlink" title="0.1 + 0.2 &#x3D;&#x3D; 0.3 吗？"></a>0.1 + 0.2 &#x3D;&#x3D; 0.3 吗？</h3><p>0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。</p><h1 id="二、操作系统结构"><a href="#二、操作系统结构" class="headerlink" title="二、操作系统结构"></a>二、操作系统结构</h1><h2 id="2-1-Linux-内核-vs-Windows-内核"><a href="#2-1-Linux-内核-vs-Windows-内核" class="headerlink" title="2.1 Linux 内核 vs Windows 内核"></a>2.1 Linux 内核 vs Windows 内核</h2><p><strong>什么是内核？</strong></p><p>内核是应用连接硬件设备的桥梁，一般会提供 4 个基本能力：</p><ul><li>管理进程、线程，决定哪个进程、线程使用 CPU，也就是<strong>进程调度</strong>的能力；</li><li>管理内存，决定内存的分配和回收，也就是<strong>内存管理</strong>的能力；</li><li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是<strong>硬件通信</strong>能力；</li><li><strong>提供系统调用</strong>，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。</li></ul><p>多数操作系统，把内存分成了两个区域：</p><ul><li>内核空间，这个内存空间只有内核程序可以访问，即<strong>内核态</strong>执行；</li><li>用户空间，这个内存空间专门给应用程序使用，即<strong>用户态</strong>执行；</li></ul><p><strong>系统调用过程</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317204720389.png" style="zoom: 67%;" /><hr><h3 id="Linux-的设计"><a href="#Linux-的设计" class="headerlink" title="Linux 的设计"></a>Linux 的设计</h3><p>Linux 内核设计的理念主要有这几个点：</p><ul><li><em>MultiTask</em>，多任务：可以有多个任务同时执行，这里的「同时」可以是并发或并行</li><li><em>SMP</em>，对称多处理：每个 CPU 的地位是相等的，对资源的使用权限也是相同的，多个 CPU 共享同一个内存，每个 CPU 都可以访问完整的内存和硬件资源。</li><li><em>ELF</em>，可执行文件链接格式：是 Linux 操作系统中可执行文件的存储格式</li><li><em>Monolithic Kernel</em>，宏内核：宏内核的特征是系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。</li></ul><blockquote><p><strong>微内核</strong></p><ul><li><p>微内核架构的内核只保留最基本的能力，比如进程调度、虚拟机内存、中断等，把一些应用放到了用户空间，比如驱动程序、文件系统等。</p></li><li><p>这样服务与服务之间是隔离的，单个服务出现故障或者完全攻击，也不会导致整个操作系统挂掉，提高了操作系统的稳定性和可靠性。</p></li><li><p>缺点：由于驱动程序不在内核中，其会频繁调用底层能力，于是就需要频繁切换到内核态，带来性能损耗</p></li></ul><p><strong>混合内核</strong></p><ul><li>是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序；</li></ul></blockquote><hr><h3 id="Windows-设计"><a href="#Windows-设计" class="headerlink" title="Windows 设计"></a>Windows 设计</h3><p>Window 的内核设计则是采用了混合内核</p><p>Windows 的可执行文件格式叫 PE，称为<strong>可移植执行文件</strong>，扩展名通常是<code>.exe</code>、<code>.dll</code>、<code>.sys</code>等</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317205424836.png" style="zoom:50%;" /><h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><h2 id="3-1-为什么要有虚拟内存？"><a href="#3-1-为什么要有虚拟内存？" class="headerlink" title="3.1 为什么要有虚拟内存？"></a>3.1 为什么要有虚拟内存？</h2><p>如果程序都直接操纵物理地址，那么不仅内存利用率低，且程序的迁移性也差。</p><p>操作系统为每个进程分配独立的一套「<strong>虚拟地址</strong>」，并提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</p><blockquote><p><strong>如何转换地址？</strong></p><p>虚拟地址通过 CPU 芯片中的内存管理单元（MMU），来转换变成物理地址</p></blockquote><hr><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段的形式把这些段分离出来。</p><p><strong>分段机制下，虚拟地址和物理地址是如何映射的？</strong></p><p>分段机制下的虚拟地址由两部分组成：</p><ul><li>段选择因子：保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。</li><li>段内偏移量：位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li></ul><p><strong>分段机制不足</strong></p><ul><li>内存碎片：由于每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以会出现外部<strong>内存碎片</strong>，其<strong>不存在内部碎片</strong>。可以使用<strong>内存交换</strong>解决外部内存碎片（将碎片合并）。</li><li>内存交换效率低：内存交换是将内存展示写入硬盘，但硬盘访问速度十分慢。如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</li></ul><hr><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间叫<strong>页</strong>。在 Linux 下，每一页的大小为 4KB。</p><p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，页表是存储在内存里的</p><p>当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p><p><strong>优缺点</strong></p><ul><li>采用了分页，页与页之间是紧密排列的，所以不会有外部碎片，但会有内部内存碎片。</li><li>当内存不足时，每次从硬盘读取写入的都只有几个页，内存交换的效率就相对比较高。</li><li>不再需要一次性都把程序加载到物理内存中，<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去</strong>。</li></ul><p><strong>分页机制下，虚拟地址和物理地址是如何映射的？</strong></p><p>虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。转换过程如下：</p><ul><li>把虚拟内存地址，切分成页号和偏移量；</li><li>根据页号，从页表里面，查询对应的物理页号；</li><li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li></ul><p><strong>多级页表</strong></p><p>一级页表会导致占用内存过大，解决办法即多级页表</p><ul><li>当前页表中存储下一级页表地址</li><li>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。从而达到节约内存作用。</li></ul><blockquote><p><strong>为什么不分级的页表就做不到这样节约内存呢？</strong></p><p>对于每个虚拟地址，查找页表时需要找到其对应（区间）位置，一级页表直接存储物理地址则就需要将所有地址进行存储，而多级页表存储的是一个页表位置，可以在下一页表中继续查找，而不会直接查找失败。</p></blockquote><p><strong>TLB</strong></p><p>多级页表需要多次地址转换，而程序是有局部性的，利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，因此加入了存储最常访问的页表项的 Cache，这个 Cache 就是 TLB。</p><p>CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表</p><hr><h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p>段页式内存管理实现的方式：</p><ul><li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</li><li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li></ul><p>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。</p><p><strong>地址转换过程</strong></p><ul><li>第一次访问段表，得到页表起始地址；</li><li>第二次访问页表，得到物理页号；</li><li>第三次将物理页号与页内位移组合，得到物理地址。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318105243087.png" style="zoom: 80%;" /><hr><h3 id="Linux-内存布局"><a href="#Linux-内存布局" class="headerlink" title="Linux 内存布局"></a>Linux 内存布局</h3><p><strong>Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制</strong>。</p><ul><li>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。</li><li>Linux 把所有段的基地址设为 <code>0</code>，因此包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），段只被用于访问控制和内存保护。</li><li>通俗讲，由于段基地址都设为0，那么所有段其实就共用了一个地址空间，而段只是作为内存访问控制保护用。</li></ul><p>虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318160056933.png" style="zoom: 67%;" /><p>虽然每个进程都各自有独立的虚拟内存，但是<strong>每个虚拟内存中的内核地址，其实关联的都是相同的物理内存</strong>。这样，进程切换到内核态后，就可以很方便地访问内核空间内存</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318160158361.png" style="zoom:67%;" /><p><strong>用户空间分布的情况</strong></p><ul><li>代码段，包括二进制可执行代码；</li><li>数据段，包括已初始化的静态常量和全局变量；</li><li>BSS 段，包括未初始化的静态变量和全局变量；</li><li>堆段，包括动态分配的内存，从低地址开始向上增长；</li><li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长；</li><li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>，可以自定义。</li></ul><p>在这 7 个内存段中，只有<strong>堆和文件映射段的内存是动态分配</strong>的</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318160256561.png" style="zoom:67%;" /><blockquote><p>上图中的内存布局可以看到，代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」。</p><p><strong>保留区作用</strong>：许多系统中比较小数值的地址不是一个合法地址，例如C中的NULL。设置保留区是防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞</p></blockquote><h2 id="3-2-malloc-是如何分配内存的？"><a href="#3-2-malloc-是如何分配内存的？" class="headerlink" title="3.2 malloc 是如何分配内存的？"></a>3.2 malloc 是如何分配内存的？</h2><p>malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存。</p><p>malloc 申请内存的时候，会有<strong>两种方式向操作系统申请堆内存</strong>：</p><ul><li><p>方式一：通过 brk() 系统调用从堆分配内存</p><ul><li><p>通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间</p></li><li><p>通过 brk() 方式申请的内存，free 释放内存的时候，并不一定会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用，这样就可以重复使用。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318173542731.png" style="zoom:67%;" /></li></ul></li><li><p>方式二：通过 mmap() 系统调用在文件映射区域分配内存；</p><ul><li><p>通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318173508637.png" style="zoom: 67%;" /></li></ul></li></ul><p><strong>什么场景下 malloc() 会通过 brk() 分配内存？又是什么场景下通过 mmap() 分配内存？</strong></p><blockquote><p>malloc() 源码里默认定义了一个阈值：</p><ul><li>如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；</li><li>如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；</li></ul></blockquote><hr><h3 id="malloc-分配的是物理内存吗？"><a href="#malloc-分配的是物理内存吗？" class="headerlink" title="malloc() 分配的是物理内存吗？"></a>malloc() 分配的是物理内存吗？</h3><blockquote><p><strong>malloc() 分配的是虚拟内存</strong>。</p><ul><li><p>如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存。</p></li><li><p>只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。</p></li></ul></blockquote><hr><h3 id="malloc-1-会分配多大的虚拟内存？"><a href="#malloc-1-会分配多大的虚拟内存？" class="headerlink" title="malloc(1) 会分配多大的虚拟内存？"></a><strong>malloc(1) 会分配多大的虚拟内存？</strong></h3><blockquote><p>malloc() 在分配内存的时候，并不是按用户预期申请的字节数来分配内存空间大小，而是<strong>会预分配更大的空间作为内存池</strong>。</p></blockquote><hr><h3 id="free-释放内存，会归还给操作系统吗？"><a href="#free-释放内存，会归还给操作系统吗？" class="headerlink" title="free 释放内存，会归还给操作系统吗？"></a><strong>free 释放内存，会归还给操作系统吗？</strong></h3><blockquote><ul><li>malloc 通过 <strong>brk()</strong> 方式申请的内存，free 释放内存的时候，<strong>并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用</strong>；</li><li>malloc 通过 <strong>mmap()</strong> 方式申请的内存，free 释放内存的时候，<strong>会把内存归还给操作系统，内存得到真正的释放</strong>。</li></ul></blockquote><hr><h3 id="为什么不全部使用-mmap-来分配内存？"><a href="#为什么不全部使用-mmap-来分配内存？" class="headerlink" title="为什么不全部使用 mmap 来分配内存？"></a><strong>为什么不全部使用 mmap 来分配内存？</strong></h3><blockquote><ol><li>因为向操作系统申请内存，是要通过系统调用的，执行系统调用是要进入内核态的，然后在回到用户态，运行态的切换会耗费不少时间。如果都用 mmap 来分配内存，等于每次都要执行系统调用。</li><li>因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会<strong>触发缺页中断</strong>。</li></ol></blockquote><p>malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。</p><p>等下次在申请内存的时候，就直接从内存池取出对应的内存块就行，不仅减少了系统调用的次数，也减少了缺页中断的次数</p><hr><h3 id="既然-brk-那么牛逼，为什么不全部使用-brk-来分配？"><a href="#既然-brk-那么牛逼，为什么不全部使用-brk-来分配？" class="headerlink" title="既然 brk 那么牛逼，为什么不全部使用 brk 来分配？"></a><strong>既然 brk 那么牛逼，为什么不全部使用 brk 来分配？</strong></h3><blockquote><p>随着系统频繁地 malloc 和 free ，堆内将产生越来越多不可用的碎片</p></blockquote><hr><h3 id="free-函数只传入一个内存地址，为什么能知道要释放多大的内存？"><a href="#free-函数只传入一个内存地址，为什么能知道要释放多大的内存？" class="headerlink" title="free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？"></a><strong>free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？</strong></h3><blockquote><p>malloc 返回给用户态的内存起始地址比实际申请的地址会多16字节，这16个字节会存储内存块的头信息。</p><p>当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小</p></blockquote><h2 id="3-3-内存满了，会发生什么？"><a href="#3-3-内存满了，会发生什么？" class="headerlink" title="3.3 内存满了，会发生什么？"></a>3.3 内存满了，会发生什么？</h2><p><strong>虚拟内存作用</strong></p><ul><li>第一，虚拟内存可以使得进程对运行内存超过物理内存大小</li><li>第二，由于每个进程都有自己虚拟内存空间，这就解决了多进程之间地址冲突的问题。</li><li>第三，页表里的页表项还有一些读写权限、页是否存在等标记属性的比特，使得操作系统提供了更好的安全性。</li></ul><p><strong>申请物理内存的过程</strong></p><p>内核在给应用程序分配物理内存的时候，如果空闲物理内存不够，那么就会进行内存回收的工作，主要有两种方式：</p><ul><li>后台内存回收：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程异步的，不会阻塞进程的执行。</li><li>直接内存回收：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，会阻塞进程的执行。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/2f61b0822b3c4a359f99770231981b07.png" alt="img" style="zoom: 50%;" /><hr><h3 id="哪些内存可以被回收？"><a href="#哪些内存可以被回收？" class="headerlink" title="哪些内存可以被回收？"></a>哪些内存可以被回收？</h3><blockquote><p>主要有两类内存可以被回收：</p><ul><li><strong>文件页</strong>：内核缓存的磁盘数据和文件数据都叫作文件页。<strong>回收干净文件页的方式是直接释放内存，回收脏文件页的方式是先写回磁盘后再释放内存</strong>。</li><li><strong>匿名页</strong>：这部分内存没有实际载体，比如堆、栈数据等。<strong>通过 Linux 的 Swap 机制进行回收</strong>，把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存。</li></ul></blockquote><p>文件页和匿名页的回收都是基于 <strong>LRU 算法</strong>，也就是优先回收不常访问的内存，其维护 两个双向链表：</p><ul><li><strong>active_list</strong> 活跃内存页链表，存放最近被访问过（活跃）的内存页；</li><li><strong>inactive_list</strong> 不活跃内存页链表，存放很少被访问（非活跃）的内存页；</li></ul><hr><h3 id="回收内存带来的性能影响"><a href="#回收内存带来的性能影响" class="headerlink" title="回收内存带来的性能影响"></a>回收内存带来的性能影响</h3><blockquote><p>回收内存的操作基本都会发生磁盘 I&#x2F;O 的，如果回收内存的操作很频繁，意味着磁盘 I&#x2F;O 次数会很多，这个过程势必会影响系统的性能，整个系统给人的感觉就是很卡。</p></blockquote><hr><h3 id="调整文件页和匿名页的回收倾向"><a href="#调整文件页和匿名页的回收倾向" class="headerlink" title="调整文件页和匿名页的回收倾向"></a>调整文件页和匿名页的回收倾向</h3><p>Linux 提供了一个 <code>/proc/sys/vm/swappiness</code> 选项，用来调整文件页和匿名页的回收倾向</p><ul><li>数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；</li><li>数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</li></ul><hr><h3 id="如何保护一个进程不被-OOM-杀掉呢"><a href="#如何保护一个进程不被-OOM-杀掉呢" class="headerlink" title="如何保护一个进程不被 OOM 杀掉呢"></a>如何保护一个进程不被 OOM 杀掉呢</h3><blockquote><p> Linux 内核里有一个 <code>oom_badness()</code> 函数，它会把系统中可以被杀掉的进程扫描一遍，并对每个进程打分，得分最高的进程就会被首先杀掉。进程得分的结果受下面这两个方面影响：</p><ul><li>第一，进程已经使用的物理内存页面数。</li><li>第二，每个进程的 OOM 校准值 oom_score_adj。</li></ul><p>因此可以调整该进程的 oom_score_adj，降低该进程被 OOM 杀死的概率。</p><p>如果想某个进程无论如何都不能被杀掉，那你可以将 oom_score_adj 配置为 -1000。</p></blockquote><h2 id="3-4-在-4GB-物理内存的机器上，申请-8G-内存会怎么样？"><a href="#3-4-在-4GB-物理内存的机器上，申请-8G-内存会怎么样？" class="headerlink" title="3.4 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？"></a>3.4 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？</h2><p>在不同位数操作系统上：</p><ul><li><strong>32 位操作系统</strong>：因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。</li><li><strong>64 位操作系统</strong>：因为进程最大只能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：<ul><li>如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；</li><li>如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；</li></ul></li></ul><p>程序申请的虚拟内存，如果没有被使用，它是不会占用物理空间的，但保存虚拟内存等结果需要占用物理内存。物理内存不足可通过开启swap来缓解。</p><blockquote><p><strong>Swap 机制</strong></p><p>当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中。</p></blockquote><h2 id="3-5-如何避免预读失效和缓存污染的问题？"><a href="#3-5-如何避免预读失效和缓存污染的问题？" class="headerlink" title="3.5 如何避免预读失效和缓存污染的问题？"></a>3.5 如何避免预读失效和缓存污染的问题？</h2><p>传统的 LRU 算法存在这两个问题：</p><ul><li><strong>「预读失效」导致缓存命中率下降</strong>：预读数据没有用到导致缓存命中率低</li><li><strong>「缓存污染」导致缓存命中率下降</strong>：批量读数据时可能会把热点数据挤出缓存从而导致命中率低</li></ul><hr><h3 id="如何避免预读失效造成的影响？"><a href="#如何避免预读失效造成的影响？" class="headerlink" title="如何避免预读失效造成的影响？"></a>如何避免预读失效造成的影响？</h3><blockquote><p>要避免预读失效带来影响，最好就是<strong>让预读页停留在内存里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在内存里的时间尽可能长</strong>。</p><p><strong>解决办法</strong>：设置两个区域，真正读取页插入活跃区域，预读页插入非活跃区域，只有当预读页真正被读取时才将其插入活跃区域。。</p><ul><li>例如Linux中，实现了active list 和 inactive list两个LRU链表，真正读取页插入active list表头，预读页插入inactive list表头，只有预读页真正被访问后才会将其移动到active list表头。</li></ul></blockquote><hr><h3 id="怎么避免缓存污染造成的影响？"><a href="#怎么避免缓存污染造成的影响？" class="headerlink" title="怎么避免缓存污染造成的影响？"></a>怎么避免缓存污染造成的影响？</h3><blockquote><p><strong>提高进入到活跃 LRU 链表（或者 young 区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young 区域）里的热点数据不会被轻易替换掉</strong>。</p><ul><li><strong>Linux 操作系统</strong>：在内存页被访问<strong>第二次</strong>的时候，才将页从 inactive list 升级到 active list 里。</li><li><strong>MySQL Innodb</strong>：在内存页被访问<strong>第二次</strong>的时候，并不会马上将该页从 old 区域升级到 young 区域，还需要判断与第一次访问时间间隔是否超过1秒，如超过则提升。</li></ul></blockquote><h2 id="3-6-深入理解-Linux-虚拟内存管理"><a href="#3-6-深入理解-Linux-虚拟内存管理" class="headerlink" title="3.6 深入理解 Linux 虚拟内存管理"></a>3.6 深入理解 Linux 虚拟内存管理</h2><h3 id="虚拟内存格式"><a href="#虚拟内存格式" class="headerlink" title="虚拟内存格式"></a>虚拟内存格式</h3><p><strong>64 位虚拟地址</strong>的格式为：全局页目录项（9位）+ 上层页目录项（9位）+ 中间页目录项（9位）+ 页表项（9位）+ 页内偏移（12位）。共 48 位组成的虚拟内存地址。<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230825201752362.png" alt="image-20230825201752362"></p><p><strong>32 位虚拟地址</strong>的格式为：页目录项（10位）+ 页表项（10位） + 页内偏移（12位）。共 32 位组成的虚拟内存地址。<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230825201816768.png" alt="image-20230825201816768"></p><hr><h3 id="为什么要使用虚拟地址访问内存"><a href="#为什么要使用虚拟地址访问内存" class="headerlink" title="为什么要使用虚拟地址访问内存"></a>为什么要使用虚拟地址访问内存</h3><ol><li>如果直接使用物理内存，程序员就需要知道每一个变量在内存中的具体位置，手动对物理内存进行布局，还需要考虑为每个进程究竟要分配多少内存？内存紧张的时候该怎么办？如何避免进程与进程之间的地址冲突（例如多进程执行同一个函数，变量地址就会一样，造成错误）</li><li>虚拟内存引入之后，每个进程都拥有自己独立的虚拟地址空间，进程与进程之间的虚拟内存地址空间是相互隔离，互不干扰的</li></ol><hr><h3 id="进程虚拟内存空间"><a href="#进程虚拟内存空间" class="headerlink" title="进程虚拟内存空间"></a>进程虚拟内存空间</h3><p>内核根据进程运行的过程中所需要不同种类的数据而为其开辟了对应的地址空间。分别为：</p><ul><li>用于存放进程程序二进制文件中的机器指令的<strong>代码段</strong></li><li>用于存放程序二进制文件中定义的全局变量和静态变量的<strong>数据段和 BSS 段</strong>。<ul><li>代码中全局变量或静态变量设置了初值的放在数据段；未设置初值的放在BSS段，BSS段会被初始化为0，因此会直接加载一段值为0的内存</li></ul></li><li>用于在程序运行过程中动态申请内存的<strong>堆</strong>。</li><li>用于存放动态链接库以及内存映射区域的<strong>文件映射与匿名映射区</strong>。</li><li>用于存放函数调用过程中的局部变量和函数参数的<strong>栈</strong>。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230825202435264.png" alt="image-20230825202435264" style="zoom: 33%;" /><hr><h3 id="Linux-进程虚拟内存空间"><a href="#Linux-进程虚拟内存空间" class="headerlink" title="Linux 进程虚拟内存空间"></a>Linux 进程虚拟内存空间</h3><p><strong>32 位机器上进程虚拟内存空间分布</strong></p><ul><li>用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000；内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF</li><li><strong>保留区</strong>：在代码段前是一段不可访问的保留区，因为在大多数操作系统中，数值比较小的地址通是不允许访问的。比如在 C 语言中将一些无效的指针设置为 NULL。</li><li><strong>代码段和数据段</strong>：从程序的二进制文件中直接加载进内存中的，因为BSS段数据是没有初值的，所以在二进制文件中只会记录 BSS 段的大小，在加载进内存时会生成一段 0 填充的内存空间。</li><li><strong>堆</strong>： start_brk 标识堆的起始位置，brk 标识堆当前的结束位置。当堆申请新的内存空间时，只需要将 brk 指针增加对应的大小，回收地址时减少对应的大小即可。（碎片如何处理？）</li><li><strong>文件映射与匿名映射区域</strong>：进程运行时所依赖的动态链接库中的代码段，数据段，BSS 段就加载在这里。还有我们调用 mmap 映射出来的一段虚拟内存空间也保存在这个区域。注意地址增长方向是从高地址向低地址增长。</li><li><strong>栈</strong>：保存函数运行过程所需要的局部变量以及函数参数等函数调用信息。地址增长方向是从高地址向低地址增长。在内核中使用 start_stack 标识栈的起始位置，RSP 寄存器中保存栈顶指针 stack pointer，RBP 寄存器中保存的是栈基地址。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230825203513675.png" alt="image-20230825203513675" style="zoom:33%;" /><p><strong>64 位机器上进程虚拟内存空间分布</strong></p><ul><li>目前的 64 位系统下只使用了 48 位来描述虚拟内存空间，所能表达的虚拟内存空间为 256TB。</li><li>低 128 T 表示用户态虚拟内存空间，虚拟内存地址范围为：0x0000 0000 0000 0000 - 0x0000 7FFF FFFF F000，注意其前16位皆为0。</li><li>高 128 T 表示内核态虚拟内存空间，虚拟内存地址范围为：0xFFFF 8000 0000 0000 - 0xFFFF FFFF FFFF FFFF ，注意其前16位皆为1。</li><li>这个高 16 位的空闲地址被称为 canonical 。如果虚拟内存地址中的高 16 位全部为 0 （表示用户空间虚拟内存地址）或者全部为 1 （表示内核空间虚拟内存地址）。不全为 0 也不全为 1 则为空洞地址，非法。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230825204033081.png" alt="image-20230825204033081" style="zoom:33%;" /><blockquote><p><strong>64位地址空间与32位地址空间主要不同</strong>：</p><ul><li>64位空间存在canonical address 空洞，用户态虚拟内存空间与内核态虚拟内存空间分别占用 128T</li><li>64位空间在代码段跟数据段的中间还有一段不可以读写的保护段，它的作用是防止程序在读写数据段的时候越界访问到代码段，这个保护段可以让越界访问行为直接崩溃</li></ul></blockquote><hr><h3 id="进程虚拟内存空间的管理"><a href="#进程虚拟内存空间的管理" class="headerlink" title="进程虚拟内存空间的管理"></a>进程虚拟内存空间的管理</h3><p>在进程描述符 task_struct 结构中，有一个专门描述进程虚拟地址空间的内存描述符 <strong>mm_struct 结构</strong>，这个结构体中包含了进程虚拟内存空间的全部信息。</p><ul><li>通过 fork() 函数创建出的子进程，它的虚拟内存空间以及相关页表相当于父进程虚拟内存空间的一份拷贝，直接从父进程中拷贝到子进程中。</li><li>通过 vfork 或者 clone 系统调用创建出的子进程，会将父进程的虚拟内存空间以及相关页表直接赋值给子进程。这样一来父进程和子进程的虚拟内存空间就变成共享的了<ul><li>子进程共享了父进程的虚拟内存空间，这样子进程就变成了我们熟悉的线程，<strong>是否共享地址空间几乎是进程和线程之间的本质区别。Linux 内核并不区别对待它们，线程对于内核来说仅仅是一个共享特定资源的进程而已</strong>。</li></ul></li><li>内核态线程和用户态线程的区别就是内核线程没有相关的内存描述符 mm_struct ，内核线程对应的 task_struct 结构中的 mm 域指向 Null，所以内核线程之间调度是不涉及地址空间切换的。<ul><li>当一个内核线程被调度时，内核会将上一个用户态进程的mm_struct 直接赋值给该内核线程。因为内核线程仅仅只会访问内核空间的内存，所以直接复用上一个用户态进程的虚拟地址空间就可以避免为内核线程分配 mm_struct 和相关页表的开销，以及避免内核线程之间调度时地址空间的切换开销。</li></ul></li></ul><p><strong>内核如何划分用户态和内核态虚拟内存空间</strong></p><p>太多了，待看</p><hr><h3 id="程序编译后的二进制文件如何映射到虚拟内存空间中"><a href="#程序编译后的二进制文件如何映射到虚拟内存空间中" class="headerlink" title="程序编译后的二进制文件如何映射到虚拟内存空间中"></a>程序编译后的二进制文件如何映射到虚拟内存空间中</h3><blockquote><p>程序代码编译之后会生成一个 ELF 格式的二进制文件，这个二进制文件中包含了程序运行时所需要的元信息，比如程序的机器码，程序中的全局变量以及静态变量等。</p><p>磁盘文件中的段我们叫做 Section，内存中的段我们叫做 Segment，也就是内存区域。</p></blockquote><p>磁盘文件中的这些 Section 会在进程运行之前加载到内存中并映射到内存中的 Segment。通常是多个 Section 映射到一个 Segment。</p><ul><li>如磁盘文件中的 .text，.rodata 等一些只读的 Section，会被映射到内存的一个只读可执行的 Segment 里（代码段）</li><li>而 .data，.bss 等一些可读写的 Section，则会被映射到内存的一个具有读写权限的 Segment 里（数据段，BSS 段）</li></ul><p>内核中完成这个映射过程的函数是 load_elf_binary </p><hr><h3 id="内核虚拟内存空间"><a href="#内核虚拟内存空间" class="headerlink" title="内核虚拟内存空间"></a>内核虚拟内存空间</h3><p>内核态虚拟内存空间是所有进程共享的，不同进程进入内核态之后看到的虚拟内存空间全部是一样的。</p><ul><li>不同进程在各自的用户态虚拟内存空间中访问虚拟地址 x，看到的内容是不一样的</li><li>由于内核虚拟内存空间是各个进程共享的，所以它们在内核空间中看到的内容全部是一样的</li></ul><blockquote><p><strong>程进入内核态之后使用的仍然是虚拟内存地址，只不过在内核中使用的虚拟内存地址被限制在了内核态虚拟内存空间范围中，而不是直接使用物理地址</strong></p></blockquote><h4 id="32-位体系内核虚拟内存空间布局"><a href="#32-位体系内核虚拟内存空间布局" class="headerlink" title="32 位体系内核虚拟内存空间布局"></a><strong>32 位体系内核虚拟内存空间布局</strong></h4><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230826201505737.png" alt="image-20230826201505737" style="zoom:80%;" /><p><strong>直接映射区</strong>：在 1G 的内核虚拟内存空间中，位于最前边有一块 896M 大小的区域，称之为直接映射区或者线性映射区，地址范围为 3G – 3G + 896m 。这块连续的虚拟内存地址会映射到 0 - 896M 这块连续的物理内存上，因此虚拟内存地址直接减去 0xC000 0000 (3G) 就得到了物理内存地址。</p><ul><li>虽然这块区域中的虚拟地址是直接映射到物理地址上，但是内核在访问这段区域的时候还是走的虚拟内存地址，内核也会为这块空间建立映射页表。</li><li>在这段 896M 大小的物理内存中，前 1M 已经在系统启动的时候被系统占用，1M 之后的物理内存存放的是内核代码段，数据段，BSS 段</li><li><em><strong>ZONE_DMA</strong></em>：直接映射区的前 16M 专门让内核用来为 DMA 分配内存。用于 DMA 的内存必须从 ZONE_DMA 区域中分配。</li><li><em><strong>ZONE_NORMAL</strong></em>：直接映射区中剩下的部分也就是从 16M 到 896M（不包含 896M）这段区域</li></ul><blockquote><p><strong>ZONE_HIGHMEM 高端内存</strong>：物理内存 896M 以上的区域被内核划分为 ZONE_HIGHMEM 区域</p><ul><li>只能动态的一部分一部分的分批映射，先映射正在使用的这部分，使用完毕解除映射，接着映射其他部分</li></ul></blockquote><p><strong>vmalloc 动态映射区</strong>：采用动态映射的方式映射物理内存中的高端内存。</p><ul><li>在这块动态映射区内核是使用 vmalloc 进行内存分配，vmalloc 分配的内存在虚拟内存上是连续的，但是物理内存是不连续的。通过页表来建立物理内存与虚拟内存之间的映射关系。</li></ul><p><strong>永久映射区</strong>：在内核的这段虚拟地址空间中允许建立与物理高端内存的长期映射关系。</p><ul><li>比如内核通过 alloc_pages() 函数在物理内存的高端内存中申请获取到的物理内存页，这些物理内存页可以通过调用 kmap 映射到永久映射区中。</li></ul><p><strong>固定映射区</strong>：在固定映射区中的虚拟内存地址可以自由映射到物理内存的高端地址上</p><ul><li>与动态映射区以及永久映射区不同的是，在固定映射区中虚拟地址是固定的，而被映射的物理地址是可以改变的。</li><li>采用固定虚拟地址的好处是它相当于一个指针常量（常量的值在编译时确定），指向物理地址，如果虚拟地址不固定，则相当于一个指针变量。</li></ul><p><strong>临时映射区</strong>：用于临时映射</p><ul><li>例如将文件从用户态拷贝到缓冲区，需要先将缓存页映射到临时映射区，然后进行拷贝。</li></ul><p><strong>32位体系结构下 Linux 虚拟内存空间整体布局</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230826202514504.png" alt="image-20230826202514504" style="zoom:50%;" /><h4 id="64-位体系内核虚拟内存空间布局"><a href="#64-位体系内核虚拟内存空间布局" class="headerlink" title="64 位体系内核虚拟内存空间布局"></a>64 位体系内核虚拟内存空间布局</h4><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230826202728014.png" alt="image-20230826202728014"></p><h2 id="3-7-深入理解-Linux-物理内存管理"><a href="#3-7-深入理解-Linux-物理内存管理" class="headerlink" title="3.7 深入理解 Linux 物理内存管理"></a>3.7 深入理解 Linux 物理内存管理</h2><h1 id="四、进程管理"><a href="#四、进程管理" class="headerlink" title="四、进程管理"></a>四、进程管理</h1><hr><h2 id="4-1-进程、线程基础知识"><a href="#4-1-进程、线程基础知识" class="headerlink" title="4.1 进程、线程基础知识"></a>4.1 进程、线程基础知识</h2><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul><li><p>运行状态（<em>Running</em>）：该时刻进程占用 CPU；</p></li><li><p>就绪状态（<em>Ready</em>）：可运行，由于其他进程处于运行状态而暂时停止运行；</p></li><li><p>阻塞状态（<em>Blocked</em>）：该进程正在等待某一事件发生（如等待输入&#x2F;输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；</p></li><li><p>创建状态（<em>new</em>）：进程正在被创建时的状态；</p></li><li><p>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态；</p></li></ul><blockquote><p>挂起状态：</p><ul><li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li><li>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；</li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230320170008285.png" style="zoom:67%;" /><hr><h3 id="进程的控制结构"><a href="#进程的控制结构" class="headerlink" title="进程的控制结构"></a>进程的控制结构</h3><p>在操作系统中，是用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程。<strong>PCB 是进程存在的唯一标识</strong></p><p><strong>PCB 具体包含信息</strong>：</p><ul><li><p><strong>进程描述信息：</strong></p><ul><li><p>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</p></li><li><p>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</p></li></ul></li><li><p><strong>进程控制和管理信息：</strong></p><ul><li><p>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</p></li><li><p>进程优先级：进程抢占 CPU 时的优先级；</p></li></ul></li><li><p><strong>资源分配清单：</strong></p><ul><li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I&#x2F;O 设备信息。</li></ul></li><li><p><strong>CPU 相关信息：</strong></p><ul><li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</li></ul></li></ul><p>PCB通过<strong>链表</strong>的方式进行组织，把具有<strong>相同状态的进程链在一起，组成各种队列</strong>，如就绪队列、阻塞队列。</p><hr><h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><p><strong>创建进程的过程</strong>：</p><ul><li>申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息，比如进程的唯一标识等；</li><li>为该进程分配运行时所必需的资源，比如内存资源；</li><li>将 PCB 插入到就绪队列，等待被调度运行；</li></ul><p><strong>进程可以有 3 种终止方式：正常结束、异常结束以及外界干预</strong>，终止进程的过程如下：</p><ul><li>查找需要终止的进程的 PCB；</li><li>如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；</li><li>如果其还有子进程，则应将该进程的子进程交给 1 号进程接管；</li><li>将该进程所拥有的全部资源都归还给操作系统；</li><li>将其从 PCB 所在队列中删除；</li></ul><p><strong>阻塞进程的过程</strong>：</p><ul><li>找到将要被阻塞进程标识号对应的 PCB；</li><li>如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；</li><li>将该 PCB 插入到阻塞队列中去；</li></ul><p><strong>唤醒进程的过程</strong>：</p><ul><li>在该事件的阻塞队列中找到相应进程的 PCB；</li><li>将其从阻塞队列中移出，并置其状态为就绪状态；</li><li>把该 PCB 插入到就绪队列中，等待调度程序调度；</li></ul><hr><h3 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h3><p><strong>CPU 上下文切换</strong>就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>CPU 上下文切换可分成：<strong>进程上下文切换、线程上下文切换和中断上下文切换</strong>。</p><p><strong>进程的上下文切换</strong>包含虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p><hr><h3 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h3><ul><li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；</li><li>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；</li></ul><hr><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主要有三种线程的实现方式：</p><ul><li><strong>用户线程</strong>：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；<ul><li>优点：可用于不支持线程技术的操作系统；线程切换无需用户态与内核态切换，所以速度特别快；</li><li>缺点：如果一个线程阻塞，那进程所包含的用户线程都阻塞；一个线程运行，同进程中的其他线程都不能运行；内核是按进程进行时间片分配，可能会导致执行慢。</li></ul></li><li><strong>内核线程</strong>：在内核中实现的线程，是由内核管理的线程；<ul><li>优点：不存在阻塞同进程其他线程问题；多线程的进程获得更多的 CPU 运行时间；</li><li>缺点：需要内核来维护线程的上下文信息；会切换到内核态，系统开销较大。</li></ul></li><li><strong>轻量级进程</strong>：在内核中来支持用户线程；<ul><li>轻量级进程与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息。</li></ul></li></ul><hr><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li><p><strong>先来先服务调度算法</strong>：非抢占式，对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p></li><li><p><strong>最短作业优先调度算法</strong>：优先选择运行时间最短的进程来运行；对长作业不利。</p></li><li><p><strong>高响应比优先</strong>：计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行。由于要求服务时间未知，所以是一种理想型算法。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230320204258422.png" style="zoom:50%;" /></li><li><p><strong>时间片轮转调度算法</strong>：每个进程被分配一个时间片，该进程在该时间段中运行。</p></li><li><p><strong>最高优先级调度算法</strong>：从就绪队列中选择最高优先级的进程运行。优先级可分为静态优先级和动态优先级，算法还可分为抢占式和非抢占式。</p></li><li><p><strong>多级反馈队列调度算法</strong>：是「时间片轮转算法」和「最高优先级算法」的综合和发展；</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短；</li><li>新的进程会被放入到第一级队列的末尾，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li></ul></li></ul><h2 id="4-2-进程间有哪些通信方式？"><a href="#4-2-进程间有哪些通信方式？" class="headerlink" title="4.2 进程间有哪些通信方式？"></a>4.2 进程间有哪些通信方式？</h2><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以<strong>进程之间要通信必须通过内核</strong>。</p><hr><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p><strong>管道传输数据是单向的</strong>，如果想相互通信，需要创建两个管道。</p><p><strong>匿名管道</strong>：没有名字标识，其是特殊文件只存在于内存，没有存在于文件系统中</p><ul><li><strong>通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</li></ul><p><strong>命名管道</strong>：也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p><ul><li><strong>可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</li></ul><p><strong>管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。管道传输的数据是无格式的流且大小受限。</p><p><strong>管道通信效率低，不适合进程间频繁地交换数据</strong>。</p><blockquote><p><strong>管道创建函数生成的两个描述符都在一个进程中，怎么起到进程间通信的作用？</strong></p><p>使用 fork 创建子进程，创建的子进程会复制父进程的文件描述符</p></blockquote><blockquote><p><strong>shell中使用管道</strong></p><p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p><p>所以在shell中要尽量少使用管道</p></blockquote><hr><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><strong>消息队列</strong>消息队列是保存在内核中的消息链表</p><ul><li>在发送数据时，会分成一个一个消息体，消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型</li><li>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在</li><li>缺点：<ul><li>通信不及时</li><li>消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限</li><li>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</li></ul></li></ul><hr><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p><strong>共享内存</strong>：是拿出一块虚拟地址空间来，映射到相同的物理内存中。因此无需多次拷贝，大大提高了进程间通信的速度。</p><ul><li>是最快的进程间通信方式，但多进程竞争同个共享资源会造成数据的错乱，需要使用信号量来控制。</li></ul><hr><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><strong>信号量</strong>是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li><strong>P 操作</strong>，信号量减去 1，相减后如果信号量 &lt; 0，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li><li><strong>V 操作</strong>，把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将阻塞进程唤醒；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p><strong>P V操作是必须成对出现的</strong></p><hr><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>以上进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，当有信号产生，有以下几种处理方式：</p><ul><li><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如 SIGTERM 信号就是终止进程。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p></li></ul><hr><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>若想<strong>跨网络与不同主机上的进程之间通信</strong>，就需要 Socket 通信，也可同主机上进程间通信。</p><p>根据创建 socket 类型的不同，可分为以下几种通信方式：</p><ul><li><strong>TCP 字节流通信</strong>： socket 类型是 AF_INET 和 SOCK_STREAM；</li><li><strong>UDP 数据报通信</strong>：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li><strong>本地进程间通信</strong>： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的。<ul><li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li><li>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</li></ul></li></ul><h2 id="4-3-多线程冲突了怎么办？"><a href="#4-3-多线程冲突了怎么办？" class="headerlink" title="4.3 多线程冲突了怎么办？"></a>4.3 多线程冲突了怎么办？</h2><p>由于多线程执行操作共享变量的这段代码可能会导致竞争状态，此段代码称为<strong>临界区</strong></p><p><strong>同步：</strong>就是并发进程&#x2F;线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程&#x2F;线程同步。</p><p>实现进程协作方法主要有两种：</p><ul><li><em>锁</em>：加锁、解锁操作；<ul><li><strong>自旋锁</strong>：获取不到锁时，线程就会一直 while 循环，不做任何事情<ul><li>通过 CPU 提供的 <code>CAS</code> 函数实现，在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换</li></ul></li><li><strong>无等待锁</strong>：当没获取到锁的时候，就把当前线程放入到锁的等待队列，然后执行调度程序</li></ul></li><li><em>信号量</em>：P、V 操作，其是原子操作；<ul><li>信号量不仅可以实现临界区的互斥访问控制，还可以线程间的事件同步。</li></ul></li></ul><h2 id="4-4-怎么避免死锁？"><a href="#4-4-怎么避免死锁？" class="headerlink" title="4.4 怎么避免死锁？"></a>4.4 怎么避免死锁？</h2><p>两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直相互等待，这就是<strong>死锁</strong>。</p><p><strong>死锁发生的必要条件</strong>：</p><ul><li>互斥条件：指多个线程不能同时使用同一个资源。</li><li>持有并等待条件：线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</li><li>不可剥夺条件：线程持有资源不能被其他线程剥夺获取</li><li>循环等待条件：两个线程获取资源的顺序构成了环形</li></ul><p>避免死锁问题就只需要破环其中一个条件，最常见的并且可行的就是<strong>使用资源有序分配法</strong></p><ul><li>即资源申请顺序一样，例如只能先申请A再申请B</li></ul><hr><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p><strong>思想</strong>：只要线程申请资源不超过拥有值，则尽可能满足其申请</p><ul><li>每一个新进程进入系统时，必须声明需要每种资源的最大数目，其数目不能超过系统所拥有的的资源总量。</li><li>当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程，若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态如果不会才将资源分配给它，否则让进程等待。</li></ul><h2 id="4-5-什么是悲观锁、乐观锁？"><a href="#4-5-什么是悲观锁、乐观锁？" class="headerlink" title="4.5 什么是悲观锁、乐观锁？"></a>4.5 什么是悲观锁、乐观锁？</h2><h3 id="互斥锁与自旋锁"><a href="#互斥锁与自旋锁" class="headerlink" title="互斥锁与自旋锁"></a><strong>互斥锁与自旋锁</strong></h3><ul><li>这两种锁是最底层的锁，其他高级锁都是基于此两种锁实现</li><li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li><li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li><li><strong>如果被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></li></ul><hr><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁，由「读锁」和「写锁」两部分构成，<strong>读写锁适用于能明确区分读操作和写操作的场景</strong>，工作原理：</p><ul><li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁</li><li>一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li></ul><p><strong>写锁是独占锁，而读锁是共享锁</strong></p><p>读写锁可以分为：</p><ul><li>「读优先锁」：当读锁被持有时，获取写锁的线程会被阻塞，且后续来的读线程仍然能获取读锁。知道所有读锁被释放，才能获取写锁成功。</li><li>「写优先锁」：当获取写锁时，持有读锁的线程会被阻塞，此时获取读锁的线程也会被阻塞</li></ul><p><strong>公平读写锁</strong>：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</p><hr><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p><strong>悲观锁</strong>：认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。</p><ul><li>互斥锁、自旋锁、读写锁，都是属于悲观锁。</li></ul><p><strong>乐观锁</strong>：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p><ul><li>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></li></ul><blockquote><p><strong>CAS 不是乐观锁吗，为什么基于 CAS 实现的自旋锁是悲观锁？</strong></p><p>CAS 是乐观锁没错，但是 CAS 和自旋锁不同之处，自旋锁基于 CAS 加了while 或者睡眠 CPU 的操作而产生自旋的效果，加锁失败会忙等待直到拿到锁，自旋锁是要需要事先拿到锁才能修改数据的，所以算悲观锁。</p></blockquote><h2 id="4-6-一个进程最多可以创建多少个线程？"><a href="#4-6-一个进程最多可以创建多少个线程？" class="headerlink" title="4.6 一个进程最多可以创建多少个线程？"></a>4.6 一个进程最多可以创建多少个线程？</h2><blockquote><ul><li>32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。</li><li>64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。</li></ul></blockquote><p>创建进程个数受两个方面影响：</p><ul><li><strong>进程的虚拟内存空间上限</strong>，因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多。</li><li><strong>系统参数限制</strong>，虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数。<ul><li><em><strong>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;threads-max</strong></em>，表示系统支持的最大线程数，默认值是 <code>14553</code>；</li><li><em><strong>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max</strong></em>，表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败，默认值是 <code>32768</code>；</li><li><em><strong>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;max_map_count</strong></em>，表示限制一个进程可以拥有的VMA(虚拟内存区域)的数量，具体什么意思我也没搞清楚，反正如果它的值很小，也会导致创建线程失败，默认值是 <code>65530</code>。</li></ul></li></ul><h2 id="4-7-线程崩溃了，进程也会崩溃吗"><a href="#4-7-线程崩溃了，进程也会崩溃吗" class="headerlink" title="4.7 线程崩溃了，进程也会崩溃吗"></a>4.7 线程崩溃了，进程也会崩溃吗</h2><p>一般来说如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃。因为某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程。</p><blockquote><p><strong>进程是如何崩溃的</strong>？</p><ul><li>调用 kill 系统调用向进程发送信号</li><li>操作系统根据情况执行相应的信号处理程序（函数），一般执行完信号处理程序逻辑后会让进程退出</li></ul></blockquote><p>虽然给进程发送了 kill 信号，但如果进程自己定义了信号处理函数或者无视信号，那么可能会毫无影响。</p><p><strong>为什么线程崩溃不会导致 JVM 进程崩溃？</strong></p><p>因为 JVM 自定义了自己的信号处理函数，拦截了 SIGSEGV 信号，针对这两者不让它们崩溃。</p><h1 id="五、调度算法"><a href="#五、调度算法" class="headerlink" title="五、调度算法"></a>五、调度算法</h1><h2 id="5-1-进程调度算法"><a href="#5-1-进程调度算法" class="headerlink" title="5.1 进程调度算法"></a>5.1 进程调度算法</h2><ul><li><p><strong>先来先服务调度算法</strong>：非抢占式，对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p></li><li><p><strong>最短作业优先调度算法</strong>：优先选择运行时间最短的进程来运行；对长作业不利。</p></li><li><p><strong>高响应比优先</strong>：计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行。由于要求服务时间未知，所以是一种理想型算法。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230320204258422.png" style="zoom:50%;" /></li><li><p><strong>时间片轮转调度算法</strong>：每个进程被分配一个时间片，该进程在该时间段中运行。</p></li><li><p><strong>最高优先级调度算法</strong>：从就绪队列中选择最高优先级的进程运行。优先级可分为静态优先级和动态优先级，算法还可分为抢占式和非抢占式。</p></li><li><p><strong>多级反馈队列调度算法</strong>：是「时间片轮转算法」和「最高优先级算法」的综合和发展；</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短；</li><li>新的进程会被放入到第一级队列的末尾，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li></ul></li></ul><h2 id="5-2-页面置换算法"><a href="#5-2-页面置换算法" class="headerlink" title="5.2 页面置换算法"></a>5.2 页面置换算法</h2><p>当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它<strong>与一般中断的主要区别</strong>在于：</p><ul><li>缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</li><li>缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。</li></ul><p>页表项通常有如下字段：</p><ul><li><em>状态位</em>：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问时参考。</li><li><em>访问字段</em>：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考。</li><li><em>修改位</em>：表示该页在调入内存后是否有被修改过</li><li><em>硬盘地址</em>：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321160617503.png"></p><p>常见的页面置换算法有如下几种：</p><ul><li><strong>最佳页面置换算法（<em>OPT</em>）</strong>：基本思路是置换在「未来」最长时间不访问的页面。<ul><li>实际系统中无法实现，因为程序访问页面时是动态的，无法预知每个页面在「下一次」访问前的等待时间。</li></ul></li><li><strong>先进先出置换算法（<em>FIFO</em>）</strong>：选择在内存驻留时间很长的页面进行中置换。</li><li><strong>最近最久未使用的置换算法（<em>LRU</em>）</strong>：发生缺页时，选择最长时间没有被访问的页面进行置换。<ul><li>该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用，近似最优置换算法。</li><li>代价很高。需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。且每次内存访问都需要更新链表，非常耗时。</li></ul></li><li><strong>时钟页面置换算法（<em>Lock</em>）</strong>：把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。当发生缺页中断时，算法首先检查表针指向的页面：<ul><li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li><li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li></ul></li><li><strong>最不常用置换算法（<em>LFU</em>）</strong>：当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰。<ul><li>缺点：查找哪个页面访问次数最小是非常耗时的，效率不高。且没有考虑访问时间。</li></ul></li></ul><h2 id="5-3-磁盘调度算法"><a href="#5-3-磁盘调度算法" class="headerlink" title="5.3 磁盘调度算法"></a>5.3 磁盘调度算法</h2><p>常见的磁盘调度算法有：</p><ul><li><strong>先来先服务算法</strong>：先到来的请求，先被服务。<ul><li>如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法在性能上就会显得很差，因为寻道时间过长。</li></ul></li><li><strong>最短寻道时间优先算法</strong>：优先选择从当前磁头位置所需寻道时间最短的请求<ul><li>可能产生了饥饿现象，因为磁头在一小块区域来回移动。</li></ul></li><li><strong>扫描算法</strong>：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，也叫做<strong>电梯算法</strong>；<ul><li>不会产生饥饿现象，但中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异</li></ul></li><li><strong>循环扫描算法</strong>：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头<ul><li>该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong>。</li></ul></li><li><strong>LOOK <strong>：针对扫描算法的优化。磁头在移动到「最远的请求」位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，</strong>反向移动的途中会响应请求</strong>。</li><li><strong>C-LOOK</strong> ：针对循环扫描算法的优化。磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong>。</li></ul><h1 id="六、文件系统"><a href="#六、文件系统" class="headerlink" title="六、文件系统"></a>六、文件系统</h1><h2 id="6-1-文件系统全家桶"><a href="#6-1-文件系统全家桶" class="headerlink" title="6.1 文件系统全家桶"></a>6.1 文件系统全家桶</h2><p>文件系统是操作系统中负责管理持久数据的子系统，基本数据单位是文件。</p><p>Linux 文件系统会为每个文件分配两个数据结构：</p><ul><li><strong>索引节点</strong>：<em>inode</em>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、<em>数据在磁盘的位置</em>等等。索引节点是文件的<strong>唯一</strong>标识，也同样都会被存储在硬盘中，所以<strong>索引节点同样占用磁盘空间</strong>。<ul><li>索引节点和文件的关系是多对一，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul></li><li><strong>目录项</strong>：<em>dentry</em>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构。<ul><li>与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>。</li></ul></li></ul><p><strong>目录也是文件</strong>，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p><strong>目录项和目录是一个东西吗？</strong></p><p>不是。目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。</p><ul><li>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存</li></ul><p><strong>文件数据是如何存储在磁盘的呢？</strong></p><p>磁盘读写的最小单位是<strong>扇区</strong>，文件系统把多个扇区组成了一个<strong>逻辑块</strong>，每次读写的最小单位就是逻辑块。</p></blockquote><p>磁盘进行格式化的时候，会被分成三个存储区域：</p><ul><li><em>超级块</em>，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。<ul><li>当文件系统挂载时进入内存；</li></ul></li><li><em>索引节点区</em>，用来存储索引节点；<ul><li>当文件被访问时进入内存；</li></ul></li><li><em>数据块区</em>，用来存储文件或目录数据；</li></ul><p>操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「<strong>文件描述符</strong>」，所以说文件描述符是打开文件的标识。操作系统在打开文件表中维护着打开文件的状态和信息：</p><ul><li>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；</li><li>文件打开计数器：该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；</li><li>文件磁盘位置：该信息保存在内存中，以免每个操作都从磁盘中读取；</li><li>访问权限：权限信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I&#x2F;O 请求；</li></ul><hr><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>操作系统希望<strong>对用户提供一个统一的接口</strong>，于是在用户层与文件系统层引入了中间层，被称为<strong>虚拟文件系统（VFS）。</strong></p><p>文件系统可分为三类：</p><ul><li><em><strong>磁盘的文件系统</strong></em>，它是直接把数据存储在磁盘中，比如 Ext 2&#x2F;3&#x2F;4、XFS 等都是这类文件系统。</li><li><em><strong>内存的文件系统</strong></em>，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 <code>/proc</code> 和 <code>/sys</code> 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。</li><li><em><strong>网络的文件系统</strong></em>，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。</li></ul><p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p><p><strong>文件系统的基本操作单位是数据块</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321163639861.png" style="zoom:33%;" /><hr><h3 id="文件的存储"><a href="#文件的存储" class="headerlink" title="文件的存储"></a>文件的存储</h3><p>文件有以下两种存储方式：</p><ul><li><p><strong>连续空间存放方式</strong>：文件存放在磁盘「连续的」物理空间中。inode里需要指定「起始块的位置」和「长度」。</p><ul><li>优点：读写效率很高</li><li>缺点：磁盘空间碎片问题；文件长度不易扩展；</li></ul></li><li><p><strong>非连续空间存放方式</strong></p><ul><li><p><strong>链表</strong></p><ul><li><strong>隐式链表</strong>：inode中要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置。<ul><li>缺点：无法直接访问数据块；稳定性较差，如果其中一个指针丢失，会导致文件数据丢失。</li></ul></li><li><strong>显式链接</strong>：把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，该表在<strong>整个磁盘仅设置一张</strong>，每个表项中存放链接指针，指向下一个数据块号。如win曾经的FAT。它的<strong>主要的缺点是不适用于大磁盘</strong>。</li></ul></li><li><p><strong>索引</strong>：为每个文件创建一个「索引数据块」，里面存放的是指向文件数据块的指针列表。另外，inode需要包含指向「索引数据块」的指针。</p><ul><li>优点：文件的创建、增大、缩小很方便；不会有碎片的问题；支持顺序读写和随机读写；</li><li>缺点：<strong>索引数据存放在磁盘块</strong>，会带来存储索引的开销</li></ul><blockquote><p><strong>链式索引</strong>：链表 + 索引。在索引数据块留出一个存放下一个索引数据块的指针，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。</p><p><strong>多级索引</strong>：通过一个索引块来存放多个索引数据块，一层套一层索引</p></blockquote></li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321170248979.png" style="zoom:80%;" /><hr><h3 id="Unix-文件的实现方式"><a href="#Unix-文件的实现方式" class="headerlink" title="Unix 文件的实现方式"></a>Unix 文件的实现方式</h3><p>根据文件的大小，存放的方式会有所变化：</p><ul><li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；</li><li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；</li><li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；</li><li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；</li></ul><p>因此，文件头（<em>Inode</em>）就需要包含 13 个指针：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321170712531.png" style="zoom:50%;" /><hr><h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><p>查找空闲块需要高效，有以下几种方法：</p><ul><li><strong>空闲表法</strong>：为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数。注意，这个方式是连续分配的。<ul><li>当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。</li><li>当用户撤销一个文件时，也需顺序扫描寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。</li><li>仅当有少量的空闲区时才有较好的效果</li></ul></li><li><strong>空闲链表法</strong>：每一个数据空闲块里有一个指针指向下一个数据空闲块。<ul><li>其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I&#x2F;O 操作，同时数据块的指针消耗了一定的存储空间。</li></ul></li><li><strong>位图法</strong>：利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。<ul><li>Linux 文件系统就采用了位图的方式来管理空闲空间，还用于 inode 空闲块的管理</li></ul></li></ul><hr><h3 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h3><p>一个块存放的位图能表示的存储大小是有限的，如只能128M。因此，在linux中使用了一个结构体<strong>块组</strong>来表示，然后大量块组就可以表示超大的文件，块组内容如下：</p><ul><li><em><strong>超级块</strong></em>，包含文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等。</li><li><em><strong>块组描述符</strong></em>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</li><li><em><strong>数据位图和 inode 位图</strong></em>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。</li><li><em><strong>inode 列表</strong></em>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</li><li><em><strong>数据块</strong></em>，包含文件的有用数据。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321212613348.png" style="zoom:67%;" /><blockquote><p>为什么每个块组中都有超级块和块组描述符表？</p><ul><li>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。</li><li>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。</li></ul></blockquote><hr><h3 id="目录的存储"><a href="#目录的存储" class="headerlink" title="目录的存储"></a>目录的存储</h3><p>普通文件的块里面保存的是文件数据，而<strong>目录文件的块里面保存的是目录里面一项一项的文件信息</strong>。</p><p>目录内容如下：</p><ul><li>第一项是「<code>.</code>」，表示当前目录，第二项是「<code>..</code>」，表示上一级目录</li><li>保存目录是使用<strong>哈希表</strong>，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希来匹配。<ul><li>种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321213002362.png" style="zoom: 67%;" /><hr><h3 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h3><p><strong>硬链接</strong></p><ul><li><strong>多个目录项中的「索引节点」指向一个文件</strong>，也就是指向同一个 inode</li><li>每个文件系统都有各自的 inode 数据结构和列表，所以<strong>硬链接是不可用于跨文件系统的</strong>。</li><li>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件</li></ul><p><strong>软链接</strong></p><ul><li>相当于重新创建一个文件，这个文件有<strong>独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件</li><li><strong>软链接是可以跨文件系统的</strong>，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</li></ul><hr><h3 id="文件-I-x2F-O"><a href="#文件-I-x2F-O" class="headerlink" title="文件 I&#x2F;O"></a>文件 I&#x2F;O</h3><p><strong>缓冲与非缓冲 I&#x2F;O</strong>：根据「是否利用标准库缓冲」，可以把文件 I&#x2F;O 分为缓冲 I&#x2F;O 和非缓冲，「缓冲」特指标准库内部实现的缓冲。</p><ul><li>缓冲 I&#x2F;O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。</li><li>非缓冲 I&#x2F;O，直接通过系统调用访问文件，不经过标准库缓存。</li></ul><p><strong>直接与非直接 I&#x2F;O</strong>： Linux 内核为了减少磁盘 I&#x2F;O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来只有当缓存满足某些条件的时候，才发起磁盘 I&#x2F;O 的请求。根据是「否利用操作系统的缓存」，可以把文件 I&#x2F;O 分为直接 I&#x2F;O 与非直接 I&#x2F;O：</p><ul><li><p>直接 I&#x2F;O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。</p><ul><li>如果你在使用文件操作类的系统调用函数时，指定了 <code>O_DIRECT</code> 标志，则表示使用直接 I&#x2F;O。如果没有设置过，默认使用的是非直接 I&#x2F;O。</li></ul></li><li><p>非直接 I&#x2F;O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。</p><blockquote><p>以下几种场景会触发内核缓存的数据写入磁盘：</p><ul><li>在调用 <code>write</code> 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；</li><li>用户主动调用 <code>sync</code>，内核缓存会刷到磁盘上；</li><li>当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；</li><li>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；</li></ul></blockquote></li></ul><p><strong>阻塞与非阻塞 I&#x2F;O VS 同步与异步 I&#x2F;O</strong>：这两类IO其实是内核数据准备和数据拷贝的不同区分。</p><ul><li><p>阻塞 I&#x2F;O：阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</p><ul><li>当用户程序执行 <code>read</code> ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，<code>read</code> 才会返回。</li></ul></li><li><p>非阻塞 I&#x2F;O：非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，<code>read</code> 调用才可以获取到结果</p><ul><li>注意，成功获取数据 的那次read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。</li></ul><blockquote><p>无论是阻塞 I&#x2F;O、非阻塞 I&#x2F;O，还是基于非阻塞 I&#x2F;O 的多路复用<strong>都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。</strong></p></blockquote></li><li><p>异步 I&#x2F;O ：「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待</p><blockquote><p>I&#x2F;O 是分为两个过程的：</p><ol><li>数据准备的过程</li><li>数据从内核空间拷贝到用户进程缓冲区的过程</li></ol><p>阻塞 I&#x2F;O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I&#x2F;O 和基于非阻塞 I&#x2F;O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I&#x2F;O。</p><p>异步 I&#x2F;O 则不同，「过程 1 」和「过程 2 」都不会阻塞。</p></blockquote></li></ul><h2 id="6-2-进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"><a href="#6-2-进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？" class="headerlink" title="6.2 进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"></a>6.2 进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？</h2><p>答案：不会丢失。</p><ul><li>因为进程在执行 write （使用缓冲 IO）系统调用的时候，实际上是将文件数据写到了内核的 page cache，它是文件系统中用于缓存文件数据的缓冲，所以即使进程崩溃了，文件数据还是保留在内核的 page cache</li><li>内核会找个合适的时机，将 page cache 中的数据持久化到磁盘。但是如果 page cache 里的文件数据，在持久化到磁盘化到磁盘之前，系统发生了崩溃，那这部分数据就会丢失了。</li><li>也可以在程序里调用 fsync 函数，在写文文件的时候，立刻将文件数据持久化到磁盘，这样就可以解决系统崩溃导致的文件数据丢失的问题。</li></ul><hr><h3 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h3><p>Page Cache 的本质是由 Linux 内核管理的内存区域。我们通过 mmap 以及 buffered I&#x2F;O 将文件读取到内存空间实际上都是读取到 Page Cache 中</p><p><strong>优势</strong></p><ul><li>加快数据访问</li><li>减少 I&#x2F;O 次数，提高系统磁盘 I&#x2F;O 吞吐量</li></ul><p><strong>劣势</strong></p><ul><li>需要占用额外物理内存空间，物理内存在比较紧俏的时候可能会导致频繁的 swap 操作，最终导致系统的磁盘 I&#x2F;O 负载的上升</li><li>对应用层并没有提供很好的管理 API，导致想优化 Page Cache 的使用策略很难进行</li><li>在某些应用场景下比 Direct I&#x2F;O 多一次磁盘读 I&#x2F;O 以及磁盘写 I&#x2F;O</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321215335466.png"></p><blockquote><p><strong>page 与 Page Cache</strong></p><p>page 是内存管理分配的基本单位， Page Cache 由多个 page 构成。page 在操作系统中通常为 4KB 大小（32bits&#x2F;64bits），而 Page Cache 的大小则为 4KB 的整数倍。</p></blockquote><hr><h3 id="Page-Cache-与-buffer-cache"><a href="#Page-Cache-与-buffer-cache" class="headerlink" title="Page Cache 与 buffer cache"></a>Page Cache 与 buffer cache</h3><p>执行 free 命令，注意到会有两列名为 buffers 和 cached，也有一行名为 “-&#x2F;+ buffers&#x2F;cache”。</p><p><strong>Page Cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据。</strong></p><ul><li>页是逻辑上的概念，因此 Page Cache 是与文件系统同级的；</li><li>块是物理上的概念，因此 buffer cache 是与块设备驱动程序同级的。</li></ul><p>Page Cache 与 buffer cache 的<strong>共同目的都是加速数据 I&#x2F;O</strong>：</p><ul><li>写数据时首先写到缓存，将写入的页标记为 dirty，然后向外部存储 flush，也就是缓存写机制中的 write-back（另一种是 write-through，Linux 默认情况下不采用）；</li><li>读数据时首先读取缓存，如果未命中，再去外部存储读取，并且将读取来的数据也加入缓存。操作系统总是积极地将所有空闲内存都用作 Page Cache 和 buffer cache，当内存不够用时也会用 LRU 等算法淘汰缓存页。</li></ul><p><strong>在 2.4 版本内核之后，两块缓存近似融合在了一起：如果一个文件的页加载到了 Page Cache，那么同时 buffer cache 只需要维护块指向页的指针就可以了</strong></p><hr><h3 id="Page-Cache-与文件持久化的一致性-amp-可靠性"><a href="#Page-Cache-与文件持久化的一致性-amp-可靠性" class="headerlink" title="Page Cache 与文件持久化的一致性&amp;可靠性"></a>Page Cache 与文件持久化的一致性&amp;可靠性</h3><p>Linux 下以两种方式实现文件一致性：</p><ol><li><strong>Write Through（写穿）</strong>：向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性；<ul><li>以牺牲系统 I&#x2F;O 吞吐量作为代价，向上层应用确保一旦写入，数据就已经落盘，不会丢失</li></ul></li><li><strong>Write back（写回）</strong>：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的 Linux 一致性方案；<ul><li>在系统发生宕机的情况下无法确保数据已经落盘，因此存在数据丢失的问题。</li></ul></li></ol><p>上述两种方式最终都依赖于系统调用，主要分为如下三种系统调用：</p><table><thead><tr><th align="left">方法</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">fsync(intfd)</td><td align="left">fsync(fd)：将 fd 代表的文件的脏数据和脏元数据全部刷新至磁盘中。</td></tr><tr><td align="left">fdatasync(int fd)</td><td align="left">fdatasync(fd)：将 fd 代表的文件的脏数据刷新至磁盘，同时对必要的元数据刷新至磁盘中，这里所说的必要的概念是指：对接下来访问文件有关键作用的信息，如文件大小，而文件修改时间等不属于必要信息</td></tr><tr><td align="left">sync()</td><td align="left">sync()：则是对系统中所有的脏的文件数据元数据刷新至磁盘中</td></tr></tbody></table><ol><li>系统中存在一个管理线程和多个刷新线程（每个持久存储设备对应一个刷新线程）。<ul><li>管理线程监控设备上的脏页面情况，若设备一段时间内没有产生脏页面，就销毁设备上的刷新线程；若监测到设备上有脏页面需要回写且尚未为该设备创建刷新线程，那么创建刷新线程处理脏页面回写。</li><li>刷新线程的任务较为单调，只负责将设备中的脏页面回写至持久存储设备中。</li></ul></li><li>刷新线程刷新设备上脏页面大致设计如下：<ul><li>每个设备保存脏文件链表，保存的是该设备上存储的脏文件的 inode 节点。所谓的回写文件脏页面即回写该 inode 链表上的某些文件的脏页面；</li><li>系统中存在多个回写时机，第一是应用程序主动调用回写接口，第二管理线程周期性地唤醒设备上的回写线程进行回写，第三是某些应用程序&#x2F;内核任务发现内存不足时要回收部分缓存页面而事先进行脏页面回写</li></ul></li></ol><h1 id="七、设备管理"><a href="#七、设备管理" class="headerlink" title="七、设备管理"></a>七、设备管理</h1><h2 id="7-1-键盘敲入-A-字母时，操作系统期间发生了什么？"><a href="#7-1-键盘敲入-A-字母时，操作系统期间发生了什么？" class="headerlink" title="7.1 键盘敲入 A 字母时，操作系统期间发生了什么？"></a>7.1 键盘敲入 A 字母时，操作系统期间发生了什么？</h2><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p>为了屏蔽设备之间的差异，每个设备都有一个叫<strong>设备控制器</strong>，CPU 是通过设备控制器来和设备打交道的</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230322174034974.png" style="zoom:33%;" /><p>设备控制器里有芯片，也有寄存器用来与 CPU 进行通信，可分为三类：</p><ul><li><em><strong>数据寄存器</strong></em>，CPU 向 I&#x2F;O 设备写入需要传输的数据，比如要打印的内容是「Hello」，CPU 就要先发送一个 H 字符给到对应的 I&#x2F;O 设备。</li><li><em><strong>命令寄存器</strong></em>，CPU 发送一个命令，告诉 I&#x2F;O 设备，要进行输入&#x2F;输出操作，于是就会交给 I&#x2F;O 设备去工作，任务完成后，会把状态寄存器里面的状态标记为完成。</li><li><em><strong>状态寄存器</strong></em>，目的是告诉 CPU ，现在已经在工作或工作已经完成，如果已经在工作状态，CPU 再发送数据或者命令过来，都是没有用的，直到前面的工作已经完成，状态寄存标记成已完成，CPU 才能发送下一个字符和命令。</li></ul><p> 输入输出设备可分为两大类 ：</p><ul><li><em><strong>块设备</strong></em>，把数据存储在固定大小的块中，每个块有自己的地址，硬盘、USB 是常见的块设备。<ul><li>块设备通常传输的数据量会非常大，于是控制器设立了一个可读写的<strong>数据缓冲区</strong>。无论读写都是囤够了一部分，才会发给设备或拷贝到内存。</li></ul></li><li><em><strong>字符设备</strong></em>，以字符为单位发送或接收一个字符流，字符设备是不可寻址的，也没有任何寻道操作，鼠标是常见的字符设备。</li></ul><p>CPU 设备的控制寄存器和数据缓冲区通信方法：</p><ul><li><em><strong>端口 I&#x2F;O</strong></em>，每个控制寄存器被分配一个 I&#x2F;O 端口，可以通过特殊的汇编指令操作这些寄存器，比如 <code>in/out</code> 类似的指令。</li><li><em><strong>内存映射 I&#x2F;O</strong></em>，将所有控制寄存器映射到内存空间中，这样就可以像读写内存一样读写数据缓冲区。</li></ul><hr><h3 id="I-x2F-O-控制方式"><a href="#I-x2F-O-控制方式" class="headerlink" title="I&#x2F;O 控制方式"></a>I&#x2F;O 控制方式</h3><p><strong>轮询等待</strong>：CPU 一直检查寄存器的状态</p><p><strong>中断</strong>：当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU</p><p><strong>DMA</strong>：可以使得设备在 CPU 不参与的情况下，能够自行完成把设备 I&#x2F;O 数据放入到内存，工作方式如下：</p><ul><li>CPU 需对 DMA 控制器下发指令，告诉它想读取多少数据，读完的数据放在内存的某个地方就可以了；</li><li>接下来，DMA 控制器会向磁盘控制器发出指令，通知它从磁盘读数据到内存缓冲区中，接着磁盘控制器将缓冲区的数据传输到内存；</li><li>当磁盘控制器把数据传输到内存的操作完成后，磁盘控制器在总线上发出一个确认成功的信号到 DMA 控制器；</li><li>DMA 控制器收到信号后，DMA 控制器发中断通知 CPU 指令完成，CPU 就可以直接用内存里面现成的数据了；</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230322173920982.png" style="zoom:80%;" /><hr><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>每种设备的控制器的寄存器、缓冲区等使用模式都是不同的，所以为了屏蔽「设备控制器」的差异，引入了<strong>设备驱动程序</strong>。设备驱动程序会提供统一的接口给操作系统。</p><p>设备驱动程序里会响应控制器发来的中断请求，并根据这个中断的类型调用响应的<strong>中断处理程序</strong>进行处理。通常，设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数。</p><p><strong>中断处理程序的处理流程</strong>：</p><ol><li>在 I&#x2F;O 时，设备控制器如果已经准备好数据，则会通过中断控制器向 CPU 发送中断请求；</li><li>保护被中断进程的 CPU 上下文；</li><li>转入相应的设备中断处理函数；</li><li>进行中断处理；</li><li>恢复被中断进程的上下文；</li></ol><hr><h3 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h3><p>对于块设备，为了减少不同块设备的差异带来的影响，Linux 通过一个统一的<strong>通用块层</strong>，来管理不同的块设备。</p><p>通用块层是处于文件系统和磁盘驱动中间的一个块设备抽象层，它主要有两个功能：</p><ul><li>向上为文件系统和应用程序，提供访问块设备的标准接口，向下把各种不同的磁盘设备抽象为统一的块设备，并在内核层面，提供一个框架来管理这些设备的驱动程序；</li><li>通用块层还会给文件系统和应用程序发来的 I&#x2F;O 请求排队，接着会对队列重新排序、请求合并等方式，也就是 I&#x2F;O 调度，主要目的是为了提高磁盘读写的效率。</li></ul><p>Linux 内存支持 5 种 I&#x2F;O 调度算法，分别是：</p><ul><li><strong>没有调度算法</strong>：不做任何处理，通常用于虚拟机IO</li><li><strong>先入先出调度算法</strong></li><li><strong>完全公平调度算法</strong>：为每个进程维护了一个 I&#x2F;O 调度队列，并按照时间片来均匀分布每个进程的 I&#x2F;O 请求，常作为默认调度算法。</li><li><strong>优先级调度</strong>：优先级高的 I&#x2F;O 请求先发生， 它适用于运行大量进程的系统</li><li><strong>最终期限调度算法</strong>：分别为读、写请求创建了不同的 I&#x2F;O 队列，这样可以提高机械磁盘的吞吐量，并确保达到最终期限的请求被优先处理，适用于在 I&#x2F;O 压力比较大的场景，比如数据库等。</li></ul><hr><h3 id="存储系统-I-x2F-O-软件分层"><a href="#存储系统-I-x2F-O-软件分层" class="headerlink" title="存储系统 I&#x2F;O 软件分层"></a>存储系统 I&#x2F;O 软件分层</h3><p>Linux 存储系统的 I&#x2F;O 由上到下可以分为三个层次：</p><ul><li><strong>文件系统层</strong>，包括虚拟文件系统和其他文件系统的具体实现，它向上为应用程序统一提供了标准的文件访问接口，向下会通过通用块层来存储和管理磁盘数据。</li><li><strong>通用块层</strong>，包括块设备的 I&#x2F;O 队列和 I&#x2F;O 调度器，它会对文件系统的 I&#x2F;O 请求进行排队，再通过 I&#x2F;O 调度器，选择一个 I&#x2F;O 发给下一层的设备层。</li><li><strong>设备层</strong>，包括硬件设备、设备控制器和驱动程序，负责最终物理设备的 I&#x2F;O 操作。</li></ul><p>存储系统的 I&#x2F;O 是整个系统最慢的一个环节，所以 Linux 提供了不少缓存机制来提高 I&#x2F;O 的效率。</p><ul><li>为了提高文件访问的效率，会使用<strong>页缓存、索引节点缓存、目录项缓存</strong>等多种缓存机制，目的是为了减少对块设备的直接调用。</li><li>为了提高块设备的访问效率， 会使用<strong>缓冲区</strong>，来缓存块设备的数据</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230322175046656.png" style="zoom:50%;" /><hr><h3 id="键盘敲入字母时，期间发生了什么？"><a href="#键盘敲入字母时，期间发生了什么？" class="headerlink" title="键盘敲入字母时，期间发生了什么？"></a>键盘敲入字母时，期间发生了什么？</h3><ul><li>当用户输入了键盘字符，<strong>键盘控制器</strong>就会产生扫描码数据，并将其缓冲在键盘控制器的寄存器中，紧接着键盘控制器通过总线给 CPU 发送<strong>中断请求</strong>。</li><li>CPU 收到中断请求后，操作系统会<strong>保存被中断进程的 CPU 上下文</strong>，然后调用键盘的<strong>中断处理程序</strong>。</li><li>键盘的中断处理程序是在<strong>键盘驱动程序</strong>初始化时注册的，即从键盘控制器的寄存器的缓冲区读取扫描码，再根据扫描码找到用户在键盘输入的字符。如果输入的字符是显示字符，那就会把扫描码翻译成对应显示字符的 ASCII 码</li><li>把 ASCII 码放到「读缓冲区队列」，显示设备的驱动程序会定时从「读缓冲区队列」读取数据放到「写缓冲区队列」，最后把「写缓冲区队列」的数据写入到显示设备控制器的寄存器中的数据缓冲区</li><li>最后，恢复被中断进程的上下文</li></ul><h1 id="八、网络系统"><a href="#八、网络系统" class="headerlink" title="八、网络系统"></a>八、网络系统</h1><h2 id="8-1-什么是零拷贝？"><a href="#8-1-什么是零拷贝？" class="headerlink" title="8.1 什么是零拷贝？"></a>8.1 什么是零拷贝？</h2><h3 id="传统的文件传输有多糟糕？"><a href="#传统的文件传输有多糟糕？" class="headerlink" title="传统的文件传输有多糟糕？"></a>传统的文件传输有多糟糕？</h3><p>将磁盘上的文件读取出来，然后通过网络协议发送给客户端<strong>发生了 4 次用户态与内核态的上下文切换</strong>，<strong>发生了 4 次数据拷贝</strong>。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323153949122.png" style="zoom:67%;" /><hr><h3 id="如何优化文件传输的性能？"><a href="#如何优化文件传输的性能？" class="headerlink" title="如何优化文件传输的性能？"></a>如何优化文件传输的性能？</h3><p><strong>如何减少「用户态与内核态的上下文切换」的次数？</strong>  </p><p> 减少系统调用的次数</p><p><strong>如何减少「数据拷贝」的次数？</strong> </p><p>「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」这个过程是没有必要的。因为在用户空间我们并不会对数据「再加工」，因此<strong>用户的缓冲区是没有必要存在的</strong>。</p><hr><h3 id="如何实现零拷贝？"><a href="#如何实现零拷贝？" class="headerlink" title="如何实现零拷贝？"></a>如何实现零拷贝？</h3><p>零拷贝技术实现的方式通常有 2 种：</p><ul><li><p><strong>mmap + write</strong>：用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p><ul><li><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。而write函数直接从内核缓冲区将数据拷贝到socket缓冲区中。</li><li>可以减少一次数据拷贝的过程，但仍然需要 4 次上下文切换，因为系统调用还是 2 次</li></ul></li><li><p><strong>sendfile</strong>：这是一个专门发送文件的系统调用函数。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">ssize_t</span> <span class="token function">sendfile</span><span class="token punctuation">(</span><span class="token keyword">int</span> out_fd<span class="token punctuation">,</span> <span class="token keyword">int</span> in_fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> <span class="token operator">*</span>offset<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用</li><li>该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝</li></ul><blockquote><p>如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术，那么可以将拷贝次数缩小为2此，从而实现<strong>零拷贝</strong>，其过程如下：</p><ul><li>通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，减少了一次数据拷贝；</li></ul></blockquote></li></ul><hr><h3 id="PageCache-有什么作用？"><a href="#PageCache-有什么作用？" class="headerlink" title="PageCache 有什么作用？"></a>PageCache 有什么作用？</h3><p>把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是<strong>磁盘高速缓存（*PageCache*）</strong>。</p><p><strong>PageCache 的优点</strong>主要是两个：</p><ul><li>缓存最近被访问的数据；</li><li>预读功能；</li></ul><p><strong>但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能</strong>，这是因为：</p><ul><li>PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；</li><li>PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；</li></ul><p><strong>所以大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术</strong></p><hr><h3 id="大文件传输用什么方式实现？"><a href="#大文件传输用什么方式实现？" class="headerlink" title="大文件传输用什么方式实现？"></a>大文件传输用什么方式实现？</h3><p><strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I&#x2F;O + 直接 I&#x2F;O」来替代零拷贝技术</strong>。</p><p>异步 I&#x2F;O 工作方式如下图，异步 I&#x2F;O 并没有涉及到 PageCache，所以使用异步 I&#x2F;O 就意味着要绕开 PageCache。对于磁盘，异步 I&#x2F;O 只支持直接 I&#x2F;O。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323160634929.png" style="zoom:67%;" /><blockquote><p>直接 I&#x2F;O 应用场景常见的两种：</p><ul><li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存</li><li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销</li></ul><p>由于直接 I&#x2F;O 绕过了 PageCache，就无法享受内核的这两点的优化：</p><ul><li>合并IO请求从而减少磁盘寻址操作</li><li>预读数据从而减少对磁盘的操作</li></ul></blockquote><p>传输文件的时候，要根据文件的大小来使用不同的方式：</p><ul><li>传输大文件的时候，使用「异步 I&#x2F;O + 直接 I&#x2F;O」；</li><li>传输小文件的时候，则使用「零拷贝技术」；</li></ul><h2 id="8-2-I-x2F-O-多路复用：select-x2F-poll-x2F-epoll"><a href="#8-2-I-x2F-O-多路复用：select-x2F-poll-x2F-epoll" class="headerlink" title="8.2 I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll"></a>8.2 I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll</h2><p><strong>文件描述符的作用是什么？</strong></p><blockquote><p>每一个进程都有一个数据结构 <code>task_struct</code>，该结构体里有一个指向「文件描述符数组」的成员指针。该数组里列出这个进程打开的所有文件的文件描述符。数组的下标是文件描述符，是一个整数，而数组的内容是一个指针，指向内核中所有打开的文件的列表，也就是说内核可以通过文件描述符找到对应打开的文件。</p></blockquote><p>每个文件都有一个 inode，Socket 文件的 inode 指向了内核中的 Socket 结构，在这个结构体里有两个队列，分别是<strong>发送队列</strong>和<strong>接收队列</strong>，这个两个队列里面保存的是一个个 <code>struct sk_buff</code>，用链表的组织形式串起来。</p><hr><h3 id="select-x2F-poll"><a href="#select-x2F-poll" class="headerlink" title="select&#x2F;poll"></a>select&#x2F;poll</h3><p>select 实现多路复用的方式：</p><ul><li>将已连接的 Socket 都放到一个<strong>文件描述符集合</strong></li><li>然后调用 select 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生</li><li>检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写</li><li>接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket</li></ul><p>缺点：</p><ul><li>需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里</li><li>发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中</li><li>所支持的文件描述符的个数是有限制的，但可以通过修改内核参数FD_SETSIZE 来解决</li></ul><p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p><p>poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong></p><hr><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><strong>使用</strong>:先用e poll_create 创建一个 epol l对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据</p><p>epoll 通过两个方面，很好解决了 select&#x2F;poll 的问题:</p><ul><li>epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，增删改一般时间复杂度是 <code>O(logn)</code>。 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</li><li>epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li></ul><p>epoll_wait返回数据时会将数据从内核拷贝到用户空间。</p><hr><h3 id="边缘触发和水平触发"><a href="#边缘触发和水平触发" class="headerlink" title="边缘触发和水平触发"></a>边缘触发和水平触发</h3><p>epoll 支持两种事件触发模式:</p><ul><li><strong>边缘触发</strong>：当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没一次读完数据。</li><li><strong>水平触发</strong>：当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong><ul><li>由于I&#x2F;O 事件发生时只会通知一次，因此需要<strong>循环</strong>从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里。所以，<strong>边缘触发模式一般和非阻塞 I&#x2F;O 搭配使用</strong>。</li></ul></li></ul><p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p><h2 id="8-3-高性能网络模式：Reactor-和-Proactor"><a href="#8-3-高性能网络模式：Reactor-和-Proactor" class="headerlink" title="8.3 高性能网络模式：Reactor 和 Proactor"></a>8.3 高性能网络模式：Reactor 和 Proactor</h2><h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p>Reactor 模式是<strong>非阻塞同步网络模式</strong>，主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：</p><ul><li>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；</li><li>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</li></ul><p>Reactor一般使用以下三种方案：</p><ul><li><p><strong>单 Reactor 单进程 &#x2F; 线程</strong></p><ul><li><p>Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发</p></li><li><p>如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；</p></li><li><p>如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；</p></li><li><p>缺点：</p><ul><li>无法充分利用 多核 CPU 的性能；</li><li>Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就造成响应的延迟；</li></ul></li><li><p>不适用计算机密集型的场景，只适用于业务处理非常快速的场景。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323175338913.png" style="zoom:67%;" /></li></ul></li><li><p><strong>单 Reactor 多进程 &#x2F; 线程</strong></p><ul><li>监听和事件分发和单Reactor单线程方案一样，不一样的步骤是：<ul><li>Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理；</li><li>子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client；</li></ul></li><li>因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323175718048.png" style="zoom:67%;" /></li><li><p><strong>多 Reactor 多进程 &#x2F; 线程</strong></p><ul><li>主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程；</li><li>子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。</li><li>如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。</li><li>Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li></ul></li></ul><hr><h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h3><p><strong>Proactor 是异步网络模式</strong></p><p>无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 <strong>Reactor 模式是基于「待完成」的 I&#x2F;O 事件，而 Proactor 模式则是基于「已完成」的 I&#x2F;O 事件</strong>。</p><blockquote><p>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」，而 Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</p><ul><li><strong>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件</strong>。在每次感知到有事件发生后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</li><li><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read&#x2F;write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323180503685.png" style="zoom:80%;" /><p>Proactor 模式的工作流程：</p><ul><li>Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核；</li><li>Asynchronous Operation Processor 负责处理注册请求，并处理 I&#x2F;O 操作；</li><li>Asynchronous Operation Processor 完成 I&#x2F;O 操作后通知 Proactor；</li><li>Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理；</li><li>Handler 完成业务处理；</li></ul><blockquote><p>在 Linux 下的异步 I&#x2F;O 是不完善的， <code>aio</code> 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的</p><p> Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 <code>IOCP</code></p></blockquote><h1 id="8-4-什么是一致性哈希？"><a href="#8-4-什么是一致性哈希？" class="headerlink" title="8.4 什么是一致性哈希？"></a>8.4 什么是一致性哈希？</h1><blockquote><p>对于分布式系统，由于需要考虑负载均衡，因此需要将数据水平切分到不同节点上，访问数据的时候寻址存储该数据的节点。</p><p>哈希算法虽然能建立数据和节点的映射关系，但是每次在节点数量发生变化的时候，最坏情况下所有数据都需要迁移，这样太麻烦了，所以不适用节点数量变化的场景。</p></blockquote><p><strong>一致性哈希</strong>是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上（例如2^32大小的环），如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。</p><ul><li>对存储节点进行哈希计算，比如根据节点的 IP 地址进行哈希，将其映射到哈希环上；</li><li>当对数据进行存储或访问时，对数据进行哈希映射；</li></ul><p><strong>一致性哈希算法不能够均匀的分布节点</strong>，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。</p><p>解决办法：引入虚拟节点。不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，而真实节点包含多个虚拟节点。</p><ul><li>引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1619. 删除某些元素后的数组均值</title>
      <link href="/2023/02/15/leetcode/other/leetcode-1619-simple/"/>
      <url>/2023/02/15/leetcode/other/leetcode-1619-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="1619-删除某些元素后的数组均值"><a href="#1619-删除某些元素后的数组均值" class="headerlink" title="1619. 删除某些元素后的数组均值"></a><a href="https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/">1619. 删除某些元素后的数组均值</a></h1><p>FIrst：排序，再去掉前后数相加求平均</p><hr><p><strong>方法1</strong>：<strong>排序</strong></p><p>先排序，然后去掉前后各5%的数，将剩下的数相加求和即可</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    double trimMean(vector&lt;int&gt;&amp; arr) &#123;        sort(arr.begin(),arr.end());        long long sum&#x3D;0;        for(int i&#x3D;arr.size()*0.05;i&lt;arr.size()*0.95;++i)&#123;            sum+&#x3D;arr[i];        &#125;        return sum&#x2F;(arr.size()*0.9);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小林coding-计算机网络-笔记</title>
      <link href="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>总结知识点，以便以后快速复习。</p><p><em>参考小林coding网络图解</em>, <a href="https://www.xiaolincoding.com/network">地址</a></p><h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="1-1-TCP-x2F-IP-网络模型有哪几层？"><a href="#1-1-TCP-x2F-IP-网络模型有哪几层？" class="headerlink" title="1.1 TCP&#x2F;IP 网络模型有哪几层？"></a>1.1 TCP&#x2F;IP 网络模型有哪几层？</h2><p><strong>应用层</strong></p><ul><li>应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的</li><li>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态</li></ul><p><strong>传输层</strong>：</p><ul><li><p>为应用层提供网络支持</p></li><li><p>TCP 的全称叫传输控制协议，大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p><blockquote><p><strong>IP层有分块，为什么TCP还要分块？</strong></p><p>应用需要传输的数据可能会非常大，当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。</p><p>如果TCP不进行分块，则在IP层可能会分块，当一个分块丢失，则需要重传整个数据，造成效率很低。</p></blockquote></li><li><p>UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。</p></li><li><p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。</p></li></ul><p><strong>网络层</strong></p><ul><li><p>实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，这就是网络层要干的事。</p></li><li><p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p></li><li><p>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</p></li></ul><p><strong>网络接口层</strong></p><ul><li>网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备</li><li>网络接口层通常负责直接相连的节点之间的传输</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316210322498.png"></p><p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p><h2 id="1-2-键入网址到网页显示，期间发生了什么？"><a href="#1-2-键入网址到网页显示，期间发生了什么？" class="headerlink" title="1.2 键入网址到网页显示，期间发生了什么？"></a>1.2 键入网址到网页显示，期间发生了什么？</h2><ol><li><p>解析 URL：使用DNS解析域名</p><ul><li>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/6.jpg"></li></ul></li><li><p>使用操作系统中的协议栈来发送HTTP数据</p><ul><li><p>先三次握手建立连接</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316211136080.png"></p></li></ul></li></ol><h2 id="1-3-Linux-系统是如何收发网络包的？"><a href="#1-3-Linux-系统是如何收发网络包的？" class="headerlink" title="1.3 Linux 系统是如何收发网络包的？"></a>1.3 Linux 系统是如何收发网络包的？</h2><p><strong>Linux 网络协议栈</strong></p><ul><li>应用程序需要通过系统调用，来跟 Socket 层进行数据交互；</li><li>Socket 层的下面就是传输层、网络层和网络接口层；</li><li>最下面的一层，则是网卡驱动程序和硬件网卡设备；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316211406095.png"></p><p><strong>Linux 接收网络包的流程</strong></p><ul><li>当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区</li><li>触发一个中断告诉操作系统有数据到达，后面操作系统会发起一个软中断用于处理数据。内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。<ul><li>为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 NAPI 机制（<em>NAPI 机制</em>：不采用中断的方式读取数据，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据）</li></ul></li><li>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</li><li>在网络接口层，检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，接着再去掉帧头和帧尾，然后交给网络层</li><li>到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。</li><li>传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」(TCP) 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。</li><li>应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316211518689.png"></p><p><strong>Linux 发送网络包的流程</strong></p><ol><li>应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 sk_buff 内存，<strong>将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区</strong>。</li><li>网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理</li><li>如果使用的是 TCP 传输协议发送数据，那么<strong>先拷贝一个新的 sk_buff 副本</strong>，然后对 sk_buff 填充 TCP 头。<ul><li>拷贝副本原因：因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉，而 TCP 协议是支持丢失重传的。</li></ul></li><li>在网络层里会选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。然后交给网络接口层处理。</li><li>网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中。</li><li>这些工作准备好后，会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</li><li>当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放 sk_buff 内存和清理 RingBuffer 内存。</li><li>最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 sk_buff 。</li></ol><blockquote><p>为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，通过调整 sk_buff 中 <code>data</code> 的指针：</p><ul><li>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。</li><li>当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。</li></ul></blockquote><blockquote><p><strong>发送网络数据的时候，涉及几次内存拷贝操作？</strong></p><ul><li>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</li><li>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</li><li>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff</li></ul></blockquote><h1 id="二、HTTP篇"><a href="#二、HTTP篇" class="headerlink" title="二、HTTP篇"></a>二、HTTP篇</h1><h2 id="2-1-HTTP-常见面试题"><a href="#2-1-HTTP-常见面试题" class="headerlink" title="2.1 HTTP 常见面试题"></a>2.1 HTTP 常见面试题</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316213651972.png"></p><h3 id="HTTP-是什么？"><a href="#HTTP-是什么？" class="headerlink" title="HTTP 是什么？"></a>HTTP 是什么？</h3><p>HTTP 的名字「超文本协议传输」，它可以拆成三个部分：</p><ul><li>超文本：超越普通文字，包括文字、图片、视频等</li><li>传输：确立在两点之间传输数据的约定和规范</li><li>协议：确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式（行为约定和规范）</li></ul><p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><hr><h3 id="HTTP-常见的状态码有哪些？"><a href="#HTTP-常见的状态码有哪些？" class="headerlink" title="HTTP 常见的状态码有哪些？"></a>HTTP 常见的状态码有哪些？</h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329155907563.png"></p><hr><h3 id="HTTP-常见字段有哪些？"><a href="#HTTP-常见字段有哪些？" class="headerlink" title="HTTP 常见字段有哪些？"></a>HTTP 常见字段有哪些？</h3><ul><li><strong><em>Host</em> 字段</strong>：使用此字段可以在相同ip+端口部署不同服务</li><li><em><strong>Content-Length 字段</strong></em>：数据长度（为了解决粘包问题）</li><li><em><strong>Connection 字段</strong></em>：最常用于客户端要求服务器使用「HTTP 长连接」机制（http1.1默认开启keep alibe，1.0则是关闭）</li><li><em><strong>Content-Type 字段</strong></em>：数据格式</li><li><em><strong>Content-Encoding 字段</strong></em>：数据压缩方法</li></ul><hr><h3 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h3><ul><li>GET 的语义是从服务器获取指定的资源，GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII</li><li>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理，POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据</li></ul><hr><h3 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h3><blockquote><p>「安全」是指请求方法不会「破坏」服务器上的资源；「幂等」是指多次执行相同的操作，结果都是「相同」的。</p></blockquote><ul><li>GET 方法就是安全且幂等的，因为它是「只读」操作（所以可以对get请求的数据做缓存）</li><li>POST方法是不安全且不幂等的，因为它会修改服务器上的资源（所以一般不会缓存post请求）</li></ul><p>上述是RFC规范，但如果不遵循规范可能会导致get并非安全且幂等</p><blockquote><p><strong>GET 请求可以带 body 吗？</strong></p><p>RFC 规范并没有规定 GET 请求不能带 body，任何请求都可以带 body 的 。</p><p>URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的</p></blockquote><hr><h3 id="HTTP-缓存有哪些实现方式？"><a href="#HTTP-缓存有哪些实现方式？" class="headerlink" title="HTTP 缓存有哪些实现方式？"></a>HTTP 缓存有哪些实现方式？</h3><p>两种实现方式：</p><ul><li><p><strong>强制缓存</strong>：只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p><ul><li>HTTP头部有两个字段用于表示缓存有效时间：<code>Cache-Control</code>，相对时间；<code>Expires</code>，绝对时间；</li><li>Cache-Control 的优先级高于 Expires </li><li>具体实现流程如下：<ul><li>当第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul></li></ul></li><li><p><strong>协商缓存</strong>：与服务端协商之后，通过协商结果来判断是否使用本地缓存。协商缓存可以基于两种头部来实现：</p><ul><li>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现<ul><li><code>Last-Modified</code> ：标示这个响应资源的最后修改时间</li><li><code>If-Modified-Since</code>：当资源过期，其具有Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后与被请求资源的最后修改时间进行对比，如果资源被改过，则返回最新资源，HTTP 200 OK；如果资源无新修改，响应 HTTP 304 走缓存。</li></ul></li><li>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段<ul><li><code>Etag</code>：唯一标识响应资源；</li><li><code>If-None-Match</code>：当资源过期时，其具有有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul></li><li>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</li></ul><blockquote><p>请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，<strong>这时 Etag 的优先级更高</strong>。服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。这样做是因为：</p><ul><li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致认为这文件被改动了</li><li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的</li><li>有些服务器不能精确获取文件的最后修改时间</li></ul></blockquote></li></ul><p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329164950051.png" style="zoom:67%;" /><hr><h3 id="HTTP的优点有哪些？"><a href="#HTTP的优点有哪些？" class="headerlink" title="HTTP的优点有哪些？"></a>HTTP的优点有哪些？</h3><ul><li><em>简单</em>：基本的报文格式就是 <code>header + body</code>，头部信息是 <code>key-value</code> 形式，易于理解</li><li><em>灵活和易于扩展</em>：HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等都允许开发人员自定义和扩充，且下层可以随意变化。</li><li><em>应用广泛和跨平台</em></li></ul><hr><h3 id="HTTP的缺点有哪些？"><a href="#HTTP的缺点有哪些？" class="headerlink" title="HTTP的缺点有哪些？"></a>HTTP的缺点有哪些？</h3><ul><li><em>无状态双刃剑</em>：<ul><li>好处：不需要额外的资源来记录状态信息，能减轻服务器的负担</li><li>坏处：完成有关联性的操作时会非常麻烦</li></ul></li><li><em>明文传输双刃剑</em>：对调试工作十分方便，但信息容易被窃取。</li><li><em>不安全</em>：通信使用明文（不加密），内容可能会被窃听；不验证通信方的身份，因此有可能遭遇伪装；无法证明报文的完整性，所以有可能已遭篡改。</li></ul><hr><h3 id="HTTP-x2F-1-1-相比-HTTP-x2F-1-0-提高了什么性能？"><a href="#HTTP-x2F-1-1-相比-HTTP-x2F-1-0-提高了什么性能？" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h3><ul><li><em><strong>长连接</strong></em>：http1.1默认使用长连接，减少了 TCP 连接的重复建立和断开所造成的额外开销。</li><li><em><strong>管道网络传输</strong></em>：即发送完第一个请求后可以马上发送下一个请求，而无序等待第一个请求完成。<ul><li>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。所以只<strong>解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong></li></ul></li></ul><hr><h3 id="HTTP-x2F-2-做了什么优化？"><a href="#HTTP-x2F-2-做了什么优化？" class="headerlink" title="HTTP&#x2F;2 做了什么优化？"></a>HTTP&#x2F;2 做了什么优化？</h3><p>HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p><ul><li><strong>重复头部压缩：</strong>如果多个请求的头部是一样的，那么会消除重复的部分。采用<code>HPACK</code> 算法，在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后只发送索引号，从而减少数据。<code>HPACK</code> 算法由以下三个部分组成：<ul><li>静态表编码：HTTP&#x2F;2 为高频出现在头部的字符串和字段建立了一张静态表，它不会变化，共61组（序号所在字节第一位用于表示其是否在静态表存在）</li><li>动态表编码：对于不在静态表中的字段就需要构建动态表，每次发送一个字段后，客户端和服务端都会更新动态表，以后按动态表的序号发送即可（服务器一般会限制动态表大小）</li><li>哈夫曼编码：HTTP&#x2F;2 根据出现频率将 ASCII 码编码为了 Huffman 编码表，是固定不变的。（在头部字段后面的下一个字节的第一位表示是否使用哈夫曼编码，后7为表示value长度）</li></ul></li><li><strong>二进制格式：</strong>头信息和数据体都采用二进制格式。</li><li><strong>并发传输：</strong>初步解决http1.1中的服务端队头阻塞问题，使用了stream，多个 Stream 复用在一条 TCP 连接。<ul><li>1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 是一个请求或响应</li><li>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应。</li><li>不同 Stream 的帧是可以乱序发送的，而同一 Stream 内部的帧必须是严格有序的</li></ul></li><li><strong>服务器主动推送资源：</strong>服务端不再是被动地响应，可以主动向客户端发送消息。<ul><li>客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</li></ul></li></ul><blockquote><p><strong>HTTP2缺陷</strong></p><p>HTTP2是基于TCP协议的，而TCP协议必须保证收到的报文是完整且连续的。如果接受窗口的一部分数据没有收到，那么即使其后面数据收到也只有等待前面数据收到后，内核才能拿到数据。因此并未真正解决队头阻塞问题。</p></blockquote><hr><h3 id="HTTP-x2F-3-做了哪些优化？"><a href="#HTTP-x2F-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h3><p> HTTP&#x2F;3 把 下层的 TCP 协议改成了 基于UDP的QUIC协议，其特点如下：</p><ul><li><p><em><strong>无队头阻塞</strong></em>：QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，且有一套机制保证传输可靠性。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。</p></li><li><p><em><strong>更快的连接建立</strong></em>：HTTP&#x2F;3 的 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商。</p><ul><li><p>且在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329203350684.png" style="zoom:50%;" /></li></ul></li><li><p><em><strong>连接迁移</strong></em>：TCP协议是基于四元组确认一条连接，当设备网络发生变化后需要重新建立连接。QUIC协议通过连接ID来标记通信的两个端点，当网络变化后通过连接ID、TLS密钥等就可以复用原连接，从而达到连接迁移功能。</p></li></ul><p>HTTP3相比HTTP2变化：</p><ul><li>HTTP&#x2F;3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream</li><li>HTTP&#x2F;3使用QPACK算法压缩，主要将静态表扩大到91项，且利用了QUIC中的两个单向流来同步双方的动态表。</li></ul><hr><h3 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h3><ul><li>HTTP 是明文传输，存在安全风险。HTTPS 在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 在 TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><hr><h3 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？"></a>HTTPS 解决了 HTTP 的哪些问题？</h3><p>解决了窃听问题、篡改问题、网站冒充问题，使用下面方法进行解决的：</p><ul><li><strong>混合加密的方式实现信息的机密性，解决了窃听的风险。</strong><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。这是因为：<ul><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题，但速度慢。</li></ul></li></ul></li><li><strong>摘要算法的方式来实现完整性，解决了篡改的风险。</strong><ul><li>对内容计算出一个「指纹」，然后同内容一起传输给对方。对方收到后先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</li><li>指纹是通过哈希函数计算出的一个哈希值，但并不能保证「内容 + 哈希值」不会被中间人替换。<strong>解决办法</strong>是使用私钥对内容的哈希值进行加密，接收方对其解密并验证哈希是否相同。</li></ul></li><li><strong>将服务器公钥放入到数字证书中，解决了冒充的风险。</strong><ul><li>通过数字证书的方式保证服务器公钥的身份</li></ul></li></ul><blockquote><p><strong>非对称加密有两种用途</strong>：</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul></blockquote><hr><h3 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h3><ol><li><p><em><strong>ClientHello</strong></em>：客户端向服务器发起加密通信请求，主要发送以下信息：支持的 TLS 协议版本、生产的随机数、支持的密码套件列表。</p></li><li><p><em><strong>SeverHello</strong></em>：服务器收到客户端请求后，向客户端发出响应，回应的内容主要如下：确认 TLS 协议版本；服务器生产的随机数；确认的密码套件列表；服务器的数字证书</p></li><li><p><em><strong>客户端回应</strong></em>：先根据CA公钥确认服务器的数字证书的真实性。如果没有问题，客户端会从数字证书中取出公钥，使用它加密报文，向服务器发送如下信息：</p><ul><li>一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</li><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li></ul><blockquote><p><strong>服务器和客户端有了这三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p></blockquote></li><li><p><em><strong>服务器的最后回应</strong></em>：服务器收到客户端的第三个随机数之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发送最后的信息：</p><ul><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</li></ul></li></ol><blockquote><p>SSL&#x2F;TLS 1.2 需要 4 握手，需要 2 个 RTT 的时延。</p><p>而SSL&#x2F;TLS 1.3 优化了过程，只需要 1 个 RTT 往返时延，也就是只需要 3 次握手，细节见后文。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329193344364.png"></p><p><strong>数字证书签发和验证流程：</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329194543425.png"></strong></p><blockquote><p><strong>多层证书验证过程</strong></p><ul><li>根据收到的证书找到其签发机构，如果签发机构不是根证书，则继续找直到达到根证书。</li><li>如果此根证书已经预载于系统重，则使用根证书的公钥去验证下一级的证书，不断进行验证从而完成所有证书信任。</li></ul><p><strong>为什么要搞这么多层级证书？</strong></p><p>为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题</p></blockquote><hr><h3 id="HTTPS-的应用数据是如何保证完整性的？"><a href="#HTTPS-的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS 的应用数据是如何保证完整性的？"></a>HTTPS 的应用数据是如何保证完整性的？</h3><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议就是 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据；</li><li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li></ul><p>记录协议过程如下：</p><ol><li>消息被分割成多个较短片段，对每个片段分别进行压缩</li><li>再压缩片段后面加上消息认证码（MAC值）。为防止重放攻击，计算消息认证码时还加上了片段的编码。</li><li>使用对称密码对每个片段进行加密，加上报文头从而组成最终报文数据</li></ol><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329200337847.png" style="zoom:50%;" /><hr><h3 id="HTTPS-一定安全可靠吗？"><a href="#HTTPS-一定安全可靠吗？" class="headerlink" title="HTTPS 一定安全可靠吗？"></a>HTTPS 一定安全可靠吗？</h3><p>受到中间人攻击（伪基站）时，https安全吗？</p><p>安全，即使有伪基站进行中间攻击，但客户端会验证其公钥是否与域名对应（CA机构可验证），如果不对应则拒绝后续执行，而伪基站自己生成的公钥和所要访问的域名肯定是不对应的。</p><p>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</p><blockquote><p><strong>为什么抓包工具能截取 HTTPS 数据？</strong></p><p>对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:</p><ol><li>作为客户端与真实服务端建立连接，这一步不会有问题，因为服务端不会校验客户端的身份；</li><li>作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；中间人要拿到私钥只能通过如下方式：<ul><li>去网站服务端拿到私钥；</li><li>去CA处拿域名签发私钥；</li><li>自己签发证书，切要被浏览器信任；</li></ul></li></ol><p>因此，使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这也是能被截取数据的关键所在</p><p><strong>如何避免被中间人抓取数据？</strong></p><ul><li>不要点击任何证书非法的网站</li><li>通过 HTTPS 双向认证，即服务器也验证客户端身份：将包含客户端公钥的证书发给服务器，服务器进行验证</li></ul></blockquote><h2 id="2-2-HTTP-x2F-1-1-优化"><a href="#2-2-HTTP-x2F-1-1-优化" class="headerlink" title="2.2 HTTP&#x2F;1.1 优化"></a>2.2 HTTP&#x2F;1.1 优化</h2><ul><li><strong>避免发送HTTP请求</strong>：使用HTTP的强制缓存和协商缓存技术，即收到请求后将其缓存到本地，下次请求时如果缓存没过期则直接使用缓存数据，如果过期则请求时带上数据的摘要，由服务端判断是否继续使用原缓存。</li><li><strong>减少 HTTP 请求次数</strong><ul><li><strong><em>减少重定向请求次数</em>：</strong>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数</li><li><strong><em>合并请求</em>：</strong>将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输</li><li><strong><em>延迟发送请求</em>：</strong>按需访问资源，只访问当前用户看得到&#x2F;用得到的资源，才接下来的资源</li></ul></li><li><strong>减少 HTTP 响应的数据大小</strong>：对数据进行压缩，例如对关键数据进行无损压缩，对图片音频等进行有损压缩</li></ul><h2 id="2-3-HTTPS-RSA-握手解析"><a href="#2-3-HTTPS-RSA-握手解析" class="headerlink" title="2.3 HTTPS RSA 握手解析"></a>2.3 HTTPS RSA 握手解析</h2><p>TLS 的握手过程，如下图：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329205705346.png" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329212203781.png"></p><ul><li><strong>第一次握手</strong>：发一个「Client Hello」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random），这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</li><li><strong>第二次握手</strong>：返回「Server Hello」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件<ul><li>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成随机数（Server Random）</li><li>服务端为了证明自己的身份，会发送「Server Certificate」给客户端，这个消息里含有数字证书</li></ul></li><li><strong>第三次握手</strong>：在收到服务端发送的第二次握手信息后，会先验证证书可靠性，如果不可靠则终止。客户端就会生成一个新的随机数 (pre-master)，用服务器的 RSA 公钥加密该随机数，通过「Client Key Exchange」消息传给服务端。<ul><li>生成完「会话密钥」后，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息</li><li>再发一个「Encrypted Handshake Message（Finishd）」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」</li></ul></li><li><strong>第四次握手</strong>：发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</li></ul><blockquote><p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。因为随机数使用公钥加密的，如果私钥泄露，以前的报文都会被泄露。</p></blockquote><h2 id="2-4-HTTPS-ECDHE-握手解析"><a href="#2-4-HTTPS-ECDHE-握手解析" class="headerlink" title="2.4 HTTPS ECDHE 握手解析"></a>2.4 HTTPS ECDHE 握手解析</h2><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329212936210.png" style="zoom:50%;" /><h2 id="2-5-HTTPS-如何优化？"><a href="#2-5-HTTPS-如何优化？" class="headerlink" title="2.5 HTTPS 如何优化？"></a>2.5 HTTPS 如何优化？</h2><p>产生性能消耗的两个环节：</p><ul><li>第一个环节， TLS 协议握手过程；</li><li>第二个环节，握手后的对称加密报文传输。</li></ul><p><strong>硬件优化</strong>：应该选择可以支持 AES-NI 特性的 CPU，因为这种CPU 在指令级别优化了 AES 算法，加速了数据的加解密传输过程</p><p><strong>软件优化</strong>：</p><ul><li><p><strong>协议优化</strong></p><ul><li>密钥交换算法应该选择 ECDHE 算法，而不用 RSA 算法，因为 ECDHE 算法具备前向安全性，而且客户端可以在第三次握手之后，就发送加密应用数据，节省了 1 RTT。ECDHE算法尽量选择 x25519 曲线。</li><li>将 TLS1.2 升级 TLS1.3，因为 TLS1.3 的握手过程只需要 1 RTT，而且安全性更强。</li></ul></li><li><p><strong>证书优化</strong></p><ul><li>服务器应该选用 ECDSA 证书，而非 RSA 证书，因为在相同安全级别下，ECC 的密钥长度比 RSA 短很多</li><li>服务器应该开启 OCSP Stapling 功能，由服务器预先获得 OCSP 的响应，并把响应结果缓存起来，这样 TLS 握手的时候就不用再访问 CA 服务器，减少了网络通信的开销，提高了证书验证的效率；（OCSP：向 CA 发送查询请求，让 CA 返回证书的有效状态）</li></ul></li><li><p><strong>会话复用：</strong>对于重连 HTTPS 时，可以使用Session ID 和 Session Ticket等回话重用技术，从而快速恢复对话。</p><ul><li>Session ID：<ul><li>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识。</li><li>当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态。</li></ul></li><li>Session Ticket：<ul><li>客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。</li><li>客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，就可以恢复会话了，开始加密通信。</li></ul></li><li>Pre-shared Key：和ticket类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端</li></ul></li></ul><blockquote><p><strong>TLS1.3减少1RTT的方法</strong>：</p><ul><li>客户端在 Client Hello 消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥</li><li>服务端收到后选择其中一中曲线计算公钥，返回时带上公钥，从而双方皆有能生成会话密钥。</li></ul></blockquote><h2 id="2-6-既然有-HTTP-协议，为什么还要有-RPC？"><a href="#2-6-既然有-HTTP-协议，为什么还要有-RPC？" class="headerlink" title="2.6 既然有 HTTP 协议，为什么还要有 RPC？"></a>2.6 既然有 HTTP 协议，为什么还要有 RPC？</h2><p>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义消息边界。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</p><p>HTTP 和 RPC 区别</p><ul><li><strong>服务发现</strong><ul><li>在 HTTP 中，知道服务的域名，就可以通过 DNS 服务去解析得到 IP 地址，默认 80 端口。</li><li>在 RPC 中，一般会有专门的中间服务去保存服务名和IP信息，比如 Consul 或者 Etcd。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。</li></ul></li><li><strong>底层连接形式</strong><ul><li>HTTP&#x2F;1.1 默认在建立底层 TCP 连接之后会一直保持这个连接</li><li>RPC 协议也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用</li></ul></li><li><strong>传输的内容</strong><ul><li>HTTP&#x2F;1.1使用 Json 来序列化结构体数据</li><li>RPC一般采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></li></ul></li></ul><blockquote><p>HTTP&#x2F;2 在1.1的基础上做了很多改进，所以性能可能比很多 RPC 协议还要好，甚至连 gRPC 底层都直接用的 HTTP&#x2F;2。</p></blockquote><h2 id="2-7-既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#2-7-既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="2.7 既然有 HTTP 协议，为什么还要有 WebSocket？"></a>2.7 既然有 HTTP 协议，为什么还要有 WebSocket？</h2><p><strong>服务器主动发消息给客户端该怎么实现？</strong></p><ul><li><strong>使用 HTTP 不断轮询</strong>：代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息<ul><li>缺点：消耗带宽和服务器性能；由于存在轮询间隔，因此会感到明显的卡顿</li></ul></li><li><strong>长轮询</strong>：HTTP 请求将超时设置的很大，比如 30 秒，在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。<ul><li>缺点：适用于简单场景，如果有大量数据需要推送则不适合。</li></ul></li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>HTTP1.1是一种半双工协议，服务器不能主动向客户端发送消息，因此WebSocket应运而生。</p><p>为了兼容HTTP场景和WebSocket场景，浏览器在 TCP 三次握手建立连接之后，都统一使用 HTTP 协议先进行一次通信：</p><ul><li>如果此时是普通的 HTTP 请求，那后续双方就还是老样子继续用普通 HTTP 协议进行交互，这点没啥疑问。</li><li>如果这时候是想建立 WebSocket 连接，就会在 HTTP 请求里带上一些特殊的header 头，表示想升级成 WebSocket 协议</li></ul><p>WebSocket握手过程：</p><ul><li><p>第一次握手：在建立http连接后，在http请求里面加上升级协议字段，并生成一个随机的base64码，发送给服务器</p><pre class="line-numbers language-none"><code class="language-none">Connection: UpgradeUpgrade: WebSocketSec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg&#x3D;&#x3D;\r\n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>第二次握手：如果服务器支持升级WebSocket协议，根据客户端生成的 base64 码，用某个公开的算法变成另一段字符串，放在 HTTP 响应的 Sec-WebSocket-Accept 头里，同时带上101状态码，发回给浏览器。</p></li><li><p>浏览器也用同样的公开算法将base64码转成另一段字符串，如果这段字符串跟服务器传回来的字符串一致，那就可以使用 webscoket 的数据格式进行通信。</p></li></ul><blockquote><p>注意！WebSocket是利用HTTP协议来完成的握手过程，握手完成后就不再使用http协议</p></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230330173008117.png" style="zoom:50%;" /><h1 id="三、TCP篇"><a href="#三、TCP篇" class="headerlink" title="三、TCP篇"></a>三、TCP篇</h1><h2 id="3-1-TCP-三次握手与四次挥手面试题"><a href="#3-1-TCP-三次握手与四次挥手面试题" class="headerlink" title="3.1 TCP 三次握手与四次挥手面试题"></a>3.1 TCP 三次握手与四次挥手面试题</h2><h3 id="TCP-头格式有哪些？"><a href="#TCP-头格式有哪些？" class="headerlink" title="TCP 头格式有哪些？"></a>TCP 头格式有哪些？</h3><ul><li><p><strong>序列号</strong>：在建立连接时生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」（不包含首部大小）的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p><p><strong>控制位：</strong></p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示不会再有数据发送，希望断开连接。</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230330191311058.png" style="zoom:50%;" /><hr><h3 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a>什么是 TCP ？</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议：</p><ul><li><p><strong>面向连接</strong>：一定是「一对一」连接，不像 UDP 协议可以一个主机同时向多个主机发送消息，一对多是无法做到的；</p></li><li><p><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p></li><li><p><strong>字节流</strong>：通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。</p><ul><li>TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul></li></ul><blockquote><p><strong>什么是TCP连接？</strong></p><p>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合（Socket、序列号和窗口大小）称为连接。</p><p><strong>为什么 TCP 是面向字节流的协议？</strong></p><p>当用户消息通过 TCP 协议传输时，消息可能会被操作系统分组成多个的 TCP 报文，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。至于什么时候真正被发送，取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件。</p><p><strong>如何解决粘包</strong></p><ul><li>固定长度的消息；</li><li>特殊字符作为边界；</li><li>自定义消息结构。</li></ul></blockquote><hr><h3 id="如何唯一确定一个-TCP-连接呢？"><a href="#如何唯一确定一个-TCP-连接呢？" class="headerlink" title="如何唯一确定一个 TCP 连接呢？"></a>如何唯一确定一个 TCP 连接呢？</h3><p>TCP 四元组可以唯一的确定一个连接，四元组包括：源地址、源端口、目的地址、目的端口</p><ul><li>源地址和目的地址是在 IP 头部中，源端口和目的端口是在 TCP 头部中</li></ul><blockquote><p>有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</p><p>由于本地ip和端口固定，理论最大链接数&#x3D;客户端IP数*客户端端口数&#x3D;2^32 x 2^16。但实际会受文件描述符限制、内存限制</p></blockquote><hr><h3 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h3><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。UPD非常简单，头部只有 <code>8</code> 个字节：</p><ul><li>目标和源端口：告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度： UDP 首部的长度跟数据的长度之和。</li><li>校验和：为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230330192533307.png" style="zoom:33%;" /><p><strong>TCP 和 UDP 区别：</strong></p><ul><li><p><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但可以基于 UDP 传输协议实现一个可靠的传输协议</li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul></li></ul><p><strong>TCP 和 UDP 应用场景：</strong></p><ul><li>TCP 常用于：FTP文件传输、HTTP等</li><li>UDP常用于：包总量较少的通信DNS；视频、音频等多媒体通信；广播通信</li></ul><blockquote><p><strong>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</strong></p><ul><li>原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的</li></ul><p><strong>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong></p><ul><li>TCP计算负载数据长度方法：IP总长度-IP首部长度-TCP首部长度，因此TCP无需包长度字段也能计算出包长度</li><li>UDP也可利用上述方法求，有包长度字段的原因可能是以前UDP不一定基于IP</li></ul></blockquote><hr><h3 id="半连接队列、全连接队列是什么"><a href="#半连接队列、全连接队列是什么" class="headerlink" title="半连接队列、全连接队列是什么"></a>半连接队列、全连接队列是什么</h3><p>执行<code>listen方法</code>后，内核会为每一个处于<code>LISTEN</code>状态的<code>socket</code> 分配两个队列：</p><ul><li><p><strong>半连接队列（SYN队列）</strong>，服务端收到<strong>第一次握手</strong>后，会将<code>sock</code>加入到这个队列中，队列内的<code>sock</code>都处于<code>SYN_RECV</code> 状态。</p><ul><li><p>半连接队列是个哈希表；当收到第三次握手时，如果半连接队列是个链表，就需要依次遍历才能拿到想要的连接，算法复杂度就是O(n)。</p></li><li><p>通过以下命令可以查看当前半连接数量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> <span class="token parameter variable">-nt</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> <span class="token string">'127.0.0.1:8080'</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> <span class="token string">'SYN_RECV'</span> <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p><strong>全连接队列（ACCEPT队列）</strong>，在服务端收到<strong>第三次握手</strong>后，会将半连接队列的<code>sock</code>取出，放到全连接队列中。队列里的<code>sock</code>都处于 <code>ESTABLISHED</code>状态。这里面的连接，就<strong>等着服务端执行accept()后被取出了。</strong></p><ul><li>全连接队列是个链表</li><li>通过ss -lnt命令，可以看到全连接队列的大小，其中Send-Q是指全连接队列的最大值，Recv-Q是指当前的全连接队列的使用值</li></ul></li></ul><hr><h3 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h3><p><strong>可以</strong></p><p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序（相同协议）。</p><p>主机收到数据包后，根据 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p><hr><h3 id="TCP-三次握手过程是怎样的？"><a href="#TCP-三次握手过程是怎样的？" class="headerlink" title="TCP 三次握手过程是怎样的？"></a>TCP 三次握手过程是怎样的？</h3><ul><li>客户端会随机初始化序号，将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，之后客户端处于 <code>SYN-SENT</code> 状态。此阶段不能携带应用数据。</li><li>服务端收到 <code>SYN</code> 报文后，也随机初始化自己的序号，将此序号填入 TCP 首部的「序号」字段中，其次把 「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，之后服务端处于 <code>SYN-RCVD</code> 状态。此阶段不能携带应用数据。</li><li>客户端收到服务端报文后，向服务端回应最后一个应答报文，首应答报文  <code>ACK</code> 标志位置为 <code>1</code> ，「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，<strong>这次报文可以携带客户到服务端的数据</strong>，之后客户端处于 <code>ESTABLISHED</code> 状态。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230330202343022.png" style="zoom:50%;" /><blockquote><p>如何在 Linux 系统中查看 TCP 状态？在 Linux 可以通过 <code>netstat -napt</code> 命令查看</p></blockquote><hr><h3 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h3><ul><li><p><strong>三次握手才可以阻止重复历史连接的初始化（主要原因）</strong></p><ul><li><p>当旧SYN报文比新SYN报文先抵达时，服务器能会对其响应，但客户端收到后会发现并非预期报文，会回RST报文，服务器会关闭连接（二次连接也可以回RST报文，但无法避免丢失情况）。</p><blockquote><p>为什么 TCP 两次握手为什么无法阻止历史连接呢？</p><p>像上述情况，在收到旧报文并做出响应后，服务端就会建立连接，导致服务端资源浪费</p></blockquote></li></ul></li><li><p><strong>三次握手才可以同步双方的初始序列号</strong></p><ul><li>三次握手才能确保对方正确收到了自己报文，才能同步序列号</li></ul></li><li><p><strong>三次握手才可以避免资源浪费</strong></p><ul><li>如果只有「两次握手」，当客户端发生的 SYN 报文在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以服务端每收到一个 SYN 就只能先主动建立一个连接。导致建立多个冗余的无效链接，造成不必要的资源浪费。</li></ul></li></ul><blockquote><p><strong>如果客户端发送的第三次握手丢失，而又发送了数据，那数据会不会丢失？</strong></p><p>不会，即使服务端还是在 syn_received 状态，也是可以收数据的，而数据包中有ack和确认号，这个确认号和第三次握手的确认号一样。</p></blockquote><p>小结：不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><hr><h3 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h3><p>主要原因：</p><ul><li><p><strong>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</strong></p><ul><li><p>如果有报文被阻塞了，而服务器此时宕机重启，之前连接就断掉了，而与客户端又建立了一个新连接。如果被阻塞的报文此时到达，其序号很大可能就在服务端接受端口中，会被正常接受，从而导致数据错乱。</p></li><li><p>初始化序列化不同并不能完全阻止历史报文问题，还需要用时间戳来判断历史报文。如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包。</p><blockquote><p>解决时间戳回绕：</p><ul><li>增加时间戳的大小，由32 bit扩大到64bit：但会导致协议兼容问题</li><li>将一个与时钟频率无关的值作为时间戳，时钟频率可以增加但时间戳的增速不变</li></ul></blockquote></li></ul></li><li><p><strong>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</strong></p></li></ul><blockquote><p><strong>初始序列号 ISN 是如何随机产生的？</strong></p><p>ISN &#x3D; M + F</p><ul><li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li><li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。</li></ul></blockquote><hr><h3 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h3><p>当超过 <code>MTU</code> 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层</p><p>但是<strong>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文，也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发整个 TCP 报文。</p><blockquote><p>为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，即SYN报文中会有MSS值</p></blockquote><hr><h3 id="三次握手丢失分析"><a href="#三次握手丢失分析" class="headerlink" title="三次握手丢失分析"></a>三次握手丢失分析</h3><ul><li><p><strong>第一次握手丢失了，会发生什么？</strong></p><ul><li>当发送第一个报文后，进入到 <code>SYN_SENT</code> 状态。如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</li><li>不同系统重传时间不同，Linux系统重传次数默认为5，且每次超时等待时间翻倍。</li></ul></li><li><p><strong>第二次握手丢失了，会发生什么？</strong></p><ul><li><p>当服务端收到客户端的第一次握手后，会进入 <code>SYN_RCVD</code> 状态。当第二次握手丢失了，客户端和服务端都会重传：</p><ul><li><p>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code>内核参数决定；</p></li><li><p>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</p></li></ul></li></ul></li><li><p><strong>第三次握手丢失了，会发生什么</strong></p><ul><li>当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</li></ul></li></ul><hr><h3 id="什么是-SYN-攻击？如何避免-SYN-攻击"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击"></a>什么是 SYN 攻击？如何避免 SYN 攻击</h3><blockquote><p>内核中建立连接过程：</p><ul><li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li><li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li><li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出连接对象。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331112943795.png" style="zoom:50%;" /></blockquote><p><strong>SYN 攻击</strong>：把 TCP 半连接队列打满，这样当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接。</p><p>避免 SYN 攻击方式，可以有以下四种方法：</p><ul><li><p><strong>调大 netdev_max_backlog：</strong>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。调大 netdev_max_backlog值能增加该队列大小。</p></li><li><p><strong>增大 TCP 半连接队列：</strong>增大 TCP 半连接队列，要同时增大下面这三个参数：</p><ul><li>增大 net.ipv4.tcp_max_syn_backlog（主要参数，如果超过tcp_max_syn_backlog值则直接丢弃）</li><li>增大 listen() 函数中的 backlog（这个是全连接参数，但半连接丢弃逻辑里面会判断全连接是否满，如果满了则丢弃）</li><li>增大 net.core.somaxconn（全连接队列大小也受此参数影响）</li></ul></li><li><p><strong>开启 tcp_syncookies：</strong>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</p><ul><li><p>当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 <code>cookie</code> 值；</p></li><li><p>将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端（服务器不保存cookie）；</p></li><li><p>服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的cookie。如果合法，将该连接对象放入到「 Accept 队列」。</p></li><li><p>最后应用程序通过调用 <code>accpet()</code> 接口，从「 Accept 队列」取出的连接。</p><blockquote><p>注意！不会有一个cookies队列，它是通过通信双方的IP地址端口、时间戳、MSS等信息进行实时计算的，保存在TCP报头的seq里。当服务端收到客户端发来的第三次握手包时，会通过seq还原出通信双方的IP地址端口、时间戳、MSS，验证通过则建立连接。</p><p>简单说SYNcookie就是将连接信息编码在ISN(initialsequencenumber)中返回给客户端，这时server不需要将半连接保存在队列中，而是利用客户端随后发来的ACK带回的ISN还原连接信息，以完成连接的建立，避免了半连接队列被攻击SYN包填满。</p></blockquote></li></ul></li><li><p><strong>减少 SYN+ACK 重传次数：</strong>减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开</p></li></ul><blockquote><p><strong>如何增大 TCP 全连接队列？</strong></p><ul><li>TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，backlog 在listen时设定</li></ul><p><strong>cookies方案为什么不直接取代半连接队列？</strong></p><ul><li>因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。</li><li>编码解码cookies，都是比较耗CPU的，可能会出现cookies攻击，使得cpu耗费大量资源</li></ul></blockquote><hr><h3 id="TCP-四次挥手过程是怎样的？"><a href="#TCP-四次挥手过程是怎样的？" class="headerlink" title="TCP 四次挥手过程是怎样的？"></a>TCP 四次挥手过程是怎样的？</h3><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，之后进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。<ul><li>在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，这个 EOF 会被<strong>放在已排队等候的其他已接收的数据之后</strong>。当read读取到EOF后，如果有数据待发送则发送完数据才调用关闭连接函数，否则直接调用关闭连接函数。</li></ul></li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li></ul><blockquote><p><strong>主动关闭连接的，才有 TIME_WAIT 状态</strong></p></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331113717875.png" style="zoom:50%;" /><hr><h3 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h3><p>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，<strong>但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序</strong>：</p><ul><li>如果应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；</li><li>如果应用程序没有数据要发送的话，可以直接调用关闭连接的函数，</li></ul><hr><h3 id="四次挥手丢失分析"><a href="#四次挥手丢失分析" class="headerlink" title="四次挥手丢失分析"></a>四次挥手丢失分析</h3><ul><li><p><strong>第一次挥手丢失了，会发生什么？</strong></p><ul><li>客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文。当重传次数超过限制，那么等待一段时间后就直接进入close状态</li></ul></li><li><p><strong>第二次挥手丢失了，会发生什么？</strong></p><ul><li>客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</li></ul><blockquote><p>如果收到第二次挥手，客户端就会处于 <code>FIN_WAIT2</code> 状态，在这个状态需要等服务端发送第三次挥手：</p><ul><li>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以<code>FIN_WAIT2</code> 状态不可以持续太久，默认 60 秒。</li><li>如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭。如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 <code>FIN_WAIT2</code> 状态</li></ul></blockquote></li><li><p><strong>第三次挥手丢失了，会发生什么？</strong></p><ul><li>服务端就会重发 FIN 报文，直到达到最大重传次数</li></ul></li><li><p><strong>第四次挥手丢失了，会发生什么？</strong></p><ul><li>服务端就会重发 FIN 报文，直到达到最大重传次数</li></ul></li></ul><hr><h3 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h3><blockquote><p><code>MSL</code> 是指报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p><strong>MSL 与 TTL 的区别</strong>： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡</p></blockquote><p>如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p><blockquote><p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p></blockquote><hr><h3 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h3><p>主要是两个原因：</p><ul><li><strong>防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong><ul><li>由于序列号是会循环使用的，如果没有timewait状态，那么新建立的连接可能就会接受到历史连接的数据。</li><li>而timewait&#x3D;2msl 足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。（也可以利用时间戳过滤历史数据）</li></ul></li><li><strong>保证「被动关闭连接」的一方，能被正确的关闭</strong><ul><li>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</li><li>假设没有 TIME_WAIT 状态，在发完最后一次 ACK 报文就进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传FIN 报文，而客户端已经进入到关闭状态了，就会回 RST 报文。服务端收到这个 RST 会将其解释为一个错误。</li></ul></li></ul><hr><h3 id="TIME-WAIT-过多有什么危害"><a href="#TIME-WAIT-过多有什么危害" class="headerlink" title="TIME_WAIT 过多有什么危害"></a>TIME_WAIT 过多有什么危害</h3><ul><li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li><li>第二是占用端口资源，端口资源也是有限的。</li></ul><p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong></p><ul><li>如果占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接，但可以对不同IP或端口发起连接</li></ul><p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong></p><ul><li>并不会导致端口资源受限，因为服务端只监听一个端口，而客户端IP和端口是不同的。但会占用系统资源。</li></ul><hr><h3 id="如何优化-TIME-WAIT？"><a href="#如何优化-TIME-WAIT？" class="headerlink" title="如何优化 TIME_WAIT？"></a>如何优化 TIME_WAIT？</h3><ul><li><strong>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项</strong><ul><li>打开reuse参数后，可以将处于 TIME_WAIT 的 socket 为新的连接所用</li><li>tcp_tw_reuse 功能只能用于连接发起方，因为在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</li><li>开始reuse参数则必须打开timestamps，主要是根据时间戳来过滤历史数据。</li></ul></li><li><strong>net.ipv4.tcp_max_tw_buckets</strong><ul><li>系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</li></ul></li><li><strong>程序中使用 SO_LINGER ，应用强制使用 RST 关闭</strong><ul><li>对so_linger的<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</li></ul></li></ul><blockquote><p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p></blockquote><hr><h3 id="服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>服务器出现大量 TIME_WAIT 状态的原因有哪些？</h3><ul><li><strong>第一个场景：HTTP 没有使用长连接</strong><ul><li>在大多数 Web 服务的实现中，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</li></ul></li><li><strong>第二个场景：HTTP 长连接超时</strong><ul><li>一般在Web服务实现中，如果长连接超过60秒为传输数据，就会关闭连接，从而服务器上出现timewait状态</li></ul></li><li><strong>第三个场景：HTTP 长连接的请求数量达到上限</strong><ul><li>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</li></ul></li></ul><hr><h3 id="服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h3><p><strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p><p>可能原因如下：</p><ul><li>没有将服务端监听 socket 注册到 epoll，服务端无法获取新链接，也就不能对 socket 调用 close 函数。（第二次挥手的ACK是内核处理发送的）</li><li>有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数</li><li>通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端无法调用 close 函数</li><li>当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为死锁、代码bug等原因。</li></ul><hr><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP存在一个保活机制，需要创建socket时使用SO_KEEPALIVE参数，原理如下：</p><ul><li>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会每隔一个时间间隔，发送一个探测报文，如果连续几个探测报文都没有得到响应，则认为TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</li></ul><p>如果开启了 TCP 保活，会有以下几种情况：</p><ol><li><strong>对端程序是正常工作的</strong>。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。</li><li><strong>对端主机宕机并重启</strong>。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被重置。</li><li><strong>对端主机宕机或报文不可达</strong>。当连续几次探测报文没有响应则会报告该连接已死亡</li></ol><blockquote><p><strong>心跳机制</strong></p><p>TCP保活的检测时间过长，可以在应用层实现一个心跳机制。</p></blockquote><hr><h3 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h3><p>TCP 的连接信息是由内核维护的，当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与</p><hr><h3 id="listen-时候参数-backlog-的意义？"><a href="#listen-时候参数-backlog-的意义？" class="headerlink" title="listen 时候参数 backlog 的意义？"></a>listen 时候参数 backlog 的意义？</h3><p>在早期是指半连接队列，在linux2.2后指全连接队列长度。</p><p>但是 全连接队列长度 &#x3D; min(backlog, somaxconn)，somaxconn是内核一个参数</p><hr><h3 id="accept-发生在三次握手的哪一步？"><a href="#accept-发生在三次握手的哪一步？" class="headerlink" title="accept 发生在三次握手的哪一步？"></a>accept 发生在三次握手的哪一步？</h3><p><strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331162105259.png" style="zoom:50%;" /><hr><h3 id="没有-accept，能建立-TCP-连接吗？"><a href="#没有-accept，能建立-TCP-连接吗？" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h3><p><strong>可以</strong></p><p>accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。</p><hr><h3 id="没有-listen，能建立-TCP-连接吗？"><a href="#没有-listen，能建立-TCP-连接吗？" class="headerlink" title="没有 listen，能建立 TCP 连接吗？"></a>没有 listen，能建立 TCP 连接吗？</h3><p><strong>可以</strong></p><p>客户端是可以自己连自己的形成连接（<strong>TCP自连接</strong>），也可以两个客户端同时向对方发出请求建立连接（<strong>TCP同时打开</strong>），这两个情况都有个共同点，就是<strong>没有服务端参与，也就是没有 listen，就能 TCP 建立连接。</strong></p><h2 id="3-2-TCP-重传、滑动窗口、流量控制、拥塞控制"><a href="#3-2-TCP-重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="3.2 TCP 重传、滑动窗口、流量控制、拥塞控制"></a>3.2 TCP 重传、滑动窗口、流量控制、拥塞控制</h2><h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><ul><li><strong>超时重传</strong><ul><li>TCP 会在以下两种情况发生超时重传：数据包丢失；确认应答丢失；</li><li>超时时间是以RTO表示，其若过大会很久才回重传，若过小则重发次数显增，其应略大于报文往返RTT值。</li><li>Linux中，RTO计算方式考虑两个方面：<ol><li>TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，这个值是不断变化的</li><li>还要采样 RTT 的波动范围，避免如果 RTT 有一个大的波动的话，很难被发现</li></ol></li><li>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。</li></ul></li><li><strong>快速重传</strong><ul><li>当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</li><li><strong>需要解决重传的时候，是重传一个，还是重传所有的问题，为此设计了SACK。</strong>。例如，当发送了Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，所以发送方并不知道该重传哪些报文。</li></ul></li><li><strong>SACK方法</strong><ul><li><code>SACK</code>（ Selective Acknowledgment）， 选择性确认。在 TCP 头部「选项」字段里加一个 SACK ，可以将已收到的数据的信息发送给「发送方」，就可以只重传丢失的数据</li></ul></li><li><strong>Duplicate  SACK</strong><ul><li>又称 D-SACK，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。就是当ACK值大于SACK值时，就会认为SACK数据被重复接受。</li><li>例如传送了两个数据包，而「接收方」发给「发送方」的两个 ACK 确认应答都丢失，接收方发送了一个SACK告诉发送方第一个数据包被接受了，而此时ACK确认两个包都被接受，所以这个 SACK 就代表着 <code>D-SACK</code>。接受方就知道数据没丢，只是ACK丢了。</li><li>好处：<ul><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ul></li></ul></li></ul><hr><h3 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h3><p>由于等待每个请求返回再发送新请求会导致效率很低，因此引入了滑动窗口概念。只要在滑动窗口中的数据都可以直接发送。窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。</p><ul><li>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</li></ul><p><strong>窗口大小由哪一方决定？</strong></p><ul><li>通常窗口的大小是由接收方的窗口大小来决定的（还由拥塞窗口大小决定，取最小值）。</li><li>TCP 头有一个 <code>Window</code>字段，表示窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</li></ul><p><strong>程序是如何表示发送方的四个部分的呢？</strong></p><ul><li><code>SND.WND</code>：表示发送窗口的大小</li><li><code>SND.UNA</code>（<em>Send Unacknoleged</em>）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li><li><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</li><li>指向 #4 的第一个字节是个相对指针，它需要 <code>SND.UNA</code> 指针加上 <code>SND.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331191516242.png" style="zoom:67%;" /><p><strong>接收方的滑动窗口</strong></p><ul><li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li><li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li><li>指向 #4 的第一个字节是个相对指针，它需要 <code>RCV.NXT</code> 指针加上 <code>RCV.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331191722409.png" style="zoom:67%;" /><p><strong>接收窗口和发送窗口的大小是相等的吗？</strong></p><ul><li>并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。因为告诉发送方窗口大小是需要时延的。</li></ul><p><strong>窗口关闭问题</strong></p><ul><li>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</li><li><strong>窗口关闭导致的死锁问题</strong>：如果发送方现在是窗口关闭状态，如果接受方发送的一个新的窗口非0的报文丢失，那么发送方会一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，从而造成死锁。<ul><li>解决办法：TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</li></ul></li></ul><p><strong>糊涂窗口综合症</strong></p><ul><li>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。</li><li>由于头部存在，发送几个字节的数据利用率很低，解决办法：<ul><li>让接收方不通告小窗口给发送方：即小于一定空间，通告窗口为0</li><li>让发送方避免发送小数据：等到窗口大于一定阈值或收到之前发送数据的 <code>ack</code> 回包（Nagle 算法）</li></ul></li></ul><hr><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><blockquote><p>流量控制是避免「发送方」的数据填满「接收方」的缓存；拥塞控制是避免「发送方」的数据填满整个网络</p></blockquote><p>拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化。只要发生了超时重传，就会认为网络出现了拥塞。</p><ul><li><strong>慢启动</strong><ul><li>当发送方每收到一个数据的 ACK，拥塞窗口 cwnd 的大小就会加 1（加经过确认的数据大小）。</li><li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li></ul></li><li><strong>拥塞避免</strong><ul><li>每当收到一个数据的 ACK 时，cwnd 增加 1&#x2F;cwnd（线性增长）。</li></ul></li><li><strong>拥塞发生</strong>：当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：<ul><li>超时重传：<code>ssthresh</code> 设为 <code>cwnd/2</code>；cwnd<code>重置为</code>1（初始值）；</li><li>快速重传：cwnd &#x3D; cwnd&#x2F;2；<code>ssthresh = cwnd</code>;并进入快速恢复算法。</li></ul></li><li><strong>快速恢复</strong>：快速重传和快速恢复算法一般同时使用，因为还能收到 3 个重复 ACK 说明网络也不那么糟糕。算法如下：<ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值（是+3前的那个值），原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331194227959.png" style="zoom:80%;" /><h2 id="3-3-如何优化-TCP"><a href="#3-3-如何优化-TCP" class="headerlink" title="3.3 如何优化 TCP?"></a>3.3 如何优化 TCP?</h2><h3 id="TCP-三次握手的性能提升"><a href="#TCP-三次握手的性能提升" class="headerlink" title="TCP 三次握手的性能提升"></a><strong>TCP 三次握手的性能提升</strong></h3><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401154456625.png" style="zoom:50%;" /><ul><li><p><strong>客户端优化</strong></p><ul><li><strong>SYN_SENT 状态的优化</strong>：客户端在发送SYN报文后会等待服务器的报文，如果一直没等到则会重传SYN报文。因此可以根据网络的稳定性和目标服务器的繁忙程度修改 SYN 的重传次数，调整客户端的三次握手时间上限</li></ul></li><li><p><strong>服务端优化</strong></p><ul><li><strong>SYN_RCV 状态的优化</strong>：服务端在发送第二次握手后，如果一直没有回应则会重传报文。因此也可以根据网络情况设置重传次数和重传时间。</li><li><strong>调整SYN半连接队列长度</strong>：通过 <code>tcp_max_syn_backlog、somaxconn、backlog</code> 参数来调整 SYN 半连接队列的大小。</li><li><strong>调整accpet全连接队列长度</strong>：通过 listen 函数的 <code>backlog</code> 参数和 <code>somaxconn</code> 系统参数提高队列大小</li><li><strong>开启tcp_syncookies</strong>：如果遭受 SYN 攻击，应把 <code>tcp_syncookies</code> 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接成功建立。</li></ul></li><li><p><strong>绕过三次握手</strong></p><ul><li><strong>TCP Fast Open</strong>：<ul><li>第一次三次握手建立连接时，服务器生成cookie交给客户端缓存起来。</li><li>当第二次想再次建立连接时，客户端发送的SYN报文中包含请求数据和Cookie，服务器会对cookie进行验证，如果有效则对请求数据进行处理，并返回SYN+ACK报文和请求响应报文。</li><li>cookie 的值是存放到 TCP option 字段</li></ul></li></ul></li></ul><blockquote><p><strong>accept 队列已满，只能丢弃连接吗？</strong></p><ul><li>丢弃连接只是 Linux 的默认行为，还可以选择向客户端发送 RST 复位报文，告诉客户端连接已经建立失败。需要将 tcp_abort_on_overflow 参数设置为 1。</li></ul></blockquote><hr><h3 id="TCP-四次挥手的性能提升"><a href="#TCP-四次挥手的性能提升" class="headerlink" title="TCP 四次挥手的性能提升"></a><strong>TCP 四次挥手的性能提升</strong></h3><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401154407005.png" style="zoom:50%;" /><ul><li><strong>主动关闭方的优化</strong><ul><li>FIN_WAIT1 状态的优化：发送第一次挥手后，如果未收到ack报文会重传，因此可以优化重传次数</li><li>FIN_WAIT2 状态的优化：根据关闭方式不同，优化方式不同：<ul><li>close函数关闭：这是一个孤儿连接，如果tcp_fin_timeout时间内没收到FIN报文，就直接关闭。可使用tcp_max_orphans参数来限制最大孤儿连接数量。</li><li>shutdown函数关闭：此函数关闭会一直等待FIN报文，其不受tcp_max_orphans参数限制。</li></ul></li><li>TIME_WAIT 状态的优化：<ul><li>Linux 提供了 tcp_max_tw_buckets 参数，当 TIME_WAIT 的连接数量超过该参数时，新关闭的连接就不再经历 TIME_WAIT 而直接关闭；当连接过多时，可以适当调大<code>tcp_max_tw_buckets</code> 参数，减少不同连接间数据错乱的概率。</li><li>打开 tcp_tw_reuse 参数复用处于 TIME_WAIT 状态的连接（只能用于连接发起方，因为是在调用 connect() 时起作用的）</li><li>设置so_linger，如果其<code>l_onoff</code> 为非 0， 且 <code>l_linger</code> 值为 0，那么调用 close 后，会立该发送一个 RST 标志给对端，也就跳过了 TIME_WAIT 状态，直接关闭（只推荐客户端使用）。</li></ul></li></ul></li><li><strong>被动关闭方的优化</strong><ul><li>被动关闭的连接方应对非常简单，它在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。</li><li>当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，会在 <code>tcp_orphan_retries</code> 参数的控制下重发 FIN 报文</li></ul></li></ul><blockquote><p><strong>如果连接双方同时关闭连接，会怎么样？</strong></p><ul><li>两方发送 FIN 报文时，都认为自己是主动方，所以都进入了 FIN_WAIT1 状态</li><li>双方在等待 ACK 报文的过程中，都等来了 FIN 报文。这是一种新情况，所以连接会进入一种叫做 CLOSING 的新状态，它替代了 FIN_WAIT2 状态。</li><li>双方内核回复 ACK 确认对方发送通道的关闭后，进入 TIME_WAIT 状态，等待 2MSL 的时间后，连接自动关闭。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401153825397.png" style="zoom:33%;" /></blockquote><hr><h3 id="TCP-数据传输的性能提升"><a href="#TCP-数据传输的性能提升" class="headerlink" title="TCP 数据传输的性能提升"></a><strong>TCP 数据传输的性能提升</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401154704168.png"></p><ul><li><strong>扩大滑动窗口大小</strong>：通过设置 <code>tcp_window_scaling</code> 提升滑动窗口的上限（需要考虑带宽时延积进行设置）</li><li><strong>调整发送缓冲区</strong>：通过 tcp_wmem 参数配置缓冲区大小。发送缓冲区是自行调节的，当发送方发送的数据被确认后，并且没有新的数据要发送，就会把发送缓冲区的内存释放掉。</li><li><strong>调整接受缓冲区</strong>：通过设置tcp_rmem 参数配置接收缓冲区大小。需要配置 tcp_moderate_rcvbuf 为 1 来开启自动调节功能。</li><li><strong>调节 TCP 内存范围</strong>：通过 tcp_mem 配置不自动调节范围、自动调节范围、不分配新内存范围。</li><li><strong>根据实际场景</strong><ul><li>在高并发服务器中，为了兼顾网速与大量的并发连接，我们应当保证缓冲区的动态调整的最大值达到带宽时延积，而最小值保持默认的 4K 不变即可。而对于内存紧张的服务而言，调低默认值是提高并发的有效手段。</li><li>如果是网络 IO 型服务器，调大 tcp_mem 的上限可以让 TCP 连接使用更多的系统内存，这有利于提升并发能力。千万不要在 socket 上直接设置 SO_SNDBUF 或者 SO_RCVBUF，这样会关闭缓冲区的动态调整功能。</li></ul></li></ul><h2 id="3-4-SYN-报文什么时候情况下会被丢弃？"><a href="#3-4-SYN-报文什么时候情况下会被丢弃？" class="headerlink" title="3.4 SYN 报文什么时候情况下会被丢弃？"></a>3.4 SYN 报文什么时候情况下会被丢弃？</h2><p>两种场景：</p><ul><li><strong>开启 tcp_tw_recycle 参数，并且在 NAT 环境下，造成 SYN 报文被丢弃</strong><ul><li>Linux提供了两个参数来快速回收处于 TIME_WAIT 状态的连接，一个是net.ipv4.tcp_tw_reuse，一个是net.ipv4.tcp_tw_recycle。都需要打开时间戳才能生效。</li><li>如果同时开启了recycle 和 timestamps 选项，则会开启一种称之为「 per-host 的 PAWS 机制」<ul><li>PAWS 机制是防止 TCP 包中的序列号发生绕回。PAWS 要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</li><li>per-host 是对「对端 IP 做 PAWS 检查」，而非对「IP + 端口」四元组做 PAWS 检查</li></ul></li><li>当客户端是在NAT网关中，其对外IP是相同的。当使用recycle时，如果A客户端已经连接，然后服务器主动关闭并且快速回收 TIME-WAIT 状态的连接后，此时B客户端也建立连接，如果客户端 B 的 timestamp 比 客户端 A 的 timestamp 小，那么由于服务端的 per-host 的 PAWS 机制的作用，服务端就会丢弃客户端主机 B 发来的 SYN 包。</li></ul></li><li><strong>TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃</strong><ul><li>当TCP 半连接队列满了，后面来的 syn 包都会被丢弃。但如果开启了syncookies 功能，即使半连接队列满了，也不会丢弃syn 包。</li><li>当TCP全连接队列满了，后续的连接就会被丢弃，这样就会出现服务端请求数量上不去的现象（有点不对题，全连接满影响的是第三次ACK报文，于SYN报文丢弃无关）</li></ul></li></ul><h2 id="3-5-已建立连接的TCP，收到SYN会发生什么？"><a href="#3-5-已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="3.5 已建立连接的TCP，收到SYN会发生什么？"></a>3.5 已建立连接的TCP，收到SYN会发生什么？</h2><blockquote><p>一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，一直处于 Established 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理？</p></blockquote><p>TCP是由四元组确定，因此需要看客户端的源端口是否发生变化：</p><ul><li><p><strong>客户端的 SYN 报文里的端口号与历史连接不相同</strong></p></li><li><p>此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。</p></li><li><p>而旧连接中，如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</p></li><li><p><strong>客户端的 SYN 报文里的端口号与历史连接相同</strong></p></li><li><p>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</p></li><li><p>客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</p></li></ul><hr><h3 id="如何关闭一个-TCP-连接？"><a href="#如何关闭一个-TCP-连接？" class="headerlink" title="如何关闭一个 TCP 连接？"></a>如何关闭一个 TCP 连接？</h3><p>最简单办法是杀掉进程，但如果服务端杀掉进程会导致其他连接都会被关闭，无法继续提供访问服务。</p><p><strong>解决办法</strong>：伪造一个四元组相同的 RST 报文，但必须拿到连接的序列号否则RST报文会被拒绝。</p><p><strong>如何拿到序列号？</strong></p><ul><li>处于 Established 状态的服务端，收到四元组相同的 SYN 报文后，会回复一个 Challenge ACK，这个 ACK 报文里的「确认号」，正好是服务端下一次想要接收的序列号。</li></ul><p><strong>killcx原理</strong>：主动像服务端发送 SYN 包获取 SEQ&#x2F;ACK 号，然后利用 SEQ&#x2F;ACK 号伪造两个 RST 报文分别发给客户端和服务端，这样双方的 TCP 连接都会被释放，这种方式活跃和非活跃的 TCP 连接都可以杀掉。</p><p><strong>tcpkill原理</strong>：在双方进行 TCP 通信时，拿到对方下一次期望收到的序列号，然后将序列号填充到伪造的 RST 报文，并将其发送给对方，达到关闭 TCP 连接的效果。这种方式无法关闭非活跃的 TCP 连接；</p><blockquote><p>如何伪造成四元组相同的连接？报文伪造很简单，但是对方会根据报文的IP来发送回文，不是主机IP也收不到</p><p>应该需要拦截发送的报文进行处理</p></blockquote><h2 id="3-6-四次挥手中收到乱序的-FIN-包会如何处理？"><a href="#3-6-四次挥手中收到乱序的-FIN-包会如何处理？" class="headerlink" title="3.6 四次挥手中收到乱序的 FIN 包会如何处理？"></a>3.6 四次挥手中收到乱序的 FIN 包会如何处理？</h2><blockquote><p>如果服务端在二三次挥手之间发了数据，但因为网络延迟而导致第三次挥手的FIN比数据包先到，会怎么处理？</p></blockquote><p><strong>答案</strong></p><ul><li>在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。</li><li>等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。</li></ul><h2 id="3-7-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？"><a href="#3-7-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？" class="headerlink" title="3.7 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？"></a>3.7 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</h2><ul><li><strong>收到合法 SYN</strong><ul><li>如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程。</li></ul></li><li><strong>收到非法的 SYN</strong><ul><li>如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，就会再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端。</li></ul></li></ul><p><strong>在 TIME_WAIT 状态，收到 RST 会断开连接吗？</strong></p><ul><li>如果 <code>net.ipv4.tcp_rfc1337</code> 参数为 0，则提前结束 TIME_WAIT 状态，释放连接。</li><li>如果 <code>net.ipv4.tcp_rfc1337</code> 参数为 1，则会丢掉该 RST 报文。</li></ul><blockquote><ul><li><strong>合法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。</li><li><strong>非法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。</li></ul></blockquote><h2 id="3-8-12-TCP-连接，一端断电和进程崩溃有什么区别？"><a href="#3-8-12-TCP-连接，一端断电和进程崩溃有什么区别？" class="headerlink" title="3.8 12 TCP 连接，一端断电和进程崩溃有什么区别？"></a>3.8 12 TCP 连接，一端断电和进程崩溃有什么区别？</h2><p>当TCP没有开启keepalive，也没有数据交换时：</p><ul><li><strong>主机崩溃</strong><ul><li>客户端主机崩溃了（断电也属于崩溃一种），服务端是无法感知到的，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。</li></ul></li><li><strong>进程崩溃</strong><ul><li>TCP 的连接信息是由内核维护的，内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与</li></ul></li></ul><p>当TCP没有开启keepalive，却有数据交换时：</p><ul><li><strong>客户端主机宕机，又迅速重启</strong><ul><li>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发超时重传机制。</li><li>服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：<ul><li>如果客户端主机上没有进程绑定该 TCP 报文的目标端口号，那么客户端内核就会回复 RST 报文，重置该 TCP 连接；</li><li>如果客户端主机上有进程绑定该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会回复 RST 报文，重置该 TCP 连接。</li><li>因此，只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接</li></ul></li></ul></li><li><strong>客户端主机宕机，一直没有重启</strong><ul><li>服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，于是服务端的 TCP 连接就会断开。</li></ul></li></ul><blockquote><p><strong>TCP 的数据报文具体重传几次呢？</strong></p><p>Linux中tcp_retries2 默认为15，但还会根据tcp_retries2 算出一个timeout，如果重传间隔超过这个 timeout，则认为超过了阈值，就会停止重传，然后就会断开 TCP 连接。</p></blockquote><h2 id="3-9-拔掉网线后，-原本的-TCP-连接还存在吗？"><a href="#3-9-拔掉网线后，-原本的-TCP-连接还存在吗？" class="headerlink" title="3.9 拔掉网线后， 原本的 TCP 连接还存在吗？"></a>3.9 拔掉网线后， 原本的 TCP 连接还存在吗？</h2><p>客户端拔掉网线后，并不会直接影响 TCP 连接状态。拔掉网线后，TCP 连接是否还会存在，关键要看有没有进行数据传输：</p><ul><li><p><strong>有数据传输的情况：</strong></p><ul><li><p>如果服务端发送了数据报文，在服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在。</p></li><li><p>如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。</p></li></ul></li><li><p><strong>没有数据传输的情况：</strong></p><ul><li><p>如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。</p></li><li><p>如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。</p></li></ul></li></ul><h2 id="3-10-tcp-tw-reuse-为什么默认是关闭的？"><a href="#3-10-tcp-tw-reuse-为什么默认是关闭的？" class="headerlink" title="3.10 tcp_tw_reuse 为什么默认是关闭的？"></a>3.10 tcp_tw_reuse 为什么默认是关闭的？</h2><blockquote><p>这题在变相问「<strong>如果 TIME_WAIT 状态持续时间过短或者没有，会有什么问题？</strong>」</p></blockquote><p>开启 tcp_tw_reuse 会有 2 个问题：</p><ol><li>虽然 tcp_tw_reuse 的同时，也需要开启 tcp_timestamps，但 <strong>RST 报文的时间戳即使过期了，只要 RST 报文的序列号在对方的接收窗口内，也是能被接受的</strong>。<ul><li>这样如果有历史RST报文存在可能会导致新连接被断开，如果设置了timewait状态，历史rst报文就会消失。</li></ul></li><li>如果第四次挥手的 ACK 报文丢失了，服务端会触发超时重传，重传第三次挥手报文，而重用后的连接处于 syn_sent 状态，收到服务端重传第三次挥手报文，则会回 RST 给服务端，导致服务端不能被正常关闭。</li></ol><blockquote><p><strong>如果 TIME_WAIT 状态被快速复用后，刚好第四次挥手的 ACK 报文丢失了，那客户端复用 TIME_WAIT 状态后发送的 SYN 报文被处于 last_ack 状态的服务端收到了会发生什么呢？</strong></p><ul><li>处于 last_ack 状态的服务端收到了 SYN 报文后，会回复确认号与服务端上一次发送 ACK 报文一样的 ACK 报文，这个 ACK 报文称为 Challenge ACK ，并不是确认收到 SYN 报文。</li><li>处于 syn_sent 状态的客户端收到服务端的 Challenge ACK后，发现不是自己期望收到的确认号，于是就会回复 RST 报文，服务端收到后，就会断开连接。</li></ul></blockquote><h2 id="3-11-HTTPS-中-TLS-和-TCP-能同时握手吗？"><a href="#3-11-HTTPS-中-TLS-和-TCP-能同时握手吗？" class="headerlink" title="3.11 HTTPS 中 TLS 和 TCP 能同时握手吗？"></a>3.11 HTTPS 中 TLS 和 TCP 能同时握手吗？</h2><p>一般情况下，不管 TLS 握手次数如何，都得先经过 TCP 三次握手后才能进行。</p><p>HTTPS 中的 TLS 握手过程同时进行三次握手需要特定条件：</p><ul><li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong><ul><li>开启了TCP FAST OPEN后，当第二次建立连接时可以绕过三次握手直接发送数据，携带Cookies即可</li><li>TLS1.3也存在会话恢复机制，在第一次发送数据时携带上TLS握手数据即可。</li></ul></li><li><strong>客户端和服务端已经完成过一次通信。</strong></li></ul><blockquote><p><strong>TCP 连接的第三次握手是可以携带数据的，如果客户端在第三次握手发送了 TLSv1.3 第一次握手数据，是不是就表示「<em>HTTPS 中的 TLS 握手过程可以同时进行三次握手</em>」？</strong></p><ul><li>TLS握手是在应用层，服务端只有在收到客户端的 TCP 的第三次握手后，才能和客户端进行后续 TLSv1.3 握手。</li></ul></blockquote><h2 id="3-12-TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？"><a href="#3-12-TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？" class="headerlink" title="3.12 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？"></a>3.12 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</h2><p>这两个完全是两样不同东西，实现的层面也不同：</p><ul><li><p><strong>HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接；</strong></p><ul><li><p>HTTP 的 Keep-Alive 实现了使用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销，这个方法称为 HTTP 长连接。</p></li><li><p>其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态</p><blockquote><p>如果客户端完成一个 HTTP 请求后，就不再发起新的请求，会导致资源浪费。因此一般会设置一个定时器，在一定时间没有请求则释放连接。</p></blockquote></li></ul></li><li><p><strong>TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制；</strong></p><ul><li>TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活</li><li>keepalive的默认时间为2小时，由于过于长久，因此可以设定一个心跳机制来判断是否存活</li></ul></li></ul><h2 id="3-13-TCP-协议有什么缺陷？"><a href="#3-13-TCP-协议有什么缺陷？" class="headerlink" title="3.13 TCP 协议有什么缺陷？"></a>3.13 TCP 协议有什么缺陷？</h2><p>TCP 协议缺陷：</p><ul><li><strong>升级 TCP 的工作很困难</strong>：TCP 协议是在内核中实现的，应用程序只能使用不能修改，如果要想升级 TCP 协议，那么只能升级内核，而升级内核工作十分繁琐。</li><li><strong>TCP 建立连接的延迟</strong>：TCP Fast Open能解决延迟问题，但需要客户端和服务端都支持，而现在却并未普及。<ul><li>对 HTTPS 来说，TLS 是在应用层实现的握手，而 TCP 是在内核实现的握手，这两个握手过程是无法结合在一起的，总是得先完成 TCP 握手，才能进行 TLS 握手。</li><li>TCP 是在内核实现的，所以 TLS 是无法对 TCP 头部加密的，这意味着 TCP 的序列号都是明文传输，所以就存安全的问题。</li></ul></li><li><strong>TCP 存在队头阻塞问题</strong>：TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据</li><li><strong>网络迁移需要重新建立 TCP 连接</strong>：TCP是通过四元组确定一条连接，当设备从网络切换时需要重新建立TCP连接。</li></ul><h2 id="3-14-如何基于-UDP-协议实现可靠传输？"><a href="#3-14-如何基于-UDP-协议实现可靠传输？" class="headerlink" title="3.14 如何基于 UDP 协议实现可靠传输？"></a>3.14 如何基于 UDP 协议实现可靠传输？</h2><h3 id="QUIC-是如何实现可靠传输的？"><a href="#QUIC-是如何实现可靠传输的？" class="headerlink" title="QUIC 是如何实现可靠传输的？"></a><strong>QUIC 是如何实现可靠传输的？</strong></h3><p>如HTTP3为例，在 UDP 报文头部与 HTTP 消息之间，共有 3 层头部：<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403155224700.png" style="zoom:67%;" /></p><ul><li><p><strong>Packet Header</strong></p><ul><li><p>可分为两种头部：</p><ul><li>Long Packet Header 用于首次建立连接。包含源连接ID和目标连接ID。</li><li>Short Packet Header 用于日常传输数据。包含目标连接ID、编号和数据（没有源连接ID）<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403155523216.png" style="zoom: 33%;" /></li></ul></li><li><p>QUIC 也是需要三次握手来建立连接的，主要目的是为了协商连接 ID。协商出连接 ID 后，后续传输时，双方只需要固定住连接 ID，从而实现连接迁移功能。</p></li><li><p><code>Packet Number</code> 是每个报文独一无二的编号，它是<strong>严格递增</strong>的，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。原因如下：</p><ul><li>如果使用原来的编号，发送方无法知道确认号是对第一次的确认还是重传的确认，使得RTT采样不准确</li><li>更便于支持乱序确认，不会因重传而阻塞在原地</li></ul><blockquote><p>编号不一样，那报文？岂不是乱序</p><p>QUIC分离了编号的确认功能和数据有序功能，在frame层还有一个序号用于数据顺序</p></blockquote></li></ul></li><li><p><strong>QUIC Frame Header</strong></p><ul><li><p>一个 Packet 报文中可以存放多个 QUIC Frame，每一个 Frame 都有明确的类型，针对类型的不同，功能也不同，自然格式也不同。例如stream类型的frame格式如下：</p><ul><li>Stream ID ：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别，类似于 HTTP2 的 Stream ID；</li><li>Offset ：类似于 TCP 协议中的 Seq 序号，<strong>保证数据的顺序性和可靠性</strong>；</li><li>Length ：指明了 Frame 数据的长度。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403160152234.png" style="zoom:33%;" /></li><li><p><strong>通过 Stream ID + Offset 字段信息实现数据的有序性</strong>，通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。</p></li></ul><p>QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装</p></li></ul><hr><h3 id="QUIC-是如何解决-TCP-队头阻塞问题的？"><a href="#QUIC-是如何解决-TCP-队头阻塞问题的？" class="headerlink" title="QUIC 是如何解决 TCP 队头阻塞问题的？"></a>QUIC 是如何解决 TCP 队头阻塞问题的？</h3><blockquote><p>HTTP&#x2F;2 多个 Stream 请求都是在一条 TCP 连接上传输，这意味着多个 Stream 共用同一个 TCP 滑动窗口，那么当发生数据丢失，滑动窗口是无法往前移动的，此时就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。</p></blockquote><p><strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。</p><hr><h3 id="QUIC-是如何做流量控制的？"><a href="#QUIC-是如何做流量控制的？" class="headerlink" title="QUIC 是如何做流量控制的？"></a>QUIC 是如何做流量控制的？</h3><p>QUIC 实现流量控制的方式：</p><ul><li>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。</li><li>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。</li></ul><p>QUIC 实现了两种级别的流量控制：</p><ul><li><p><strong>Stream 级别的流量控制</strong>：</p><ul><li><p>Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</p></li><li><p>整个滑动窗口可以分为最大接受窗口和接收窗口：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403161209035.png" style="zoom:50%;" /></li><li><p>接收窗口的左边界取决于接收到的最大偏移字节数，此时的接收窗口 &#x3D; 最大窗口数 - 接收到的最大偏移数。</p></li><li><p>当图中的绿色部分数据超过最大接收窗口的一半后，最大接收窗口向右移动，接收窗口的右边界也向右扩展，同时给对端发送「窗口更新帧」，当发送方收到接收方的窗口更新帧后，发送窗口的右边界也会往右扩展，以此达到窗口滑动的效果。</p><blockquote><p>QUIC 的流量控制和 TCP 区别：</p><ul><li>TCP 的接收窗口只有在前面所有的 Segment 都接收的情况下才会移动左边界，当在前面还有字节未接收但收到后面字节的情况下，窗口也不会移动。</li><li>QUIC 的接收窗口的左边界滑动条件取决于接收到的最大偏移字节数。</li></ul></blockquote></li></ul></li><li><p><strong>Connection 流量控制</strong>：</p><ul><li>限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。</li><li>其接收窗口大小就是各个 Stream 接收窗口大小之和。</li></ul></li></ul><blockquote><p><strong>QUIC如何做到乱序确认？</strong></p><ul><li>发送缓冲区根据尚未接收到确认的数据包来移动缓冲区左边界（即当前已提交的偏移量）</li><li>当发送方的缓存区收缩到阈值，接收方发送 MAX_STREAM_DATA Frame（协商缓存大小的特定帧）给发送方，请求增长最大绝对字节偏移量。协商完毕后最大绝对字节偏移量右移，发送方的缓存区变大</li><li>当发送方发现有数据包超时，则将超时数据包重新编号为 当前最大值继续发送</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403162210765.png" style="zoom:50%;" /></blockquote><hr><h3 id="QUIC-对拥塞控制改进"><a href="#QUIC-对拥塞控制改进" class="headerlink" title="QUIC 对拥塞控制改进"></a>QUIC 对拥塞控制改进</h3><ul><li>QUIC 协议当前默认使用了 TCP 的 Cubic 拥塞控制算法（慢开始、拥塞避免、快重传、快恢复策略），同时也支持 CubicBytes、Reno、RenoBytes、BBR、PCC 等拥塞控制算法</li><li>QUIC 是处于应用层的，应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。因此可以可以针对不同的应用设置不同的拥塞控制算法。</li></ul><hr><h3 id="QUIC-更快的连接建立"><a href="#QUIC-更快的连接建立" class="headerlink" title="QUIC 更快的连接建立"></a>QUIC 更快的连接建立</h3><p>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p><ul><li>当HTTP&#x2F;3 使用会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT</li></ul><hr><h3 id="QUIC-是如何迁移连接的？"><a href="#QUIC-是如何迁移连接的？" class="headerlink" title="QUIC 是如何迁移连接的？"></a>QUIC 是如何迁移连接的？</h3><p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><h2 id="3-15-TCP-和-UDP-可以使用同一个端口吗？"><a href="#3-15-TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="3.15 TCP 和 UDP 可以使用同一个端口吗？"></a>3.15 TCP 和 UDP 可以使用同一个端口吗？</h2><p><strong>TCP 和 UDP 可以同时绑定相同的端口吗？</strong></p><ul><li>可以</li><li>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，然后模块根据报文「端口号」确定送给哪个应用程序处理</li></ul><p><strong>多个 TCP 服务进程可以绑定同一个端口吗？</strong></p><ul><li>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。</li><li>有些机器有多个IP，此时如果绑定IP不同，而端口相同也是能绑定成功</li><li>注意，0.0.0.0 地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0 地址，相当于把主机上的所有 IP 地址都绑定了</li></ul><blockquote><p>如果想多个进程绑定相同的 IP 地址和端口，也是有办法的，就是对 socket 设置 SO_REUSEPORT 属性（内核 3.9 版本提供的新特性）</p></blockquote><p><strong>客户端的端口可以重复使用吗？</strong></p><ul><li>客户端在执行 connect 函数的时候，会在内核里随机选择一个端口，然后向服务端发起 SYN 报文，然后与服务端进行三次握手。</li><li>如果重复使用端口是连接不同IP+端口，那么可以重复使用。否则不可重复使用（主机只有一个IP情况下）</li></ul><p><strong>多个客户端可以 bind 同一个端口吗？</strong></p><ul><li>如果多个客户端绑定的 IP + PORT 相同，那么在执行 bind() 时候就会出错。否则不会出错。</li></ul><p><strong>客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？</strong></p><ul><li>如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了</li><li>只要客户端连接的服务器不同，端口资源可以重复使用的</li></ul><p><strong>客户端端口选择的流程</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401205103176.png" style="zoom: 25%;" /><h2 id="3-16-服务端没有-listen，客户端发起连接建立，会发生什么？"><a href="#3-16-服务端没有-listen，客户端发起连接建立，会发生什么？" class="headerlink" title="3.16 服务端没有 listen，客户端发起连接建立，会发生什么？"></a>3.16 服务端没有 listen，客户端发起连接建立，会发生什么？</h2><p>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。</p><ul><li>没有调用 listen 函数，也就找不到监听该端口的 socket</li></ul><p><strong>不使用 listen ，可以建立 TCP 连接吗？</strong></p><ul><li>可以的，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接。</li></ul><p><strong>那没有listen，为什么还能建立连接？</strong></p><ul><li>因为<strong>半连接队列和全连接队列都是在执行 listen 方法时内核创建的</strong>，所以客户端没有执行listen也就不会创建两种队列。</li><li>但内核还有个全局 hash 表，可以用于存放 sock 连接的信息。<ul><li>在 TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash 表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash 中取出信息。于是握手包一来一回，最后成功建立连接。</li><li>而两个客户端同时打开原理也类似</li></ul></li></ul><h2 id="3-17-用了-TCP-协议，数据一定不会丢吗？"><a href="#3-17-用了-TCP-协议，数据一定不会丢吗？" class="headerlink" title="3.17 用了 TCP 协议，数据一定不会丢吗？"></a>3.17 用了 TCP 协议，数据一定不会丢吗？</h2><p>数据包的发送和接收流程：</p><ul><li>消息会从应用所在的用户空间拷贝到内核空间的发送缓冲区（send buffer），数据包就这样顺着传输层、网络层，进入到数据链路层，在这里数据包会经过流控（qdisc），再通过RingBuffer发到物理层的网卡。数据就这样顺着网卡发到了纷繁复杂的网络世界里。这里头数据会经过n多个路由器和交换机之间的跳转，最后到达目的机器的网卡处。</li><li>目的机器的网卡会通知DMA将数据包信息放到RingBuffer中，再触发一个硬中断给CPU，CPU触发软中断让ksoftirqd去RingBuffer收包，于是一个数据包就这样顺着物理层，数据链路层，网络层，传输层，最后从内核空间拷贝到用户空间里的聊天软件里。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401212856546.png" style="zoom:80%;" /><p>数据传输中可能发生丢包的情况：</p><ul><li><p><strong>建立连接时丢包</strong></p><ul><li>半连接、全连接队列都有长度限制，如果它们满了，那新来的包就会被丢弃。</li></ul></li><li><p><strong>流量控制丢包</strong></p><ul><li>应用层发送的数据在通过传输层、网络层后，进入网卡前会进行排队处理，其队列名叫qdisc。当发送数据过快，流控队列长度txqueuelen又不够大时，就容易出现丢包现象</li></ul></li><li><p><strong>RingBuffer过小导致丢包</strong></p><ul><li>在接收数据时，会将数据暂存到RingBuffer接收缓冲区中，然后等着内核触发软中断慢慢收走。如果这个缓冲区过小，而这时候发送的数据又过快，就有可能发生溢出，此时也会产生丢包。</li></ul></li><li><p><strong>网卡性能不足</strong></p><ul><li>网卡传输速度是有上限的。当网络传输速度过大，达到网卡上限时，就会发生丢包</li></ul></li><li><p><strong>接收缓冲区丢包</strong></p><ul><li>在TCP编程中，会为每一个socket建立一个发送缓冲区和接收缓冲区。当收到数据后，将数据拷贝到接收缓冲区就完事，发送数据也是拷贝到发送缓冲区就完事。发送缓冲区在这种情况下一般不会丢失数据，但接受缓冲区满了之后，虽然会向发送方报告接收窗口为0，但仍然可能有数据被发送过来，从而导致数据丢失。</li></ul></li><li><p><strong>两端之间的网络丢包</strong></p><ul><li>数据传输链路上可能会发生丢包</li></ul></li></ul><p><strong>TCP只保证数据从A机器的传输层可靠地发到B机器的传输层，即保证发到了对方的传输层TCP接收缓冲区</strong>，但应用还需要将数据从TCP的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。发送端以为自己发的消息已经发给对方了，但接收端却并没有收到这条消息。</p><ul><li>解决方法：在应用层实现可靠性</li></ul><blockquote><p><strong>两端通信的时候也能对账，为什么还要引入第三端服务器？</strong></p><ul><li>如果引入服务端，你只需要跟服务器建立<code>1个</code>连接，而不需要跟每个人建立连接。</li><li>安全问题，如果是两端通信，随便一个人找你对账一下，你就把聊天记录给同步过去了，这并不合适吧。如果对方别有用心，信息就泄露了。引入第三方服务端就可以很方便的做各种鉴权校验。</li><li>软件版本问题。两端的软件版本跨度太大，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件。</li></ul></blockquote><h2 id="3-18-TCP-四次挥手，可以变成三次吗？"><a href="#3-18-TCP-四次挥手，可以变成三次吗？" class="headerlink" title="3.18 TCP 四次挥手，可以变成三次吗？"></a>3.18 TCP 四次挥手，可以变成三次吗？</h2><p><strong>为什么 TCP 挥手需要四次呢？</strong></p><ul><li>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序</li><li>因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，所以服务端的 ACK 和 FIN 一般都会分开发送</li></ul><p><strong>粗暴关闭 vs 优雅关闭</strong></p><ul><li>close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。由于不再具有发送和接收数据的能力，所以内核会回 RST 报文给服务端，也就不经过四次挥手。</li><li>shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。</li></ul><p><strong>什么情况会出现三次挥手？</strong></p><ul><li>当被动关闭方在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></li><li>TCP 延迟确认机制是默认开启的</li></ul><blockquote><p>什么是 TCP 延迟确认机制？</p><ul><li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li><li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li><li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li></ul></blockquote><h2 id="3-19-TCP-序列号和确认号是如何变化的？"><a href="#3-19-TCP-序列号和确认号是如何变化的？" class="headerlink" title="3.19 TCP 序列号和确认号是如何变化的？"></a>3.19 TCP 序列号和确认号是如何变化的？</h2><p><strong>发送的 TCP 报文序列号和确认号变化：</strong></p><ul><li>公式一：序列号 &#x3D; 上一次发送的序列号 + 上次len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</li><li>公式二：确认号 &#x3D; 上一次收到的报文中的序列号 + 上次len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</li></ul><blockquote><p><strong>为什么第二次和第三次握手报文中的确认号是将对方的序列号 + 1 后作为确认号呢？</strong></p><p> TCP 将 SYN 报文视为 1 字节的数据，目的如下：</p><ul><li>告诉对方，我方已经收到 SYN 报文。</li><li>告诉对方，我方下一次「期望」收到的报文的序列号为此确认号，比如客户端与服务端完成三次握手之后，服务端接下来期望收到的是序列号为 client_isn + 1 的 TCP 数据报文。</li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403105347105.png" style="zoom: 67%;" /><h1 id="四、IP篇"><a href="#四、IP篇" class="headerlink" title="四、IP篇"></a>四、IP篇</h1><h2 id="4-1-IP-基础知识"><a href="#4-1-IP-基础知识" class="headerlink" title="4.1 IP 基础知识"></a>4.1 IP 基础知识</h2><p>网络层的主要作用是：<strong>实现主机与主机之间的通信，也叫点对点（end to end）通信</strong></p><p><strong>网络层与数据链路层区别</strong></p><ul><li>MAC 的作用则是实现「直连」的两个设备之间通信， IP 则负责在「没有直连」的两个网络之间进行通信传输</li><li>传输过程汇中，源IP地址和目标IP地址在传输过程中是不会变化的，源 MAC 地址和目标 MAC 一直在变化</li></ul><p><strong>IP 地址的分类</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403164233104.png" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403164323231.png" style="zoom:50%;" /><blockquote><p>在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。</p><ul><li>主机号全为 1 指定某个网络下的所有主机，用于广播</li><li>主机号全为 0 指定某个网络</li></ul><p>广播地址可以分为本地广播和直接广播两种。</p><ul><li><strong>在本网络内广播的叫做本地广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的情况下，广播地址是 192.168.0.255 ，不会到达 192.168.0.0&#x2F;24 以外的其他链路上。</li><li><strong>在不同网络之间的广播叫做直接广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的主机向 192.168.1.255&#x2F;24 的目标地址发送 IP 包。使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包。</li></ul><p>D 类常被用于多播，多播地址用于什么？</p><ul><li>多播用于将包发送给特定组内的所有主机。</li></ul></blockquote><p><strong>无分类地址 CIDR</strong></p><ul><li>由于IP分类缺少地址的灵活性，因此出现了CIDR。32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号</li><li>表示形式 <code>a.b.c.d/x</code>，其中 <code>/x</code> 表示前 x 位属于网络号</li></ul><p><strong>子网掩码</strong></p><ul><li>另一种划分网络号与主机号形式。子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址。</li><li>将子网掩码和 IP 地址按位计算 AND，就可得到网络号。</li></ul><p><strong>公有 IP 地址与私有 IP 地址</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403165306620.png"></p><blockquote><p>公有 IP 地址由谁管理呢？</p><ul><li>私有 IP 地址通常是内部的 IT 人员管理，公有 IP 地址是由 <code>ICANN</code> 组织管理。IANA 是 ICANN 的其中一个机构，它负责分配互联网 IP 地址，是按州的方式层层分配。</li></ul></blockquote><p><strong>IP地址如何路由？</strong></p><ul><li>IP地址的网络地址这一部分是用于进行路由控制。</li><li>从路由控制表中找到与目标地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是<strong>最长匹配</strong>。</li></ul><p><strong>环回地址</strong></p><ul><li>环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。</li><li>计算机使用一个特殊的 IP 地址 127.0.0.1 作为环回地址。与该地址具有相同意义的是一个叫做 localhost 的主机名。使用这个 IP 或主机名时，数据包不会流向网络</li></ul><p><strong>IPv6 基本认识</strong></p><ul><li>IPv6 可自动配置，即使没有 DHCP 服务器也可以实现自动分配IP地址</li><li>IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大提升了安全性</li><li>IPv6 相比 IPv4 的首部改进：<ul><li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li><li><strong>取消了分片&#x2F;重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li><li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 <code>40</code> 字节。</li></ul></li></ul><hr><h3 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a><strong>DNS</strong></h4><p>域名解析的工作流程：</p><ul><li>浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 <code>hosts</code>，如果还是没有，就会 DNS 服务器进行查询</li><li>客户端首先向本地 DNS 服务器发出一个 DNS 请求，本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 请求域名，则直接返回 IP 地址。如果没有，本地 DNS 会去问根域名服务器</li><li>根 DNS 收到来自本地 DNS 的请求后，会返回对应的顶级域名服务器，本地DNS再向顶级域名服务器发起请求</li><li>顶级域名服务器会返回一个负责该域名的权威DNS服务器，DNS再向其发起请求</li><li>权威DNS服务器返回IP地址，本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403171127948.png" style="zoom:80%;" /><h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>在发送数据时，需要知道下一跳主机的MAC地址，ARP就是用于通过IP地址查询MAC地址，工作流程如下：</p><ul><li>主机会通过广播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li><li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。</li></ul><p>操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址，但缓存是有一定期限的。</p><blockquote><p><strong>RARP</strong>：已知 自己MAC 地址求自己的 IP 地址，工作流程如下：</p><ul><li>该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li><li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。</li></ul><p><strong>RARP和DHCP区别</strong>：</p><ul><li>DHCP是BOOTP协议的升级，而BOOTP在某种意义上又是RARP协议的升级</li><li>RARP是在数据链路层实现的，而DHCP是在应用层实现的</li><li>RARP只能实现简单的从MAC地址到IP地址的查询工作，RARP server上的MAC地址和IP地址是必须事先静态配置好的。但DHCP却可以实现除静态分配外的动态IP地址分配以及IP地址租期管理等等相对复杂的功能。</li><li>由于RAPR是链路层协议，因此当RARP客户与RARP服务器不在同一网段,中间有路由器等设备连接时无法获取到IP地址</li></ul></blockquote><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>DHCP全程都是使用 UDP 广播通信，工作流程如下：</p><ul><li>客户端发起 DHCP 发现报文的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP 广播通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。</li><li>DHCP 服务器收到 DHCP 发现报文时，用 DHCP 提供报文向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。</li><li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 DHCP 请求报文（DHCP REQUEST进行响应，回显配置的参数。</li><li>最后，服务端用 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数。</li><li>一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址</li></ul><blockquote><p><strong>如果 DHCP 服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络都要配一个 DHCP 服务器？</strong></p><p>为了解决这一问题，就出现了 DHCP 中继代理。其工作流程如下：</p><ul><li>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以<strong>单播</strong>的形式发给 DHCP 服务器。</li><li>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包广播给 DHCP 客户端 。</li></ul></blockquote><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>通过路由器的端口映射，把私有 IP 地址转换成公有 IP 地址。</p><p>缺点：</p><ul><li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li><li>转换表的生成与转换操作都会产生性能开销。</li><li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li></ul><h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><p>ICMP 大致可以分为两大类：</p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403201453060.png"></p><h4 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h4><p><strong>IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong></p><ul><li>IGMP 报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过 IGMP 加入到组播组，主机申请加入到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了。</li><li>IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为 1，因为 IGMP 是工作在主机与连接的路由器之间。</li></ul><p>IGMP常规查询与响应工作机制：</p><ol><li>路由器会周期性发送目的地址为 <code>224.0.0.1</code>（表示同一网段内所有主机和路由器） <strong>IGMP 常规查询报文</strong>。</li><li>主机1 和 主机 3 收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是 0~10 秒，计时器超时后主机就会发送 <strong>IGMP 成员关系报告报文</strong>（源 IP 地址为自己主机的 IP 地址，目的 IP 地址为组播地址）。如果在定时器超时之前，收到同一个组内的其他主机发送的成员关系报告报文，则自己不再发送，这样可以减少网络中多余的 IGMP 报文数量。</li><li>路由器收到主机的成员关系报文后，就会在 IGMP 路由表中加入该组播组，后续网络中一旦该组播地址的数据到达路由器，它会把数据包转发出去。</li></ol><p>IGMP离开组播组工作机制：</p><ol><li>主机 1 要离开组 224.1.1.1，发送 IGMP 离组报文，报文的目的地址是 224.0.0.2（表示发向网段内的所有路由器）</li><li>路由器 收到该报文后，以 1 秒为间隔连续发送 IGMP 特定组查询报文（共计发送 2 个），以便确认该网络是否还有 224.1.1.1 组的其他成员。</li><li>主机 3 仍然是组 224.1.1.1 的成员，因此它立即响应这个特定组查询。路由器知道该网络中仍然存在该组播组的成员，于是继续向该网络转发 224.1.1.1 的组播数据包。</li><li>当主机3也离开，路由器连续发送查询报文，如果没有响应，将不会再向这个网段转发该组播地址的数据包。</li></ol><h2 id="4-2-ping-的工作原理"><a href="#4-2-ping-的工作原理" class="headerlink" title="4.2 ping 的工作原理"></a>4.2 ping 的工作原理</h2><p>ping 是基于 <code>ICMP</code> 协议工作的，</p><ul><li>ping 命令执行的时候，源主机首先会构建一个 <strong>ICMP 回送请求消息</strong>数据包，字段类型为8.</li><li>然后，由 ICMP 协议将这个数据包连同目标地址一起交给 IP 层，构建一个 IP 数据包。</li><li>目的主机收到消息后，会构建一个 <strong>ICMP 回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为 <code>0</code>，<strong>序号</strong>为接收到的请求数据包中的序号，然后再发送出去</li><li>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</li><li>此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403203128549.png"></p><h4 id="traceroute-——-差错报文类型的使用"><a href="#traceroute-——-差错报文类型的使用" class="headerlink" title="traceroute —— 差错报文类型的使用"></a>traceroute —— 差错报文类型的使用</h4><p>traceroute作用：</p><ul><li>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。<ul><li>利用 IP 包的生存期限 从 1 开始按照顺序递增的同时发送 UDP 包，强制接收 ICMP 超时消息的一种方法。traceroute 就可以拿到了所有的途径路由器 IP。</li><li>发送方如何知道发出的 UDP 包是否到达了目的主机呢？<ul><li>traceroute 在发送 UDP 包时，会填入一个不可能的端口号值作为 UDP 目标端口号。当目的主机收到 UDP 包后，会返回 ICMP 差错报文消息，其类型是「端口不可达」。</li></ul></li></ul></li><li>为了得到路径MTU大小，故意设置不分片，从而确定路径的 MTU<ul><li>发送端主机发送 IP 数据报时，将 IP 包首部的<strong>分片禁止标志位设置为 1</strong>。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。</li><li>随后，通过一个 ICMP 的不可达消息将<strong>数据链路上 MTU 的值</strong>一起给发送主机，不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」。</li><li>发送主机端每次收到 ICMP 差错报文时就<strong>减少</strong>包的大小，以此来定位一个合适的 <code>MTU</code> 值，以便能到达目标主机。</li></ul></li></ul><h2 id="4-3-断网了，还能-ping-通-127-0-0-1-吗？"><a href="#4-3-断网了，还能-ping-通-127-0-0-1-吗？" class="headerlink" title="4.3 断网了，还能 ping 通 127.0.0.1 吗？"></a>4.3 断网了，还能 ping 通 127.0.0.1 吗？</h2><p>答案：可以ping通。</p><p><strong>什么是127.0.0.1？</strong></p><ul><li>127 开头的都属于回环地址，而127.0.0.1是众多回环地址中的一个</li><li>在ipv6下环回地址是 ::1</li></ul><p><strong>TCP发数据和ping的区别</strong></p><ul><li>TCP 传输中创建的方式是 <code>socket(AF_INET, SOCK_STREAM, 0);</code>，其中 <code>AF_INET</code> 表示将使用 IPV4 里 host:port 的方式去解析待会你输入的网络地址。<code>SOCK_STREAM</code> 是指使用面向字节流的 TCP 协议，工作在传输层。</li><li>ping创建 <code>socket</code> 的时候用的是 <code>socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)</code>，<code>SOCK_RAW</code> 是原始套接字 ，工作在网络层</li></ul><h4 id="为什么断网了还能-ping-通-127-0-0-1"><a href="#为什么断网了还能-ping-通-127-0-0-1" class="headerlink" title="为什么断网了还能 ping 通 127.0.0.1"></a>为什么断网了还能 ping 通 127.0.0.1</h4><ul><li>发送数据时，到了网络层，系统会根据目的IP，在路由表中获取对应的路由信息，而这其中就包含选择哪个网卡把消息发出。</li><li>当发现目标IP是外网IP时，会从”真网卡”发出。当发现目标IP是回环地址时，就会选择本地网卡。</li><li>本地网卡，其实就是个”假网卡”，它不像”真网卡”那样有个ring buffer什么的，”假网卡”会把数据推到一个叫 input_pkt_queue 的 链表 中。这个链表是所有网卡共享的，上面挂着发给本机的各种消息。消息被发送到这个链表后，会再触发一个软中断。</li><li>ksoftirqd在收到软中断后就会立马去链表里把消息取出，然后顺着数据链路层、网络层等层层往上传递最后给到应用程序。</li></ul><h4 id="ping回环地址和ping本机地址有什么区别"><a href="#ping回环地址和ping本机地址有什么区别" class="headerlink" title="ping回环地址和ping本机地址有什么区别"></a>ping回环地址和ping本机地址有什么区别</h4><p>ping 本机IP 跟 ping 回环地址一样，相关的网络数据都是走的本地回环接口。只要走了本地回环接口，那数据都不会发送到网络中，在本机网络协议栈中兜一圈，就发回来了。因此 <strong>ping回环地址和ping本机地址没有区别</strong>。</p><h4 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗"></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h4><ul><li>127.0.0.1 是回环地址</li><li>localhost是一个域名，默认解析为127.0.0.1</li><li>0.0.0.0表示本机上的所有IPV4地址。执行 ping 0.0.0.0会失败的，因为它在IPV4中表示的是无效的目标地址。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>179. 最大数</title>
      <link href="/2023/02/15/leetcode/other/leetcode-179-%E6%9C%80%E5%A4%A7%E6%95%B0-middle/"/>
      <url>/2023/02/15/leetcode/other/leetcode-179-%E6%9C%80%E5%A4%A7%E6%95%B0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a href="https://leetcode.cn/problems/largest-number/">179. 最大数</a></h1><p>FIrst：开始折腾比较规则，后来想到为啥不直接拼好再比较。。。</p><hr><p><strong>方法1</strong>：<strong>排序</strong></p><p>将所有值进行比较排序，每两个值比较时看谁拼接起来大（也可以使用数字算加和）</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(int a,int b)&#123;        string sa&#x3D;to_string(a);        string sb&#x3D;to_string(b);        string ka&#x3D;sa+sb;        string kb&#x3D;sb+sa;        return ka&gt;kb;    &#125;    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end(),compare);        if(nums[0]&#x3D;&#x3D;0) return &quot;0&quot;;        string ans;        for(auto a:nums)&#123;            ans+&#x3D;to_string(a);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>341. 扁平化嵌套列表迭代器</title>
      <link href="/2023/02/15/leetcode/other/leetcode-341-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8-middle/"/>
      <url>/2023/02/15/leetcode/other/leetcode-341-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="341-扁平化嵌套列表迭代器"><a href="#341-扁平化嵌套列表迭代器" class="headerlink" title="341. 扁平化嵌套列表迭代器"></a><a href="https://leetcode.cn/problems/flatten-nested-list-iterator/description/">341. 扁平化嵌套列表迭代器</a></h1><p>FIrst：不难，按逻辑来即可</p><hr><p><strong>方法1</strong>：<strong>深度优先搜索</strong></p><p>先深度遍历得到所有的值，然后使用一个index来记录当前遍历的位置。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class NestedIterator &#123;    vector&lt;int&gt; nums;    int index;public:    void traverse(const vector&lt;NestedInteger&gt; &amp;nestedList)&#123;        if(nestedList.empty()) return;        for(const auto &amp;a:nestedList)&#123;            if(a.isInteger())&#123;                nums.push_back(a.getInteger());            &#125;else&#123;                traverse(a.getList());            &#125;        &#125;    &#125;    NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList):nums(),index(0) &#123;        traverse(nestedList);    &#125;        int next() &#123;        return nums[index++];    &#125;        bool hasNext() &#123;        return index&lt;nums.size();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-深度搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>670. 最大交换</title>
      <link href="/2023/02/15/leetcode/other/leetcode-670-middle/"/>
      <url>/2023/02/15/leetcode/other/leetcode-670-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="670-最大交换"><a href="#670-最大交换" class="headerlink" title="670. 最大交换"></a><a href="https://leetcode.cn/problems/maximum-swap/">670. 最大交换</a></h1><p>FIrst：看着数也不大，直接每两两交换也会很快，但复杂度较高。想着是找到最大的可交换的数，但逻辑还是没理清</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>要想找到最大交换值，那么应该找到最大数字，但这数字必须能与前面数字交换才有用，能交换的要求是其前面存在比它小的数字。</p><p>因此，问题就变成找一个能与前面数字交换的最大数字，然后再找一个能与此数字交换的最靠前数字。数字相同情况下，最大数字位置应越靠末尾越好，被交换数字应越靠前越好。</p><ul><li>时间复杂度：O(lognum)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maximumSwap(int num) &#123;        string s&#x3D;to_string(num);        int maxid&#x3D;s.length();        int resmin&#x3D;-1,resmax&#x3D;-1;        for(int i&#x3D;s.length()-1;i&gt;&#x3D;0;--i)&#123;            if(s[maxid]&lt;s[i])&#123;                maxid&#x3D;i;            &#125;else if(s[maxid]&gt;s[i])&#123;                resmin&#x3D;i;                resmax&#x3D;maxid;            &#125;        &#125;        if(resmin!&#x3D;-1)&#123;            swap(s[resmin],s[resmax]);            return stoi(s);        &#125;else&#123;            return num;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>直接遍历</strong></p><p>直接遍历查找</p><ul><li>时间复杂度：O(log^2^num)</li><li>空间复杂度：O(lognum)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>475. 供暖器</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="475-供暖器"><a href="#475-供暖器" class="headerlink" title="475. 供暖器"></a><a href="https://leetcode.cn/problems/heaters/description/">475. 供暖器</a></h1><p>First：这道题折腾了老久，方法上虽然知道了，但在边界处理上一直不行，最后看了一个评论说将所有数转为负数处理会更方便，真走进思维误区了。</p><hr><p><strong>方法1</strong>：<strong>二分查找</strong></p><p>由于不能用除法，那么先假设其商cur为1，此时divisorL&#x3D;divisor。如果divisorL&lt;dividend，那么将cur和divisorL都翻倍，如果此时divisorL&gt;dividend，则说明答案在cur&#x2F;2到cur之间。对此，可以使用递归对dividend-divisorL&#x2F;2求商，最后将结果相加即可。</p><p>此题不好处理的是正负数越界问题，为方便处理，需要将除数和被除数都转变为正数或负数，由于负数的临界值的绝对值比正数大，将所有数准变为负数进行处理更加方便。</p><ul><li>时间复杂度：O(logn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int divide(int dividend, int divisor) &#123;         int flag&#x3D;1;        if(dividend&gt;0)&#123;            dividend&#x3D;-dividend;            flag*&#x3D;-1;        &#125;        if(divisor&gt;0)&#123;            divisor&#x3D;-divisor;            flag*&#x3D;-1;        &#125;        if(divisor&lt;dividend) return 0;        long divisorL&#x3D;divisor;        long cur&#x3D;1;        while(divisorL&gt;&#x3D;dividend)&#123;            if(divisorL&#x3D;&#x3D;dividend) &#123;                if(flag*cur&gt;INT_MAX) return INT_MAX;                return flag*cur;            &#125;            cur+&#x3D;cur;            divisorL+&#x3D;divisorL;        &#125;        divisorL&gt;&gt;&#x3D;1;        cur&gt;&gt;&#x3D;1;        return flag*(cur+divide(dividend-divisorL,divisor));    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>378. 有序矩阵中第 K 小的元素</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%AC%20K%20%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%AC%20K%20%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="378-有序矩阵中第-K-小的元素"><a href="#378-有序矩阵中第-K-小的元素" class="headerlink" title="378. 有序矩阵中第 K 小的元素"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素</a></h1><p>First：思维挺nice的</p><hr><p><strong>方法1</strong>：<strong>二分查找</strong></p><p>使用二分查找，l&#x3D;matrix[0] [0], r&#x3D;matrix[n-1] [n-1]，mid虽然可能不会出现在矩阵中，但是找到k个小于其值时并未退出查找，而是继续查找，因此最终找到的值一定在矩阵中。</p><p>对于一个数，比其小的数一定是连在一起的，会将整个矩阵划分为两块，如下图。那么可以从最左下角开始找，算法如下：</p><ul><li>初始位置在 matrix[n−1] [0]（即左下角）；</li><li>设当前位置为 matrix[i] [j]。若 matrix[i] [j]≤mid，则将当前所在列的不大于 mid 的数的数量累加到答案中，并向右移动，否则向上移动；</li><li>不断移动直到走出格子为止。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230825164755534.png" alt="image-20230825164755534" style="zoom:50%;" /><ul><li>时间复杂度：O(nlogn2) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int getCount(vector&lt;vector&lt;int&gt;&gt;&amp; matrix,int mid)&#123;        int count&#x3D;0;        int i&#x3D;matrix.size()-1,j&#x3D;0;        while(i&gt;&#x3D;0&amp;&amp;j&lt;matrix.size())&#123;            while(i&gt;&#x3D;0&amp;&amp;matrix[i][j]&gt;mid) --i;            count+&#x3D;i+1;            ++j;        &#125;        return count;    &#125;    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123;        int m&#x3D;matrix.size(),n&#x3D;matrix[0].size();        int l&#x3D;matrix[0][0],r&#x3D;matrix[m-1][n-1];        while(l&lt;r)&#123;            int mid&#x3D;l+(r-l)&#x2F;2;            int count&#x3D;getCount(matrix,mid);            if(count&gt;&#x3D;k)&#123;                r&#x3D;mid;            &#125;else&#123;                l&#x3D;mid+1;            &#125;        &#125;        return l;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>归并</strong></p><p>使用归并思想，使用一个优先队列存储。</p><ul><li>时间复杂度：O(klogn) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123;        struct point&#123;            int val,x,y;            bool operator&gt;(const point &amp;a)const &#123; return this-&gt;val&gt;a.val;&#125;        &#125;;        priority_queue&lt;point,vector&lt;point&gt;,greater&lt;point&gt;&gt; que;        int n&#x3D;matrix.size();        for(int i&#x3D;0;i&lt;n;++i)&#123;            que.push(point&#123;matrix[i][0],i,0&#125;);        &#125;        int ans&#x3D;0;        while(k&gt;0)&#123;            auto p&#x3D;que.top();            ans&#x3D;p.val;            que.pop();                        if(p.y&lt;n-1) que.push(point&#123;matrix[p.x][p.y+1],p.x,p.y+1&#125;);                --k;                &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>475. 供暖器</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-475-%E4%BE%9B%E6%9A%96%E5%99%A8-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-475-%E4%BE%9B%E6%9A%96%E5%99%A8-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="475-供暖器"><a href="#475-供暖器" class="headerlink" title="475. 供暖器"></a><a href="https://leetcode.cn/problems/heaters/description/">475. 供暖器</a></h1><p>First：使用二分查找时，找上边界泽腾了挺久</p><hr><p><strong>方法1</strong>：<strong>对供暖器位置二分查找</strong></p><p>对于每间屋子，找到离它最近的供暖器，然后取所有最近值中的最大值即为供暖器半径。注意二分查找时，需要比较左右两个供暖器。</p><ul><li>时间复杂度：O((n+m)logn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isEnough(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters,int radius)&#123;        int i&#x3D;0,j&#x3D;0;        while(i&lt;houses.size()&amp;&amp;j&lt;heaters.size())&#123;            if(houses[i]&gt;&#x3D;heaters[j]-radius&amp;&amp;houses[i]&lt;&#x3D;heaters[j]+radius) ++i;            else ++j;        &#125;        if(j&gt;&#x3D;heaters.size()&amp;&amp;i&lt;houses.size()) return false;        return true;    &#125;    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;        sort(heaters.begin(),heaters.end());        int ans&#x3D;0;        for(auto &amp;house:houses)&#123;            int left&#x3D;0,right&#x3D;heaters.size()-1;            while(left&lt;right)&#123;                int mid&#x3D;left+(right-left)&#x2F;2;                if(heaters[mid]&lt;house) left&#x3D;mid+1;                else right&#x3D;mid;            &#125;            int t&#x3D;0;            if(left&lt;1) t&#x3D;abs(heaters[left]-house);            else t&#x3D;min(abs(heaters[left]-house),abs(heaters[left-1]-house));            ans&#x3D;max(ans,t);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法2</strong>：<strong>对供暖器半径二分查找</strong></p><p>直接使用二分查找判断每次半径是否满足要求，不断二分得到最终结果。需要注意的是二分查找边界等设定。</p><ul><li>时间复杂度：O((n+m)logn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isEnough(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters,int radius)&#123;        int i&#x3D;0,j&#x3D;0;        while(i&lt;houses.size()&amp;&amp;j&lt;heaters.size())&#123;            if(houses[i]&gt;&#x3D;heaters[j]-radius&amp;&amp;houses[i]&lt;&#x3D;heaters[j]+radius) ++i;            else ++j;        &#125;        if(j&gt;&#x3D;heaters.size()&amp;&amp;i&lt;houses.size()) return false;        return true;    &#125;    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;        sort(houses.begin(),houses.end());        sort(heaters.begin(),heaters.end());        int left&#x3D;0,right&#x3D;1e9;        while(left&lt;right)&#123;            int mid&#x3D;left+(right-left)&#x2F;2;            if(isEnough(houses,heaters,mid)) right&#x3D;mid;            else left&#x3D;mid+1;        &#125;        return left;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>106. 从中序与后序遍历序列构造二叉树</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h1><p>First：没想到可以利用pos1求出的长度来求出pos2所在位置</p><hr><p><strong>方法1</strong>：<strong>递归</strong></p><p>postorder的最后一个数k可以将inorder分为两部分，这两部分分别是k的左右两个子树构成。而这两部分也可以将postorder划成两部分，从而构成新的两组inorder和postorder然后不断递归构造二叉树。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    unordered_map&lt;int,int&gt; inmap,postmap;public:    &#x2F;&#x2F; TreeNode* creatTree(vector&lt;int&gt;&amp; inorder,vector&lt;int&gt;&amp; postorder,int inl,int inr,int postl,int postr)&#123;    &#x2F;&#x2F;     if(inl&gt;inr||postl&gt;postr) return nullptr;    &#x2F;&#x2F;     TreeNode *root&#x3D;new TreeNode(postorder[postr]);    &#x2F;&#x2F;     int pos1&#x3D;inmap[postorder[postr]];&#x2F;&#x2F;pos1是在inorder中的分割    &#x2F;&#x2F;     int pos2&#x3D;-1;&#x2F;&#x2F;pos2是在postorder中的分割    &#x2F;&#x2F;     for(int i&#x3D;inl;i&lt;pos1;++i)&#123;    &#x2F;&#x2F;         pos2&#x3D;max(pos2,postmap[inorder[i]]);    &#x2F;&#x2F;     &#125;    &#x2F;&#x2F;     root-&gt;left&#x3D;creatTree(inorder,postorder,inl,pos1-1,postl,pos2);    &#x2F;&#x2F;     root-&gt;right&#x3D;creatTree(inorder,postorder,pos1+1,inr,pos2+1,postr-1);    &#x2F;&#x2F;     return root;    &#x2F;&#x2F; &#125;    &#x2F;&#x2F;上面方法还专门计算post2来找到在postorder中的切割点，但是中序遍历和后序遍历数组是相同的，可以用post1得到的数组大小来直接推导post2    TreeNode* creatTree(vector&lt;int&gt;&amp; inorder,vector&lt;int&gt;&amp; postorder,int inl,int inr,int postl,int postr)&#123;        if(inl&gt;inr||postl&gt;postr) return nullptr;        TreeNode *root&#x3D;new TreeNode(postorder[postr]);        int pos1&#x3D;inmap[postorder[postr]];&#x2F;&#x2F;pos1是在inorder中的分割        int pos2&#x3D;pos1-1-inl+postl;&#x2F;&#x2F;pos2是在postorder中的分割        root-&gt;left&#x3D;creatTree(inorder,postorder,inl,pos1-1,postl,pos2);        root-&gt;right&#x3D;creatTree(inorder,postorder,pos1+1,inr,pos2+1,postr-1);        return root;    &#125;    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;        for(int i&#x3D;0;i&lt;inorder.size();++i)&#123;            inmap[inorder[i]]&#x3D;i;            postmap[postorder[i]]&#x3D;i;        &#125;        return creatTree(inorder,postorder,0,inorder.size()-1,0,postorder.size()-1);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>116. 填充每个节点的下一个右侧节点指针</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h1><p>First：普通解法挺简单，进阶要求要复杂些。此题和117题解法一模一样，没任何差别。</p><hr><p><strong>方法1</strong>：<strong>层序遍历</strong></p><p>使用层序遍历，每次将前一个节点指向后一个节点即可</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    Node* connect(Node* root) &#123;        &#x2F;&#x2F;层序遍历        queue&lt;Node*&gt; que;        if(root!&#x3D;nullptr) que.push(root);        while(!que.empty())&#123;            int size&#x3D;que.size();            for(int i&#x3D;0;i&lt;size;++i)&#123;                Node *tem&#x3D;que.front();                que.pop();                if(i&lt;size-1)&#123;                    tem-&gt;next&#x3D;que.front();                &#125;else&#123;                    tem-&gt;next&#x3D;nullptr;                &#125;                if(tem-&gt;left) que.push(tem-&gt;left);                if(tem-&gt;right) que.push(tem-&gt;right);            &#125;        &#125;        return root;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>使用指针记录</strong></p><p>此方法无法使用队列，使得为常数空间。</p><p>使用curLen和nextLen分别记录当前层节点数和下一层节点数，使用p记录当前需要处理的节点，nextP记录下一层第一个节点，last记录当前节点的前一个节点。</p><p>p指针如果为空则结束遍历，在每次遍历时，分别判断p的左右节点情况，如果此时nextLen为0，则说明此子节点是下一层的第一个节点，使用nextP记录下此子节点，并将last置为此几点。否则，将last指向当前节点并更新last。每次遍历都需要将curLen减1，如果curLen等于0则说明当前层已经遍历完成，更新上述变量皆可，否则p应该更新为下一个节点。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    Node* connect(Node* root) &#123;        &#x2F;&#x2F;进阶        int curLen&#x3D;1,nextLen&#x3D;0;&#x2F;&#x2F;记录当前层节点数和下一层节点数        Node *p&#x3D;root,*nextP&#x3D;nullptr,*last&#x3D;nullptr;&#x2F;&#x2F;p记录当前需要处理的节点，nextP记录下一层第一个节点，last记录当前节点的前一个节点        while(p)&#123;            --curLen;            if(p-&gt;left)&#123;                if(nextLen&#x3D;&#x3D;0) &#123;&#x2F;&#x2F;如果下一层节点数为0则表示此节点是下一层第一个节点                    nextP&#x3D;p-&gt;left;                    last&#x3D;p-&gt;left;                &#125;                else &#123;&#x2F;&#x2F;设置next                    last-&gt;next&#x3D;p-&gt;left;                    last&#x3D;p-&gt;left;                &#125;                 ++nextLen;            &#125;            if(p-&gt;right)&#123;                if(nextLen&#x3D;&#x3D;0) &#123;                    nextP&#x3D;p-&gt;right;                    last&#x3D;p-&gt;right;                &#125;                else&#123;                    last-&gt;next&#x3D;p-&gt;right;                    last&#x3D;p-&gt;right;                &#125;                ++nextLen;            &#125;            if(curLen&#x3D;&#x3D;0)&#123;                curLen&#x3D;nextLen;                nextLen&#x3D;0;                p&#x3D;nextP;                nextP&#x3D;nullptr;                last&#x3D;nullptr;            &#125;else&#123;                p&#x3D;p-&gt;next;            &#125;        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>450. 删除二叉搜索树中的节点</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h1><p>First：方法不难，记一下细节</p><hr><p><strong>方法1</strong>：<strong>递归遍历</strong></p><p>由于当前被删节点是可能有父节点，父节点要删除此子节点，因此遍历时返回TreeNode*指针。先找到被删节点，如果被删节点左右孩子有一个不为空，返回不为空的那个即可。如果都不为空，则将右子树的左子树移到root的左子树的最右边或者直接将root的右子树移动到root的左子树的最右边</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    TreeNode* deleteNode(TreeNode* root, int key) &#123;        if(root&#x3D;&#x3D;nullptr) return root;        if(root-&gt;val&#x3D;&#x3D;key)&#123;            if(root-&gt;right&#x3D;&#x3D;nullptr) return root-&gt;left;            else if(root-&gt;left&#x3D;&#x3D;nullptr) return root-&gt;right;            else&#123;                &#x2F;&#x2F;法1 将右子树的左子树移到root的左子树的最右边                &#x2F;&#x2F; TreeNode *sonLeft&#x3D;root-&gt;right-&gt;left;                &#x2F;&#x2F; root-&gt;val&#x3D;root-&gt;right-&gt;val;                &#x2F;&#x2F; root-&gt;right&#x3D;root-&gt;right-&gt;right;                &#x2F;&#x2F; TreeNode *p&#x3D;root-&gt;left;                &#x2F;&#x2F; if(sonLeft!&#x3D;nullptr)&#123;                &#x2F;&#x2F;     while(p-&gt;right!&#x3D;nullptr)&#123;                &#x2F;&#x2F;     p&#x3D;p-&gt;right;                &#x2F;&#x2F;     &#125;                &#x2F;&#x2F;     p-&gt;right&#x3D;sonLeft;                &#x2F;&#x2F; &#125;                &#x2F;&#x2F;法2 直接将root的右子树移动到root的左子树的最右边                TreeNode *p&#x3D;root-&gt;left;                while(p-&gt;right!&#x3D;nullptr)&#123;                    p&#x3D;p-&gt;right;                &#125;                p-&gt;right&#x3D;root-&gt;right;                root&#x3D;root-&gt;left;            &#125;        &#125;else if(root-&gt;val&lt;key)&#123;            root-&gt;right&#x3D;deleteNode(root-&gt;right,key);        &#125;else&#123;            root-&gt;left&#x3D;deleteNode(root-&gt;left,key);        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>236. 二叉树的最近公共祖先</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h1><p>First：递归解法挺巧妙，但还是没写出来</p><hr><p><strong>方法1</strong>：<strong>递归遍历</strong></p><p>原理值得细看，原来只是知其然不知其所以然。<a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">解析</a></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        if(root&#x3D;&#x3D;nullptr||root&#x3D;&#x3D;p||root&#x3D;&#x3D;q) return root;        TreeNode *left&#x3D;lowestCommonAncestor(root-&gt;left,p,q);        TreeNode *right&#x3D;lowestCommonAncestor(root-&gt;right,p,q);        if(left&#x3D;&#x3D;nullptr) return right;        if(right&#x3D;&#x3D;nullptr) return left;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>根据路径判断</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>617. 合并二叉树</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-simple/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h1><p>First：比较简单，只是解析答案有些巧妙，记录下</p><hr><p><strong>方法1</strong>：<strong>递归</strong></p><p>开始使用的创建新树来做，代码随想录的解法巧妙些。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    TreeNode* createTree(TreeNode* root1,TreeNode* root2)&#123;        if(root1&#x3D;&#x3D;nullptr&amp;&amp;root2&#x3D;&#x3D;nullptr) return nullptr;                int val1&#x3D;0,val2&#x3D;0;        if(root1!&#x3D;nullptr)&#123;            val1&#x3D;root1-&gt;val;        &#125;        if(root2!&#x3D;nullptr)&#123;            val2&#x3D;root2-&gt;val;        &#125;        TreeNode *root&#x3D;new TreeNode(val1+val2);        root-&gt;left&#x3D;createTree(root1&#x3D;&#x3D;nullptr?nullptr:root1-&gt;left,root2&#x3D;&#x3D;nullptr?nullptr:root2-&gt;left);        root-&gt;right&#x3D;createTree(root1&#x3D;&#x3D;nullptr?nullptr:root1-&gt;right,root2&#x3D;&#x3D;nullptr?nullptr:root2-&gt;right);        return root;    &#125;    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;        &#x2F;&#x2F;方法1 效率有点低        &#x2F;&#x2F; return createTree(root1,root2);        &#x2F;&#x2F;方法2 代码随想录,挺巧妙的        if(root1&#x3D;&#x3D;nullptr) return root2;        if(root2&#x3D;&#x3D;nullptr) return root1;        root1-&gt;val+&#x3D;root2-&gt;val;        root1-&gt;left&#x3D;mergeTrees(root1-&gt;left,root2-&gt;left);        root1-&gt;right&#x3D;mergeTrees(root1-&gt;right,root2-&gt;right);        return root1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>669. 修剪二叉搜索树</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h1><p>First：在细节处折腾挺久</p><hr><p><strong>方法1</strong>：<strong>后续遍历</strong></p><p>对于每个节点都需要进行判断是否满足要求，如果不满足要求那么在子节点中找到一个满足要求的进行填充，因此先对子节点进行判断，如果节点不满足要求才使用子节点进行替代，那么就应该使用后序遍历。</p><p>判断当前节点是否满足要求，如果不满足要求，则使用left或right中不为空的那个（当前节点不满足要求则说明left和right中最多只有一个不为空），若都为nullptr，则说明找不到替代节点，返回nullptr。若满足要求，返回当前节点既可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;        if(root&#x3D;&#x3D;nullptr) return nullptr;        root-&gt;left&#x3D;trimBST(root-&gt;left,low,high);        root-&gt;right&#x3D;trimBST(root-&gt;right,low,high);        if(root-&gt;val&gt;high||root-&gt;val&lt;low)&#123;            if(root-&gt;left!&#x3D;nullptr) root&#x3D;root-&gt;left;            else if(root-&gt;right!&#x3D;nullptr) root&#x3D;root-&gt;right;            else root&#x3D;nullptr;        &#125;        return root;    &#125;&#125;;&#x2F;&#x2F;代码随想录中的class Solution &#123;public:    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;        if (root &#x3D;&#x3D; nullptr) return nullptr;        if (root-&gt;val &lt; low) return trimBST(root-&gt;right, low, high);        if (root-&gt;val &gt; high) return trimBST(root-&gt;left, low, high);        root-&gt;left &#x3D; trimBST(root-&gt;left, low, high);        root-&gt;right &#x3D; trimBST(root-&gt;right, low, high);        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>98. 验证二叉搜索树</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h1><p>First：不难，使用中序遍历来验证即可，记录下技巧</p><hr><p><strong>方法1</strong>：<strong>中序遍历</strong></p><p>使用中序遍历，每次比较当前节点和前一个节点的大小，如果小于或等于前一个节点，则将flag置为false。使用TreeNode* last来记录上一个节点（使用数值来记录会有相同值影响）。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    bool flag;    TreeNode* last;&#x2F;&#x2F;last设置为数字会有一些局限性public:    void midorder(TreeNode* root)&#123;        if(flag&#x3D;&#x3D;false) return;        if(root&#x3D;&#x3D;nullptr) return;        midorder(root-&gt;left);        if(last!&#x3D;nullptr&amp;&amp;root-&gt;val&lt;&#x3D;last-&gt;val) flag&#x3D;false;        last&#x3D;root;        midorder(root-&gt;right);    &#125;    bool isValidBST(TreeNode* root) &#123;        flag&#x3D;true;        last&#x3D;nullptr;        midorder(root);        return flag;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 07. 重建二叉树</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-%E5%89%91%E6%8C%87Offer07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-%E5%89%91%E6%8C%87Offer07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/description/">剑指 Offer 07. 重建二叉树</a></h1><p>First：自己递归写的效率太低</p><hr><p><strong>方法1</strong>：<strong>递归</strong></p><p>每次找到新的preorder和inorder，不断递归遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        if(preorder.size()&#x3D;&#x3D;0&amp;&amp;inorder.size()&#x3D;&#x3D;0) return nullptr;        TreeNode *root&#x3D;new TreeNode(preorder[0]);        unordered_set&lt;int&gt; mset;        vector&lt;int&gt; curInFir,curInSec;        int idx&#x3D;0;        while(inorder[idx]!&#x3D;preorder[0]) &#123;            mset.insert(inorder[idx]);            curInFir.push_back(inorder[idx++]);        &#125;        ++idx;        while(idx&lt;inorder.size())&#123;            curInSec.push_back(inorder[idx++]);        &#125;        vector&lt;int&gt; curPreFir,curPreSec;        for(int i&#x3D;1;i&lt;preorder.size();++i)&#123;            if(mset.count(preorder[i]))&#123;                curPreFir.push_back(preorder[i]);            &#125;else&#123;                curPreSec.push_back(preorder[i]);            &#125;        &#125;        root-&gt;left&#x3D;buildTree(curPreFir,curInFir);        root-&gt;right&#x3D;buildTree(curPreSec,curInSec);        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>递归</strong></p><p>前序遍历性质： 节点按照 <code>[ 根节点 | 左子树 | 右子树 ]</code> 排序。 中序遍历性质： 节点按照 <code>[ 左子树 | 根节点 | 右子树 ]</code> 排序。</p><p>只需要不断找到根节点从而构建树即可，左子树的根节点可由当前根节点在前序遍历中+1即可，右子树的根节点则需要先找到左子树的元素个数，然后即可找到右子树的根节点。使用一组left和right来指向当前树在inorder中的边界。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;int&gt; mpreorder;    unordered_map&lt;int,int&gt; map;    &#x2F;&#x2F;前序遍历的根节点，在中序遍历的左边界和右边界    TreeNode* build(int cur,int left,int right)&#123;        if(left&gt;right) return nullptr;        TreeNode *root&#x3D;new TreeNode(mpreorder[cur]);        int idx&#x3D;map[mpreorder[cur]];        root-&gt;left&#x3D;build(cur+1,left,idx-1);        root-&gt;right&#x3D;build(cur+idx-left+1,idx+1,right);        return root;    &#125;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        mpreorder&#x3D;preorder;        for(int i&#x3D;0;i&lt;inorder.size();++i)&#123;            map[inorder[i]]&#x3D;i;        &#125;        return build(0,0,preorder.size()-1);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 33. 二叉搜索树的后序遍历序列</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-%E5%89%91%E6%8C%87Offer33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-%E5%89%91%E6%8C%87Offer33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/description/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h1><p>First：没写出来，还是没深刻理解到后序遍历的规律。题解中的单调栈后面还需要看懂。</p><hr><p><strong>方法1</strong>：<strong>递归分治</strong></p><p>后序遍历是[ 左子树 | 右子树 | 根节点 ]形式，而最后一个点是根节点，左子树中的节点都小于根节点，因此找到第一个大于根节点的数即为右子树区间的第一个节点，因而三个区间都可以得出了。右子树中的节点需要大于根节点，因此不满足要求的返回false。</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool traverse(vector&lt;int&gt;&amp; postorder,int start,int end)&#123;        if(start&gt;&#x3D;end) return true;        int idx&#x3D;start;        while(idx&lt;&#x3D;end&amp;&amp;postorder[idx]&lt;postorder[end]) ++idx;        int tmp&#x3D;idx;        while(tmp&lt;&#x3D;end) &#123;            if(postorder[tmp++]&lt;postorder[end]) return false;        &#125;        return traverse(postorder,start,idx-1)&amp;&amp;traverse(postorder,idx,end-1);    &#125;    bool verifyPostorder(vector&lt;int&gt;&amp; postorder) &#123;        return traverse(postorder,0,postorder.size()-1);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>单调栈</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
            <tag> Alg-单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的递归遍历理论笔记</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E7%A1%80%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E7%A1%80%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h1><p>对于前中后序的递归遍历，有统一的框架，只是读节点所处位置不同</p><p><strong>前序遍历</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) &#123;        if (cur &#x3D;&#x3D; NULL) return;        vec.push_back(cur-&gt;val);    &#x2F;&#x2F; 中        traversal(cur-&gt;left, vec);  &#x2F;&#x2F; 左        traversal(cur-&gt;right, vec); &#x2F;&#x2F; 右    &#125;    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        traversal(root, result);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中序遍历</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) &#123;    if (cur &#x3D;&#x3D; NULL) return;    traversal(cur-&gt;left, vec);  &#x2F;&#x2F; 左    vec.push_back(cur-&gt;val);    &#x2F;&#x2F; 中    traversal(cur-&gt;right, vec); &#x2F;&#x2F; 右&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>后序遍历</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) &#123;    if (cur &#x3D;&#x3D; NULL) return;    traversal(cur-&gt;left, vec);  &#x2F;&#x2F; 左    traversal(cur-&gt;right, vec); &#x2F;&#x2F; 右    vec.push_back(cur-&gt;val);    &#x2F;&#x2F; 中&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h1><p><strong>前序遍历</strong></p><p>前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; st;        vector&lt;int&gt; result;        if (root &#x3D;&#x3D; NULL) return result;        st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();                       &#x2F;&#x2F; 中            st.pop();            result.push_back(node-&gt;val);            if (node-&gt;right) st.push(node-&gt;right);           &#x2F;&#x2F; 右（空节点不入栈）            if (node-&gt;left) st.push(node-&gt;left);             &#x2F;&#x2F; 左（空节点不入栈）        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中序遍历</strong></p><p>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;自己写得中序遍历迭代，但这会对原来的树进行修改class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        if(root&#x3D;&#x3D;nullptr) return&#123;&#125;;        &#x2F;&#x2F;迭代法        vector&lt;int&gt; ans;        stack&lt;TreeNode*&gt; st;        st.push(root);        while(!st.empty())&#123;            TreeNode *tem&#x3D;st.top();            while(tem-&gt;left!&#x3D;nullptr)&#123;                st.push(tem-&gt;left);                TreeNode *k&#x3D;tem;                tem&#x3D;tem-&gt;left;                k-&gt;left&#x3D;nullptr;&#x2F;&#x2F;left已经添加了，如不置为nullptr则会重复一直添加            &#125;            tem&#x3D;st.top();            st.pop();            ans.push_back(tem-&gt;val);            if(tem-&gt;right!&#x3D;nullptr) st.push(tem-&gt;right);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;代码随想录中的解法，将遍历节点和处理节点进行分开，使用一个指针来指向遍历节点class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        TreeNode* cur &#x3D; root;        while (cur !&#x3D; NULL || !st.empty()) &#123;            if (cur !&#x3D; NULL) &#123; &#x2F;&#x2F; 指针来访问节点，访问到最底层                st.push(cur); &#x2F;&#x2F; 将访问的节点放进栈                cur &#x3D; cur-&gt;left;                &#x2F;&#x2F; 左            &#125; else &#123;                cur &#x3D; st.top(); &#x2F;&#x2F; 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）                st.pop();                result.push_back(cur-&gt;val);     &#x2F;&#x2F; 中                cur &#x3D; cur-&gt;right;               &#x2F;&#x2F; 右            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>后序遍历</strong></p><p>先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221023170330174.png" alt="image-20221023170330174"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; st;        vector&lt;int&gt; result;        if (root &#x3D;&#x3D; NULL) return result;        st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();            st.pop();            result.push_back(node-&gt;val);            if (node-&gt;left) st.push(node-&gt;left); &#x2F;&#x2F; 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）            if (node-&gt;right) st.push(node-&gt;right); &#x2F;&#x2F; 空节点不入栈        &#125;        reverse(result.begin(), result.end()); &#x2F;&#x2F; 将结果反转之后就是左右中的顺序了        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h1><p>以中序遍历为例，使用栈的话，<strong>无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况</strong>。</p><p><strong>那就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</strong></p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p><p>简单说，先判断栈顶元素是否为空指针，如果是则说明其后面元素是处理元素，如果不是则说明应对栈顶元素进行遍历，先将其弹出，以前中后序将其与其左右节点重新排序，然后压入栈中。</p><p><strong>中序遍历</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        if (root !&#x3D; NULL) st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();            if (node !&#x3D; NULL) &#123;                st.pop(); &#x2F;&#x2F; 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中                if (node-&gt;right) st.push(node-&gt;right);  &#x2F;&#x2F; 添加右节点（空节点不入栈）                st.push(node);                          &#x2F;&#x2F; 添加中节点                st.push(NULL); &#x2F;&#x2F; 中节点访问过，但是还没有处理，加入空节点做为标记。                if (node-&gt;left) st.push(node-&gt;left);    &#x2F;&#x2F; 添加左节点（空节点不入栈）            &#125; else &#123; &#x2F;&#x2F; 只有遇到空节点的时候，才将下一个节点放进结果集                st.pop();           &#x2F;&#x2F; 将空节点弹出                node &#x3D; st.top();    &#x2F;&#x2F; 重新取出栈中元素                st.pop();                result.push_back(node-&gt;val); &#x2F;&#x2F; 加入到结果集            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>前序排序</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        if (root !&#x3D; NULL) st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();            if (node !&#x3D; NULL) &#123;                st.pop();                if (node-&gt;right) st.push(node-&gt;right);  &#x2F;&#x2F; 右                if (node-&gt;left) st.push(node-&gt;left);    &#x2F;&#x2F; 左                st.push(node);                          &#x2F;&#x2F; 中                st.push(NULL);            &#125; else &#123;                st.pop();                node &#x3D; st.top();                st.pop();                result.push_back(node-&gt;val);            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>后序排序</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        if (root !&#x3D; NULL) st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();            if (node !&#x3D; NULL) &#123;                st.pop();                st.push(node);                          &#x2F;&#x2F; 中                st.push(NULL);                if (node-&gt;right) st.push(node-&gt;right);  &#x2F;&#x2F; 右                if (node-&gt;left) st.push(node-&gt;left);    &#x2F;&#x2F; 左            &#125; else &#123;                st.pop();                node &#x3D; st.top();                st.pop();                result.push_back(node-&gt;val);            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><p><strong>迭代解法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;自己写得，但不够简洁class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        if(root&#x3D;&#x3D;nullptr) return &#123;&#125;;        vector&lt;vector&lt;int&gt;&gt; ans;        vector&lt;int&gt; layer;        queue&lt;TreeNode*&gt; que;        que.push(root);        int curLen&#x3D;1,nextLen&#x3D;0;        while(!que.empty())&#123;            TreeNode *tem&#x3D;que.front();            que.pop();            if(tem-&gt;left)&#123;                que.push(tem-&gt;left);                ++nextLen;            &#125;            if(tem-&gt;right)&#123;                que.push(tem-&gt;right);                ++nextLen;            &#125;            layer.push_back(tem-&gt;val);            --curLen;            if(curLen&#x3D;&#x3D;0)&#123;                ans.push_back(layer);                layer&#x3D;vector&lt;int&gt;&#123;&#125;;                curLen&#x3D;nextLen;                nextLen&#x3D;0;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;代码随想录中的，简洁明了，处理一些复杂情况时逻辑更加清晰class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; que;        if (root !&#x3D; NULL) que.push(root);        vector&lt;vector&lt;int&gt;&gt; result;        while (!que.empty()) &#123;            int size &#x3D; que.size();            vector&lt;int&gt; vec;            &#x2F;&#x2F; 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的            for (int i &#x3D; 0; i &lt; size; i++) &#123;                TreeNode* node &#x3D; que.front();                que.pop();                vec.push_back(node-&gt;val);                if (node-&gt;left) que.push(node-&gt;left);                if (node-&gt;right) que.push(node-&gt;right);            &#125;            result.push_back(vec);        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>递归法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"># 递归法class Solution &#123;public:    void order(TreeNode* cur, vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth)    &#123;        if (cur &#x3D;&#x3D; nullptr) return;        if (result.size() &#x3D;&#x3D; depth) result.push_back(vector&lt;int&gt;());        result[depth].push_back(cur-&gt;val);        order(cur-&gt;left, result, depth + 1);        order(cur-&gt;right, result, depth + 1);    &#125;    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        int depth &#x3D; 0;        order(root, result, depth);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1035. 不相交的线</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a><a href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></h1><p>First：虽然做出来了，但看了解析才知道可以转换为找最长公共子序列</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>要找不相交的线可以转换为找最长公共子序列（最长公共子序列之间的连线一定不相交，而最长又保证了不相交线是最多的）</p><p>使用二维dp数组来记录状态，dp[i] [j] 表示nums1前i个数和nums2前j个数公共子序列的长度。</p><p>当nums1[i]&#x3D;nums2[j]时，此时应该比dp[i-1] [j-1]多1。而不相等时，由于时找公共子序列的长度，那么dp[i] [j]&#x3D;max(dp[i-1] [j]，dp[i] [j-1])</p><p>皆初始化为0。</p><p>两重循环皆从小到大遍历</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(nums1.size()+1,vector&lt;int&gt;(nums2.size()+1,0));        for(int i&#x3D;1;i&lt;&#x3D;nums1.size();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;nums2.size();++j)&#123;                if(nums1[i-1]&#x3D;&#x3D;nums2[j-1])&#123;                    dp[i][j]&#x3D;dp[i-1][j-1]+1;                &#125;else&#123;                    dp[i][j]&#x3D;max(dp[i-1][j],dp[i][j-1]);                &#125;            &#125;        &#125;        return dp[nums1.size()][nums2.size()];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>组合数学</strong></p><p>从左上角到右下角的过程中，我们需要移动 m+n-2m+n−2 次，其中有 m-1m−1 次向下移动，n-1n−1 次向右移动。因此路径的总数，就等于从 m+n-2m+n−2 次移动中选择 m-1m−1 次向下移动的方案数，即组合数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922152234753.png" alt="image-20220922152234753"></p><ul><li>时间复杂度：O(m) </li><li>空间复杂度：O1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1049. 最后一块石头的重量 II</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h1><p>First：没想出来咋做，看了答案发现可以转换为01背包来做，还是对问题理解得不够深刻</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>问题实质就是将所有石头尽可能均分为2份，这两堆石头相互碰撞后就能得到最小重量。因此，先求所有石头重量之和，然后找0到sum&#x2F;2中最大能挑选出得石头重量之和，挑选方法和第343题类似，只是多了个flag来记录最大值即可。</p><ul><li>时间复杂度：O(sum × n) </li><li>空间复杂度：O(sum)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;        if(stones.size()&#x3D;&#x3D;1) return stones[0];        int sum&#x3D;0;        for(auto a:stones)&#123;            sum+&#x3D;a;        &#125;        int target&#x3D;sum&#x2F;2;        vector&lt;int&gt; dp(target+1,0);        int flag&#x3D;stones[0];        for(int i&#x3D;0;i&lt;stones.size();++i)&#123;            for(int j&#x3D;target;j&gt;&#x3D;stones[i];--j)&#123;                dp[j]&#x3D;max(dp[j],dp[j-stones[i]]+stones[i]);                if(dp[j]&#x3D;&#x3D;j) flag&#x3D;max(flag,j);&#x2F;&#x2F;找到最大能挑选出来得重量之和            &#125;        &#125;        return sum-2*flag;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1143. 最长公共子序列</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h1><p>First：和748题很像，只是在处理字符不相同情况时的处理方法不一样</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j] 表示text1前i个字符和text2前j个字符公共子序列的长度。</p><p>当text1[i]&#x3D;text2[j]时，此时应该比dp[i-1] [j-1]多1。而不相等时，由于时找公共子序列的长度，那么dp[i] [j]&#x3D;max(dp[i-1] [j]，dp[i] [j-1])</p><p>皆初始化为0。</p><p>两重循环皆从小到大遍历</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn) 可优化为n</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int longestCommonSubsequence(string text1, string text2) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(text1.length()+1,vector&lt;int&gt;(text2.length()+1,0));        int ans&#x3D;0;        for(int i&#x3D;1;i&lt;&#x3D;text1.length();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;text2.length();++j)&#123;                if(text2[j-1]&#x3D;&#x3D;text1[i-1])&#123;                    dp[i][j]&#x3D;dp[i-1][j-1]+1;                &#125;else&#123;                    dp[i][j]&#x3D;max(dp[i][j-1],dp[i-1][j]);                &#125;                ans&#x3D;max(ans,dp[i][j]);            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>115. 不同的子序列</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97-difficult/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></h1><p>First：没做出来，没推导出转移方程</p><p>Second：还是没做出来，淦</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j] 表示s的前i-1个字符的子序列中t的前j-1个字符出现的个数</p><p>当s[i - 1] 与 t[j - 1]相等，dp[i] [j]可以有两部分组成：一部分是用s[i - 1]来匹配，那么个数为dp[i - 1] [j - 1]。一部分是不用s[i - 1]来匹配，个数为dp[i - 1] [j]（这部分是因为s的第i-1个字符可选可不选，如果不选才能出现所有子序列匹配的情况）。 dp[i] [j] &#x3D; dp[i - 1] [j - 1] + dp[i - 1] [j]</p><p>当s[i - 1] 与 t[j - 1]不相等时，dp[i] [j]只有一部分组成，不用s[i - 1]来匹配，即：dp[i - 1] [j]</p><p>由定义可知，dp[i] [0]&#x3D;1（因为出现空字符个数为1）</p><p>dp[i] [j]由dp[i-1] [j-1]决定，因此需要以遍历s为外层，遍历t为内层循环。</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n^2^)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numDistinct(string s, string t) &#123;        vector&lt;vector&lt;unsigned int&gt;&gt; dp(s.length()+1,vector&lt;unsigned int&gt;(t.length()+1,0));        for(int i&#x3D;0;i&lt;&#x3D;s.length();++i)&#123;            dp[i][0]&#x3D;1;        &#125;        for(int i&#x3D;1;i&lt;&#x3D;s.length();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;t.length();++j)&#123;                if(s[i-1]&#x3D;&#x3D;t[j-1])&#123;                    dp[i][j]&#x3D;dp[i-1][j-1]+dp[i-1][j];                &#125;else&#123;                    dp[i][j]&#x3D;dp[i-1][j];                &#125;            &#125;        &#125;        return dp[s.length()][t.length()];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121. 买卖股票的最佳时机</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h1><p>First：卡住了，淦，dp时分成了三种状态：买、卖、持有，折腾了半天还是没把状态搞好</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>找最优间距，不断找到遍历前的最小值，然后使用当前值减去左边最小值，并记录最大差值即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int pMin&#x3D;INT_MAX,res&#x3D;0;        for(int i&#x3D;0;i&lt;prices.size();++i)&#123;            pMin&#x3D;min(pMin,prices[i]);            res&#x3D;max(prices[i]-pMin,res);        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>每天可以分为两种状态，持有股票和不持有股票，且这两种状态都可以由前一天推导出来</p><p>每个二维dp数组来记录状态，dp[i] [0]表示第i天持有股票所得最多现金，dp[i] [1]表示持有股票所得最多现金。</p><p>第i天持有股票可以由前一天推导出来，即dp[i] [0]&#x3D;max(dp[i-1] [0],-prices[i]) （注意，由于只能买一次股票，所以这里为-prices[i]；同理，dp[i] [1]&#x3D;max(dp[i-1] [1],dp[i-1] [0]+prices[i])。可以优化为两个值来记录即可。</p><p>第一天持有或不持有股票，则dp[0] [0]&#x3D;-prices[0], dp[0] [1]&#x3D;0。</p><p>由于根节点需要由左右节点状态所得，那么使用后序遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int have&#x3D;-prices[0],nohave&#x3D;0;        for(int i&#x3D;1;i&lt;prices.size();++i)&#123;            int t&#x3D;have;            have&#x3D;max(have,-prices[i]);            nohave&#x3D;max(t+prices[i],nohave);            &#x2F;&#x2F; cout&lt;&lt;have&lt;&lt;&quot; &quot;&lt;&lt;nohave&lt;&lt;endl;        &#125;        return max(have,nohave);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>322. 零钱兑换</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h1><p>First：做的时候陷入到挑选数的套路中去了，觉得还要记录以下选了单词后的剩余状态。最后看了点解析就发现还是没理解透动态规划关于挑选物品的核心。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用滚动一维dp数组来记录状态，dp[j] 表示凑成是否能凑成字符串前j个字符。</p><p>假设选择字符串str，其是否能拼接出前j个字符，与dp[j-str.length()]有关，且当前选择字符也必须与字符串中(j-str.length()-1, j-1) 必须相同。因此，dp[j]&#x3D;dp[j-str.length()]&amp;&amp;isSame(s,str,pos)（这是一个判断字符串是否相同的函数）。</p><p>dp[0]&#x3D;1，其余初始化为0。</p><p>字典中的单词可能在字符串的任意位置出现，如果先遍历物品（字典），那么先遍历的单词就不能在后面出现了，因此需要先遍历背包（字符串），再遍历物品（字典），由于字符串可以重复使用，那么内部循环应该从小到大遍历。</p><ul><li>时间复杂度：O(n*amount) </li><li>空间复杂度：O(amount)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isSame(const string &amp;s1,const string &amp;s2,int pos)&#123;        int t1&#x3D;pos,t2&#x3D;s2.length()-1;        while(t2&gt;&#x3D;0)&#123;            if(s1[t1--]!&#x3D;s2[t2--]) return false;        &#125;        return true;    &#125;    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;        vector&lt;int&gt; dp(s.length()+1,0);        dp[0]&#x3D;1;        for(int j&#x3D;1;j&lt;&#x3D;s.length();++j)&#123;            for(int i&#x3D;0;i&lt;wordDict.size();++i)&#123;                if(j&gt;&#x3D;wordDict[i].length()&amp;&amp;dp[j-wordDict[i].length()]&#x3D;&#x3D;1)&#123;                    if(isSame(s,wordDict[i],j-1))&#123;                        dp[j]&#x3D;1;                    &#125;                &#125;            &#125;        &#125;        return dp[s.length()];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>213. 打家劫舍 II</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h1><p>First：没做出来，一直想着直接用dp来做，而不是转化为两次dp</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>由于房屋是环状，因此第一个房屋和最后一个房屋中最多只能选择其中一个，因此可以分成不考虑最后一个房屋和不考虑第一个房屋两种情况分别求最大值，然后选择其中最大值即可。</p><p>使用一维dp数组来记录状态，dp[j] 表示前j个房屋最多能偷盗的金额。</p><p>dp[j]由选不选第j个房屋决定，因此dp[j]&#x3D;max(dp[j-1],dp[j-2]+nums[j])</p><p>dp初始化为0。</p><p>从小到大遍历皆可</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()&#x3D;&#x3D;1) return nums[0];        return max(robRange(nums,0,nums.size()-2),robRange(nums,1,nums.size()-1));    &#125;    int robRange(const vector&lt;int&gt; &amp;nums,int s,int e)&#123;        int t1&#x3D;0,t2&#x3D;0;        for(int i&#x3D;s;i&lt;&#x3D;e;++i)&#123;            int tem&#x3D;t2;            t2&#x3D;max(t2,t1+nums[i]);            t1&#x3D;tem;        &#125;        return t2;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>322. 零钱兑换</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h1><p>First：看着像01背包，但无法解决不能连续选的问题，后来做的方法和答案有些差别，想的是只有两种选择，要么选往前退第二个数，要么第三个数，但最后需要在最后两个数中选择最大的数。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[j] 表示前j个房屋最多能偷盗的金额。</p><p>dp[j]由选不选第j个房屋决定，因此dp[j]&#x3D;max(dp[j-1],dp[j-2]+nums[j])</p><p>dp初始化为0。</p><p>从小到大遍历皆可</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        int t1&#x3D;0,t2&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            int tem&#x3D;t2;            t2&#x3D;max(t1+nums[i],t2);            t1&#x3D;tem;        &#125;        return t2;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2767. 将字符串分割为最少的美丽子字符串</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-2767-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E4%B8%BA%E6%9C%80%E5%B0%91%E7%9A%84%E7%BE%8E%E4%B8%BD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-2767-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E4%B8%BA%E6%9C%80%E5%B0%91%E7%9A%84%E7%BE%8E%E4%B8%BD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="2767-将字符串分割为最少的美丽子字符串"><a href="#2767-将字符串分割为最少的美丽子字符串" class="headerlink" title="2767. 将字符串分割为最少的美丽子字符串"></a><a href="https://leetcode.cn/problems/partition-string-into-minimum-beautiful-substrings/description/">2767. 将字符串分割为最少的美丽子字符串</a></h1><p>First：较常规，只是找二进制麻烦一点，直接计算出二进制，预置到数组中。使用dp求解即可。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[i] 表示以s[i-1]结尾字符串最少得美丽字符串个数。</p><p>要求当前字符串的美丽字符串个数，那么只需要遍历所有美丽字符串，减去美丽字符串后的美丽字符串个数+1即可，找出其中最小即可、</p><p>dp[0]&#x3D;0，皆初始化为大于5的数即可。</p><p>从左到右遍历即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;string&gt; beau_str&#123;&quot;1&quot;,&quot;101&quot;,&quot;11001&quot;,&quot;1111101&quot;,&quot;1001110001&quot;,&quot;110000110101&quot;,&quot;11110100001001&quot;&#125;;class Solution &#123;public:    int minimumBeautifulSubstrings(string s) &#123;        int n&#x3D;s.size();        vector&lt;int&gt; dp(n+1,100);        dp[0]&#x3D;0;        for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;            for(int j&#x3D;0;j&lt;beau_str.size();++j)&#123;                int start&#x3D;i-beau_str[j].size(),size&#x3D;beau_str[j].size();                if(i&gt;&#x3D;size&amp;&amp;beau_str[j]&#x3D;&#x3D;s.substr(start,size))&#123;                    dp[i]&#x3D;min(dp[i],dp[start]+1);                &#125;            &#125;        &#125;        return dp[n]&#x3D;&#x3D;100?-1:dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>279. 完全平方数</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h1><p>First：也是一道完全背包中求目标和所需最小数量类型题，和322一样，只是稍有变化</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>相比322题，此题只是需要自己求出物品值，其余皆类似</p><p>使用一维dp数组来记录状态，dp[j] 表示凑成j所需的最少数量。</p><p>凑足总额为j - i*i的最少个数为dp[j - i *i]，那么只需要加上一个平方数即dp[j - i *i] + 1就是dp[j]，所以dp[j] 要取所有 dp[j - i *i] + 1 中最小的。dp[j] &#x3D; min(dp[j - i *i] + 1, dp[j])</p><p>凑足目标为0所需平方的个数一定是0，那么dp[0] &#x3D; 0;dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p><p>求最小个数，那么平方数有顺序和没有顺序都可以，都不影响平方数的最小个数，因此先遍历背包容量还是物品都可。</p><ul><li>时间复杂度：O(n*amount) </li><li>空间复杂度：O(amount)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numSquares(int n) &#123;        int amount&#x3D;sqrt(n);        vector&lt;int&gt; dp(n+1,n+1);        dp[0]&#x3D;0;        for(int i&#x3D;1;i&lt;&#x3D;amount;++i)&#123;            int t&#x3D;i*i;            for(int j&#x3D;t;j&lt;&#x3D;n;++j)&#123;                dp[j]&#x3D;min(dp[j],dp[j-t]+1);            &#125;        &#125;        return dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法1</strong>：<strong>数学</strong></p><ul><li>时间复杂度：O(sqrt{n}) </li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>300. 最长递增子序列</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h1><p>First：以前做过，不难，就按动态规划思想来即可</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用滚动一维dp数组来记录状态，dp[i] 表示前i+1个字符的最长递增子序列长度。</p><p>dp[i]与前i个值都有关系，如果nums[i]&gt;nums[k]（k为0到i-1），那么dp[i]&#x3D;dp[k]+1，每次遍历第i+1个数时，都遍历前i个数，找到最大的dp[i]。dp[i]&#x3D;max(dp[k]+1) （nums[i]&gt;nums[k] k为0到i-1）</p><p>每个数自身变为长度为1的子序列，因此dp都初始化为1。</p><p>从左到右遍历即可</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        int ans&#x3D;1;        int n&#x3D;nums.size();        vector&lt;int&gt; dp(n,1);        for(int i&#x3D;1;i&lt;n;++i)&#123;            for(int j&#x3D;0;j&lt;i;++j)&#123;                if(nums[j]&lt;nums[i])&#123;                    dp[i]&#x3D;max(dp[i],dp[j]+1);                                    &#125;            &#125;            ans&#x3D;max(dp[i],ans);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>贪心 + 二分查找</strong></p><p>思想：要使上升子序列尽可能的长，则需要让序列上升得尽可能慢。</p><p>使用一个数组记录当前已有的递增序列，从左到右进行遍历，如果nums[i]序列中末尾值，则将其插入到递增序列中（序列延长），否则的话就将序列中第一个大于nums[i]的值替换为nums[i]（使序列尽可能上升慢）。</p><ul><li><p>原因：如果以此值为开始的递增序列更大，那么它们按上述方法插入到递增序列后必定使得序列更长，而如果递增序列更小也不会影响最终答案。</p></li><li><p>时间复杂度：O(nlogn) </p></li><li><p>空间复杂度：O(n)</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lenNums<span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>lenNums<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                lenNums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">auto</span> it<span class="token operator">=</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>lenNums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>lenNums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">*</span>it<span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> lenNums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>213. 打家劫舍 II</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h1><p>First：没想出咋记录选与不选状态，感觉用数组来记录又消耗太大，这是到树形动态规划的基本题</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>每个节点使用大小为2的一维dp数组来记录状态，dp[0] 表示选当前节点所能获得的最大金额，dp[1]表示不选当前节点所能获得的最大金额，然后从中选择最大值即可。</p><p>如果选当前节点，那么dp[0]&#x3D;root-&gt;val+left[1]+right[1]；如果不选当前节点dp[1]&#x3D;max{left[0],left[1]}+max{right[0],right[1]}。</p><p>dp初始化为0。</p><p>由于根节点需要由左右节点状态所得，那么使用后序遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int rob(TreeNode* root) &#123;        vector&lt;int&gt; ans&#x3D;robTree(root);        return max(ans[0],ans[1]);    &#125;    vector&lt;int&gt; robTree(TreeNode *root)&#123;        if(root&#x3D;&#x3D;nullptr) return &#123;0,0&#125;;        vector&lt;int&gt; left&#x3D;robTree(root-&gt;left);        vector&lt;int&gt; right&#x3D;robTree(root-&gt;right);        int val1&#x3D;root-&gt;val+left[1]+right[1];&#x2F;&#x2F;偷当前节点        int val2&#x3D;max(left[0],left[1])+max(right[0],right[1]);&#x2F;&#x2F;不偷当前节点        return &#123;val1,val2&#125;;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>343. 整数拆分</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h1><p>First：用数学方法做出来的，虽然逻辑想清楚了，但最底层的原理大于4的数拆分成两项后的乘积大于原数没理出来，只是理出了只能用2和3进行拆分。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[i] 表示i拆分能获得的最大乘积。</p><p>拆分可以分为三种：</p><ul><li>只将当前值拆分为j和k，j和k不继续拆分</li><li>j和k其中一个继续拆分</li><li>j和k都继续拆分（解答中不考虑这种情况我认为是因为每个值最后都会拆成2和3的组合，2和3不能继续拆了，不然就变小了）</li></ul><p>因此dp[i]就取遍历时三种情况中最大的值</p><p>大数是由小数加起来，因此由小到大遍历</p><p>dp[1]&#x3D;1。</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int integerBreak(int n) &#123;        if(n&lt;4) return n-1;        vector&lt;int&gt; dp(n+1,0);        dp[1]&#x3D;1;        for(int i&#x3D;2;i&lt;&#x3D;n;++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;i&#x2F;2;++j)&#123;                dp[i]&#x3D;max(dp[i],max(j*(i-j),max(j*dp[i-j],dp[j]*dp[i-j])));                &#x2F;&#x2F; dp[i]&#x3D;max(dp[i],max(j*(i-j),j*dp[i-j])); &#x2F;&#x2F;官方解答是这个状态转换，但上面的更易懂，这个只是由于最后都是拆分为2和3，因此也就可以省略一种拆分            &#125;        &#125;        return dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>数学</strong></p><p>大于4的数拆分成两项后的乘积大于原数，而对于4也能拆分成2和2。因此每个数都是被拆分为由2和3组成，且应尽可能使3更多。</p><ul><li>时间复杂度：O(m) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int integerBreak(int n) &#123;        if(n&lt;&#x3D;3) return n-1;        int res&#x3D;n%3;        n&#x2F;&#x3D;3;        int ans&#x3D;1;        for(int i&#x3D;0;i&lt;n;++i)&#123;            ans*&#x3D;3;        &#125;        if(res&#x3D;&#x3D;1)&#123;            return ans&#x2F;3*4;        &#125;else if(res&#x3D;&#x3D;2)&#123;            return ans*2;        &#125;else&#123;            return ans;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>322. 零钱兑换</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h1><p>First：这次没做出来，但以前做过，是动态规划中又出现的一种类型题，主要是这道题的初始化没搞对，再加上遍历顺序也理解不深刻。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[j] 表示凑成j所需的最少硬币数量。</p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]，所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j])</p><p>凑足总金额为0所需钱币的个数一定是0，那么dp[0] &#x3D; 0;dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p><p>求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数，因此先遍历背包容量还是物品都可。</p><ul><li>时间复杂度：O(n*amount) </li><li>空间复杂度：O(amount)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        vector&lt;int&gt; dp(amount+1,INT_MAX);        dp[0]&#x3D;0;        &#x2F;&#x2F;先遍历背包容量还是物品皆可，因为与顺序无关        for(int i&#x3D;0;i&lt;coins.size();++i)&#123;            for(int j&#x3D;coins[i];j&lt;&#x3D;amount;++j)&#123;                if(dp[j-coins[i]]!&#x3D;INT_MAX)                    dp[j]&#x3D;min(dp[j],dp[j-coins[i]]+1);            &#125;        &#125;        return dp[amount]&#x3D;&#x3D;INT_MAX?-1:dp[amount];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>377. 组合总和 Ⅳ</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h1><p>First：这是一道完全背包中求排列方法数量类型的题，此时需要注意必须容量在外层循环否则只是求得组合方法数量，注意求排列和组合两种类型遍历顺序的差别</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[j] 表示凑成i的排列个数。</p><p>dp[j]同样由前面状态推导出来，即dp[j]+&#x3D;dp[j-nums[i]]</p><p>必须将dp[0]&#x3D;1，否则没有基础方法累加</p><p>为了获得排列数，必须先遍历背包容量再遍历物品，比如有{1,3} {3,1}这样的结果，如果先遍历物品再遍历背包容量，那么就不会出现{3,1}结果，这是因为遍历时编号大的物品一定比编号小的物品后出现</p><blockquote><p>如果是求排列数，那么就应该先遍历物品再遍历背包容量</p></blockquote><p>此题中dp值会overflow，使用unsigned int就不会，但是使用long long任然会overflow，没搞明白为啥，按理说unsigned int 比long long最大值小。而答案是使用的int，只是多判断了一个是否overflow</p><ul><li>时间复杂度：O(n*target) </li><li>空间复杂度：O(target)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;unsigned int&gt; dp(target+1,0);        dp[0]&#x3D;1;        for(int j&#x3D;1;j&lt;&#x3D;target;++j)&#123;            for(int i&#x3D;0;i&lt;nums.size();++i)&#123;                if(nums[i]&lt;&#x3D;j)&#123;                &#x2F;&#x2F;if (nums[i]&lt;&#x3D;j &amp;&amp; dp[j] &lt; INT_MAX - dp[j - nums[i]]) &#123; &#x2F;&#x2F;答案是使用这种方法来解决overflow情况的，dp仍为int值                    dp[j]+&#x3D;dp[j-nums[i]];                &#125;            &#125;        &#125;        return dp[target];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>392. 判断子序列</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97-simple/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h1><p>First：开始使用动态规划找最长公共子序列来做的，虽然也能通过但比较耗时，后来一想这简单题也应该这么复杂。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>和1143题找最长公共子序列一样，只是最后判断最长子序列长度是否等于s长度即可。</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isSubsequence(string s, string t) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(s.length()+1,vector&lt;int&gt;(t.length()+1,0));        for(int i&#x3D;1;i&lt;&#x3D;s.length();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;t.length();++j)&#123;                if(s[i-1]&#x3D;&#x3D;t[j-1])&#123;                    dp[i][j]&#x3D;dp[i-1][j-1]+1;                &#125;else&#123;                    dp[i][j]&#x3D;max(dp[i-1][j],dp[i][j-1]);                &#125;            &#125;        &#125;        return dp[s.length()][t.length()]&#x3D;&#x3D;s.length()?true:false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>双指针</strong></p><p>定义两个指针分别指向字符按的串首，依次比较两个指针指向数是否相同，如果不同则指向字符串t的指针加1，否则两个指针同时加1。此方法能有效的原因是，如果s是t的子序列，那么s每个字符的排序在t中都能找到（无论其中是否有重复类似子序列）。</p><ul><li>时间复杂度：O(n+m) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool isSubsequence(string s, string t) &#123;        int i&#x3D;0,j&#x3D;0;        for(;i&lt;s.length()&amp;&amp;j&lt;t.length();++j)&#123;            if(s[i]&#x3D;&#x3D;t[j])&#123;                ++i;            &#125;        &#125;        return i&gt;&#x3D;s.length()?true:false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
            <tag> Alg-双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>416. 分割等和子集</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h1><p>First：从代码备忘录中做到这题，考虑用动态规划方法，但开始想的是找n-1以下个数字，如果找到和的一半则返回true，但是忽略了找几个数字之和都是找到的最大和，但和的一般可能不是由几个数字的最大和组成，这种思路应该用回溯才能成功。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>根据题意，需要做到的是从数组挑出若干个数得到目标和target。可以转换为01背包问题：</p><ul><li>背包体积为sum&#x2F;2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum &#x2F; 2 的子集。</li><li>背包中每一个元素是不可重复放入。</li></ul><p>使用二维dp数组来记录状态，dp[i] [j] 表示容量为j的背包，对nums前i+1个数，能凑成的最大和。</p><p>对于dp[i] [j]只会有两种选择，取当前数或者不取，如果不取则和dp[i-1] [j]相同，如果取则需要对找到减去当前数所占体积的dp对应值，</p><p>即dp[i] [j]&#x3D;max(dp[i-1] [j],dp[i-1] [j-weight[i]]+value[i])</p><p>两重循环中，无论先遍历i还是先遍历j都可，都从小到大遍历，只是理解不同。</p><p>dp可以只使用一维数据来记录，注意这样就需要里面那层遍历从大到小遍历</p><ul><li>时间复杂度：O(n*target) </li><li>空间复杂度：O(target)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int n&#x3D;nums.size();        int sum&#x3D;0;        for(auto &amp;n:nums)&#123;            sum+&#x3D;n;        &#125;        if(sum%2&#x3D;&#x3D;1) return false;        sum&#x2F;&#x3D;2;        vector&lt;int&gt; dp(sum+1,0);        for(int i&#x3D;0;i&lt;n;++i)&#123;            for(int j&#x3D;sum;j&gt;&#x3D;nums[i];--j)&#123;                dp[j]&#x3D;max(dp[j],dp[j-nums[i]]+nums[i]);                if(dp[j]&#x3D;&#x3D;sum) return true;            &#125;        &#125;        return dp[sum]&#x3D;&#x3D;sum?true:false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>474. 一和零</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-474-%E4%B8%80%E5%92%8C%E9%9B%B6-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-474-%E4%B8%80%E5%92%8C%E9%9B%B6-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/">474. 一和零</a></h1><p>First：想了下，相比常规01背包只是变成了两个维度，dp多一维就行了。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>此题是找最大子集长度，和普通01背包中挑选最大和类似，只是相比1个维度的容量，此题容量变为两个维度，以每个string的0和1的个数作为两个维度的容量值weight，value皆为1。</p><p>使用二维dp数组来记录状态，dp[i] [j]表示最多有i个0和j个1的strs的最大子集的大小</p><p>dp[i] [j]&#x3D;max(dp[i] [j],dp[i-num0] [j-num1])，这里使用的滚动数组，num0指string中0的个数</p><p>到第0行第0列个格子的方法1中，所以dp[0] [0]&#x3D;1。</p><p>机器人只能向右或向下移动，那么要知道当前方格路径就需要知道上方方格和左边方格路径数，因此先从左到右遍历一行，再由上到下遍历每一行。</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));        for(string &amp;s:strs)&#123;            int l0&#x3D;0,l1&#x3D;0;            for(char c:s)&#123;                if(c&#x3D;&#x3D;&#39;0&#39;)&#123;                    ++l0;                &#125;else&#123;                    ++l1;                &#125;            &#125;            for(int j&#x3D;m;j&gt;&#x3D;l0;--j)&#123;                for(int k&#x3D;n;k&gt;&#x3D;l1;--k)&#123;                    dp[j][k]&#x3D;max(dp[j][k],dp[j-l0][k-l1]+1);                &#125;            &#125;         &#125;        return dp[m][n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>494. 目标和</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-494-%E7%9B%AE%E6%A0%87%E5%92%8C-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-494-%E7%9B%AE%E6%A0%87%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h1><p>First：以前做过，但还是没做出来，想到了要找(sum-target)&#x2F;2，但dp含义没理解透彻，初始化也没搞对。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>给定数组所有数相加和sum是确定的，因为只有两种符号，因此所有数就可以分为两堆，一堆全为+，一堆全为-，因此找到其中任意一堆的值有多少种组合方法即可。如果找减数堆都赋为减号，那么此时所有和加起来相比sum少了两倍减数堆之和，因此，减数堆之和a&#x3D;(sum-target)&#x2F;2。</p><p>由此，算法也就变成了nums组成a和的方法数。</p><p>使用二维dp数组来记录状态，dp[i] [j]表示由nums前i+1个数组成j的方法数。</p><p>dp[i] [j]也两种选择，</p><ul><li>当j&lt;nums[i]时，此时j不可能由nums[i]组成，因此dp[i] [j]&#x3D;dp[i-1] [j]</li><li>否则，j可能也有nums[i]组成，此时组成j就有两种可能，即不包含nums[i]和包含nums[i]，因此dp[i] [j]&#x3D;dp[i-1] [j]+dp[i-1] [j-nums[i]]</li></ul><p>当j&#x3D;0时，不需要挑选数就可以等于0，因此dp[0] [0]&#x3D;1。</p><p>更大的j是由更小的j组成，因此需要从小到大遍历</p><p>可以优化为以为数组</p><ul><li>时间复杂度：O(n*a) </li><li>空间复杂度：O(a)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;        int sum&#x3D;0;        for(auto a:nums)&#123;            sum+&#x3D;a;        &#125;                if((sum-target)%2!&#x3D;0||sum&lt;target) return 0;        target&#x3D;(sum-target)&#x2F;2;        vector&lt;int&gt; dp(target+1,0);        dp[0]&#x3D;1;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            for(int j&#x3D;target;j&gt;&#x3D;0;--j)&#123;                if(j&gt;&#x3D;nums[i])&#123;                    dp[j]&#x3D;dp[j]+dp[j-nums[i]];                &#125;            &#125;        &#125;        return dp[target];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>回溯</strong></p><ul><li>时间复杂度：O(2^n^) </li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>509. 斐波那契数</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0-simple/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></h1><p>First：直接使用递归来做，但时间打败率挺低。</p><hr><p><strong>方法1</strong>：<strong>递归</strong></p><p>不断递归找到最终结果即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int fib(int n) &#123;        if(n&lt;2)&#123;            return n;        &#125;else&#123;            return fib(n-1)+fib(n-2);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>循环遍历（动态规划）</strong></p><p>循环遍历得到每个数的斐波那契值即可</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int fib(int n) &#123;        if(n&lt;2) return n;        &#x2F;&#x2F; if(n&#x3D;&#x3D;1) return 1;        int a&#x3D;0,b&#x3D;1;        for(int i&#x3D;2;i&lt;&#x3D;n;++i)&#123;            int t&#x3D;a+b;            a&#x3D;b;            b&#x3D;t;        &#125;        return b;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>516. 最长回文子序列</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h1><p>First：开始看错题了，虽然后面也做出来了</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示以s以位置i开头位置j结尾所形成的字符串的最长回文子序列，因此选最大的dp返回。</p><p>递推公式：</p><ul><li><p>当s[i]&#x3D;&#x3D;s[j]时，此时最长回文长度是在由内层字符s[i+1]到s[j-1]基础上加2，所以dp[i] [j]&#x3D;dp[i-1] [j-1]+2，由于皆初始化为0，当i&#x3D;j和i&#x3D;j-1时，此时dp[i] [j]&#x3D;1;</p></li><li><p>当s[i]!&#x3D;s[j]时，此时回文长度不增加，而是由原来回文长度决定。而现有字符串可以由三种情况组成，字符串首部少一个字符，或尾部少一个字符，或首尾皆少一个字符（其实要么少首要么少尾两种情况就够了），因此dp[i] [j]&#x3D;max(dp[i+1] [j],max(dp[i] [j-1],dp[i+1] [j-1]))。</p></li></ul><p>dp皆初始化为0</p><p>从递推公式可以看出是从左下方推导出当前结果，因此需要先外层从大到小遍历s，再内层从小到大遍历s</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n^2^)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int longestPalindromeSubseq(string s) &#123;        int len&#x3D;s.length();        vector&lt;vector&lt;int&gt;&gt; dp(len,vector&lt;int&gt;(len,0));        int ans&#x3D;1;        for(int i&#x3D;len-1;i&gt;&#x3D;0;--i)&#123;            for(int j&#x3D;i;j&lt;len;++j)&#123;                if(s[i]&#x3D;&#x3D;s[j])&#123;                    if(i&#x3D;&#x3D;j) dp[i][j]&#x3D;1;                    else if(j-i&#x3D;&#x3D;1) dp[i][j]&#x3D;2;                    else dp[i][j]&#x3D;dp[i+1][j-1]+2;                &#125;else&#123;                    dp[i][j]&#x3D;max(dp[i+1][j-1],max(dp[i+1][j],dp[i][j-1]));                &#125;                ans&#x3D;max(ans,dp[i][j]);            &#125;                &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>518. 零钱兑换 II</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h1><p>First：是一道完全背包中找组合数类型的题</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>此题是一道完全背包找目标组合数类型的题，weight[i]&#x3D;nums[i]</p><p>使用滚动一维维dp数组来记录状态，dp[i]组成金额为i的组合数。</p><p>由于完全背包的遍历方法，dp[j]+&#x3D;dp[j-weight[i]]</p><p>dp[0] &#x3D;1。</p><ul><li>时间复杂度：O(n*amount) </li><li>空间复杂度：O(amount)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;        vector&lt;int&gt; dp(amount+1,0);        dp[0]&#x3D;1;        for(int i&#x3D;0;i&lt;coins.size();++i)&#123;            for(int j&#x3D;coins[i];j&lt;&#x3D;amount;++j)&#123;                dp[j]+&#x3D;dp[j-coins[i]];            &#125;        &#125;        return dp[amount];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53. 最大子数组和</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h1><p>First：没做出来，定义不好dp含义，用两重循环超时了</p><p>Second：才做几天，刷贪心算法系列题又遇见了，不过没用贪心做出来，对这题理解得不够透彻</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[i] 表示以nums[i-1]结尾的最大连续子数组的和，那么找到最大的dp即为结果。</p><p>要求以nums[i-1]结尾的最大和，那么对于nums[i-2]结尾的最大和dp[i-1]，如果dp[i-1]&gt;0，那么加上dp[i-1]才能使得dp[i]更大，否则就不应该加上dp[i-1]，而是从num[i-1]重新作为连续子数组的头和尾。因此，dp[i]&#x3D;max(dp[i-1]+nums[i-1],nums[i-1])。</p><p>皆初始化为0。</p><p>从小到大遍历即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n) 可优化为1</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int n&#x3D;nums.size();        vector&lt;int&gt; dp(n+1,0);        int ans&#x3D;INT_MIN;        for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;            dp[i]&#x3D;max(nums[i-1]+dp[i-1],nums[i-1]);            ans&#x3D;max(ans,dp[i]);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>贪心</strong></p><p>遍历整个数组，当遍历到任意位置k时，若现有连续子数组和为负时，nums[k]加上前面的连续子数组结果会更小，此时应该舍弃前面数组，而以nums[k]作为新子数组的起始。</p><p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p><p>全局最优：选取最大“连续和”</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int ans&#x3D;INT_MIN;        int count&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            count+&#x3D;nums[i];            ans&#x3D;max(ans,count);            if(count&lt;0) count&#x3D;0;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：<strong>分治法</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>583. 两个字符串的删除操作</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h1><p>First：虽然做出来了，但做出来后细想才发现有些没搞懂原因</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>对于两个字符串A、B，若AB相同时，此时A若添加一个字符后，其实可以堪称B减少了一个字符，因此，添加操作和删除操作可以看成 相等的。对于此题，使用添加操作进行推导（只能使用一种操作，不能使用两种操作，虽然本质相同）。</p><p>使用二维dp数组来记录状态，dp[i] [j]表示word1前i个字符和word2前j个字符相同所需最小步骤。</p><p>递推公式：</p><ul><li><p>当word1[i-1]&#x3D;&#x3D;word2[j-1]时，此时无需修改字符，所以dp[i] [j]&#x3D;dp[i-1] [j-1]；</p></li><li><p>当word1[i-1]!&#x3D;word2[j-1]时，此时有两种操作可以使得字符相等，要么在dp[i-1] [j]情况下对word1添加一个字符，要么在dp[i] [j-1]情况下对word2添加一个字符。因此，dp[i] [j]&#x3D;max(dp[i-1] [j],dp[i] [j-1])+1;</p></li></ul><p>由dp定义可知，dp[i] [0]&#x3D;i（word2的0个字符要变成word1前i个字符需要添加i次），dp[0] [j]&#x3D;j（原因同理）</p><p>从递推公式可以看出是从左上方推导出当前结果，因此需要先外层从小到大遍历word1，再内层从小到大遍历word2</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minDistance(string word1, string word2) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1,vector&lt;int&gt;(word2.size()+1,0));        for(int i&#x3D;1;i&lt;&#x3D;word1.size();++i)&#123;            dp[i][0]&#x3D;i;        &#125;        for(int j&#x3D;1;j&lt;&#x3D;word2.size();++j)&#123;            dp[0][j]&#x3D;j;        &#125;        for(int i&#x3D;1;i&lt;&#x3D;word1.size();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;word2.size();++j)&#123;                if(word1[i-1]&#x3D;&#x3D;word2[j-1])&#123;                    dp[i][j]&#x3D;dp[i-1][j-1];                &#125;else&#123;                    dp[i][j]&#x3D;min(dp[i-1][j],dp[i][j-1])+1;                &#125;            &#125;        &#125;        return dp[word1.size()][word2.size()];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>62. 不同路径</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h1><p>First：以前做过，但一下子没看懂组合数学方法。这次用的动态规划做。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示到第i行j列个网格时的不同路径。</p><p>由题中可知，只能向右或向下移动，因此到当前方格的路径则由左边方格路径和上方方格路径相加得到。</p><p>到第0行第0列个格子的方法1中，所以dp[0] [0]&#x3D;1。</p><p>机器人只能向右或向下移动，那么要知道当前方格路径就需要知道上方方格和左边方格路径数，因此先从左到右遍历一行，再由上到下遍历每一行。</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int uniquePaths(int m, int n) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,0));        dp[0][0]&#x3D;1;        for(int i&#x3D;0;i&lt;m;++i)&#123;            for(int j&#x3D;0;j&lt;n;++j)&#123;                if(j&gt;0) dp[i][j]&#x3D;dp[i][j-1];                if(i&gt;0) dp[i][j]+&#x3D;dp[i-1][j];            &#125;        &#125;        return dp[m-1][n-1];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>组合数学</strong></p><p>从左上角到右下角的过程中，我们需要移动 m+n-2m+n−2 次，其中有 m-1m−1 次向下移动，n-1n−1 次向右移动。因此路径的总数，就等于从 m+n-2m+n−2 次移动中选择 m-1m−1 次向下移动的方案数，即组合数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922152234753.png" alt="image-20220922152234753"></p><ul><li>时间复杂度：O(m) </li><li>空间复杂度：O1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>63. 不同路径 II</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h1><p>First：以前做过，且和62题思想一样，只是需要判断是否有障碍即可</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示到第i行j列个网格时的不同路径数量。</p><p>由题中可知，只能向右或向下移动，因此到当前方格的路径则由左边方格路径和上方方格路径相加得到。若两个方向有障碍，则不加上那个方向的路径</p><p>到第0行第0列个格子的方法1中，所以dp[0] [0]&#x3D;1。</p><p>机器人只能向右或向下移动，那么要知道当前方格路径就需要知道上方方格和左边方格路径数，因此先从左到右遍历一行，再由上到下遍历每一行。</p><p>还可以对空间进行优化，只使用一行来存储数据，空间复杂度优化成O(m)。</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;        int m&#x3D;obstacleGrid.size(),n&#x3D;obstacleGrid[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,0));        if(obstacleGrid[0][0]&#x3D;&#x3D;1||obstacleGrid[m-1][n-1]&#x3D;&#x3D;1) return 0;        dp[0][0]&#x3D;1;        for(int i&#x3D;0;i&lt;m;++i)&#123;            for(int j&#x3D;0;j&lt;n;++j)&#123;                if(obstacleGrid[i][j]&#x3D;&#x3D;1) continue;                if(j&gt;0&amp;&amp;obstacleGrid[i][j-1]&#x3D;&#x3D;0) dp[i][j]&#x3D;dp[i][j-1];                if(i&gt;0&amp;&amp;obstacleGrid[i-1][j]&#x3D;&#x3D;0) dp[i][j]+&#x3D;dp[i-1][j];            &#125;        &#125;        return dp[m-1][n-1];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>647. 回文子串</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h1><p>First：使用的动态规划做，但效率比双指针低很多</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示以s以位置i开头位置j结尾所形成的字符串是否为回文。</p><p>递推公式：</p><ul><li><p>当s[i]&#x3D;&#x3D;s[j]时，此时是否为回文由内层字符s[i+1]到s[j-1]决定，所以dp[i] [j]&#x3D;dp[i-1] [j-1]，由于皆初始化为0，当i&#x3D;j和i&#x3D;j-1时，此时dp[i] [j]&#x3D;1;</p></li><li><p>当word1[i-1]!&#x3D;word2[j-1]时，dp[i] [j]&#x3D;0;</p></li></ul><p>dp皆初始化为0</p><p>从递推公式可以看出是从左下方推导出当前结果，因此需要先外层从大到小遍历s，再内层从小到大遍历s</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n^2^)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int countSubstrings(string s) &#123;        int len&#x3D;s.length();        vector&lt;vector&lt;int&gt;&gt; dp(len,vector&lt;int&gt;(len,0));        int ans&#x3D;0;        for(int i&#x3D;len-1;i&gt;&#x3D;0;--i)&#123;            for(int j&#x3D;i;j&lt;len;++j)&#123;                if(s[i]&#x3D;&#x3D;s[j])&#123;                    dp[i][j]&#x3D;j-i&gt;1?dp[i+1][j-1]:1;                &#125;                ans+&#x3D;dp[i][j];            &#125;                &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>双指针</strong></p><p>从头到尾遍历s，且对于每个s的每个字符，以当前字符和当前两个字符往两边扩散，判断是否为回文</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n^2^)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
            <tag> Alg-双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>674. 最长连续递增序列</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97-simple/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h1><p>First：基础题，方法可理解为动态规划也可以理解为贪心</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划（贪心）</strong></p><p>dp[i]表示以第i+1个数结尾能找到的最长连续递增子序列的长度</p><p>当nums[i-1]&lt;nums[i]，dp[i]&#x3D;dp[i-1]+1。否则dp[i]&#x3D;1</p><p>初始皆为0</p><p>从左到右遍历即可，并记录最大的dp值作为结果。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;        int cur&#x3D;1,ans&#x3D;1;        for(int i&#x3D;1;i&lt;nums.size();++i)&#123;            if(nums[i]&gt;nums[i-1])&#123;                ++cur;                ans&#x3D;max(cur,ans);            &#125;else&#123;                cur&#x3D;1;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70. 爬楼梯</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF-simple/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>First：爬到当前楼梯方法等于前面两级楼梯方法之和</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>dp[i]表示阶梯为i时的方法</p><p>当前阶梯方法等于前两阶阶梯方法和，即dp[i]&#x3D;dp[i-1]+dp[i-2]；</p><p>再确定初始值，然后遍历推导即可。</p><p>但是，dp使用过后就不会再使用，因此使用两个值来存储前两个阶梯状态即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int climbStairs(int n) &#123;        if(n&lt;3) return n;        int a&#x3D;1,b&#x3D;2;        for(int i&#x3D;3;i&lt;&#x3D;n;++i)&#123;            int t&#x3D;a+b;            a&#x3D;b;            b&#x3D;t;        &#125;        return b;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划+完全背包</strong></p><p>本题使用方法1就可，但如果可以每次爬1–m多个台阶，也就转换为了完全背包问题中的排列方法数</p><p>dp[j]表示爬到j阶的方法数</p><p>和完全背包求排列方法数一样，即dp[j]+&#x3D;dp[j-nums[i]]；</p><p>求排列方法数的第一个值为1，其余为0，dp[0]&#x3D;1;</p><p>由于是求排列数，因此需要先遍历背包容量再遍历物品，原因见leet377题解</p><ul><li>时间复杂度：O(2*n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int climbStairs(int n) &#123;        vector&lt;int&gt; dp(n+1,0);        dp[0]&#x3D;1;        for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;            for(int i&#x3D;1;i&lt;&#x3D;2;++i)&#123;                if(j&gt;&#x3D;i)&#123;                    dp[j]+&#x3D;dp[j-i];                &#125;            &#125;        &#125;        return dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>718. 最长重复子数组</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h1><p>First：用一维数组做的时候有些细节没弄好，最后还是先使用的二维数组，再优化一维数组</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>两个数组的最长重复子数组如果去除末尾不重复部分，那么最长重复子数组就都处于末尾，那么求所有处在末尾的重复子数组的大小即可，取其中最大值即为答案。</p><p>使用二维dp数组来记录状态，dp[i] [j] 表示nums1中前i个数和nums2中前j个数在末尾处的重复子数组长度，注意是末尾处重复子数组长度，如果末尾处不相等，则dp[i] [j]&#x3D;0，这是因为即使去除最长重复子串后面不相等的部分仍不会改变最长重复子串长度。</p><p>当nums1[i-1]&#x3D;nums[j-1]时，dp[i] [j]&#x3D;dp[i-1] [j-1]，否则dp[i] [j] &#x3D;0（dp两个维度上都加1是为了代码方便处理）;</p><p>皆初始化为0。</p><p>当前dp值与前面数有关系，因此两重循环皆从左到右遍历，记录最大dp值即可</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(nums1.size()+1,vector&lt;int&gt;(nums2.size()+1,0));        int ans&#x3D;0;        for(int i&#x3D;1;i&lt;&#x3D;nums1.size();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;nums2.size();++j)&#123;                if(nums2[j-1]&#x3D;&#x3D;nums1[i-1])&#123;                       dp[i][j]&#x3D;dp[i-1][j-1]+1;                &#125;                ans&#x3D;max(ans,dp[i][j]);                cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;            &#125;            cout&lt;&lt;endl;        &#125;        &#x2F;&#x2F;优化为1维数组        &#x2F;&#x2F; vector&lt;int&gt; dp(nums2.size()+1,0);        &#x2F;&#x2F; int ans&#x3D;0;        &#x2F;&#x2F; for(int i&#x3D;0;i&lt;nums1.size();++i)&#123;        &#x2F;&#x2F;     for(int j&#x3D;nums2.size();j&gt;0;--j)&#123;        &#x2F;&#x2F;         if(nums2[j-1]&#x3D;&#x3D;nums1[i])&#123;           &#x2F;&#x2F;             dp[j]&#x3D;dp[j-1]+1;        &#x2F;&#x2F;         &#125;else&#123;        &#x2F;&#x2F;             dp[j]&#x3D;0;        &#x2F;&#x2F;         &#125;        &#x2F;&#x2F;         ans&#x3D;max(ans,dp[j]);        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>二分查找 + 哈希</strong></p><ul><li>时间复杂度：O((<em>M</em>+<em>N</em>)log(min(<em>M</em>,<em>N</em>)) </li><li>空间复杂度：O(<em>N</em>)</li></ul><hr><p><strong>方法3</strong>：<strong>滑动窗口</strong></p><ul><li>时间复杂度：O((<em>N</em>+<em>M</em>)×min(<em>N</em>,<em>M</em>)) </li><li>空间复杂度：O(<em>1</em>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>72. 编辑距离</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-difficult/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h1><p>First：虽然做出来了，但不透</p><p>帆软提前批笔试：一样的题目，只是删除插入替换需要消耗不同的操作</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>对于两个字符串A、B，若AB相同时，此时A若添加一个字符后，其实可以看成B减少了一个字符，因此，添加操作和删除操作可以看成相等的。对于此题，使用添加操作进行推导。</p><p>使用二维dp数组来记录状态，dp[i] [j]表示使word1前i个字符和word2前j个字符相同所需最小步骤（虽然题目是将world1转换为word2，但word2添加字符可以看成word1减少字符，其操作数是相同的，因此word2和word1子序列上都进行添加任然是求结果，为了逻辑更清晰，就只使用添加和替换操作）。</p><p>递推公式：</p><ul><li><p>当word1[i-1]&#x3D;&#x3D;word2[j-1]时，此时无需修改操作，所以dp[i] [j]&#x3D;dp[i-1] [j-1]；</p></li><li><p>当word1[i-1]!&#x3D;word2[j-1]时，此时有三种操作可以使得字符相等，要么在dp[i-1] [j]情况下对word1添加一个字符（其实应该是删去，多了第i个字符）；要么在dp[i] [j-1]情况下对word2添加一个字符；要么在dp[i-1] [j-1]情况下将word1[i-1]替换为word2[j-1]。因此，dp[i] [j]&#x3D;min(dp[i-1] [j],min(dp[i-1] [j-1],dp[i] [j-1]))+1;</p></li></ul><p>由dp定义可知，dp[i] [0]&#x3D;i（word2的0个字符要变成word1前i个字符需要添加i次），dp[0] [j]&#x3D;j（原因同理）</p><p>从递推公式可以看出是从左上方推导出当前结果，因此需要先外层从小到大遍历word1，再内层从小到大遍历word2</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minDistance(string word1, string word2) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1,vector&lt;int&gt;(word2.size()+1,0));        for(int i&#x3D;1;i&lt;&#x3D;word1.size();++i) dp[i][0]&#x3D;i;        for(int j&#x3D;1;j&lt;&#x3D;word2.size();++j) dp[0][j]&#x3D;j;        for(int i&#x3D;1;i&lt;&#x3D;word1.size();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;word2.size();++j)&#123;                if(word1[i-1]&#x3D;&#x3D;word2[j-1]) dp[i][j]&#x3D;dp[i-1][j-1];                else dp[i][j]&#x3D;min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1]))+1;            &#125;        &#125;        return dp[word1.size()][word2.size()];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>帆软笔试</strong></p><p>插入消耗x，删除消耗y，替换消耗z</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>str1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>str2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>y<span class="token punctuation">,</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>x<span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230809170723330.png" alt="image-20230809170723330"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230809170759620.png" alt="image-20230809170759620"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>746. 使用最小花费爬楼梯</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF-simple/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h1><p>First：爬到当前楼梯方法等于前面两级楼梯当前费用+继续爬代价中最小的</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>dp[i]表示爬到阶梯为i时的费用</p><p>当前阶梯费用等于前两阶阶梯费用+继续爬楼梯费用代价最小的，即dp[i]&#x3D;min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-1]；</p><p>再确定初始值，爬到第1阶和第2阶是不需要费用的。</p><p>然后遍历推导即可。同理，dp使用过后就不会再使用，因此使用两个值来存储前两个阶梯费用即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;        int n&#x3D;cost.size();        if(n&lt;2) return 0;        int a&#x3D;0,b&#x3D;0;        for(int i&#x3D;2;i&lt;&#x3D;n;++i)&#123;            int t&#x3D;min(a+cost[i-2],b+cost[i-1]);            a&#x3D;b;            b&#x3D;t;        &#125;        return b;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>96. 不同的二叉搜索树</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h1><p>First：以前做过，想了会找出状态转换公式即可。</p><p>23.07.09：没做出来，感觉用动态规划应该会有个简单的数学公式，但没推导出公式，看解析还看了好一会，</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[i] 表示到i个节点拥有的互不相同二叉搜索树个数。</p><p>若有n个结点，假设其由1个节点添加n-1个节点得到，而这n-1个节点只能在这一个节点的左右进行组合，那么找出所有组合数之和就是n个节点的二叉搜索树个数。</p><p>即dp[i]&#x3D;sum(dp[k]*dp[i-1-k]) k: 0–i-1。</p><p>更多结点的个数是由更少节点的个数组合得到，因此就从小到大遍历。</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numTrees(int n) &#123;        vector&lt;int&gt; dp(n+1,0);        dp[0]&#x3D;1;        for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;            for(int j&#x3D;0;j&lt;i;++j)&#123;                dp[i]+&#x3D;dp[j]*dp[i-j-1];            &#125;        &#125;        return dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>数学</strong></p><p>求二叉树不同树的个数也就是求卡特兰数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220923193749678.png" alt="image-20220923193749678"></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买卖股票类型算法总结</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="买卖股票类型"><a href="#买卖股票类型" class="headerlink" title="买卖股票类型"></a>买卖股票类型</h1><ul><li><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2></li><li><h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h2></li><li><h2 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h2></li><li><h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h2></li></ul><p>买卖股票类型题总结，皆使用动态规划来做，动态规划步骤如下：</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><p>买卖股票使用</p><ul><li><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2></li></ul><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>找最优间距，不断找到遍历前的最小值，然后使用当前值减去左边最小值，并记录最大差值即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int pMin&#x3D;INT_MAX,res&#x3D;0;        for(int i&#x3D;0;i&lt;prices.size();++i)&#123;            pMin&#x3D;min(pMin,prices[i]);            res&#x3D;max(prices[i]-pMin,res);        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>每天可以分为两种状态，持有股票和不持有股票，且这两种状态都可以由前一天推导出来</p><p>每个二维dp数组来记录状态，dp[i] [0]表示第i天持有股票所得最多现金，dp[i] [1]表示持有股票所得最多现金。</p><p>第i天持有股票可以由前一天推导出来，即dp[i] [0]&#x3D;max(dp[i-1] [0],-prices[i]) （注意，由于只能买一次股票，所以这里为-prices[i]；同理，dp[i] [1]&#x3D;max(dp[i-1] [1],dp[i-1] [0]+prices[i])。可以优化为两个值来记录即可。</p><p>第一天持有或不持有股票，则dp[0] [0]&#x3D;-prices[0], dp[0] [1]&#x3D;0。</p><p>由于根节点需要由左右节点状态所得，那么使用后序遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int have&#x3D;-prices[0],nohave&#x3D;0;        for(int i&#x3D;1;i&lt;prices.size();++i)&#123;            int t&#x3D;have;            have&#x3D;max(have,-prices[i]);            nohave&#x3D;max(t+prices[i],nohave);            &#x2F;&#x2F; cout&lt;&lt;have&lt;&lt;&quot; &quot;&lt;&lt;nohave&lt;&lt;endl;        &#125;        return max(have,nohave);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h2><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>每天可以分为三种状态，刚买了股票buy和刚卖了股票sell，卖了股票第二天sell2，且这三种状态都可以由前一天推导出来</p><p>第i天持有股票可以由前一天推导出来，buy更新时只能将当前值和卖了股票第二天然后今天买进行比较，而sell2就只能等于前一天的sell，sell更新时将当前值和昨天买了股票然后今天卖进行比较。</p><p>由于根节点需要由左右节点状态所得，那么使用后序遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> buy<span class="token operator">=</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>sell<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>sell2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token keyword">int</span> t<span class="token operator">=</span>buy<span class="token punctuation">;</span>            buy<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>buy<span class="token punctuation">,</span>sell2<span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    sell2<span class="token operator">=</span>sell<span class="token punctuation">;</span>            sell<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">,</span>t<span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span>sell2<span class="token punctuation">,</span>buy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. 两数之和</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-1-simple/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-1-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h1><p>First：使用哈希表</p><hr><p><strong>方法1</strong>：<strong>哈希表</strong></p><p>直接使用哈希表判断是否存在数即可</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        if(nums.size()&lt;2) return &#123;&#125;;        unordered_map&lt;int,int&gt; s;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            auto f&#x3D;s.find(target-nums[i]);            if(f&#x3D;&#x3D;s.end())&#123;                s[nums[i]]&#x3D;i;            &#125;else&#123;                return &#123;f-&gt;second,i&#125;;            &#125;        &#125;        return &#123;&#125;;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>暴力法</strong></p><p>暴力遍历即可</p><ul><li>时间复杂度：O(n^2^)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 三数之和</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-15-middle/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-15-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h1><p>First：开始打算使用set来排除重复项，但太麻烦了。先进行排序，用一个哈希表记录下值和序号，然后用双重遍历找出结果。但这种打败比例很低，还是双指针快。</p><hr><p><strong>方法1</strong>：<strong>排序+哈希表</strong></p><p>先将数据进行排序，然后使用一个map记录下数组中的值和其出现的最大序号，然后使用双重遍历查找结果。为了避免重复值，遍历时遇见和前一个值相同时需要跳过。</p><ul><li>时间复杂度：O(n^2^)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        unordered_map&lt;int,int&gt; map;        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;++i)&#123;            map[nums[i]]&#x3D;i;        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;             for(int i&#x3D;0;i&lt;n;++i)&#123;            if(nums[i]&gt;0) break;            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;            for(int j&#x3D;i+1;j&lt;n;++j)&#123;                if(nums[i]+nums[j]&gt;0) break;                if(j&gt;i+1&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]) continue;                int res&#x3D;-nums[i]-nums[j];                auto f&#x3D;map.find(res);                if(f!&#x3D;map.end())&#123;                    if(f-&gt;second&gt;j)&#123;                        ans.push_back(&#123;nums[i],nums[j],nums[f-&gt;second]&#125;);                    &#125;                &#125;            &#125;        &#125;                return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><hr><p><strong>方法2</strong>：<strong>排序+双指针</strong></p><p>先将数据进行排序，使用两重循环来遍历，第一重循环依次遍历数值i，第二重循环设置两个指针j、k分别指向数组前段和末端，如果i j k对应值相加小于0，则j右移；等于0，添加到结果中；大于0，则k左移。</p><ul><li>时间复杂度：O(n^2^)</li><li>空间复杂度：O(logn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202. 快乐数</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-202-%E5%BF%AB%E4%B9%90%E6%95%B0-simple/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-202-%E5%BF%AB%E4%B9%90%E6%95%B0-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h1><p>First：看到这题觉得值会越来越大，就没法判别无限大的情况，但是这种情况不会出现</p><p>Second: 22-11-19，干，虽然知道数到一定值后就不能再变大，但感觉也只能硬比，没想到再小区间中无限循环值是一定会重复的。</p><hr><p><strong>方法1</strong>：<strong>哈希表</strong></p><p>按题中描述，n可能出现三种情况：</p><ul><li>（1）循环得到1</li><li>（2）无限循环（存在环）</li><li>（3）值越来越大</li></ul><p>但是第三种情况不存在，观察下表可发现，随着原始值越大，其平方和后的数会变得很小（只要低于243以后，就不可能再回到243），所有值越来越大这种情况可以排除。</p><p>只需要考虑无限循环和得到1两种情况，在一个比较小的区间中无限循环必定存在环，因此此题也就变为是否存在环了。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912141214094.png" alt="image-20220912141214094"></p><ul><li>时间复杂度：O(logn) 计算方法可见官方解析</li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isHappy(int n) &#123;        unordered_set&lt;int&gt; s;        while(1)&#123;            int sum&#x3D;0;            while(n&gt;0)&#123;                sum+&#x3D;(n%10)*(n%10);                n&#x2F;&#x3D;10;            &#125;            if(sum&#x3D;&#x3D;1) return true;            if(s.count(sum)&gt;0) return false;            s.insert(sum);            n&#x3D;sum;        &#125;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>快慢指针</strong></p><p>使用快慢指针来判断是否有环</p><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int getSum(int n)&#123;        int sum&#x3D;0;        while(n&gt;0)&#123;            sum+&#x3D;(n%10)*(n%10);            n&#x2F;&#x3D;10;        &#125;        return sum;    &#125;    bool isHappy(int n) &#123;        int p&#x3D;n,q&#x3D;n;        while(1)&#123;            p&#x3D;getSum(p);            q&#x3D;getSum(q);            if(q&#x3D;&#x3D;1)return true;            q&#x3D;getSum(q);            if(q&#x3D;&#x3D;1)return true;            if(p&#x3D;&#x3D;q)return false;        &#125;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：数学</p><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>204. 计数质数</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0-middle/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a><a href="https://leetcode.cn/problems/count-primes/description/">204. 计数质数</a></h1><p>First：刚开始的时候还判断了下是否属于质数，但细节问题导致超时了，后来想到直接每个质数倍乘，最后找出质数即可</p><hr><p><strong>方法1</strong>：<strong>埃氏筛</strong></p><p>如果x是质数，那么2x、3x一定不是质数，那么从2开始，不断将倍乘置为非质数，统计所有质数即可。</p><ul><li>时间复杂度：O(nloglogn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int countPrimes(int n) &#123;        vector&lt;int&gt; flags(n,0);        int ans&#x3D;0;        for(int i&#x3D;2;i&lt;n;++i)&#123;            if(flags[i]&#x3D;&#x3D;0)&#123;                if((long long) i*i&lt;n)&#123;                    for(int j&#x3D;i*i;j&lt;n;j+&#x3D;i)&#123;                        flags[j]&#x3D;1;                    &#125;                &#125;            &#125;        &#125;        for(int i&#x3D;2;i&lt;n;++i)&#123;            if(flags[i]&#x3D;&#x3D;0) &#123;                ++ans;            &#125;        &#125;        return ans;    &#125;&#125;;&#x2F;&#x2F;解析有点技巧，没有单独一次遍历来统计，因为找到的第一个flags[i]&#x3D;&#x3D;0就是质数class Solution &#123;public:    int countPrimes(int n) &#123;        vector&lt;int&gt; flags(n,0);        int ans&#x3D;0;        for(int i&#x3D;2;i&lt;n;++i)&#123;            if(flags[i]&#x3D;&#x3D;0)&#123;                ++ans;                if((long long) i*i&lt;n)&#123;                    for(int j&#x3D;i*i;j&lt;n;j+&#x3D;i)&#123;                        flags[j]&#x3D;1;                    &#125;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法1</strong>：<strong>线性筛</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18. 四数之和</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-18-middle/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-18-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h1><p>First：将其当成四组数据再两两分组来做的话，感觉排除重复值太麻烦了。还是用的三重循环来做，但我先用的target减前两个值时，遇见了overflow情况，解决方法是先将target转为long long，虽然可以用加法但写起来不简洁且有可能也会overflow。</p><hr><p><strong>方法1</strong>：<strong>排序+双指针</strong></p><p>先将数组进行排序，然后类似三数求和那道题使用三重循环来做，外面写两重循环，在最里面一重循环中使用双指针来分别指向头部和尾部，若两个指针相加和小于值，则将左指针右移，大于则将右指针左移动，否则添加进结果容器中。</p><ul><li>时间复杂度：O(n^3^)</li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;        sort(nums.begin(),nums.end());        int n&#x3D;nums.size();        vector&lt;vector&lt;int&gt;&gt; ans;        for(int i&#x3D;0;i&lt;n;++i)&#123;            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;            for(int j&#x3D;i+1;j&lt;n;++j)&#123;                if(j&gt;i+1&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]) continue;                long long remain&#x3D;(long long)target-nums[i]-nums[j];&#x2F;&#x2F;不转为long long有个例子会越界,转成long也不会报错，但迷惑的是long和int相同范围，猜测减法时long会提升到long long                for(int l&#x3D;j+1,r&#x3D;n-1;l&lt;r;)&#123;                    if(l&gt;j+1&amp;&amp;nums[l]&#x3D;&#x3D;nums[l-1])&#123;&#x2F;&#x2F;避免重复值                        ++l;                        continue;                    &#125;                    if(r&lt;n-1&amp;&amp;nums[r]&#x3D;&#x3D;nums[r+1])&#123;&#x2F;&#x2F;避免重复值                        --r;                        continue;                    &#125;                    int sum&#x3D;nums[l]+nums[r];                    if(sum&#x3D;&#x3D;remain)&#123;                        ans.push_back(&#123;nums[i],nums[j],nums[l],nums[r]&#125;);                        ++l;                    &#125;else if(sum&gt;remain)&#123;                        --r;                    &#125;else&#123;                        ++l;                    &#125;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>242. 有效的字母异位词</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-242-simple/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-242-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h1><p>First：直接定义一个数组来存储字母出现频率</p><hr><p><strong>方法1</strong>：<strong>哈希表</strong></p><p>定义两个数组来分别存储两个字符串中各自字符出现频率（官方解答中还有点优化空间，只定义一个数组来存储s频率，在遍历t时依次将s中对应字母个数减一，如减到小于0则返回false）</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(S) S为字符集大小</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isAnagram(string s, string t) &#123;        if(s.length()!&#x3D;t.length()) return false;        int sf[26]&#123;0&#125;,tf[26]&#123;0&#125;;        for(int i&#x3D;0;i&lt;s.length();++i)&#123;            sf[s[i]-&#39;a&#39;]++;            tf[t[i]-&#39;a&#39;]++;        &#125;        for(int i&#x3D;0;i&lt;26;++i)&#123;            if(sf[i]!&#x3D;tf[i]) return false;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>排序</strong></p><p>排序后比较是否相等</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>349. 两个数组的交集</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-349-simple/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-349-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h1><p>First：使用一个1001大小的数组来存储是否出现过</p><hr><p><strong>方法1</strong>：<strong>哈希表</strong></p><p>定义一个1001大小的数组来存储字符串s的频率，但这是已知值范围的情况下才可这么做。然后，直接遍历t中每个字符是否出现在频率数组中即可。</p><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(S) S为字符集大小</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int fq[1001]&#123;0&#125;;        vector&lt;int&gt; res;        for(int i&#x3D;0;i&lt;nums1.size();++i)&#123;            ++fq[nums1[i]];        &#125;        for(int i&#x3D;0;i&lt;nums2.size();++i)&#123;            if(fq[nums2[i]]&gt;0)&#123;                res.push_back(nums2[i]);                fq[nums2[i]]&#x3D;0;            &#125;        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>两个集合</strong></p><p>使用hash_set来存储出现过的字符，然后找相同字符</p><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(m+n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>383. 赎金信</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-383-simple/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-383-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h1><p>First：直接使用哈希表</p><hr><p><strong>方法1</strong>：<strong>哈希表</strong></p><p>直接使用哈希表或自己使用一个数组记录第二个字符串的字母出现次数，再遍历第一个字符串即可</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        if(ransomNote.size()&gt;magazine.size()) return false;        &#x2F;&#x2F; unordered_map&lt;char,int&gt; map;        &#x2F;&#x2F; for(auto c:magazine)&#123;        &#x2F;&#x2F;     ++map[c];        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; for(auto c:ransomNote)&#123;        &#x2F;&#x2F;     auto f&#x3D;map.find(c);        &#x2F;&#x2F;     if(f&#x3D;&#x3D;map.end()||f-&gt;second&lt;&#x3D;0)&#123;        &#x2F;&#x2F;         return false;        &#x2F;&#x2F;     &#125;else&#123;        &#x2F;&#x2F;         map[c]-&#x3D;1;        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; return true;        int col[26]&#123;0&#125;;        for(auto c:magazine)&#123;            ++col[c-&#39;a&#39;];        &#125;        for(auto c:ransomNote)&#123;            --col[c-&#39;a&#39;];            if(col[c-&#39;a&#39;]&lt;0)&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>454. 四数相加 II</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-454-middle/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-454-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h1><p>First：开始尝试了下三重循环做，但超时了。想过是否可以排除一些特殊分支，减少循环。想将两两分组来做，但感觉太麻烦了。</p><hr><p><strong>方法1</strong>：<strong>哈希表+两两分组</strong></p><p>将四组数据两两分组，将ab两组先加起来存储到哈希表中，再遍历cd两组数据，从哈希表中查找是否有满足循环的数据。</p><ul><li>时间复杂度：O(n^2^)</li><li>空间复杂度：O(n^2^)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;        unordered_map&lt;int,int&gt; ab;        for(auto a:nums1)&#123;            for(auto b:nums2)&#123;                ++ab[a+b];            &#125;        &#125;        int ans&#x3D;0;        for(auto c:nums3)&#123;            for(auto d:nums4)&#123;                auto f&#x3D;ab.find(-(c+d));                if(f!&#x3D;ab.end())&#123;                    ans+&#x3D;f-&gt;second;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>532. 数组中的 k-diff 数对</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-532-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%20k-diff%20%E6%95%B0%E5%AF%B9-middle/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-532-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%20k-diff%20%E6%95%B0%E5%AF%B9-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="532-数组中的-k-diff-数对"><a href="#532-数组中的-k-diff-数对" class="headerlink" title="532. 数组中的 k-diff 数对"></a><a href="https://leetcode.cn/problems/k-diff-pairs-in-an-array/description/">532. 数组中的 k-diff 数对</a></h1><p>FIrst：使用的方法1做出来，但效率不高，关键是去重的同时k&#x3D;0时也要能找到</p><hr><p><strong>方法1</strong>：<strong>排序+set</strong></p><p>先对数组进行从小到大排序，使用map存储已经出现的数字，再依次遍历数组，如果nums[i]-k已经在map中那么将nums[i]添加进set中，set自带去重。</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findPairs(vector&lt;int&gt;&amp; nums, int k) &#123;        int ans&#x3D;0;        sort(nums.begin(),nums.end());        set&lt;int&gt; ansSet;        unordered_map&lt;int,int&gt; map;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(map.find(nums[i]-k)!&#x3D;map.end())&#123;                ansSet.insert(nums[i])  ;            &#125;            map[nums[i]]&#x3D;1;                    &#125;        return ansSet.size();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>哈希表</strong></p><p>使用一个哈希表存储已经已经遍历过的值，依次遍历，由于不排序则需要判断当前值作为减数和被减数两种情况，注意！判断这两种情况时，如果找到数字则应该按相同规则将结果插入到set中，比如都插入被减数。最后统计set的大小即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findPairs(vector&lt;int&gt;&amp; nums, int k) &#123;        int ans&#x3D;0;        unordered_set&lt;int&gt; ansSet;        unordered_map&lt;int,int&gt; map;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(map.find(nums[i]-k)!&#x3D;map.end())&#123;                ansSet.insert(nums[i]);&#x2F;&#x2F;注意这里插入的数要按规则插，比如都插入被减数            &#125;            if(map.find(nums[i]+k)!&#x3D;map.end())&#123;                ansSet.insert(nums[i]+k);&#x2F;&#x2F;注意这里插入的数要按规则插，比如都插入被减数            &#125;            map[nums[i]]&#x3D;1;                    &#125;        return ansSet.size();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：<strong>排序+双指针</strong></p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>131. 分割回文串</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h1><p>First：每理解到分割和组合取其实是差不多得，看了解析的这个分割理解才做出来。</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><blockquote><p><strong>切割问题类似组合问题</strong>。</p><p>例如对于字符串abcdef：</p><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</li></ul></blockquote><p>此题的分割也就是选结束的字符，已结束字符拼成的字符串是回文就说明结束字符满足要求。</p><p>中止条件：当需要遍历的起始位置index等于字符串长度时，将temp添加进结果中</p><p>遍历过程：从给定的起始位置index遍历，假设遍历到i，如果s[index:i]是回文，那么就可以将此字符串添加进temp中，且回溯递归遍历找到下一个回文子串。否则将i+1，继续判断。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;string&gt;&gt; ans;    vector&lt;string&gt; temp;public:    bool isPalindrome(const string &amp;s)&#123;        for(int i&#x3D;0,j&#x3D;s.size()-1;i&lt;j;++i,--j)&#123;            if(s[i]!&#x3D;s[j]) return false;        &#125;        return true;    &#125;    void backtrace(const string &amp;s,int index)&#123;        if(index&#x3D;&#x3D;s.size())&#123;            ans.push_back(temp);            return;        &#125;        string scur;        for(int i&#x3D;index;i&lt;s.size();++i)&#123;            scur.push_back(s[i]);            if(isPalindrome(scur)) temp.push_back(scur);            else continue;            backtrace(s,i+1);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        backtrace(s,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>回溯+动态规划</strong></p><p>方法1中每个都需要进行判断子串是否是回文，会造成很多重复计算。可以使用动态规划先判断每个子串是否是回文，动态规划判断每个子串是时间复杂度为O(n^2^)。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17. 电话号码的字母组合</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h1><p>First：回溯遍历即可</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>使用一个map记录下每个数字对应哪些字母，然后回溯遍历每个数字对应的字母即可</p><p>中止条件：遍历下标值和digits大小相等时</p><p>遍历过程：从小到大遍历digits每个数字对应的字母，将当前值添加进临时数组，再回溯。</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;string&gt; ans;    string tem;    vector&lt;string&gt; map;public:    void backtrace(int index,const string &amp;digits)&#123;        if(index&#x3D;&#x3D;digits.size())&#123;            ans.push_back(tem);            return;        &#125;        const string &amp;s&#x3D;map[digits[index]-&#39;2&#39;];        for(char c:s)&#123;            tem.push_back(c);            backtrace(index+1,digits);            tem.pop_back();        &#125;    &#125;    vector&lt;string&gt; letterCombinations(string digits) &#123;        if(digits.size()&#x3D;&#x3D;0) return&#123;&#125;;        map&#x3D;vector&lt;string&gt;&#123;&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;&#125;;        backtrace(0,digits);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>216. 组合总和 III</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h1><p>First：和77差不多</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>使用k记录还需多少个数，使用n记录还需寻找之和，不断递归重复找，按顺序遍历（只添加当前值后面的数）使得不存在重复值</p><p>中止条件：当n等于0且k&#x3D;&#x3D;0时，将收集到的数组添加到结果中</p><p>遍历过程：从小到大遍历，将当前值添加进临时数组，再回溯。</p><p>剪枝：当n小于0时进行剪枝</p><ul><li>时间复杂度：O((<em>k**n</em>)×<em>k</em>)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; tem;    int cursum;public:    void backtrace(int st,int k,int n)&#123;        if(n&#x3D;&#x3D;0&amp;&amp;k&#x3D;&#x3D;0)&#123;            ans.push_back(tem);            return;        &#125;else if(n&lt;0)&#123;            return;        &#125;        for(int i&#x3D;st;i&lt;&#x3D;9-k+1;++i)&#123;                        tem.push_back(i);            backtrace(i+1,k-1,n-i);            tem.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;        backtrace(1,k,n);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法1</strong>：<strong>二进制（子集）枚举</strong></p><ul><li>时间复杂度：O((<em>M</em>×2**M)</li><li>空间复杂度：O(M)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>332. 重新安排行程</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B-difficult/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332. 重新安排行程"></a><a href="https://leetcode.cn/problems/reconstruct-itinerary/">332. 重新安排行程</a></h1><p>First：思想挺简单，但比较麻烦</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>先使用一个set记录所有的机场名字，为了保证字典排序小的行程优先，因此需要对机场名字进行排序，得到sortNames。然后以sortName为序，使用一个矩阵来距离每两个机场间的票数（无票为0），为了快速找到机场名字在sortName中的位置，使用一个nameIndex数组来记录位置。使用temp记录当前添加的行程顺序，然后进行回溯遍历。</p><p>中止条件：当temp大小等于总票数+1时，此时已经找到所有形成，将flag置为true。</p><p>遍历过程：以index为行号，从index行从小到大遍历，如果matrix[index] [i]&gt;0，说明有票，此时将票数减1，然后进行回溯，回溯完成后应将票数加1.</p><p>剪枝：使用一个flag来记录是否找到答案，如果找到直接返回。</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;string&gt; ans;    vector&lt;string&gt; temp;    vector&lt;vector&lt;int&gt;&gt; matrix;    bool flag;public:    void backtrace(const vector&lt;string&gt; &amp;names,int index,int num)&#123;        if(flag) return;        temp.push_back(names[index]);        &#x2F;&#x2F; cout&lt;&lt;names[index]&lt;&lt;endl;        if(temp.size()&#x3D;&#x3D;num)&#123;            ans&#x3D;temp;            flag&#x3D;true;        &#125;        for(int i&#x3D;0;i&lt;names.size();++i)&#123;            if(matrix[index][i]&gt;0)&#123;                matrix[index][i]-&#x3D;1;                backtrace(names,i,num);                matrix[index][i]+&#x3D;1;            &#125;        &#125;        temp.pop_back();    &#125;    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;        flag&#x3D;false;        unordered_set&lt;string&gt; ticNames;&#x2F;&#x2F;记录有哪些机场        for(int i&#x3D;0;i&lt;tickets.size();++i)&#123;            for(auto &amp;name:tickets[i])&#123;                ticNames.insert(name);            &#125;        &#125;        vector&lt;string&gt; sortNames;&#x2F;&#x2F;将机场名字按顺序排列        int index&#x3D;-1;        for(auto &amp;s:ticNames)&#123;            sortNames.push_back(s);        &#125;        sort(sortNames.begin(),sortNames.end());        unordered_map&lt;string,int&gt; nameIndex;&#x2F;&#x2F;用于记录每个机场名字在sortNames中的位置        for(int i&#x3D;0;i&lt;sortNames.size();++i)&#123;            nameIndex[sortNames[i]]&#x3D;i;            if(sortNames[i]&#x3D;&#x3D;&quot;JFK&quot;) index&#x3D;i;        &#125;        matrix&#x3D;vector&lt;vector&lt;int&gt;&gt;(sortNames.size(),vector&lt;int&gt;(sortNames.size(),0));&#x2F;&#x2F;记录有哪些机场是之间是有票的        for(int i&#x3D;0;i&lt;tickets.size();++i)&#123;            int pos1&#x3D;nameIndex[tickets[i][0]];            int pos2&#x3D;nameIndex[tickets[i][1]];            matrix[pos1][pos2]+&#x3D;1;        &#125;        backtrace(sortNames,index,tickets.size()+1);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>37. 解数独</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC-difficult/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></h1><p>First：思想不难，但细节较多</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>使用used1矩阵来记录每一个3*3宫格内数字使用情况，使用used2来记录每行数字使用情况，使用used3矩阵来记录每列数字使用情况。计算出所有需要填充的空格数dianNum，然后开始回溯。</p><p>中止条件：当需要找的dianNum等于0时，将flag设为true，返回。</p><p>遍历过程：对board矩阵进行遍历，找到第一个空格。然后对这空格使用1到9尝试填充，只有当used1、used2、used3对应的数字都未使用时，才能使用此数字进行填充。<strong>注意</strong>，这里进行回溯后，如果flag为true则直接结束此次循环（不然会将正确答案覆盖），否则应该将board[i] [j]设置 ‘.’（不然如果此次填充失败，会导致下次寻找待填充位置时认为此空格已经被填充）。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; used1;    vector&lt;vector&lt;int&gt;&gt; used2;    vector&lt;vector&lt;int&gt;&gt; used3;    bool flag;public:    void backtrace(vector&lt;vector&lt;char&gt;&gt;&amp; board,int dianNum)&#123;        if(flag) return;        if(dianNum&#x3D;&#x3D;0)&#123;            flag&#x3D;true;            return;        &#125;        int i,j;        for(i&#x3D;0;i&lt;board.size();++i)&#123;            for(j&#x3D;0;j&lt;board.size();++j)&#123;                if(board[i][j]!&#x3D;&#39;.&#39;) continue;                for(int k&#x3D;1;k&lt;&#x3D;9;++k)&#123;                    if(used1[i&#x2F;3][j&#x2F;3][k-1]&#x3D;&#x3D;0&amp;&amp;used2[i][k-1]&#x3D;&#x3D;0&amp;&amp;used3[j][k-1]&#x3D;&#x3D;0)&#123;                        used1[i&#x2F;3][j&#x2F;3][k-1]&#x3D;1;                        used2[i][k-1]&#x3D;1;                        used3[j][k-1]&#x3D;1;                        board[i][j]&#x3D;&#39;0&#39;+k;                        cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;board[i][j]&lt;&lt;endl;                        backtrace(board,dianNum-1);                        if(flag) return;                        board[i][j]&#x3D;&#39;.&#39;;                        used1[i&#x2F;3][j&#x2F;3][k-1]&#x3D;0;                        used2[i][k-1]&#x3D;0;                        used3[j][k-1]&#x3D;0;                    &#125;                &#125;                                return;&#x2F;&#x2F;只是为了找一个空格而已            &#125;        &#125;    &#125;    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;        flag&#x3D;false;        int n&#x3D;board.size();        used1&#x3D;vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(3,vector&lt;vector&lt;int&gt;&gt;(3,vector&lt;int&gt;(9,0)));&#x2F;&#x2F;3*3使用情况        used2&#x3D;vector&lt;vector&lt;int&gt;&gt;(9,vector&lt;int&gt;(9,0));&#x2F;&#x2F;水平使用情况        used3&#x3D;vector&lt;vector&lt;int&gt;&gt;(9,vector&lt;int&gt;(9,0));&#x2F;&#x2F;竖直使用情况        int dianNum&#x3D;0;        for(int i&#x3D;0;i&lt;n;++i)&#123;            for(int j&#x3D;0;j&lt;n;++j)&#123;                if(board[i][j]!&#x3D;&#39;.&#39;)&#123;                used1[i&#x2F;3][j&#x2F;3][board[i][j]-&#39;0&#39;-1]&#x3D;1;                used2[i][board[i][j]-&#39;0&#39;-1]&#x3D;1;                used3[j][board[i][j]-&#39;0&#39;-1]&#x3D;1;                &#125;else&#123;                    ++dianNum;                &#125;            &#125;        &#125;        backtrace(board,dianNum);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>40. 组合总和 II</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h1><p>First：和39差不多，只是需要点技巧来避免重复</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>本题关键是避免重复值，先对数组进行排序，使得更容易剪枝优化。</p><p>中止条件：当需要找的target为0时，将其添加进结果中</p><p>遍历过程：从小到大遍历，假设遍历到i，如果candidates[i]&#x3D;&#x3D;candidates[i-1]，且i&gt;index（起始位置），那么就应该跳过。（此题避免重复值的原理在于树枝同层有相同值得话就不能重复，就只能取一个，而不同层得相同值可以重复取）</p><p>剪枝：由于数组已经进行从小到大排序，那么当前值如果大于target了，则说明无法在数组中找到值来凑成target，此时就剪掉这个枝节。</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;public:    void backtrace(const vector&lt;int&gt;&amp; candidates,int index,int target)&#123;        if(target&#x3D;&#x3D;0)&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;index;i&lt;candidates.size()&amp;&amp;candidates[i]&lt;&#x3D;target;++i)&#123;            if(i&gt;index&amp;&amp;candidates[i]&#x3D;&#x3D;candidates[i-1]) continue;            temp.push_back(candidates[i]);            backtrace(candidates,i+1,target-candidates[i]);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;        sort(candidates.begin(),candidates.end());        backtrace(candidates,0,target);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39. 组合总和</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h1><p>First：基础的回溯算法再加上一点剪枝</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>先对数组进行排序，使得可以进行剪枝优化。再使用常规的回溯方法不断递归重复找即可。</p><p>中止条件：当需要找的target为0时，将其添加进结果中</p><p>遍历过程：从小到大遍历，将当前值添加进临时数组，再回溯。</p><p>剪枝：由于数组已经进行从小到大排序，那么当前值如果大于target了，则说明无法在数组中找到值来凑成target，此时就剪掉这个枝节。</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;public:    void backtrace(const vector&lt;int&gt;&amp; candidates,int index,int target)&#123;        if(target&#x3D;&#x3D;0)&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;index;i&lt;candidates.size()&amp;&amp;target&gt;&#x3D;candidates[i];++i)&#123;            temp.push_back(candidates[i]);            backtrace(candidates,i,target-candidates[i]);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;        sort(candidates.begin(),candidates.end());        backtrace(candidates,0,target);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>47. 全排列 II</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-47-%E5%85%A8%E6%8E%92%E5%88%97II-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-47-%E5%85%A8%E6%8E%92%E5%88%97II-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h1><p>First：和46题的唯一不同之处是需要去重</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>先对数组进行排序，使得相同值位于一处，以便于遍历的时候进行去重。使用一个数组used来标记当前已经添加进temp中的数。</p><p>中止条件：当index等于数组长度时，结束</p><p>遍历过程：每次回溯都从0开始遍历。去重：若当前值和前一个值相同且前一个值并未使用的话，就代表两个数是在同一层，应当去重，此时应跳过此数。若当前值并未使用过，则添加进temp中并再used数组中进行标记，否则跳过当前数。每次回溯完成后，都需要将当前值弹出，且将标记更改为未使用。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;    vector&lt;int&gt; used;public:    void backtrace(vector&lt;int&gt; &amp;nums)&#123;        if(temp.size()&#x3D;&#x3D;nums.size())&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(used[i]&#x3D;&#x3D;1) continue;            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]&amp;&amp;used[i-1]&#x3D;&#x3D;0) continue;&#x2F;&#x2F;去重            used[i]&#x3D;1;            temp.push_back(nums[i]);            backtrace(nums);            temp.pop_back();            used[i]&#x3D;0;        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        used&#x3D;vector&lt;int&gt;(nums.size(),0);        backtrace(nums);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46. 全排列</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h1><p>First：挺简单，使用一个数组来标记已经使用过的数即可</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>使用一个数组used来标记当前已经添加进temp中的数。</p><p>中止条件：当index等于数组长度时，结束</p><p>遍历过程：每次回溯都从0开始遍历，若当前值并未使用过，则添加进temp中并再used数组中进行标记，否则跳过当前数。每次回溯完成后，都需要将当前值弹出，且将标记更改为未使用。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;    vector&lt;int&gt; used;public:    void backtrace(vector&lt;int&gt; &amp;nums)&#123;        if(temp.size()&#x3D;&#x3D;nums.size())&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(used[i]&#x3D;&#x3D;1) continue;            used[i]&#x3D;1;            temp.push_back(nums[i]);            backtrace(nums);            temp.pop_back();            used[i]&#x3D;0;        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        used&#x3D;vector&lt;int&gt;(nums.size(),0);        backtrace(nums);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>491. 递增子序列</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode.cn/problems/increasing-subsequences/">491. 递增子序列</a></h1><p>First：折腾了挺久，想着整体只用一个数组来去重，感觉始终只差一步，解析十分简单，每次遍历都用一个数组来去重</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>此题不能先进行排序，因此会导致相同的数分布在不同位置，因此对于每个遍历，都定义一个数组来去重，如果数已经出现过，则跳过当前值，否则进行回溯。</p><p>中止条件：当index等于数组长度时，结束</p><p>遍历过程：从index遍历，当前值如果未出现，则在去重数组中进行标记再进行回溯。否则跳过。为了保证序列有序，每次添加值时都与末尾数组进行比较，大于等于末尾数组时才添加进临时数组中。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;    unordered_map&lt;int,int&gt; appear;    vector&lt;int&gt; used;public:    void backtrace(const vector&lt;int&gt;&amp; nums,int index)&#123;        if(index&gt;&#x3D;nums.size()) return;        int used[201]&#x3D;&#123;0&#125;;        for(int i&#x3D;index;i&lt;nums.size();++i)&#123;            if(used[nums[i]+100]&#x3D;&#x3D;1) continue;            used[nums[i]+100]&#x3D;1;            if(temp.size()&gt;0&amp;&amp;nums[i]&lt;temp.back()) continue;            temp.push_back(nums[i]);            if(temp.size()&gt;&#x3D;2) ans.push_back(temp);            backtrace(nums,i+1);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;        backtrace(nums,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51. N 皇后</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-51-N%E7%9A%87%E5%90%8E-difficult/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-51-N%E7%9A%87%E5%90%8E-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h1><p>First：思想不难，但比较麻烦</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>显然，每行必须也只能放一个皇后。使用一个矩阵来表示当前哪些位置不能放，使用temp来记录目前结果，使用num表示当前应该在第几行放置皇后。</p><p>中止条件：当放置皇后数量num等于n时，将temp添加进答案中。</p><p>遍历过程：从index行从小到大遍历，如果matrix[num] [i]&#x3D;&#x3D;‘.’，说明此位置可以放置皇后，然后使用一个新矩阵来记录现在所有不能放的位置（使用原矩阵的话很难返回上次状态），在temp中将此位置标记为放置皇后，然后回溯遍历，此次回溯完成后应将temp更改为原来状态.</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;string&gt;&gt; ans;    vector&lt;string&gt; temp;public:    vector&lt;string&gt; changeMatrix(const vector&lt;string&gt; &amp;matrix,int i,int j)&#123;&#x2F;&#x2F;因放置新皇后，返回现在不能放的所有位置        vector&lt;string&gt; res&#x3D;matrix;        int sum&#x3D;i+j;        int dif&#x3D;i-j;        for(int a&#x3D;0;a&lt;matrix.size();++a)&#123;            res[i][a]&#x3D;&#39;Q&#39;;            res[a][j]&#x3D;&#39;Q&#39;;                 if(0&lt;&#x3D;sum-a&amp;&amp;sum-a&lt;matrix.size())&#123;                res[a][sum-a]&#x3D;&#39;Q&#39;;            &#125;            if(a+dif&lt;matrix.size())&#123;                res[a+dif][a]&#x3D;&#39;Q&#39;;            &#125;        &#125;        return res;    &#125;    void backtrace(vector&lt;string&gt; &amp;matrix,int n,int num)&#123;        if(num&#x3D;&#x3D;n)&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;0;i&lt;n;++i)&#123;            if(matrix[num][i]&#x3D;&#x3D;&#39;.&#39;)&#123;&#x2F;&#x2F;尝试放置                vector&lt;string&gt; newMatrex&#x3D;changeMatrix(matrix,num,i);                temp[num][i]&#x3D;&#39;Q&#39;;                backtrace(newMatrex,n,num+1);                temp[num][i]&#x3D;&#39;.&#39;;            &#125;        &#125;    &#125;    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        vector&lt;string&gt; matrix&#x3D;vector&lt;string&gt;(n,string(n,&#39;.&#39;));        temp&#x3D;vector&lt;string&gt;(n,string(n,&#39;.&#39;));        backtrace(matrix,n,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>679. 24 点游戏</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-679-24%E7%82%B9%E6%B8%B8%E6%88%8F-difficult/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-679-24%E7%82%B9%E6%B8%B8%E6%88%8F-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="679-24-点游戏"><a href="#679-24-点游戏" class="headerlink" title="679. 24 点游戏"></a><a href="https://leetcode.cn/problems/24-game/description/">679. 24 点游戏</a></h1><p>First：开始使用的深度遍历来做，先取得所有树的排列组合，然后对每个组合都使用四个运算符进行回溯，按理说这样没问题，不过还是报错，以后有机会再检查吧（感觉是有些减法排列取不到）。</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>直接穷举，不断从数组中取出两个数进行计算，然后将新数插入回去，再进行列举，每次都可以减少一个数字，最后判断第一个数字是否为24即可。为了解决实数除法，需要先将所有数字转为double型。</p><p>剪枝：加法和乘法只需要遍历遍历一次即可，所以当第一个数大于第二个数时跳过，减少遍历次数。</p><ul><li>时间复杂度：O(1) ，总可能性是9216种，固定的</li><li>空间复杂度：O(1)，递归最多只调用4层，因此是常数级</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    static constexpr double Target&#x3D;24;public:    bool judgePoint24(vector&lt;int&gt;&amp; cards) &#123;        vector&lt;double&gt; ll;        for(auto &amp;a:cards)            ll.push_back(static_cast&lt;double&gt;(a));        return solve(ll);    &#125;    bool solve(vector&lt;double&gt; &amp;ll)&#123;        if(ll.size()&#x3D;&#x3D;0) return false;        if(ll.size()&#x3D;&#x3D;1) return fabs(ll[0]-Target)&lt;1e-6;        int n&#x3D;ll.size();        for(int i&#x3D;0;i&lt;n;++i)&#123;            for(int j&#x3D;0;j&lt;n;++j)&#123;                if(i!&#x3D;j)&#123;                    vector&lt;double&gt; list2;                    for(int k&#x3D;0;k&lt;n;++k)&#123;                        if(k!&#x3D;i&amp;&amp;k!&#x3D;j) list2.push_back(ll[k]);                    &#125;                    for(int k&#x3D;0;k&lt;4;++k)&#123;                        if(k&lt;2&amp;&amp;i&gt;j) continue;                        if(k&#x3D;&#x3D;0)&#123;                            list2.push_back(ll[i]+ll[j]);                        &#125;else if(k&#x3D;&#x3D;1)&#123;                            list2.push_back(ll[i]*ll[j]);                        &#125;else if(k&#x3D;&#x3D;2)&#123;                            list2.push_back(ll[i]-ll[j]);                        &#125;else if(k&#x3D;&#x3D;3)&#123;                            if(fabs(ll[j])&lt;1e-6) return false;                            list2.push_back(ll[i]&#x2F;ll[j]);                        &#125;                        if(solve(list2)) return true;                        list2.pop_back();                    &#125;                &#125;            &#125;        &#125;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>77. 组合</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-77-%E7%BB%84%E5%90%88-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-77-%E7%BB%84%E5%90%88-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h1><p>First：基础的回溯算法再加上一点剪枝</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>不断递归重复找，按顺序遍历（只添加当前值后面的数）使得不存在重复值</p><p>中止条件：当k值小于等于0时，将收集到的数组添加到结果种</p><p>遍历过程：从小到大遍历，将当前值添加进临时数组，再回溯。</p><p>剪枝：当不存在k个数时进行剪枝</p><ul><li>时间复杂度：O((<em>k**n</em>)×<em>k</em>)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;int&gt; tem;    vector&lt;vector&lt;int&gt;&gt; ans;public:    void backtrace(int st,int end,int k)&#123;        if(k&lt;&#x3D;0) &#123;            ans.push_back(tem);            return;        &#125;        for(int i&#x3D;st;i&lt;&#x3D;end&amp;&amp;(end-i+1&gt;&#x3D;k);++i)&#123;            tem.push_back(i);            backtrace(i+1,end,k-1);            tem.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;        backtrace(1,n,k);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>78. 子集</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-78-%E5%AD%90%E9%9B%86-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-78-%E5%AD%90%E9%9B%86-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h1><p>First：很简单，注意添加空就可</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>按回溯递归进行遍历，记录每次路径即可，需要在开头添加一个空容器。</p><p>中止条件：当index等于数组长度时，结束</p><p>遍历过程：从index遍历，每当添加一个数字到temp中后，就将temp添加到ans中，回溯结束后需要弹出。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;public:    void backtrace(const vector&lt;int&gt; &amp;nums,int index)&#123;        if(index&#x3D;&#x3D;nums.size())&#123;            return;        &#125;        for(int i&#x3D;index;i&lt;nums.size();++i)&#123;            temp.push_back(nums[i]);            ans.push_back(temp);            backtrace(nums,i+1);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        ans.push_back(&#123;&#125;);        backtrace(nums,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>90. 子集 II</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-90-%E5%AD%90%E9%9B%86%20II-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-90-%E5%AD%90%E9%9B%86%20II-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></h1><p>First：注意不遍历同层相同值即可</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>和78题差不多，只是本题关键是避免重复值，先对数组进行排序，使得避免重复。</p><p>中止条件：当index与数组大小相同时，结束</p><p>遍历过程：从小到大遍历，假设遍历到i，如果nums[i]&#x3D;&#x3D;nums[i-1]，且i&gt;index（起始位置），那么就应该跳过。（此题避免重复值的原理在于树枝同层有相同值得话就不能重复，就只能取一个，而不同层得相同值可以重复取）将每个路径添加进结果中即可。</p><p>剪枝：</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;public:    void backtrace(const vector&lt;int&gt; &amp;nums,int index)&#123;        if(index&#x3D;&#x3D;nums.size())&#123;            return;        &#125;        for(int i&#x3D;index;i&lt;nums.size();++i)&#123;            if(i&gt;index&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;            temp.push_back(nums[i]);            ans.push_back(temp);            backtrace(nums,i+1);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        ans.push_back(&#123;&#125;);        backtrace(nums,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>93. 复原 IP 地址</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h1><p>First：在细节处折腾了好久，虽然最后还是做出来了</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>题目中规定了逗号只能有三个，因此使用k来记录现有逗号数量（不包括最后一个，因为是要删除的），index来记录从哪开始遍历。不断递归重复找，按顺序遍历（只添加当前值后面的数）使得不存在重复值</p><p>中止条件：当k等于4时，若index等于s长度，则将当前temp添加进结果（这里temp最后也有个逗号，需要删除）</p><p>遍历过程：从index遍历，将当前字符添加进段字符串scur中，如果临时字符串对应的值满足要求，则将scur添加进temp中，再回溯遍历，否则应该结束遍历。注意，为了保证前导不能有0，而0又能作为一段，所以当scur对应的值为0时，进行递归回溯，但是递归回溯结束后就结束遍历。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;string&gt; ans;    string temp;public:    void backtrace(const string &amp;s,int index,int k)&#123;&#x2F;&#x2F;k表示逗号数量        if(k&#x3D;&#x3D;4)&#123;            if(index&#x3D;&#x3D;s.size())&#123;                ans.push_back(temp.substr(0,temp.size()-1));&#x2F;&#x2F;不能直接pop_back，否则后面删除时会出现错误            &#125;            return;        &#125;        string scur;        for(int i&#x3D;index;i&lt;s.size();++i)&#123;            scur+&#x3D;s[i];            int num&#x3D;atoi(scur.c_str());            if(num&lt;&#x3D;255&amp;&amp;num&gt;&#x3D;0)&#123;                temp+&#x3D;scur;                temp+&#x3D;&#39;.&#39;;            &#125;else break;            backtrace(s,i+1,k+1);            temp&#x3D;temp.substr(0,temp.size()-scur.size()-1);            if(num&#x3D;&#x3D;0) break;&#x2F;&#x2F;为了保证不含前导0                    &#125;    &#125;    vector&lt;string&gt; restoreIpAddresses(string s) &#123;        backtrace(s,0,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法理论总结</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><h2 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h2><p><strong>回溯法解决的问题都可以抽象为树形结构</strong></p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p><p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h2><p>回溯三部曲</p><ul><li>回溯函数模板返回值以及参数</li></ul><blockquote><p>回溯算法中函数返回值一般为void。</p><p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void backtracking(参数)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><ul><li>回溯函数终止条件</li></ul><blockquote><p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (终止条件) &#123;    存放结果;    return;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>回溯搜索的遍历过程</li></ul><blockquote><p>回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;    处理节点;    backtracking(路径，选择列表); &#x2F;&#x2F; 递归    回溯，撤销处理结果&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>回溯算法模板框架如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); &#x2F;&#x2F; 递归        回溯，撤销处理结果    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="去重方法"><a href="#去重方法" class="headerlink" title="去重方法"></a>去重方法</h2><p>去重可分为两种情况：</p><ul><li>相同值位于一处</li><li>相同值分散在不同地方</li></ul><p><strong>相同值位于一处</strong></p><p>去除重复值主要是去除树同层之间的重复，而树不同层之间的相同值无需去除。而要做到这一点，则每次回溯遍历时，如果当前值与前值相同，且此值又是此次遍历中第一次遇见（说明前一个值是在树中上一层），那么此值应该选，否则不选。代码如下：</p><p><em><strong>初始点去重</strong></em></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;40. 组合总和 IIclass Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;public:    void backtrace(const vector&lt;int&gt;&amp; candidates,int index,int target)&#123;        if(target&#x3D;&#x3D;0)&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;index;i&lt;candidates.size()&amp;&amp;candidates[i]&lt;&#x3D;target;++i)&#123;            if(i&gt;index&amp;&amp;candidates[i]&#x3D;&#x3D;candidates[i-1]) continue;&#x2F;&#x2F;去重代码            temp.push_back(candidates[i]);            backtrace(candidates,i+1,target-candidates[i]);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;        sort(candidates.begin(),candidates.end());        backtrace(candidates,0,target);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面方法是一种特殊情况：遍历起始点是从上一层后面一个节点开始，使得可以用是否是第一个节点来去重。如果，遍历起始点是从其他地方开始，上述方法就无效了。</p><p>比如每次遍历都是从0开始，此时需要使用一个数组来记录每个值是否使用。当遇见两个相同值，如果前一个值被使用（添加进路径容器），说明当前值是在前一个值得下层，当前值可以使用。否则，说明前一个值没在路径中，此时如果使用当前值会造成重复。</p><p><em><strong>全局used数组去重（单个used数组去重）</strong></em></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;47. 全排列 IIclass Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;    vector&lt;int&gt; used;public:    void backtrace(vector&lt;int&gt; &amp;nums)&#123;        if(temp.size()&#x3D;&#x3D;nums.size())&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(used[i]&#x3D;&#x3D;1) continue;            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]&amp;&amp;used[i-1]&#x3D;&#x3D;0) continue;&#x2F;&#x2F;去重            used[i]&#x3D;1;            temp.push_back(nums[i]);            backtrace(nums);            temp.pop_back();            used[i]&#x3D;0;        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        used&#x3D;vector&lt;int&gt;(nums.size(),0);        backtrace(nums);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>相同值分散在不同地方</strong></p><p>当相同值分散在各处时，此时就需要每次遍历的时候去重了。使用数组记录每个数是否使用过，在同一个循环中如果当前值被使用过，那么应该跳过，否则需要选中。</p><p><em><strong>局部used数组去重（多个used数组去重）</strong></em></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;491. 递增子序列class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;    unordered_map&lt;int,int&gt; appear;public:    void backtrace(const vector&lt;int&gt;&amp; nums,int index)&#123;        if(index&gt;&#x3D;nums.size()) return;        int used[201]&#x3D;&#123;0&#125;;        for(int i&#x3D;index;i&lt;nums.size();++i)&#123;            if(used[nums[i]+100]&#x3D;&#x3D;1) continue;&#x2F;&#x2F;去重            used[nums[i]+100]&#x3D;1;            if(temp.size()&gt;0&amp;&amp;nums[i]&lt;temp.back()) continue;            temp.push_back(nums[i]);            if(temp.size()&gt;&#x3D;2) ans.push_back(temp);            backtrace(nums,i+1);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;        backtrace(nums,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总体来看，都可以使用这种方法进行去重，但这种去重方法是最耗费空间的，每次遍历都需要申请一个数组来记录状态。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>151. 反转字符串中的单词</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-151-middle/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-151-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h1><p>First：先找出每个单词再拼一起。写到后面发现可以从尾部遍历，那么就不需要额外空间了。</p><hr><p><strong>方法1</strong>：<strong>顺序遍历+双指针</strong></p><p>从首部开始，使用两个指针来找到单词的首尾从而找到每个单词，使用一个容器存储这些单词，再将每个单词拼在一起即可</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string reverseWords(string s) &#123;        vector&lt;string&gt; words;        int left&#x3D;0,right&#x3D;0;        while(left&lt;s.length()&amp;&amp;right&lt;s.length())&#123;            while(left&lt;s.length()&amp;&amp;s[left]&#x3D;&#x3D;&#39; &#39;)&#123;                ++left;            &#125;            right&#x3D;left;            while(right&lt;s.length()&amp;&amp;s[right]!&#x3D;&#39; &#39;)&#123;                ++right;            &#125;            if(left&gt;&#x3D;s.length()||right&gt;&#x3D;s.length()+1||left&gt;&#x3D;right) break;            words.push_back(s.substr(left,right-left));            left&#x3D;right;        &#125;        string ans;        for(int i&#x3D;words.size()-1;i&gt;&#x3D;0;--i)&#123;            ans+&#x3D;words[i];            if(i!&#x3D;0) ans+&#x3D;&#39; &#39;;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>逆序遍历+双指针</strong></p><p>从尾部开始，使用两个指针来找到单词的首尾，再将每个单词拼在一起即可</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string reverseWords(string s) &#123;        int left&#x3D;s.length()-1,right&#x3D;s.length()-1;        string ans;        while(left&gt;&#x3D;0&amp;&amp;right&gt;&#x3D;0)&#123;            while(right&gt;&#x3D;0&amp;&amp;s[right]&#x3D;&#x3D;&#39; &#39;)&#123;                --right;            &#125;            left&#x3D;right;            while(left&gt;&#x3D;0&amp;&amp;s[left]!&#x3D;&#39; &#39;)&#123;                --left;            &#125;            if(left&gt;&#x3D;right) break;            ans+&#x3D;s.substr(left+1,right-left);            ans+&#x3D;&#39; &#39;;            right&#x3D;left;        &#125;        ans.pop_back();        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>原地更改</strong></p><p>直接将原来的字符串先反转，然后再将每个单词反转回来，去掉首位空格即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28. 找出字符串中第一个匹配项的下标</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-28-middle/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-28-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h1><p>First：使用KMP算法查找</p><hr><p><strong>方法1</strong>：<strong>KMP算法</strong></p><p>使用暴力算法做了许多不必要的对比，而KMP算法减少对比的方法就是使用前缀表来记录下一次应该从子串的哪个位置开始对比。</p><blockquote><p>前缀表：记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀</p><ul><li>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</li><li>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220921183734095.png" alt="image-20220921183734095"></p><p>在上图匹配过程中，原串匹配到a时匹配失败，此时可以发现没必要从子串的开始处重新比对，而只需要将子串指针移动到e，而原串指针不变继续比对即可。</p><p>如何找移动位置？</p><ul><li>其实就是找原串现已经匹配成功的字符串后缀（以匹配失败的a前一个字符b的后缀）和匹配串的前缀（以串首a构成的前缀）最多有多少相同字符</li><li>而字符串是在a和f匹配失败，那么说明前面部分是一样的，也就是说通过匹配串上就能找到移动位置</li></ul><p>找最大相同前缀后缀方法：先使用指针j指向前缀末尾，指针i指向后缀末尾（初始时比对两个字符，因此i初始化为1，j初始化为0）。比对i和j指向数是否相同，若相同，则next[i]&#x3D;j，表明i位置相同后缀后缀最大值为j，i和j都加1再比较下一个位置；如果不相同，j就需要往前退直到找到相同值（退到第一个值则表明最大相同前缀后缀值为0），next[j]记录着之前的子串的相同前后缀的长度。</p><p>因此，KMP算法就是先计算next数组，然后匹配时，如果遇见不匹配字符，则看前一个字符的next值。</p><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int strStr(string haystack, string needle) &#123;        &#x2F;&#x2F;计算next数组        vector&lt;int&gt; next(needle.size(),0);        for(int i&#x3D;1,j&#x3D;0;i&lt;needle.size();++i)&#123;            while(j&gt;0&amp;&amp;needle[j]!&#x3D;needle[i])&#123;&#x2F;&#x2F;不能是j&gt;&#x3D;0，否则面对没有公共节点的前缀和后缀会一直循环                j&#x3D;next[j-1];            &#125;            if(needle[j]&#x3D;&#x3D;needle[i]) ++j;            next[i]&#x3D;j;        &#125;        &#x2F;&#x2F;匹配        for(int i&#x3D;0,j&#x3D;0;i&lt;haystack.size();++i)&#123;            while(j&gt;0&amp;&amp;haystack[i]!&#x3D;needle[j])&#123;                j&#x3D;next[j-1];&#x2F;&#x2F;看前一个字符得next值是因为当前字符已经匹配失败，用前一个字符才能找到多少个不用不配字符            &#125;            if(haystack[i]&#x3D;&#x3D;needle[j])&#123;                ++j;            &#125;            if(j&#x3D;&#x3D;needle.size())&#123;                return i-needle.size()+1;            &#125;        &#125;        return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>Sunday算法</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-字符串 </tag>
            
            <tag> Alg-KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>344. 反转字符串</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-344-simple/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-344-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h1><p>First：直接交换即可</p><hr><p><strong>方法1</strong>：<strong>双指针</strong></p><p>双指针指向前部和尾部，再交换即可</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        int n&#x3D;s.size();        for(int i&#x3D;0,j&#x3D;n-1;i&lt;j;++i,--j)&#123;            swap(s[i],s[j]);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>459. 重复的子字符串</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-459-simple/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-459-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h1><p>First：不知道开始咋想的，想通过判断是否2个子串重复和3个子串重复来判断是否重复。看了下答案，通过移位来判断是没想到。</p><hr><p><strong>方法1</strong>：<strong>KMP</strong></p><p>如果字符串 <code>S</code> 包含一个重复的子字符串，那么这意味着您可以多次 “移位” 字符串，并使其与原始字符串匹配。</p><p>但每次移动字符串太麻烦，创建一个新的字符串为两个原字符串相加，每次移动的结果在新字符串中都有，因此直接找原字符串是否在新字符串中出现即可。但注意的是，需要将新字符串的首字符和尾字符串删除或不比对。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool kmp(string &amp;s1,string &amp;s2)&#123;        vector&lt;int&gt; next(s2.size(),0);        for(int i&#x3D;1,j&#x3D;0;i&lt;s2.size();++i)&#123;            while(j&gt;0&amp;&amp;s2[i]!&#x3D;s2[j]) j&#x3D;next[j-1];            if(s2[i]&#x3D;&#x3D;s2[j]) ++j;            next[i]&#x3D;j;        &#125;        for(int i&#x3D;1,j&#x3D;0;i&lt;s1.size()-1;++i)&#123;&#x2F;&#x2F;不比对首字符和尾字符            while(j&gt;0&amp;&amp;s1[i]!&#x3D;s2[j]) j&#x3D;next[j-1];            if(s1[i]&#x3D;&#x3D;s2[j]) ++j;            if(j&#x3D;&#x3D;s2.size()) return true;        &#125;        return false;    &#125;    bool repeatedSubstringPattern(string s) &#123;        string s1&#x3D;s+s;        return kmp(s1,s);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>优化的KMP</strong></p><p>还没看，但打败率要高很多</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-字符串 </tag>
            
            <tag> Alg-KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>541. 反转字符串 II</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-541-simple/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-541-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h1><p>First：直接交换</p><hr><p><strong>方法1</strong>：<strong>模拟</strong></p><p>每次跳过k个数，将其反转即可，只是处理下末尾数不够2k个情况</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        int n&#x3D;s.length();        for(int i&#x3D;0;i*k&lt;n;++i)&#123;            if(i%2&#x3D;&#x3D;1) continue;            int end&#x3D;(i+1)*k-1&lt;n?(i+1)*k-1:n-1;            for(int j&#x3D;i*k,k&#x3D;end;j&lt;k;++j,--k)&#123;                swap(s[j],s[k]);            &#125;        &#125;        return s;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>792. 匹配子序列的单词数</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-792-%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0-middle/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-792-%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="792-匹配子序列的单词数"><a href="#792-匹配子序列的单词数" class="headerlink" title="792. 匹配子序列的单词数"></a><a href="https://leetcode.cn/problems/number-of-matching-subsequences/description/">792. 匹配子序列的单词数</a></h1><p>First：用双指针和哈希map虽然过了，但效率不够高。看了解析使用了方法二，虽然时间复杂度低了，但最后打败比例差不多。</p><hr><p><strong>方法1</strong>：<strong>双指针+哈希map</strong></p><p>对于words中的每个字符串，使用双指针方法来判断是否是子串。但这复杂度比较高，当words中存在许多重复的就过不了，因此使用一个unordered_map来过滤。</p><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int match(const string &amp;s1,const string &amp;s2)&#123;        if(s2.size()&gt;s1.size()) return 0;        int i&#x3D;0,j&#x3D;0;        while(i&lt;s1.size()&amp;&amp;j&lt;s2.size())&#123;            if(s1[i]&#x3D;&#x3D;s2[j])&#123;                ++i;                ++j;            &#125;else&#123;                ++i;            &#125;        &#125;        return j&#x3D;&#x3D;s2.size()?1:0;    &#125;    int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) &#123;        int ans&#x3D;0;        unordered_map&lt;string,int&gt; map;        for(int i&#x3D;0;i&lt;words.size();++i)&#123;            map[words[i]]++;        &#125;        for(auto &amp;it:map)&#123;            int t&#x3D;match(s,it.first);            ans+&#x3D;t*it.second;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>二分查找+哈希map</strong></p><p>同样先使用unordered_map过滤相同元素。</p><p>使用传统双指针来匹配是否为子序列速度比较慢，其找下一个匹配元素是逐个找的，可使用二分查找加快。</p><p>使用一个二维pos数据来记录字符出现位置，pos[i]记录s中’a’+i字符出现的所有位置。当进行匹配时，通过二分不断找到word[i]的每个字符出现位置（注意，找到第一个字符位置后，只会在这个位置之后找第二个字符的位置）。</p><ul><li>时间复杂度：O(logn*words数量 * word字符数)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; pos;public:    int match(const string &amp;s1,const string &amp;s2)&#123;        if(s2.size()&gt;s1.size()) return 0;        int p&#x3D;-1;        for(int i&#x3D;0;i&lt;s2.size();++i)&#123;            auto &amp;t&#x3D;pos[s2[i]-&#39;a&#39;];            auto idx&#x3D;upper_bound(t.begin(),t.end(),p);            if(idx&#x3D;&#x3D;t.end())&#123;                return 0;            &#125;            p&#x3D;*idx;        &#125;        return 1;    &#125;    int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) &#123;        int ans&#x3D;0;        pos&#x3D;vector&lt;vector&lt;int&gt;&gt;(26);        for(int i&#x3D;0;i&lt;s.size();++i)&#123;            pos[s[i]-&#39;a&#39;].push_back(i);        &#125;        unordered_map&lt;string,int&gt; map;        for(int i&#x3D;0;i&lt;words.size();++i)&#123;            map[words[i]]++;        &#125;        for(auto &amp;it:map)&#123;            int t&#x3D;match(s,it.first);            ans+&#x3D;t*it.second;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> Alg-字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 05. 替换空格</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%89%91%E6%8C%87-05-simple/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%89%91%E6%8C%87-05-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h1><p>First：先数空格，然后替换。但看到答案发现可以直接在原来数组上进行替换，只是要倒序遍历，空间效率更高。</p><hr><p><strong>方法1</strong>：<strong>遍历</strong></p><p>先数空格数量，再申请一个string，依次遍历替换即可</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string replaceSpace(string s) &#123;        int num&#x3D;0;        for(auto c:s)&#123;            if(c&#x3D;&#x3D;&#39; &#39;) ++num;        &#125;        string ans(s.length()+num*2,&#39; &#39;);        for(int i&#x3D;0,j&#x3D;0;i&lt;s.length();++i)&#123;            if(s[i]!&#x3D;&#39; &#39;)&#123;                ans[j++]&#x3D;s[i];            &#125;else&#123;                ans[j++]&#x3D;&#39;%&#39;;                ans[j++]&#x3D;&#39;2&#39;;                ans[j++]&#x3D;&#39;0&#39;;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法1</strong>：<strong>原地替换</strong></p><p>先数空格数量，将原数组进行扩容，然后从尾部进行遍历替换</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 58 - II. 左旋转字符串</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%89%91%E6%8C%87-58-simple/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%89%91%E6%8C%87-58-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h1><p>First：就直接遍历即可，但没想到可以用取余来简化操作，使用反转三次效率更高</p><hr><p><strong>方法1</strong>：<strong>遍历</strong></p><p>依次遍历字符串即可，但是可以用取余操作来简化代码，不用写两个循环</p><p>或直接用substr函数</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string reverseLeftWords(string s, int n) &#123;        int len&#x3D;s.length();        string ans;        ans.reserve(len);                for(int i&#x3D;n;i&lt;len+n;++i)&#123;            ans+&#x3D;s[i%len];        &#125;        return ans;        &#x2F;&#x2F;return s.substr(n,s.size()-n)+s.substr(0,n);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>原地反转</strong></p><p>以n未界限将字符串分为两部分，前半部分和后半部分都反转，然后整体再反转得到结果</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li><li><pre><code class="c++">class Solution &#123;public:    string reverseLeftWords(string s, int n) &#123;        reverse(s.begin(),s.begin()+n);        reverse(s.begin()+n,s.end());        reverse(s.begin(),s.end());        return s;    &#125;&#125;;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>155. 最小栈</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88-middle/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/description/">155. 最小栈</a></h1><p>First：没想到咋做，看了答案才知道直接存储每次的最小值。。。不过有个解法是存储差值很有意思。</p><hr><p><strong>方法1</strong>：<strong>双栈</strong></p><p>使用两个栈，栈s存储元素，一个栈ms存最小值。当push一个元素时，ms的栈顶元素与压入栈元素比较得到最小值。当取最小值时，则返回ms的栈顶元素。</p><ul><li>时间复杂度：O(1) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MinStack &#123;    stack&lt;int&gt; s;    stack&lt;int&gt; ms;public:    MinStack() &#123;    &#125;        void push(int val) &#123;        s.push(val);        if(!ms.empty())&#123;            ms.push(min(ms.top(),s.top()));        &#125;else&#123;            ms.push(s.top());        &#125;    &#125;        void pop() &#123;        s.pop();        ms.pop();    &#125;        int top() &#123;        return s.top();    &#125;        int getMin() &#123;        return ms.top();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法2</strong>：<strong>栈中存差值</strong></p><p>此方法只需常量级空间存储最小值。</p><p>成员包括一个栈s和一个最小值minValue，当push元素val时，dif&#x3D;val-minValue，将dif压入栈，当dif小于0时，说明minValue&#x3D;val。当pop时，如果s.top()&lt;0，弹出栈顶元素即可并将minValue&#x3D;minValue-dif，否则弹出栈顶元素即可。</p><p>注意栈中存的元素应为Long，否则相减值会越界。</p><ul><li>时间复杂度：O(1) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MinStack &#123;    stack&lt;long&gt; s;    int minValue;public:    MinStack() &#123;    &#125;        void push(int val) &#123;        if(s.empty())&#123;            s.push(0);            minValue&#x3D;val;        &#125;else&#123;            long dif&#x3D;(long)val-minValue;            if(dif&lt;0) minValue&#x3D;val;            s.push(dif);        &#125;    &#125;        void pop() &#123;        if(s.top()&lt;0)&#123;            minValue-&#x3D;s.top();                    &#125;        s.pop();    &#125;        int top() &#123;        return s.top()&lt;0?minValue:minValue+s.top();    &#125;        int getMin() &#123;        return minValue;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>239. 滑动窗口最大值</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-difficult/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值</a></h1><p>First：傻了，没想到使用单调队列来找最大数</p><hr><p><strong>方法1</strong>：<strong>单调队列</strong></p><p>关键在于如何滑动窗口中快速找到最大值</p><p>使用一个deque来维持从大到小的单调队列，队首元素为最大值。</p><p>每当滑动窗口向右移动，将新添加的值与队尾元素不断比较，若大于队尾元素则将队尾元素弹出（相等不弹出），否则压入队尾；将要删除的值与队首元素比较，如果相等则说明当前最大值被删除了，此时将队首元素弹出。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; ans;        deque&lt;int&gt; que;        for(int i&#x3D;0;i&lt;k;++i)&#123;            while(!que.empty()&amp;&amp;que.back()&lt;nums[i])&#123;                que.pop_back();            &#125;            que.push_back(nums[i]);        &#125;        ans.push_back(que.front());        for(int i&#x3D;k;i&lt;nums.size();++i)&#123;            while(!que.empty()&amp;&amp;que.back()&lt;nums[i])&#123;                que.pop_back();            &#125;            que.push_back(nums[i]);            if(nums[i-k]&#x3D;&#x3D;que.front())&#123;                que.pop_front();            &#125;            ans.push_back(que.front());        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>347. 前 K 个高频元素</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-middle/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">347. 前 K 个高频元素</a></h1><p>First：使用的两次比较来做，没想到用优先级队列</p><hr><p><strong>方法1</strong>：<strong>排序</strong></p><p>先使用unordered_map统计每个数的频率，再对频率进行排序，最后取前K个值。</p><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(pair&lt;int,int&gt;&amp; a,pair&lt;int,int&gt;&amp; b)&#123;        return a.second&gt;b.second;    &#125;    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; ans;        unordered_map&lt;int,int&gt; map;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            map[nums[i]]++;        &#125;        vector&lt;pair&lt;int,int&gt;&gt; freq;        for(auto &amp;it:map)&#123;            freq.push_back(pair&lt;int,int&gt;(it.first,it.second));        &#125;        sort(freq.begin(),freq.end(),compare);        for(int i&#x3D;0;i&lt;k;++i)&#123;            ans.push_back(freq[i].first);        &#125;                return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法2</strong>：<strong>优先级队列</strong></p><p>和方法一一样，先使用map统计每个数的频率，使用一个priority_queue来维持一个小顶堆，将小顶堆的节点数维持在K个，最后返回小顶堆中的元素即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-排序 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>636. 函数的独占时间</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-636-%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4-middle/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-636-%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="636-函数的独占时间"><a href="#636-函数的独占时间" class="headerlink" title="636. 函数的独占时间"></a><a href="https://leetcode.cn/problems/exclusive-time-of-functions/description/">636. 函数的独占时间</a></h1><p>First：比较难处理的是遇到先end后start且中间有空格的情况，这就会导致必须使用栈来存储信息。目前方法效率较低</p><hr><p><strong>方法1</strong>：<strong>栈</strong></p><p>每次取相邻两组数据进行分析，如果第一组数据是start则将其压入栈中，然后分析第二组数据。可分为两种情况：</p><ul><li><p>第二组数据是start时：</p><ul><li>当第一组数据是start时，这段消耗时间属于第一组数据</li><li>当第一组数据是end时，此时这段消耗时间并不属于第一组，需要用栈来找到所属任务</li></ul></li><li><p>第二组数据是end时，先弹出栈顶元素，再分为以下情况：</p><ul><li>当第一组数据是start时，消耗时间属于第一组任务</li><li>当第一组数据是end时，消耗时间属于第二组任务</li></ul><p>注意这四张情况计算消耗时间会有所不同，</p></li><li><p>时间复杂度：O(n) </p></li><li><p>空间复杂度：O(n)</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:        vector&lt;string&gt; getLog(string &amp;log)&#123;        int k1&#x3D;0,k2&#x3D;log.size();        while(log[k1]!&#x3D;&#39;:&#39;)++k1;        while(log[k2]!&#x3D;&#39;:&#39;)--k2;        return &#123;log.substr(0,k1),log.substr(k1+1,k2-k1-1),log.substr(k2+1,log.size()-k2-1)&#125;;    &#125;    vector&lt;int&gt; exclusiveTime(int n, vector&lt;string&gt;&amp; logs) &#123;        vector&lt;int&gt; ans(n,0);        stack&lt;int&gt; st;        for(int i&#x3D;1;i&lt;logs.size();++i)&#123;            vector&lt;string&gt; log&#x3D;getLog(logs[i-1]);            int idx1&#x3D;atoi(log[0].c_str());            int num1&#x3D;atoi(log[2].c_str());            string flag1&#x3D;log[1];            log&#x3D;getLog(logs[i]);            int idx2&#x3D;atoi(log[0].c_str());            int num2&#x3D;atoi(log[2].c_str());            string flag2&#x3D;log[1];            if(flag1&#x3D;&#x3D;&quot;start&quot;) st.push(idx1);            if(flag2&#x3D;&#x3D;&quot;start&quot;) &#123;                if(flag1&#x3D;&#x3D;&quot;start&quot;) ans[idx1]+&#x3D;(num2-num1);                else if(num2-num1-1&gt;0) ans[st.top()]+&#x3D;(num2-num1-1);            &#125;            else &#123;                st.pop();                if(flag1&#x3D;&#x3D;&quot;start&quot;) ans[idx1]+&#x3D;(num2-num1+1);                 else ans[idx2]+&#x3D;(num2-num1);             &#125;           &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1004. 最大连续1的个数 III</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0III-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0III-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/">1004. 最大连续1的个数 III</a></h1><p>FIrst：比较顺利，使用双指针法即可</p><hr><p><strong>方法1</strong>：<strong>双指针</strong></p><p>使用两个指针left和right分别指向区间的左右，依次遍历数组，如果当前值为1则将right+1；如果为0，则判断当前区间中已有的0个数是否超过限制，如果未超过限制，则直接将right+1，否则需要移动左边界使得整体区间中少一个0，然后将right+1。记录区间的最大长度即为结果。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int longestOnes(vector&lt;int&gt;&amp; nums, int k) &#123;        int left&#x3D;0,right&#x3D;0,kn&#x3D;0;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(nums[i]&#x3D;&#x3D;1) ++right;            else &#123;                ++right;                if(kn&lt;k) ++kn;                                     else&#123;                    while(nums[left]!&#x3D;0) ++left;                    ++left;                &#125;                            &#125;            ans&#x3D;max(ans,right-left);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>162. 寻找峰值</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a href="https://leetcode.cn/problems/find-peak-element/description/">162. 寻找峰值</a></h1><p>FIrst：没做出来，这二分比较巧妙</p><hr><p><strong>方法1</strong>：<strong>二分法</strong></p><p>由于 <code>nums[-1] = nums[n] = -∞</code>，那么<strong>只要数组中存在一个元素比相邻元素大，那么沿着它一定可以找到一个峰值</strong>（比如nums[a]&lt;nums[a+1]，如果nums[a+2]小于nums[a+1]，则nums[a+1]为峰值，如果大于则继续比较a+2，即使一直递增但由于最末尾是一个负无穷，则也会存在一个峰值）</p><p>因此，设置两个指针left和right，计算中间值m，如果nums[m]&gt;nums[m+1]，则right&#x3D;m；否则left&#x3D;m+1；</p><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;        int left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;right)&#123;            int mid&#x3D;left+(right-left)&#x2F;2;            if(nums[mid+1]&gt;nums[mid]) left&#x3D;mid+1;            else right&#x3D;mid;        &#125;        return left;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>209. 长度最小的子数组</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-209-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-209-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h1><p>First：第一次见到这题想的还是用双重for循环或动态规划来做，但复杂度都超过O(n)</p><hr><p><strong>方法1</strong>：<strong>滑动窗口</strong> </p><p>使用一个窗口来表示选择了哪些数，循环遍历过程中，每次向滑动窗口中添加一个数，如果窗口总和小于target，则继续遍历。否则，则从窗口左边开始减少数，一直减少到窗口总和不小于target，再将此时窗口大小和返回值比较。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;                int sum&#x3D;0,ans&#x3D;INT_MAX,window&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            sum+&#x3D;nums[i];            ++window;            if(sum&lt;target) continue;            for(int j&#x3D;i-window+1;j&lt;&#x3D;i;++j)&#123;                if(sum-nums[j]&lt;target) break;                sum-&#x3D;nums[j];                window--;            &#125;            if(window&lt;ans) ans&#x3D;window;        &#125;        return ans&#x3D;&#x3D;INT_MAX?0:ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
            <tag> Alg-滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27. 移除元素</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-27-simple/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-27-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h1><p>First：看见这题直觉想的是使用双指针来做，但是我想到的是使用前后指针，即左边找到一个需要去除的，再从右边找到一个无需去除的，将右边找到的数填充的左边即可，这种方法会导致一些特俗用例通不过，如只有一个值。最后，看了解析发现这种思路需要一些技巧，见方法2.</p><hr><p><strong>方法1</strong>：<strong>快慢指针</strong></p><p>使用双指针来做，即快指针和慢指针，快指针依次遍历每个元素，同时在遍历时将每个元素复制到正确位置，因此需要一个慢指针代表元素正确位置。正确位置也就是移除元素后的位置，因此，找到快指针遍历时如果是需要移除的元素，则慢指针位置不变，否则慢指针+1.、</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        if(nums.empty())return 0;        int fast&#x3D;0,low&#x3D;0;        for(;fast&lt;nums.size();++fast)&#123;            if(nums[fast]!&#x3D;val)&#123;                nums[low]&#x3D;nums[fast];                ++low;            &#125;        &#125;        return low;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>左右双指针</strong></p><p>使用左右指针来做，左指针遍历查看是否是需要去除的元素，如果是则复制右指针的值，技巧见代码</p><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int left &#x3D; 0, right &#x3D; nums.size();        while (left &lt; right) &#123;            if (nums[left] &#x3D;&#x3D; val) &#123;                nums[left] &#x3D; nums[right - 1];                right--;            &#125; else &#123;                left++;            &#125;        &#125;        return left;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>287. 寻找重复数</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/description/">287. 寻找重复数</a></h1><p>FIrst：这映射思想值得学习</p><hr><p><strong>方法1</strong>：<strong>双指针+回环</strong></p><p>假设数组中是每个节点，可以为每个节点连接一个箭头指向下一个节点，连接规则即若节点值为k，则指向nums[k]。</p><p>由以上连接规则可知，由于数组中存在重复值，则一定会有两个箭头指向同一个节点，因此存在回环，就可以将此问题转换为检测回环起点问题。</p><p>使用快慢指针，快指针每次前进两步，慢指针每次前进一步，由于存在回环，则必相遇。和回环起点问题一样，将慢指针指向初始位置0处，然后快慢指针每次都只走一步，当指向节点值相同时即为答案（回环起始点必有两个箭头指向它）</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int slow&#x3D;0,fast&#x3D;0;        do&#123;            slow&#x3D;nums[slow];            fast&#x3D;nums[nums[fast]];        &#125;while(slow!&#x3D;fast);        slow&#x3D;0;        do&#123;            slow&#x3D;nums[slow];            fast&#x3D;nums[fast];        &#125;while(slow!&#x3D;fast);        return slow;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>二分查找</strong></p><p>假设任取一个值k，如果数组中小于等于此值的数量大于k，则说明存在重复数。使用二分查找不断缩小空间。</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int n&#x3D;nums.size();        int l&#x3D;0,r&#x3D;n-1,ans;        while(l&lt;&#x3D;r)&#123;            int mid&#x3D;(l+r)&#x2F;2;            int cnt&#x3D;0;            for(int i&#x3D;0;i&lt;n;++i)&#123;                cnt+&#x3D;nums[i]&lt;&#x3D;mid;            &#125;            if(cnt&lt;&#x3D;mid)&#123;                l&#x3D;mid+1;            &#125;else&#123;                r&#x3D;mid-1;                ans&#x3D;mid;            &#125;        &#125;        &#x2F;&#x2F;还可以建立一种隐射，找环的位置来做，还没这样做过，不过想不出为啥这样建隐射        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
            <tag> Alg-二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>581. 最短无序连续子数组</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/">581. 最短无序连续子数组</a></h1><p>FIrst：O(n)的方法没写出来， 虽然以前做过</p><hr><p><strong>方法1</strong>：<strong>线性遍历</strong></p><p>将给定的数组 nums\textit{nums}nums 表示为三段子数组拼接的形式，分别记作 numsA、numsB、numsC，重排numsB即可有序。</p><p>numsA中的每个数一定都小于等于numB的最小值，那么从后向前遍历，记录当前最小值，如果nums[i]&gt;minn，则left&#x3D;i，找到最小的left值作为左边界。</p><p>同理，numsC中的每个数一定都大于等于numsB的最大值，那么从前向后遍历，记录最大值，如果nums[i]&gt;maxn，则right&#x3D;i,找到最大的right作为右边界。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123;        int maxn&#x3D;INT_MIN,right&#x3D;-1;        int minn&#x3D;INT_MAX,left&#x3D;-1;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(maxn&gt;nums[i]) right&#x3D;i;            else maxn&#x3D;nums[i];        &#125;        for(int i&#x3D;nums.size()-1;i&gt;&#x3D;0;--i)&#123;            if(minn&lt;nums[i]) left&#x3D;i;            else minn&#x3D;nums[i];        &#125;        return right&#x3D;&#x3D;-1?0:right-left+1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>排序</strong></p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>414. 第三大的数</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-414-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0-simple/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-414-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a><a href="https://leetcode.cn/problems/third-maximum-number/description/">414. 第三大的数</a></h1><p>First：忘记set自带排序了，但最后实测两种方法打败比例差不多</p><hr><p><strong>方法1</strong>：<strong>排序</strong></p><p>先排序，然后找到是否有第三大的数，如果没有则返回第一个数。</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int thirdMax(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end(),greater&lt;int&gt;());        int n&#x3D;0,t&#x3D;nums[0]-1;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(t!&#x3D;nums[i])&#123;                t&#x3D;nums[i];                ++n;                if(n&#x3D;&#x3D;3) return t;            &#125;        &#125;        return nums[0];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>有序集合</strong></p><p>不断将数插入set中，set会自动排序，当set容量大于3时就弹出第一个元素，使得set容量始终保持为3。</p><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int thirdMax(vector&lt;int&gt;&amp; nums) &#123;        set&lt;int&gt; s;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            s.insert(nums[i]);            if(s.size()&gt;3)&#123;                s.erase(s.begin());            &#125;        &#125;        return s.size()&#x3D;&#x3D;3?*s.begin():*s.rbegin();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：<strong>使用三个数存储</strong></p><p>使用三个数来存储第一大、第二大、第三大，一次遍历即可</p><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-排序 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>59. 螺旋矩阵 II</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-59-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-59-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h1><p>FIrst：就按顺时针模拟就可。</p><hr><p><strong>方法1</strong>：<strong>按层模拟</strong></p><p>将矩阵看成若干层，每个按顺时针旋转模拟填入一层，但注意不要在每个边处理相同的个数，否则遇见n&#x3D;1时需要单独处理。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        if(n&lt;&#x3D;0) return &#123;&#123;&#125;&#125;;        vector&lt;vector&lt;int&gt;&gt; ans(n,vector(n,0));        int hl&#x3D;0,hr&#x3D;n-1;        int vt&#x3D;0,vb&#x3D;n-1;        int num&#x3D;1;        while(num&lt;&#x3D;n*n)&#123;            for(int i&#x3D;hl;i&lt;&#x3D;hr;++i)&#123;                ans[vt][i]&#x3D;num;                ++num;            &#125;            for(int i&#x3D;vt+1;i&lt;&#x3D;vb;++i)&#123;                ans[i][hr]&#x3D;num;                ++num;            &#125;            for(int i&#x3D;hr-1;i&gt;&#x3D;hl;--i)&#123;                ans[vb][i]&#x3D;num;                ++num;            &#125;            for(int i&#x3D;vb-1;i&gt;vt;--i)&#123;                ans[i][hl]&#x3D;num;                ++num;            &#125;            ++hl;            --hr;            ++vt;            --vb;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>模拟</strong></p><p>模拟矩阵的生成。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
            <tag> Alg-模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>665. 非递减数列</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-665-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-665-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a><a href="https://leetcode.cn/problems/non-decreasing-array/description/">665. 非递减数列</a></h1><p>First：失败了好几次。。。真面向测试编程</p><hr><p><strong>方法1</strong>：<strong>遍历</strong> </p><p>很明显，可以通过统计不满足非递减的个数来判断，但是当面对如[3,4,2,3]这种有两段有序但交接处不满足要求的数组时，则还需要判断前后数字是否满足要求，即判断nums[i-1]&lt;nums[i+1]&amp;&amp;nums[i]&lt;nums[i+2]是否成立（这是因为如果前后两段都满足要求的话只需要比较前段最大值和后段最小值即可，毕竟如果段中不满足要求时就不会有有序的两段），否则返回FALSE。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size()-1;++i)&#123;            if(nums[i]&gt;nums[i+1])&#123;                &#x2F;&#x2F;判断前后两段是有序的情况，这种情况下只需要判断nums[i-1]和nums[i+2]即可                if((i&gt;0&amp;&amp;nums[i-1]&gt;nums[i+1])&amp;&amp;(i&lt;nums.size()-2&amp;&amp;nums[i]&gt;nums[i+2])) return false;                ++ans;                if(ans&gt;1) return false;            &#125;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>更改数字</strong> </p><p>当找到不满足要求的数字时，如果nums[i+1]&lt;nums[i-1]时（这是为了保证前面有一段都小于nums[i+1]，如果只有一个数小于nums[i+1]，则没必要改，因为可以通过改nums[i]来解决，避免改nums[i+1]导致后面不满足要），将nums[i+1]&#x3D;nums[i]，然后继续遍历，如果不满足要求的数字大于1，则返回false。</p><blockquote><p>不设nums[i]&#x3D;nums[i+1]的原因是 此时虽然保证了此处有序，但前面的数不一定小于等于nums[i+1]，而设nums[i+1]&#x3D;nums[i]的话，nums[i+1]以前的数一定满足要求，而数组还会往后遍历查看不满足要求的数字个数</p></blockquote><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size()-1;++i)&#123;            if(nums[i]&gt;nums[i+1])&#123;                ++ans;                if(ans&gt;1) return false;                if(i&gt;0&amp;&amp;nums[i+1]&lt;nums[i-1]) nums[i+1]&#x3D;nums[i];            &#125;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>724. 寻找数组的中心下标</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87-simple/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724. 寻找数组的中心下标"></a><a href="https://leetcode.cn/problems/find-pivot-index/description/">724. 寻找数组的中心下标</a></h1><p>FIrst：傻了，从两边遍历，但遇见负数或正数就需要单独处理，麻烦且还不一定对</p><hr><p><strong>方法1</strong>：<strong>前缀和</strong></p><p>先求得数组总和total，然后从左开始遍历，如果左边以左的数相加和lsum&#x3D;&#x3D;total-lsum-nums[i]，则说明找到答案。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int pivotIndex(vector&lt;int&gt;&amp; nums) &#123;        int total&#x3D;0,lsum&#x3D;0;        for(auto a:nums) total+&#x3D;a;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(lsum&#x3D;&#x3D;total-nums[i]-lsum) return i;            lsum+&#x3D;nums[i];        &#125;        return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75. 颜色分类</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/description/">75. 颜色分类</a></h1><p>FIrst：记得以前考研时做过，这次没有一遍遍历做出来</p><hr><p><strong>方法1</strong>：<strong>双指针</strong></p><p>采用双指针分别遍历两次，第一次先将0调换到数组前部分，第二次再将1调换到数组中部。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;right)&#123;            while(nums[left]&#x3D;&#x3D;0&amp;&amp;left&lt;right) ++left;            while(nums[right]!&#x3D;0&amp;&amp;left&lt;right) --right;            if(left&lt;right)&#123;                int t&#x3D;nums[left];                nums[left]&#x3D;nums[right];                nums[right]&#x3D;t;            &#125;        &#125;        left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;nums.size()&amp;&amp;nums[left]&#x3D;&#x3D;0) ++left;        while(left&lt;right)&#123;            while(nums[left]&#x3D;&#x3D;1&amp;&amp;left&lt;right) ++left;            while(nums[right]&#x3D;&#x3D;2&amp;&amp;left&lt;right) --right;            if(left&lt;right)&#123;                int t&#x3D;nums[left];                nums[left]&#x3D;nums[right];                nums[right]&#x3D;t;            &#125;                    &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>三指针</strong></p><p>一次遍历。先使用两个指针p1 p2分别指向已排好的0和1尾部，使用一个指针从头到尾进行遍历，如果nums[i]&#x3D;1，则将其与nums[p2]进行交换，并p2+1；当nums[i]&#x3D;0时，此时将其与nums[p1]进行交换，但如果已经有1排好序，即p2&gt;p1，此时将会把1交换到nums[i]，因此还需要将nums[i]和nums[p2]交换，最后p1和p2都加1.</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int p1&#x3D;0,p2&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(nums[i]&#x3D;&#x3D;0)&#123;                swap(nums[i],nums[p1]);                                                if(p1&lt;p2)&#123;                    swap(nums[i],nums[p2]);                                    &#125;                      ++p2;                ++p1;                      &#125;else if(nums[i]&#x3D;&#x3D;1)&#123;                swap(nums[i],nums[p2]);                ++p2;            &#125;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>775. 全局倒置与局部倒置</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-775-%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-775-%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="775-全局倒置与局部倒置"><a href="#775-全局倒置与局部倒置" class="headerlink" title="775. 全局倒置与局部倒置"></a><a href="https://leetcode.cn/problems/global-and-local-inversions/description/">775. 全局倒置与局部倒置</a></h1><p>FIrst：开始打算分别计算两个值来比较，尝试了下错了，后来想到只要找到错误就可以判断了</p><hr><p><strong>方法1</strong>：<strong>维护最大值</strong></p><p>由定义得知全局倒置数量一定大于等于局部倒置数量，而只有当一个数nums[i]在大于i+1后还有比nums[i]小的数，此时全局倒置数量才会大于局部倒置数量。</p><p>对nums进行遍历，当遍历到i时，使用一个maxNum记录0到i-2的最大值，此时如果maxNum大于nums[i]，则说明全局倒置数量一定比局部多，返回false即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isIdealPermutation(vector&lt;int&gt;&amp; nums) &#123;        int maxNum&#x3D;-1;        for(int i&#x3D;1;i&lt;nums.size();++i)&#123;            if(maxNum&gt;nums[i]) return false;            maxNum&#x3D;max(maxNum,nums[i-1]);        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>977. 有序数组的平方</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-977-simple/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-977-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h1><p>FIrst：原数组有序，因此只需要处理正负数平凡带来的影响即可。见到这题的第一想法便是方法1。</p><hr><p><strong>方法1</strong>：<strong>分界值+双指针</strong></p><p>先找到正负数的分界位置，从分界处开始向左右两边遍历，依次选择最小的即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        int n&#x3D;nums.size();        if(n&#x3D;&#x3D;0) return &#123;&#125;;        vector&lt;int&gt; ans;        ans.reserve(n);        int pos&#x3D;0;        for(;pos&lt;n&amp;&amp;nums[pos]&lt;0;++pos)&#123;&#125;        int positive&#x3D;pos,negative&#x3D;pos-1;        int ansSize&#x3D;0;        while(positive&lt;n&amp;&amp;negative&gt;&#x3D;0)&#123;            int t1&#x3D;nums[positive]*nums[positive];            int t2&#x3D;nums[negative]*nums[negative];            if(t1&lt;t2)&#123;                ans.push_back(t1);                ++positive;            &#125;else&#123;                ans.push_back(t2);                                --negative;            &#125;            ++ansSize;        &#125;        while(positive&lt;n)&#123;            ans.push_back(nums[positive]*nums[positive++]);        &#125;        while(negative&gt;&#x3D;0)&#123;            ans.push_back(nums[negative]*nums[negative--]);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>双指针</strong></p><p>方法1还需要去寻找分界位置，需要一次遍历消耗。由于本题没说要排除重复值之类，因此结果大小是固定的。可以直接选择从原数组两头进行比较，选择最大值插入到结果数组中，从尾向头插入即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45. 跳跃游戏 II</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-1005-K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C-simple/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-1005-K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h1><p>First：折腾了半天，细节一直没搞好，总想着用最高效率，但这样又会太抠细节</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>局部最优：将每个负数变为正数</p><p>全局最优：尽量将所有负数都变为正数</p><p>先对数组进行排序，将所有负数变为正数，如果负数数量为大于等于k，则只将最小的K个负数变为正数，如果负数数量小于k，此时将所有负数变为正数，然后再进行一次排序。如果（k-负数数量）%2&#x3D;&#x3D;1，则表示必须翻转一次数，此时选排序后的最小值进行翻转可使得整体最大。最后，将数组相加即可。</p><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123;        sort(nums.begin(),nums.end());        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(nums[i]&lt;0&amp;&amp;k&gt;0)&#123;                nums[i]&#x3D;-nums[i];                --k;            &#125;        &#125;        sort(nums.begin(),nums.end());        if(k%2&#x3D;&#x3D;1)&#123;            nums[0]&#x3D;-nums[0];        &#125;        int sum&#x3D;0;        for(auto a:nums) sum+&#x3D;a;                return sum;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1029. 两地调度</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-1029-%E4%B8%A4%E5%9C%B0%E8%B0%83%E5%BA%A6-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-1029-%E4%B8%A4%E5%9C%B0%E8%B0%83%E5%BA%A6-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="1029-两地调度"><a href="#1029-两地调度" class="headerlink" title="1029. 两地调度"></a><a href="https://leetcode.cn/problems/two-city-scheduling/description/">1029. 两地调度</a></h1><p>First：快20天没刷题了，没做出来，想的是确定一个维度在来做，看了解析发现思想是真简洁</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>先将所有都派往A公司，然后从其中选出N个人改变行程前往B公司，那么应该选priceB-priceA最小的N个人才能使得总费用最少。</p><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int twoCitySchedCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123;        int n&#x3D;costs.size()&#x2F;2;        int res&#x3D;0;        for(int i&#x3D;0;i&lt;costs.size();++i)&#123;            res+&#x3D;costs[i][0];        &#125;        sort(costs.begin(), costs.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;            return (a[1]-a[0])&lt;(b[1]-b[0]);        &#125;);        for(int i&#x3D;0;i&lt;n;++i)&#123;            res+&#x3D;costs[i][1]-costs[i][0];        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>122. 买卖股票的最佳时机 II</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><p>First：使用的动态规划</p><p>Second：使用贪心，但思想和代码随想录中的题解有出入</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        &#x2F;&#x2F;动态规划         int dp1&#x3D;-prices[0],dp2&#x3D;0;         for(int i&#x3D;1;i&lt;prices.size();++i)&#123;             int t&#x3D;dp1;             dp1&#x3D;max(dp1,dp2-prices[i]);             dp2&#x3D;max(dp2,t+prices[i]);                     &#125;         return max(dp1,dp2);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>贪心</strong></p><p>局部最优：股票能赚钱只有在价格上升阶段，那么找出每个上升阶段，以上升阶段尾部值减去上升阶段首部值即为局部最大利润</p><p>全局最优：所有局部最优加起来即可</p><blockquote><p>代码随想录题解：</p><p>局部最优：找到每天相比前一天能赚钱的那些天（可以看成将大的上升阶段分成了小的上升阶段）</p><p>全局最优：将能赚钱的那些天利润加起来</p></blockquote><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        &#x2F;&#x2F;贪心        int ans&#x3D;0;        int sp&#x3D;prices[0];        for(int i&#x3D;1;i&lt;prices.size();++i)&#123;            if(prices[i]&lt;prices[i-1])&#123;                ans+&#x3D;prices[i-1]-sp;                sp&#x3D;prices[i];            &#125;        &#125;        ans+&#x3D;prices[prices.size()-1]-sp;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>134. 加油站</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h1><p>First：不知道为啥想到了找最大子串和</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>对于每个加油站，都可以计算出当前加油站能加油量与到下一个加油站的消耗的差值remain，由题中可知，只会存在唯一解，那么remain子串中最大值就一定是能保证开一圈的，这代表开了这些加油站后剩余油量最大，如果最大子串都不能开一圈，那么其他子串也不行。这问题也就转化为找最大子串。</p><p>局部最优：</p><p>全局最优：</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;        &#x2F;&#x2F; vector&lt;int&gt; remain(gas.size(),0);        &#x2F;&#x2F; int reSum;        &#x2F;&#x2F; for(int i&#x3D;0;i&lt;cost.size();++i)&#123;        &#x2F;&#x2F;     remain[i]&#x3D;gas[i]-cost[i];        &#x2F;&#x2F;     reSum+&#x3D;remain[i];        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; if(reSum&lt;0) return -1;        &#x2F;&#x2F; int start&#x3D;0, maxSum&#x3D;0;        &#x2F;&#x2F; for(int i&#x3D;0;i&lt;remain.size();++i)&#123;        &#x2F;&#x2F;     if(maxSum&lt;0)&#123;        &#x2F;&#x2F;         start&#x3D;i;        &#x2F;&#x2F;         maxSum&#x3D;remain[i];        &#x2F;&#x2F;     &#125;else&#123;        &#x2F;&#x2F;         maxSum+&#x3D;remain[i];        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; return start;        &#x2F;&#x2F;简化        int remainSum&#x3D;0,maxStart&#x3D;0,maxSum&#x3D;0;&#x2F;&#x2F;maxstart:子串起始点，maxsum：子串和        for(int i&#x3D;0;i&lt;gas.size();++i)&#123;            int remain&#x3D;gas[i]-cost[i];            remainSum+&#x3D;remain;            if(maxSum&lt;0)&#123;                maxSum&#x3D;remain;                maxStart&#x3D;i;            &#125;else&#123;                maxSum+&#x3D;remain;            &#125;        &#125;        return remainSum&lt;0?-1:maxStart;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>135. 分发糖果</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h1><p>First：两个月前做过，但还是没做出来。。。</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>由于相邻两个孩子评分更高的孩子会获得更多糖果，那么如果一起考虑左右孩子的情况会很复杂。将左右孩子分成两次进行考虑，每个只考虑左边或右边的孩子造成的影响，然后取最大的糖果数即可。</p><p>局部最优：</p><p>全局最优：</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int candy(vector&lt;int&gt;&amp; ratings) &#123;        vector&lt;int&gt; left(ratings.size(),1),right(ratings.size(),1);        for(int i&#x3D;1;i&lt;ratings.size();++i)&#123;            if(ratings[i]&gt;ratings[i-1])&#123;                left[i]&#x3D;left[i-1]+1;            &#125;        &#125;        for(int i&#x3D;ratings.size()-2;i&gt;&#x3D;0;--i)&#123;            if(ratings[i]&gt;ratings[i+1])&#123;                right[i]&#x3D;right[i+1]+1;            &#125;        &#125;        int sum&#x3D;0;        for(int i&#x3D;0;i&lt;left.size();++i)&#123;            sum+&#x3D;max(left[i],right[i]);        &#125;        return sum;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>376. 摆动序列</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h1><p>First：这道题我动荡了好久，上次写到写到都不想写了，始终觉得解析有点难理解，整的都有点心魔了，随想录得答案虽然能过，但始终觉得不舒服，最后写出了自己得特殊情况处理方法。</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p><img src="C:\Users\MyPC\AppData\Roaming\Typora\typora-user-images\image-20221029160040935.png" alt="image-20221029160040935"></p><p>如图，整个序列可以画成这种曲线，而其中那些没有交替的段可以将其删除，即为最大摆动序列</p><p>这道题特殊情况很难处理，比如[0,0,0] [3,3,3,2,5]。主要分为两个情况：找到第一个波动段和对第一个波动段的处理。一个是只能两端对比，那么波动第一段就很难处理；另一个是前面部分都是相同值，使得第一段不是第一个波动段。</p><p>特殊情况处理方法：对于第一个波动段处理，则在前面添加一段为波动段的相反值。而要找到第一个波动段，则要去除数组起始的重复值，则先找到第一个不重复的位置，也就找到第一个波动段所在。</p><blockquote><p>代码随想录处理方法：</p><p>处理方法就是默认最右边有一个摆动点（将count&#x3D;1)，假设第一个点左边还有一个相同值得点，即第一段dif1初始值设为0，当(dif1&gt;&#x3D;0&amp;&amp;dif2&lt;0)||(dif1&lt;&#x3D;0&amp;&amp;dif2&gt;0)时，第一段（最左边的点）也就能被计算了。</p></blockquote><p>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个摆动点。</p><p>全局最优：整个序列有最多的局部峰值，从而达到最长摆动序列。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;贪心class Solution &#123;public:    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;        &#x2F;&#x2F;代码随想录        &#x2F;&#x2F; if(nums.size()&lt;&#x3D;1) return 1;        &#x2F;&#x2F; int count&#x3D;1,dif1&#x3D;0;        &#x2F;&#x2F; for(int i&#x3D;1;i&lt;nums.size();++i)&#123;        &#x2F;&#x2F;     int dif2&#x3D;nums[i]-nums[i-1];        &#x2F;&#x2F;     if((dif1&gt;&#x3D;0&amp;&amp;dif2&lt;0)||(dif1&lt;&#x3D;0&amp;&amp;dif2&gt;0))&#123;        &#x2F;&#x2F;         ++count;        &#x2F;&#x2F;         dif1&#x3D;dif2;   &#x2F;&#x2F;不能放在if外 否则类似[3,5,5,6]会出错        &#x2F;&#x2F;     &#125;                             &#x2F;&#x2F; &#125;        &#x2F;&#x2F; return count;        &#x2F;&#x2F;自己写得        if(nums.size()&lt;&#x3D;1) return nums.size();        int index&#x3D;0;        for(;index&lt;nums.size()-1&amp;&amp;nums[index]&#x3D;&#x3D;nums[index+1];++index)&#123;&#125; &#x2F;&#x2F;去除前面重复值，重复值情况影响找交替段        if(index&#x3D;&#x3D;nums.size()-1) return 1;&#x2F;&#x2F;如果index到数组末尾了，说明整个数组全部是重复得，也就只有一个波动段        int count&#x3D;1,pre&#x3D;nums[index]-nums[index+1];&#x2F;&#x2F;将pre设置与第一段相反得值，使得第一段更好处理        for(int i&#x3D;index+1;i&lt;nums.size();++i)&#123;            int cur&#x3D;nums[i]-nums[i-1];            if(cur*pre&lt;0)&#123;                ++count;                pre&#x3D;cur;            &#125;        &#125;        return count;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>分成了两个序列来计算</p><p>一个摆动序列末尾端可能是上升的或是下降的，使用up[i]表示以前 i个元素中的某一个为结尾的末尾是上升的最长上升摆动序列的长度，<em>down</em>[<em>i</em>] 表示以前 i 个元素中的某一个为结尾的末尾是下降的最长下降摆动序列的长度。</p><p>当nums[i-1]&lt;nums[i]时，对于up数组可以从down中更新，那么up[i]&#x3D;max(up[i-1],down[i-1]+1)，但对down数组则无法更新，down[i]&#x3D;down[i-1]。反之同理。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230718155312746.png" alt="image-20230718155312746"></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">wiggleMaxLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">up</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">down</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        up<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        down<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>up<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                down<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>down<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>up<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>up<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>down<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                down<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>down<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                up<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>up<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                down<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>down<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>up<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>down<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>406. 根据身高重建队列</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h1><p>First：以前做过，今天脑袋昏昏沉沉，知道了应该先排序，但后面没做出来</p><blockquote><p><strong>当有多个维度的数据时，需要先确定一个维度，再来做另一个维度，一起考虑的话会很繁琐</strong></p></blockquote><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。<strong>如果两个维度一起考虑一定会顾此失彼</strong>。</p><p>先对身高从大到小进行排序，当身高相同时，k较小的排在前面。当排序完成后，依次遍历people[i]，people[i] [1]代表people[i] 应该插入的位置（因为此时people[i]前面的数一定比它大，插入到第k个位置就代表前面有k个比它大的），不断插入得到最终结果。</p><p>（由于是从大到小排序，且从大到小插入的，无需考虑后面插入对前面造成的影响，因为后面的数一定比前面的小，即使插入到前面去了，也不会对k造成影响）</p><p>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性</p><p>全局最优：最后都做完插入操作，整个队列满足题目队列属性</p><ul><li>时间复杂度：O(n^2)  </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)&#123;        return a[0]&gt;b[0]||(a[0]&#x3D;&#x3D;b[0]&amp;&amp;a[1]&lt;b[1]);    &#125;    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;        sort(people.begin(),people.end(),compare);&#x2F;&#x2F;先确定一个维度上的顺序 先确定高度        for(int i&#x3D;0;i&lt;people.size();++i)&#123;&#x2F;&#x2F;必须从头到尾插            vector&lt;int&gt; t&#x3D;people[i];            int index&#x3D;t[1];            &#x2F;&#x2F; if(people[index]&#x3D;&#x3D;t) continue;            for(int j&#x3D;i;j&gt;index;--j)&#123;                people[j]&#x3D;people[j-1];            &#125;            people[index]&#x3D;t;        &#125;                return people;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>435. 无重叠区间</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h1><p>First：没做出来，不知道咋处理一个区间覆盖多个区间，但被覆盖的这些区间并不交叉这种特俗情况。</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>可以使用以左边界排序或右边界排序，但遍历方向不一样。</p><p>以右边界进行排序（右边界一样时左边界小的在前），从左到右进行遍历，当找到与上一个区间不交叉时num+1，找到所有不交叉的区间数num，使用总区间数减去num即为结果。</p><p>上述方法当遇见那种特俗情况时，由于是按右边界进行排序且从左到右进行遍历，其内部的区间一定排在其前面，一定会先处理其内部区间。（此题也可按左边界排序，从右到左依次选左边界最大的值）</p><p>也可使用452题，将区间边界判定改一下</p><p>局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。</p><p>全局最优：选取最多的非交叉区间。</p><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(const vector&lt;int&gt; &amp;a,const vector&lt;int&gt; &amp;b)&#123;        return a[1]&lt;b[1]||(a[1]&#x3D;&#x3D;b[1]&amp;&amp;a[0]&gt;b[0]);    &#125;    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        sort(intervals.begin(),intervals.end(),compare);        cout&lt;&lt;endl;        int ans&#x3D;1,end&#x3D;intervals[0][1];&#x2F;&#x2F;end记录当前区间右边界        for(int i&#x3D;1;i&lt;intervals.size();++i)&#123;            vector&lt;int&gt; &amp;p&#x3D;intervals[i];            if(p[0]&gt;&#x3D;end)&#123;                ++ans;                end&#x3D;p[1];            &#125;        &#125;        return intervals.size()-ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45. 跳跃游戏 II</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h1><p>First：没做出来。</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>局部最优：找到走每一步所能到的最远距离</p><p>全局最优：当第一次当前步数的最远距离覆盖末尾时，即为最小步数</p><p>走一步会有一个距离覆盖，走2步同样有一个距离覆盖，求出每一步的距离覆盖，当第一次覆盖末尾时，即为最小步数。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()&#x3D;&#x3D;1) return 0;        int count&#x3D;0,cur_dis&#x3D;0,next_dis&#x3D;nums[0];        for(int i&#x3D;0;i&lt;nums.size();)&#123;                        while(i&lt;&#x3D;cur_dis)&#123;                next_dis&#x3D;max(next_dis,i+nums[i]);                if(next_dis&gt;&#x3D;nums.size()-1) return count+1;                ++i;            &#125;            cur_dis&#x3D;next_dis;            ++count;        &#125;        return 0;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>452. 用最少数量的箭引爆气球</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h1><p>First：ac了</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>当气球出现重叠时，就使用一只箭，注意一个重叠区域必须所有气球都有重叠。使用start和end记录当前区域，如果下一个区域和当前区域有交叉，则将当前区域区间更新为交叉区域，否则用箭数量加1。</p><p>局部最优：当气球出现重叠，一起射，所用弓箭最少。</p><p>全局最优：把所有气球射爆所用弓箭最少。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(const vector&lt;int&gt; &amp;a,const vector&lt;int&gt; &amp;b)&#123;        return a[0]&lt;b[0];    &#125;    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        sort(points.begin(),points.end(),compare);        int ans&#x3D;0,start&#x3D;-1,end&#x3D;-1;        for(int i&#x3D;0;i&lt;points.size();++i)&#123;            vector&lt;int&gt; &amp;p&#x3D;points[i];            if(p[0]&lt;start||p[0]&gt;end)&#123;                ++ans;                start&#x3D;p[0];                end&#x3D;p[1];            &#125;else&#123;                start&#x3D;max(start,p[0]);&#x2F;&#x2F;更新为重叠的区间，这样就避免三个以上气球区间其实不重叠                end&#x3D;min(end,p[1]);            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53. 最大子数组和</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h1><p>First：没做出来，定义不好dp含义，用两重循环超时了</p><p>Second：才做几天，刷贪心算法系列题又遇见了，不过没用贪心做出来，对这题理解得不够透彻</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[i] 表示以nums[i-1]结尾的最大连续子数组的和，那么找到最大的dp即为结果。</p><p>要求以nums[i-1]结尾的最大和，那么对于nums[i-2]结尾的最大和dp[i-1]，如果dp[i-1]&gt;0，那么加上dp[i-1]才能使得dp[i]更大，否则就不应该加上dp[i-1]，而是从num[i-1]重新作为连续子数组的头和尾。因此，dp[i]&#x3D;max(dp[i-1]+nums[i-1],nums[i-1])。</p><p>皆初始化为0。</p><p>从小到大遍历即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n) 可优化为1</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int n&#x3D;nums.size();        vector&lt;int&gt; dp(n+1,0);        int ans&#x3D;INT_MIN;        for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;            dp[i]&#x3D;max(nums[i-1]+dp[i-1],nums[i-1]);            ans&#x3D;max(ans,dp[i]);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>贪心</strong></p><p>遍历整个数组，当遍历到任意位置k时，若现有连续子数组和为负时，nums[k]加上前面的连续子数组结果会更小，此时应该舍弃前面数组，而以nums[k]作为新子数组的起始。</p><p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p><p>全局最优：选取最大“连续和”</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int ans&#x3D;INT_MIN;        int count&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            count+&#x3D;nums[i];            ans&#x3D;max(ans,count);            if(count&lt;0) count&#x3D;0;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：<strong>分治法</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>455. 分发饼干</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h1><p>First：做久了动态规划，一下转到贪心还是不适合，遗憾，此题没做出来，总感觉有层膜没被捅破</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>先对两个数组进行从小到大排序，每个饼干都找到小于饼干值的最小孩子，然后剔除此孩子，继续遍历下一个饼干</p><p>局部最优：每个饼干分给能满足其胃口的孩子中胃口最小的那个孩子</p><p>全局最优：每个饼干都分给合适的孩子，所有饼干所分给的孩子就最多</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;        sort(g.begin(),g.end());        sort(s.begin(),s.end());        int start&#x3D;0;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;s.size();++i)&#123;              if(start&gt;&#x3D;g.size()) break;            if(s[i]&lt;g[start])&#123;                continue;            &#125;else&#123;                ++ans;                ++start;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. 合并区间</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/description/">56. 合并区间</a></h1><p>First：和763题一样合并所有区间</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>先对数组进行排序，依次遍历，如果当前区间与前一个区间有交叉则将其合并，否则则将上一个区间加入结果中。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(const vector&lt;int&gt; &amp;a,const vector&lt;int&gt; &amp;b)&#123;        return a[0]&lt;b[0];    &#125;    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        vector&lt;vector&lt;int&gt;&gt; ans;        sort(intervals.begin(),intervals.end(),compare);        int start&#x3D;intervals[0][0],end&#x3D;intervals[0][1];        for(int i&#x3D;1;i&lt;intervals.size();++i)&#123;            if(intervals[i][0]&gt;end)&#123;                ans.push_back(&#123;start,end&#125;);                start&#x3D;intervals[i][0];                end&#x3D;intervals[i][1];            &#125;else&#123;                end&#x3D;max(end,intervals[i][1]);            &#125;        &#125;        ans.push_back(&#123;start,end&#125;);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55. 跳跃游戏</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h1><p>First：没使用贪心最初来，没想到可以用最大范围覆盖来考虑，其实用动态规划来理解贪心解析会更简单。</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>局部最优：找到每个位置所能到的最远位置</p><p>全局最优：找到每个局部最优值中的最大值，以此最大值来判断是否能达到数组末尾。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int s&#x3D;0;        int max_region&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(i&gt;max_region) return false;            max_region&#x3D;max(max_region,i+nums[i]);        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>以动态规划方法来理解上面的贪心算法</p><p>以一维数组dp来记录状态，dp[i]表示通过nums前i个数组能到达的最远位置</p><p>只有当nums前i-1个数能到第i个数时，nums[i]才有用dp[i]&#x3D;max(dp[i-1],i+nums[i])，否则dp[i]&#x3D;dp[i-1];</p><p>初始化为0</p><p>由转移公式知，dp[i]由dp[i-1]决定，因此从小到大遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>738. 单调递增的数字</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738. 单调递增的数字"></a><a href="https://leetcode.cn/problems/monotone-increasing-digits/description/">738. 单调递增的数字</a></h1><p>First：昨天没做出来，尝试了从后向前遍历但无法解决100这种情况，也尝试了从前向后遍历。其实没观察到只要一个数字变了后面的数字都要变为9这个特点</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>可以观察到一个特点：一个数字变小之后，其后面的数字会都变为9，只有这样才能变到最大。但不能从前向后遍历找到第一个非单调递增的数字，比如332这种情况，因为当遇到strNum[i-1]&gt;strNum[i]时，会将strNum[i-1]-1，这样便会导致strNum[i-2]&gt;strNum[i-1]。</p><p>因此，需要从后向前遍历，当strNum[i-1]&gt;strNum[i]时，将strNum[i-1]-1，flag标记为i，遍历完成后将flag以后的数字都变为9即可。</p><p>局部最优：</p><p>全局最优：</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int monotoneIncreasingDigits(int n) &#123;        string strNum&#x3D;to_string(n);        int size&#x3D;strNum.size();        int flag&#x3D;size;        for(int i&#x3D;size-1;i&gt;0;--i)&#123;            if(strNum[i-1]&gt;strNum[i])&#123;                flag&#x3D;i;                strNum[i-1]--;            &#125;        &#125;        for(int i&#x3D;flag;i&lt;size;++i)&#123;            strNum[i]&#x3D;&#39;9&#39;;        &#125;        return stoi(strNum);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>714. 买卖股票的最佳时机含手续费</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费</a></h1><p>First：动态规划还挺还做，用贪心是没想出来，看了解析之后发现这技巧很nice</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>在做收获利润操作的时候其实有三种情况：</p><ul><li>情况一：收获利润的这一天并不是收获利润区间里的最后一天（不是真正的卖出，相当于持有股票），所以后面要继续收获利润。</li><li>情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。</li><li>情况三：不作操作，保持原有状态（买入，卖出，不买不卖）</li></ul><p>局部最优：</p><p>全局最优：</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;        &#x2F;&#x2F;贪心        int ans&#x3D;0;        int minPrice&#x3D;prices[0];        for(int i&#x3D;1;i&lt;prices.size();++i)&#123;            if(prices[i]&lt;minPrice) minPrice&#x3D;prices[i];&#x2F;&#x2F;情况二，情况三代码可以不用写出来            if(prices[i]&gt;minPrice+fee)&#123;                ans+&#x3D;prices[i]-minPrice-fee;                minPrice&#x3D;prices[i]-fee;&#x2F;&#x2F;这一步极为关键，情况一            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>分为两种状态：持有股票和不持有股票</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;        &#x2F;&#x2F;动态规划 空间还可以优化为o(1)        &#x2F;&#x2F; vector&lt;vector&lt;int&gt;&gt; dp(prices.size(),vector&lt;int&gt;(2,0));        &#x2F;&#x2F; dp[0][0]&#x3D;-prices[0];        &#x2F;&#x2F; for(int i&#x3D;1;i&lt;prices.size();++i)&#123;        &#x2F;&#x2F;     dp[i][0]&#x3D;max(dp[i-1][1]-prices[i],dp[i-1][0]);        &#x2F;&#x2F;     dp[i][1]&#x3D;max(dp[i-1][0]+prices[i]-fee,dp[i-1][1]);        &#x2F;&#x2F;     cout&lt;&lt;dp[i][0]&lt;&lt;&quot; &quot;&lt;&lt;dp[i][1]&lt;&lt;endl;        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; return max(dp[prices.size()-1][0],dp[prices.size()-1][1]);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>763. 划分字母区间</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/description/">763. 划分字母区间</a></h1><p>First：转换下成求不相交区间个数</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>先求每一个字母出现的区间，只要相交的区间合并成一个（合并后取区间最大），最后计算剩余区间个数。</p><p>局部最优：</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(const vector&lt;int&gt; &amp;a,const vector&lt;int&gt; &amp;b)&#123;        return a[0]&lt;b[0];    &#125;    vector&lt;int&gt; partitionLabels(string s) &#123;        vector&lt;vector&lt;int&gt;&gt; letter(26,vector&lt;int&gt;(2,-2));        for(int i&#x3D;0;i&lt;s.size();++i)&#123;            int index&#x3D;s[i]-&#39;a&#39;;            if(letter[index][0]&lt;0) letter[index][0]&#x3D;i;            letter[index][1]&#x3D;max(letter[index][1],i);        &#125;        sort(letter.begin(),letter.end(),compare);        vector&lt;int&gt; ans;        int count&#x3D;0, start&#x3D;-1,end&#x3D;-1;        for(int i&#x3D;0;i&lt;letter.size();++i)&#123;            if(letter[i][0]&gt;end)&#123;                ans.push_back(end-start+1);                start&#x3D;letter[i][0];                end&#x3D;letter[i][1];            &#125;else if(letter[i][0]&gt;start)&#123;                ++count;                start&#x3D;min(start,letter[i][0]);                end&#x3D;max(end,letter[i][1]);            &#125;        &#125;        ans.push_back(end-start+1);        ans.erase(ans.begin());        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>860. 柠檬水找零</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6-simple/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a><a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h1><p>First：看着复杂，但逻辑固定</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>只会存在三种收款情况：收到5元、10元和20元，收到5元不用找零，收到10元只能找5元，而收到20元就有两种情况，一个是找3张5元，一个是找1张5元和1张10元，但是应该优先找10元，因为10元能由5元凑成。</p><p>局部最优：遇到账单20，优先消耗美元10，完成本次找零。</p><p>全局最优：完成全部账单的找零</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;        int remain5&#x3D;0,remain10&#x3D;0,remain20&#x3D;1;        for(int i&#x3D;0;i&lt;bills.size();++i)&#123;            int left&#x3D;bills[i]-5;            if(left&#x3D;&#x3D;0)&#123;                remain5+&#x3D;1;            &#125;else if(left&#x3D;&#x3D;5)&#123;                if(remain5&lt;&#x3D;0) return false;                remain5-&#x3D;1;                remain10+&#x3D;1;            &#125;else&#123;                if(remain10&gt;&#x3D;1&amp;&amp;remain5&gt;&#x3D;1)&#123;&#x2F;&#x2F;优先找10元                    remain5-&#x3D;1;                    remain10-&#x3D;1;                &#125;else if(remain5&gt;&#x3D;3)&#123;                    remain5-&#x3D;3;                &#125;else&#123;                    return false;                &#125;                remain20+&#x3D;1;            &#125;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>968. 监控二叉树</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91-difficult/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a><a href="https://leetcode.cn/problems/binary-tree-cameras/description/">968. 监控二叉树</a></h1><p>First：贪心没做出来，现在连二叉树的动态规划也搞忘了</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>假设每个节点有三种状态： 0（无覆盖），1（有覆盖），2（有摄像头）</p><p>从底部向上考虑，可以使得总摄像头数量最少，因为低层节点数一定大于等于当前上层节点数，而一个摄像头可以覆盖的低层节点更多。因此，采用后序遍历。</p><p>因此对于每个节点可以从左右子节点推导出状态，可分为三种：</p><ul><li>左右子节点都已覆盖，此时当前节点状态应该为无覆盖</li><li>左右子节点至少有一个未覆盖，此时节点状态为有摄像头</li><li>左右子节点至少一个有摄像头（由于先考虑第二种情况，此类情况就无需特殊考虑存在一个节点未被覆盖），此时节点状态为有覆盖</li></ul><p>但还存在两个问题：根节点和空节点</p><ul><li>根节点：由于上述方法只判断了根节点状态，如果根节点未覆盖状态时，并没有进行处理，因此还需最后对根节点判断是否未覆盖状态</li><li>空节点：空节点应该被设置未已覆盖状态，如果设置为未覆盖则会导致叶节点设置为有摄像头</li></ul><p>局部最优：让叶子节点的父节点安摄像头，所用摄像头最少</p><p>全局最优：全部摄像头数量所用最少！</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    int ans;public:    &#x2F;&#x2F;0:无覆盖  1：有覆盖  2：有摄像头    int postOrder(TreeNode* root)&#123;        if(root&#x3D;&#x3D;nullptr) return 1;        int left&#x3D;postOrder(root-&gt;left);        int right&#x3D;postOrder(root-&gt;right);        if(left&#x3D;&#x3D;1&amp;&amp;right&#x3D;&#x3D;1) return 0;        else if(left&#x3D;&#x3D;0||right&#x3D;&#x3D;0) &#123;            ++ans;            return 2;        &#125;else if(left&#x3D;&#x3D;2||right&#x3D;&#x3D;2)&#123;            return 1;        &#125;        return 0;    &#125;    int minCameraCover(TreeNode* root) &#123;        int t&#x3D;postOrder(root);        if(t&#x3D;&#x3D;0) ++ans;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>同样是由底向上遍历，即后序遍历。每个几点可分为三种状态：</p><ul><li>（1）当前节点安装相机时，已当前节点为根的树都被覆盖所需相机数</li><li>（2）当前节点不安装相机但被覆盖时，已当前节点为根的树都被覆盖所需相机数</li><li>（3）当前节点不安装相机不被覆盖时，已当前节点为根的树都被覆盖所需相机数</li></ul><p>状态更新：</p><ul><li><p>dp[0]找左右最小值相加后再+1即可。dp[0]&#x3D;min(left[0],min(left[1],left[2]))+min(right[0],min(right[1],right[2]))+1;</p></li><li><p>dp[1]必须左右节点其中至少一个安装相机dp[1]&#x3D;min(left[0]+min(right[0],right[1]),right[0]+min(left[0],left[1]));</p></li><li><p>dp[2]必须左右节点都是被覆盖但未安装相机</p><p>dp[2]&#x3D;left[1]+right[1];</p></li></ul><p><strong>空节点初始化值还存在问题，还没AC</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    int ans;public:    &#x2F;&#x2F;动态规划    &#x2F;&#x2F;每个节点分为三种状态：    &#x2F;&#x2F;（1）当前节点安装相机时，已当前节点为根的树都被覆盖所需相机数    &#x2F;&#x2F;（2）当前节点不安装相机但被覆盖时，已当前节点为根的树都被覆盖所需相机数    &#x2F;&#x2F;（3）当前节点不安装相机不被覆盖时，已当前节点为根的树都被覆盖所需相机数    vector&lt;int&gt; postOrder(TreeNode* root)&#123;        if(root&#x3D;&#x3D;nullptr) return&#123;0,0,INT_MAX&#x2F;2&#125;;&#x2F;&#x2F;初始化还存在问题，现在还没ac        vector&lt;int&gt; left &#x3D; postOrder(root-&gt;left);        vector&lt;int&gt; right &#x3D;postOrder(root-&gt;right);        vector&lt;int&gt; dp(3,0);        dp[0]&#x3D;min(left[0],min(left[1],left[2]))+min(right[0],min(right[1],right[2]))+1;        dp[1]&#x3D;min(left[0]+min(right[0],right[1]),right[0]+min(left[0],left[1]));        dp[2]&#x3D;left[1]+right[1];        cout&lt;&lt;dp[0]&lt;&lt;&quot; &quot;&lt;&lt;dp[1]&lt;&lt;&quot; &quot;&lt;&lt;dp[2]&lt;&lt;endl;        return dp;    &#125;    int minCameraCover(TreeNode* root) &#123;        vector&lt;int&gt; ans&#x3D;postOrder(root);        return max(ans[0],ans[1]);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>142. 环形链表 II</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-142-middle/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-142-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><p>First：以前做过，但这次卡住了，以为要算出距离来，但求了半天都算不出，还是理解不到位啊</p><hr><p><strong>方法1</strong>：<strong>双指针</strong></p><p>先使用快慢指针判断是否有环，即快指针每次走两步，慢指针每次走一步</p><p>当有环，即快慢指针相遇时，假设头节点到环起始处距离为a，环起始处到相遇节点距离为b，环长度为c</p><p>那么，快指针移动距离为：f&#x3D;a+b+nc</p><p>慢指针移动距离为：s&#x3D;a+b（一定会在第一次遍历环的时候遇见）</p><p>又知 f&#x3D;2s</p><p>可推出：a&#x3D;nc-b</p><p>由上可知，环起始处到相遇节点距离为b，那么如果从相遇节点再移动nc-b个位置，且同时从链表头节点开始也移动a个位置，那么再次相遇处即使环起始节点了。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        if(head&#x3D;&#x3D;nullptr||head-&gt;next&#x3D;&#x3D;nullptr) return nullptr;&#x2F;&#x2F;其他答案没这样处理开始时两个指针都在相同位置的情况，要更简便        ListNode *fast&#x3D;head-&gt;next-&gt;next,*slow&#x3D;head-&gt;next;        while(fast!&#x3D;nullptr&amp;&amp;fast-&gt;next!&#x3D;nullptr&amp;&amp;fast!&#x3D;slow)&#123;            fast&#x3D;fast-&gt;next-&gt;next;            slow&#x3D;slow-&gt;next;        &#125;        if(fast&#x3D;&#x3D;nullptr||fast-&gt;next&#x3D;&#x3D;nullptr) return nullptr;        fast&#x3D;head;        while(fast!&#x3D;slow)&#123;            fast&#x3D;fast-&gt;next;            slow&#x3D;slow-&gt;next;        &#125;        return fast;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>哈希表</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160. 相交链表</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-160-simple/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-160-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h1><p>First：先想到的是使用长度差来计算，但看了解析后一种很简约的思想，写起来代码也很简单，虽然两者效率是差不多的。</p><hr><p><strong>方法1</strong>：<strong>双指针+距离差</strong></p><p>分别遍历链表AB的长度，求出链表长度差n，然后使长的指针先走n个节点，然后同时向后移动节点找出公共节点即可。</p><ul><li>时间复杂度：O(a+b)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        if(headA&#x3D;&#x3D;nullptr||headB&#x3D;&#x3D;nullptr) return nullptr;        ListNode *pa&#x3D;headA,*pb&#x3D;headB;        int la&#x3D;0,lb&#x3D;0;        while(pa!&#x3D;nullptr)&#123;            ++la;            pa&#x3D;pa-&gt;next;        &#125;        while(pb!&#x3D;nullptr)&#123;            ++lb;            pb&#x3D;pb-&gt;next;        &#125;        if(la&gt;&#x3D;lb)&#123;            pa&#x3D;headB;            pb&#x3D;headA;        &#125;else&#123;            pa&#x3D;headA;            pb&#x3D;headB;        &#125;        int dis&#x3D;abs(la-lb);        while(dis&gt;0)&#123;            pb&#x3D;pb-&gt;next;            --dis;        &#125;        while(pa!&#x3D;pb)&#123;            pa&#x3D;pa-&gt;next;            pb&#x3D;pb-&gt;next;        &#125;        return pa;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>双指针</strong></p><p>假设表头A到公共节点距离为a，表头B到公共节点距离为b，公共节点到链表尾部距离为c</p><p>那么。如果让表头A走到表尾，再从链表B开始走，走到公共节点的总距离为a+b+c</p><p>同理，表头B走到表尾，再从链表A开始走，走到公共节点的总距离也同样是a+b+c</p><p>因此，按如上走法，相遇点则是公共节点（即使没有公共节点也会在nullptr相遇）</p><ul><li>时间复杂度：O(a+b)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode *A&#x3D;headA,*B&#x3D;headB;        while(A!&#x3D;B)&#123;            A&#x3D;A!&#x3D;nullptr?A-&gt;next:headB;            B&#x3D;B!&#x3D;nullptr?B-&gt;next:headA;        &#125;        return A;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19. 删除链表的倒数第 N 个结点</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-19-middle/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-19-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h1><p>First：看错题了，以为是顺数第n个节点。找两个指针间隔n个结点移动到末尾即可。</p><hr><p><strong>方法1</strong>：<strong>双指针</strong></p><p>使用一个表头节点来避免头节点的单独处理。使用两个指针p、q，p先移动n个节点，此时p和q指针再一起移动，直到p指针移动到末尾位置，q指针指向的下一个节点即为需要删除的节点。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        if(head&#x3D;&#x3D;nullptr||head-&gt;next&#x3D;&#x3D;nullptr) return head;&#x2F;&#x2F;加不加这个判断都可通过        ListNode *H&#x3D;new ListNode(0,head);        ListNode *p&#x3D;H,*q&#x3D;nullptr,*v&#x3D;nullptr;        while(p-&gt;next!&#x3D;nullptr&amp;&amp;p-&gt;next-&gt;next!&#x3D;nullptr)&#123;            v&#x3D;p;            p&#x3D;p-&gt;next;            q&#x3D;p-&gt;next;            ListNode *t&#x3D;q-&gt;next;            p-&gt;next&#x3D;q-&gt;next;            q-&gt;next&#x3D;p;            v-&gt;next&#x3D;q;        &#125;        return H-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>计算链表长度</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><hr><p><strong>方法3</strong>：<strong>栈</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203. 移除链表元素</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-203-simple/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-203-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h1><p>First：就很简单的移除元素即可，不过注意下需要移除的元素和不需要移除的处理细节上会有差别</p><hr><p><strong>方法1</strong>：<strong>迭代</strong></p><p>依次遍历每个元素判断是否需要移除即可，可以使用一个链表头来避免处理空表情况。需注意当遇见需要移除的元素时，移除后指针别跳到下一个元素，还是应该处理当前元素。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        if(head&#x3D;&#x3D;nullptr) return head;        ListNode *t&#x3D;new ListNode(0,head);        ListNode *h&#x3D;t,*p&#x3D;t-&gt;next;        while(h-&gt;next!&#x3D;nullptr)&#123;            p&#x3D;p-&gt;next;            if(h-&gt;next-&gt;val&#x3D;&#x3D;val)&#123;                              delete h-&gt;next;                h-&gt;next&#x3D;p;            &#125;else&#123;                h&#x3D;h-&gt;next;            &#125;        &#125;        return t-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>迭代</strong></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. 反转链表</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-206-simple/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-206-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h1><p>First：设置三个指针指向前中后三个位置</p><hr><p><strong>方法1</strong>：<strong>原地反转</strong></p><p>设置三个指针p、q、last指向三个连续位置，每次将q-&gt;next指向p，再将三个指针依次向后移一个位置即可，注意此链表也是有头节点的。除此外还需排除head为空和只有一个节点情况存在。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if(head&#x3D;&#x3D;nullptr||head-&gt;next&#x3D;&#x3D;nullptr) return head;        ListNode *p&#x3D;head,*q&#x3D;head-&gt;next,*last&#x3D;q;        head-&gt;next&#x3D;nullptr;        while(q!&#x3D;nullptr)&#123;            last&#x3D;q-&gt;next;            q-&gt;next&#x3D;p;            p&#x3D;q;            q&#x3D;last;        &#125;        return p;    &#125;&#125;;&#x2F;&#x2F;官方代码有点技巧，参考下class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* prev &#x3D; nullptr;        ListNode* curr &#x3D; head;        while (curr) &#123;            ListNode* next &#x3D; curr-&gt;next;            curr-&gt;next &#x3D; prev;            prev &#x3D; curr;            curr &#x3D; next;        &#125;        return prev;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>递归</strong></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24. 两两交换链表中的节点</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-24-middle/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-24-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h1><p>First：依次遍历交换节点</p><hr><p><strong>方法1</strong>：<strong>非递归</strong></p><p>使用一个表头节点来避免头节点的单独处理，使用三个指针分别指向需要交换的两个节点和这两个节点之前那个节点即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        if(head&#x3D;&#x3D;nullptr||head-&gt;next&#x3D;&#x3D;nullptr) return head;&#x2F;&#x2F;加不加这个判断都可通过        ListNode *H&#x3D;new ListNode(0,head);        ListNode *p&#x3D;H,*q&#x3D;nullptr,*v&#x3D;nullptr;        while(p-&gt;next!&#x3D;nullptr&amp;&amp;p-&gt;next-&gt;next!&#x3D;nullptr)&#123;            v&#x3D;p;            p&#x3D;p-&gt;next;            q&#x3D;p-&gt;next;            ListNode *t&#x3D;q-&gt;next;            p-&gt;next&#x3D;q-&gt;next;            q-&gt;next&#x3D;p;            v-&gt;next&#x3D;q;        &#125;        return H-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>非递归</strong></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>707. 设计链表</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-707-middle/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-707-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></h1><p>First：常规编写链表即可</p><hr><p><strong>方法1</strong>：<strong>单链表</strong></p><p>就普通的设计链表，注意下题目里是有一个空节点作为链表头。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyLinkedList &#123;    int val;    class MyLinkedList *next;public:    MyLinkedList():val(0),next(nullptr) &#123;    &#125;    MyLinkedList(int val):val(val),next(nullptr) &#123;    &#125;    int get(int index) &#123;        if(index&lt;0) return -1;        MyLinkedList *h&#x3D;this;        while(index&gt;&#x3D;0)&#123;            h&#x3D;h-&gt;next;            index--;            if(h&#x3D;&#x3D;nullptr) return -1;        &#125;        return h-&gt;val;    &#125;        void addAtHead(int val) &#123;        MyLinkedList *t&#x3D;new MyLinkedList(val);        t-&gt;next&#x3D;this-&gt;next;        this-&gt;next&#x3D;t;    &#125;        void addAtTail(int val) &#123;        MyLinkedList *t&#x3D;new MyLinkedList(val);        MyLinkedList *h&#x3D;this;        while(h-&gt;next!&#x3D;nullptr)&#123;            h&#x3D;h-&gt;next;        &#125;        h-&gt;next&#x3D;t;    &#125;        void addAtIndex(int index, int val) &#123;        if(index&lt;&#x3D;0)&#123;            addAtHead(val);            return;        &#125;        MyLinkedList *pos&#x3D;this;        while(index&gt;0&amp;&amp;pos!&#x3D;nullptr)&#123;            pos&#x3D;pos-&gt;next;            index--;        &#125;        if(pos&#x3D;&#x3D;nullptr) return;        MyLinkedList *t&#x3D;new MyLinkedList(val);        t-&gt;next&#x3D;pos-&gt;next;        pos-&gt;next&#x3D;t;    &#125;        void deleteAtIndex(int index) &#123;        if(index&lt;0) return;        MyLinkedList *p&#x3D;this,*q&#x3D;p-&gt;next;        while(index&gt;0&amp;&amp;q!&#x3D;nullptr)&#123;            p&#x3D;p-&gt;next;            q&#x3D;q-&gt;next;            index--;        &#125;        if(q&#x3D;&#x3D;nullptr) return;        p-&gt;next&#x3D;q-&gt;next;        delete q;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>双链表</strong></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. 接雨水</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-diffcult/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-diffcult/</url>
      
        <content type="html"><![CDATA[<h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h1><p>First：以前做过，还是没做出来，不知道为啥想到的是只找左右两边第一个大于的值，受了单调栈影响（这种方法其实能做出来，但没解决重复算得那部分）。。。但又没用单调栈做出来。</p><p>Second：想用找左右第一个大于的柱高度，但会多很多重复计算。最后还是使用的单调栈和按列求做出来。</p><hr><p><strong>方法1</strong>：<strong>按列求</strong></p><p>对于每一列，其能接到的最大雨水值为左边最大高度和右边最大高度中最小值减去当前高度，将所有列能接到的雨水加起来即可。</p><p>先遍历得到每个值得左边最大值，然后遍历每个值得右边最大高度时，求能接到得雨水。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int ans&#x3D;0;        vector&lt;int&gt; lmax(height.size(),-1),rmax(height.size(),-1);        int maxHeight&#x3D;height[height.size()-1];        for(int i&#x3D;height.size()-2;i&gt;&#x3D;0;--i)&#123;            rmax[i]&#x3D;maxHeight;            maxHeight&#x3D;max(maxHeight,height[i]);        &#125;        maxHeight&#x3D;height[0];        for(int i&#x3D;1;i&lt;height.size();++i)&#123;            int dif&#x3D;min(maxHeight,rmax[i])-height[i];                ans+&#x3D;dif&gt;0?dif:0;            maxHeight&#x3D;max(maxHeight,height[i]);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>单调栈</strong></p><p>单调栈其原理是使用按行求。使用单调栈方法来做，对于每个值与栈顶元素进行比较，如果大于栈顶元素，而单调栈又是递减的，因此此处也就存在一个凹槽，以当前值和栈顶第二个元素为界，求出宽度和高度。不断重复直到当前值小于栈顶元素。</p><p>这里需要注意的是当前值和栈顶元素相同时改怎么处理，不进行判断而使用单调栈方法来做的话，由于栈顶和当前值相等，两者相减求得的高度就变为0了。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> mst<span class="token punctuation">;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>mst<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>height<span class="token punctuation">[</span>mst<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> cur<span class="token operator">=</span>mst<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                mst<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>mst<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                ans<span class="token operator">+=</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>mst<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span>mst<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            mst<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：<strong>双指针</strong></p><p>是在按列求方法上运用了一些技巧</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>456. 132 模式</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-456-132%E6%A8%A1%E5%BC%8F-middle/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-456-132%E6%A8%A1%E5%BC%8F-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="456-132-模式"><a href="#456-132-模式" class="headerlink" title="456. 132 模式"></a><a href="https://leetcode.cn/problems/132-pattern/description/">456. 132 模式</a></h1><blockquote><p>什么时候用单调栈呢？</p><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p><p><strong>同理，如果要找一个大于（或小于）且最接近的数，也使用单调栈</strong></p></blockquote><p>First：22-11-15，这题使用单调栈来做是真的nice</p><hr><p><strong>方法1</strong>：<strong>单调栈</strong></p><p>参考<a href="https://leetcode.cn/problems/132-pattern/solutions/676970/xiang-xin-ke-xue-xi-lie-xiang-jie-wei-he-95gt/">解析</a></p><p>枚举i最简单，因为j&lt;k但nums[k]&lt;nums[j]，使得顺序乱了导致需要找中间值，逻辑会麻烦很多。</p><p>而枚举i时，只需要在i之后找到一段递减阶段jk，此时如果nums[i]&lt;nums[k]就满足132要求。因此对于每个nums[j]，需要找到一个比其小且最接近的数，此时既构成了递减序列且nums[k]和nums[j]也最接近，也就需要使用单调栈来找数。</p><p>从后向前遍历，维持一个递减的单调栈，当遍历到nums[i]时，如果nums[i]&lt;k，则返回true，否则将nums[i]与栈顶元素不断比较维持一个递减单调栈，且k设为最先弹出元素值。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;        vector&lt;int&gt; ans(temperatures.size(),0);        stack&lt;int&gt; s;        s.push(0);        for(int i&#x3D;1;i&lt;temperatures.size();++i)&#123;            while(!s.empty()&amp;&amp;temperatures[s.top()]&lt;temperatures[i])&#123;                ans[s.top()]&#x3D;i-s.top();                s.pop();            &#125;           s.push(i);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>496. 下一个更大元素 I</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I-simple/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h1><blockquote><p>什么时候用单调栈呢？</p><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p></blockquote><p>First：相比793，这题明显要复杂点，但难度还比那低。。</p><hr><p><strong>方法1</strong>：<strong>哈希表+单调栈</strong></p><p>使用哈希表来存储nums1中的所有数字，以便查找。遍历nums2中的每个值，对于nums[i]找到第一个大于其值的元素（使用单调栈），再使用哈希表查询其中是否存在nums[i]。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;int&gt; ans(nums1.size(),-1);        unordered_map&lt;int,int&gt; map;        stack&lt;int&gt; s;        for(int i&#x3D;0;i&lt;nums1.size();++i) map[nums1[i]]&#x3D;i;        s.push(0);        for(int j&#x3D;1;j&lt;nums2.size();++j)&#123;            while(!s.empty()&amp;&amp;nums2[s.top()]&lt;nums2[j])&#123;                if(map.find(nums2[s.top()])!&#x3D;map.end())&#123;                    ans[map[nums2[s.top()]]]&#x3D;nums2[j];                &#125;                s.pop();            &#125;            s.push(j);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>503. 下一个更大元素 II</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-503%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II-middle/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-503%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h1><blockquote><p>什么时候用单调栈呢？</p><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p></blockquote><p>First：循环数组，也就是要找其前面的数，多便利一次即可。</p><hr><p><strong>方法1</strong>：<strong>单调栈</strong></p><p>由于是循环数组，要找到其右边更大的数，那么也就需要在左边的数中去寻找，最简单的方法就是将nums复制一遍，使用单调栈遍历即可，可使用一点技巧不用拼接复制nums。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; ans(nums.size(),-1);        stack&lt;int&gt; s;        s.push(0);        for(int i&#x3D;0;i&lt;2*nums.size();++i)&#123;            int pos&#x3D;i%nums.size();            while(!s.empty()&amp;&amp;nums[s.top()]&lt;nums[pos])&#123;                ans[s.top()]&#x3D;nums[pos];                s.pop();            &#125;            s.push(pos);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>739. 每日温度</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-middle/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h1><blockquote><p>什么时候用单调栈呢？</p><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p></blockquote><p>First：22-10-14，</p><hr><p><strong>方法1</strong>：<strong>单调栈</strong></p><p>使用栈来记录暂时还没有在右边找到大于其值的元素位置，依次遍历数组，对于每一个数temperatures[j]，都将其与栈顶元素temperatures[k]进行比较，如果大于栈顶元素，ans[k]&#x3D;j，不断重复直到栈顶元素小于temperatures[j]。自然，栈里面存的元素也就是依次较小的（栈底到栈顶减小），也叫做单调栈。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;        vector&lt;int&gt; ans(temperatures.size(),0);        stack&lt;int&gt; s;        s.push(0);        for(int i&#x3D;1;i&lt;temperatures.size();++i)&#123;            while(!s.empty()&amp;&amp;temperatures[s.top()]&lt;temperatures[i])&#123;                ans[s.top()]&#x3D;i-s.top();                s.pop();            &#125;           s.push(i);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>84. 柱状图中最大的矩形</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-diffcult/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-diffcult/</url>
      
        <content type="html"><![CDATA[<h1 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h1><p>First：没发现是要找左右两边第一个小于的柱子</p><hr><p><strong>方法1</strong>：<strong>单调栈</strong></p><p>可以通过遍历每一个柱子，以当前柱子为基础向左右两边扩散，其左右两边的柱子高度不能小于当前柱子高度，这样就保证了矩形面积由于扩散肯定是增大的。会存在一种情况就是虽然左右两边柱子虽然小于当前柱子，但将其纳入勾勒出来的矩形比不纳入大，然而这种情况可以由较小柱子左右扩散得到。</p><p>而要找左右两边第一个小的柱子，就可以使用单调栈来进行查找。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;        int ans&#x3D;heights[0];        stack&lt;int&gt; lmaxs,rmaxs;        vector&lt;int&gt; lnum(heights.size(),-1),rnum(heights.size(),heights.size());        lmaxs.push(heights.size()-1);        for(int i&#x3D;heights.size()-2;i&gt;&#x3D;0;--i)&#123;            while(!lmaxs.empty()&amp;&amp;heights[lmaxs.top()]&gt;heights[i])&#123;                lnum[lmaxs.top()]&#x3D;i;                lmaxs.pop();            &#125;            lmaxs.push(i);        &#125;        rmaxs.push(0);        for(int i&#x3D;1;i&lt;heights.size();++i)&#123;            while(!rmaxs.empty()&amp;&amp;heights[rmaxs.top()]&gt;heights[i])&#123;                rnum[rmaxs.top()]&#x3D;i;                                rmaxs.pop();            &#125;            rmaxs.push(i);        &#125;        for(int i&#x3D;0;i&lt;heights.size();++i)&#123;            ans&#x3D;max(ans,(rnum[i]-lnum[i]-1)*heights[i]);        &#125;                return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>单调栈+常数优化</strong></p><p>从方法1知是要找左右两边第一个小的值，而如果单调栈是递增的，那么栈顶元素的下一个元素就自然小于栈顶，那么左边界也就找到了，而右边界可以从单调栈的遍历中得到，因此也就只需要一次单调栈遍历。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;        int ans&#x3D;heights[0];        stack&lt;int&gt; s;        heights.insert(heights.begin(),0);        heights.push_back(0);&#x2F;&#x2F;在头尾分别插入0使得对任意柱子都会存在左右边界（高为0的柱子不需要考虑）        s.push(0);        for(int i&#x3D;1;i&lt;heights.size();++i)&#123;            while(!s.empty()&amp;&amp;heights[s.top()]&gt;heights[i])&#123;                int index&#x3D;s.top();                s.pop();                ans&#x3D;max(ans,(i-s.top()-1)*heights[index]);            &#125;            s.push(i);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：<strong>双指针</strong></p><p>是在按列求方法上运用了一些技巧</p><ul><li>时间复杂度：O(n^2^)</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
