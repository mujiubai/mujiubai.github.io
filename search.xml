<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深度探索C++对象模型</title>
      <link href="/2023/07/11/c++/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/07/11/c++/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>深度探索C++对象模型，阅读笔记</p><hr><hr><h1 id="第1章-关于对象"><a href="#第1章-关于对象" class="headerlink" title="第1章 关于对象"></a>第1章 关于对象</h1><p>每一个non-inline member func tion 只会诞生一个函数实例。至于每一个“拥有零个或一个定义”的inline function则会在其每一个使用者（模块）身上产生一个函数实例</p><p>C++在布局以及存取时间上主要的额外负担是由virtual引起的，包括：</p><ul><li>virtual function 机制 用以支持一个有效率的“执行期绑定”（runtime binding）。</li><li>virtual base class 用以实现“多次出现在继承体系中的 base class，有一个单一而被共享的实例”。</li></ul><h2 id="1-1-C-对象模式"><a href="#1-1-C-对象模式" class="headerlink" title="1.1 C++对象模式"></a>1.1 C++对象模式</h2><p>在C++中，有两种class data members：static和nonstatic，以及三种class member functions：static、nonstatic和virtual。</p><p><strong>C++对象模型</strong></p><ul><li>Nonstatic data members被配置于每一个class object之内，static data members则被存放在个别的class object之外。</li><li>Static和nonstatic function members也被放在个别的class object之外。</li><li>Virtual functions则以两个步骤支持之：<ol><li>每一个 class产生出一堆指向 virtual functions 的指针，放在virtual table（vtbl）之中</li><li>每一个 class object 被添加了一个指针 vptr，指向相对应的 vtable。vptr 的设置由编译器 全权负责，程序员无需关心。。每一个 class所关联的 type_info object（用以支持 runtime type identification，RTTI）也经由 virtual table被指出来，通常放在表格的第一个 slot</li></ol></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230716151546131.png" alt="" style="zoom:67%;" /><p><strong>引入继承后的对象模型成本</strong>： </p><ul><li>如果是普通的继承，父对象被直接包含在子对象里面，这样对父对象的存取也是直接进行的， 没有额外的成本； </li><li>如果是虚拟继承，则父对象会由一个指针被指出来，这样的话对父对象的存取就添加了一层 间接性，必须经由一个指针来访问，添加了一次间接的额外成本。</li></ul><h2 id="1-2-关键词所带来的差异"><a href="#1-2-关键词所带来的差异" class="headerlink" title="1.2 关键词所带来的差异"></a>1.2 关键词所带来的差异</h2><p><strong>C++优先判断一个语句为声明</strong>：当语言无法区分一个语句是声明还是表达式时，就需用用一个 超越语言范围的规则 —— C++优先判断为声明。</p><p><strong>struct 和 class 关键字的意义</strong>： </p><ul><li>它们之间在语言层面并无本质的区别，更多的是概念和编程思想上的区别。</li><li>struct 用来表现那些只有数据的集合体 POD（Plain OI’ Data）、而 class 则希望表达的 是 ADT（abstract data type）的思想；</li><li>由于这 2 个关键字在本质是无区别，所以 class 并没有必须要引入，但是引入它的确非常令 人满意，因为这个语言所引入的不止是这个关键字，还有它所支持的封装和继承的哲学；</li></ul><p><strong>C++只保证处于同一个 access section 的数据，一定会以声明的次序出现在内存布局当中</strong></p><p><strong>组合（composition），而非继承，才是把 C 和C++结合在一起的唯一可行方法</strong></p><ul><li>只有使用组合时，才能够保证与 C 拥有相同的内存布局，使用继承时的内存布局是不受 C++ Standard 所保证的（很多编译器也可行，但是标准未定义！）。</li></ul><h2 id="1-3-对象的差异"><a href="#1-3-对象的差异" class="headerlink" title="1.3 对象的差异"></a>1.3 对象的差异</h2><p><strong>C++支持三种形式的编译风格</strong>（或称典范 paradigm）： </p><ul><li>面向过程的风格：就像 C 一样，一条语句接一条语句的执行或者函数跳转； </li><li>基于对象的风格（object-based）（或称 ADT）： 仅仅使用了 class 的封装，很多人都是 在用基于对象的风格却误以为自己在使用面向对象的风格； </li><li>面向对象的风格（object-oriented）： 使用了 class 的封装和多态的编程思维（多态才是 真正的面向对象的特征）。 </li><li>纯粹以一种 paradigm 写程序，有助于整体行为的良好稳固。</li></ul><blockquote><p>只有通过pointer或reference来调用函数，才会表现出多态。直接使用object则会在编译器就决定使用当前对象的函数进行调用。</p></blockquote><p>还有一种能引起多态的写法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">(</span><span class="token operator">*</span>point<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">vf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//当 point 指向派生类时也能引发多态，已实验验证。等价于 point->vf();</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>一个 reference 通常是以一个指针来实现的，所以 point 和 reference 并没有本质的区别。</strong></p><p><strong>一个对象的内存布局大小</strong>（通常由 3 部分组成）： </p><ul><li>其 nonstatic data member 的总和大小； </li><li>任何由于位对齐所需要的填补上去的空间； </li><li>加上了为了支持 virtual 机制而引起的额外负担。</li></ul><p><strong>指针的类型</strong>： </p><ul><li>对于内存来说，不同类型的指针并没有什么不同。它们都内是占用一个 word 的大小，包含 一个数字，这个数字代表内存中的一个地址； </li><li>感觉上，指针的类型是编译器的概念，对于硬件来说，并没有什么指针类型的概念； </li><li>转型操作也只是一种编译器的指令，它改变的内是编译器对被指内存的解释方式而已！</li></ul><p><strong>多态只能由指针或引用 来实现，根本原因在于</strong>： </p><ul><li>指针和引用（通常以指针来实现）的大小是固定的（一个 word），而对象的大小却是可变 的。其类的指针和引用可以指向（或引用）子类，但是基类的对象永远也只能是基类，没有变化则不可能引发多态。 </li><li>一个 point 或 reference 绝不会引发任何” “ 与类型有关的内存委托操作 ，在指针类型转换时 会受到的改变的只有它们所指向内存的解释方式而已。（例如指针绝不会引发 slice，因为它 们大小相同）</li></ul><blockquote><p>一个object-based（OB）设计可能比一个对等的OO设计速度更快而且空间更紧凑。速度快是因为所有的函数调用操作都在编译时期解析完成，对象建构起来时不需要设置 virtual机制；空间紧凑则是因为每一个class object 不需要负担传统上为了支持virtual机制而需要的额外负荷。不过，OB设计比较没有弹性。</p></blockquote><h1 id="第2章-构造函数语意学"><a href="#第2章-构造函数语意学" class="headerlink" title="第2章 构造函数语意学"></a>第2章 构造函数语意学</h1><blockquote><p>trivial：没有用的                nontrivial：有用的                      </p><p>memberwise：对每一个member施以……               bitwise：对每一个bit施以……</p></blockquote><h2 id="2-1-Default-Constructor的构造操作"><a href="#2-1-Default-Constructor的构造操作" class="headerlink" title="2.1 Default Constructor的构造操作"></a>2.1 Default Constructor的构造操作</h2><p>C++中对于默认构造函数的解释是：<strong>默认的构造函数会在需要的时候被编译器产生出来</strong>。 </p><ul><li>谁需要？是程序的需要还是编译器的需要？如果是程序的需要，那是程 序员的责任；</li><li>只有在是编译器的需要时，默认构造函数才会被编译器产生出来，而且被产生出来 的默认构造函数只会执行编译器所需要的行动，而且这个产生操作只有在默认构造函数真正被调 用时才会进行合成。</li></ul><p><strong>区分 trivial 和 notrivial构造函数</strong>： </p><ul><li>只有编译器需要的时候（为什么会需要？后面讲的很清楚），合成操作才是 notrivial 的， 这样的函数才会被真正的合成出来； </li><li>如果编译器不需要，而程序员又没有提供，这时的默认构造函数就是 trivial 的。虽然它在概 念上存在，但是编译器实际上根本不会去合成出来，因为他不做任何有意义的事情，所以当 然可以忽略它不去合成。trivial 的函数只存在于概念上，实际上不存在这个函数。</li></ul><p><strong>变量的初始化：只有全局变量和静态变量才会保证初始化</strong>，其中静态变量可以视为全局变量 的一种，因它静态变量也是保存在全局变量的存储空间上的。</p><ul><li>Golbal objects 的内存保证会在程序激活的时候被清 0；Local objects 配置于程序的堆栈中， Heap objects 配置于自由空间中，都不一定会被清为 0,它们的内容将是内存上次被使用后的痕 迹！</li></ul><p>类声明头文件可以被许多源文件所包含，如何避免合成默认构造函数、拷贝构造函数、析构函数、 赋值拷贝操作符（4 大成员函数）时不引起函数的重定义？</p><ul><li>解决方法是以 inline 的方式完成，如果函数太复杂不适合 inline，就会合成一个 explicit noninline static 实体（Static 函数独立于编译单元）。</li></ul><p>如果 class A 内含一个或以上的 member objects，那么 A 的 constructor 必须调用每一个 member class 的默认构造函数。 具体方法是： </p><ul><li>编译器会扩张 constructors ，在其中安插代码使得在 user code 被调用之前先调 用 member objects 的默认构造函数（当然如果需要调用基类的默认构造函数，则放在基类的 默认构造函数调用之后：基类构造函数 -&gt; 成员构造函数 -&gt;user code）</li><li>C++要求以“member objects 在 class 中的声明次序”来调用各个 construtors。这就是声明 的次序决定了初始化次序（构造函数初始化列表一直要求以声明顺序来初始化）的根本原因！</li></ul><p><strong>virtual相关class</strong></p><ul><li>带有 virtual functions 的类的默认构造函数毫无疑问是 notrivial 的，需要编译器安插额外的 成员 vptr 并在构造函数中正确的设置好 vptr，这是编译器的重要职责之一。 </li><li>带有 virtual base class 的类的默认构造函数同样也毫无疑问的 notrivial，编译器需要正确设 置相关的信息以使得这些虚基类的信息能够在执行时准备妥当，这些设置取决于编译实现虚基类 的手法。</li></ul><p><strong>编译器有 4 种情况会使得编译器真正的为 class 生成 nontrivial 的默认构造函数</strong>，这个 nontrivial 的默认构造函数只满足编译器的需要（调用 member objects 或 base class 的默 认构造函数、初始化 virtual function 或 virutal base class 机制）。其它情况时，类在概念 上拥有默认构造函数，但是实际上根本不会被产生出来（即前面的区分 trivial 和 notrivial）。</p><p><strong>C++新手常见的 2 个误区</strong>： </p><ol><li>ERROR: 如果 class 没有定义 default constructor 就会被合成一个； <ul><li>首先定义了其它的 constructor 就不会合成默认构造函数，再次即使没有定义任何构造函数 也不一定会合成 default constructor，可能仅仅是概念上有，但实际上不合成出来。</li></ul></li><li>ERROR: 编译器合成出来的默认构造函数会明确设定每一个 data member 的默认值； <ul><li>明显不会，区分了 Global objects, Stack objects, Heap objects 就非常明白了只有在 Global 上的 objects 会被清 0，其它的情况都不会保证被清 0。</li></ul></li></ol><blockquote><p>在合成的 default constructor 中，只有 base class subobjects 和 member clas s objects会被初始化。所有其他的nonstatic data member（如整数、整数指针、整数数组等等）都不会被初始化。</p></blockquote><h2 id="2-2-Copy-Constructor的构造操作"><a href="#2-2-Copy-Constructor的构造操作" class="headerlink" title="2.2 Copy Constructor的构造操作"></a>2.2 Copy Constructor的构造操作</h2><p>有三种情况，会以一个object的内容作为另一个class object的初值：</p><ul><li>对一个object做显式的初始化操作，即直接&#x3D;赋值</li><li>object被当做参数交给某个函数时</li><li>当函数传回一个class object时</li></ul><h3 id="Default-Memberwise-Initialization"><a href="#Default-Memberwise-Initialization" class="headerlink" title="Default Memberwise Initialization"></a><strong>Default Memberwise Initialization</strong></h3><ul><li><p>当class object 以“相同 class 的另一个 object”作为初值，其内部是以所谓的 default memberwise initialization手法完成的：</p></li><li><p>即把每一个内建的或派生的data member（例如一个指针或一个数组）的值，从某个object拷贝一份到另一个object身上。不过它不会拷贝其中的 member class object，而是以递归的方式施行memberwise initialization。</p></li></ul><p><strong>C++S tandard 把copy constructor 区分为 trivial 和nontrivial 两种。只有 nontrivial 的实例才会被合成于程序之中。决定一个 copy constructor 是否为 trivial 的标准在于 class 是否展现出所谓的“bitwise copy semantics”</strong></p><p>一个class不展现出“bitwise copy semantics”的4种情况：</p><ol><li><p>当class内含一个member object 而后者的class声明有一个copy constructor时（不论是被 class设计者显式地声明或是被编译器合成）。</p></li><li><p>当 class继承自一个 base class而后者存在一个 copy constructor时（不论是被显式声明或是被合成而得）。</p></li><li><p>当 class声明了一个或多个 virtual functions时。</p></li><li><p>当 class派生自一个继承串链，其中有一个或多个 virtual base classes时。</p><blockquote><p>由于带虚函数类会多一个虚函数表和虚函数指针，因此对于拷贝构造需要正确对虚函数指针进行赋值</p><ul><li>同一个类的对象，即使继承带虚函数，可以直接靠“bitwise copy semantics”完成拷贝构造。</li><li>但是对于派生类给基类赋值，则需要重新设置虚函数指针，因此需要生成一个构造函数</li></ul></blockquote><blockquote><p>一个class object 如果以另一个object作为初值，而后者有一个virtual base class subobject，那么也会使“bitwise copy semantics”失效。</p><ul><li>例如A是基类，B继承A，C继承B；如果B的对象给C的对象进行赋值，那么就需要合成一个拷贝构造函数，安插一些代码以设定virtual base class pointer&#x2F;offset 的初值，对每一个members执行必要的memberwise初始化操作，以及执行其他的内存相关工作</li><li>简单说还是上述那套规则，继承的类中不能有虚函数。</li></ul></blockquote></li></ol><p><strong>不要随意提供 copy constructor</strong>， 对于满足 bitwise copy semantics 的类来说，编译器自 动生成的拷贝构造函数自动地使用了位拷贝（这是效率最高的），如果你自己随意提供 copy constructor 就会压抑掉编译器的这个行为，画蛇添足还影响了效率。</p><h2 id="2-3-程序转化语意学"><a href="#2-3-程序转化语意学" class="headerlink" title="2.3 程序转化语意学"></a>2.3 程序转化语意学</h2><p>编译器通常会对代码进行转化，其操作可能和直观的并不同</p><p><strong>显式的初始化操作</strong></p><ul><li><p>例如以一个X的示例x0来初始化值，其并没有直接调用拷贝构造函数，可能会被转化。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711113449177.png" alt="" style="zoom:50%;" /></li><li><p>其转化有两个阶段：重写每一个变量定义，其中的初始化操作会被剥除；class的 copy constructor调用操作会被安插进去。会被转换成如下结果：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711113758369.png" alt="" style="zoom:50%;" /></li></ul><p><strong>参数的初始化</strong></p><ul><li>当函数参数是一个非引用或指针类型的变量时，如果传入参数，有的编译器会先构建一个临时对象，在调用拷贝构造，然后重写函数调用操作（为了避免再赋值，将原来的参数类型改为引用）</li><li>另一种实现方法是以“拷贝建构”（copy construct）的方式把实际参数直接建构在其应该的位置上，此位置视函数活动范围的不同，记录于程序堆栈中。在函数返回之前，destructor会被执行。</li></ul><p><strong>返回值的初始化</strong></p><ul><li><p>首先加上一个额外参数，类型是 class object的一个 reference。这个参数将用来放置被“拷贝建构（copy constructed）”而得的返回值。</p></li><li><p>在 return指令之前安插一个 copy constructor调用操作，以便将欲传回之object的内容当做上述新增参数的初值。</p></li><li><p>以下函数将被转换，且其调用处也会被相应转换</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711114732784.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711114744038.png" alt="" style="zoom:50%;" /></li></ul><p><strong>在使用者层面做优化</strong></p><ul><li>对一些通过定义变量进行操作再返回的函数，可以通过定义一个新的构造函数来避免一次拷贝</li></ul><p><strong>在编译器层面做优化</strong></p><ul><li>Named Return Value（NRV）：将需返回的局部变量修改为在参数列表中定义引用，从而减少拷贝</li></ul><h2 id="2-4-成员列表初始化"><a href="#2-4-成员列表初始化" class="headerlink" title="2.4 成员列表初始化"></a>2.4 成员列表初始化</h2><p>编译器会一一操作initialization list，以适当顺序在constructor之内安插初始化操作，并且在任何explicit user code之前。</p><ul><li>成员初始化顺序是由声明顺序决定，而不是初始化列表排列顺序决定。</li></ul><p>以下情况必须使用member initialization list：</p><ol><li>当初始化一个reference member时；</li><li>当初始化一个 const member时；</li><li>当调用一个 base class的 constructor，而它拥有一组参数时；</li><li>当调用一个 member class的 constructor，而它拥有一组参数时。</li></ol><p>如果不适用列表初始化，而在构造函数中初始化，那么编译器会</p><ul><li><p>先使用默认构造函数生成一个对象，且用初始化值生成一个临时对象</p></li><li><p>然后以赋值方式将临时对象拷贝给想要初始化的对象，最后再讲临时对象销毁。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711155120575.png" alt="" style="zoom:50%;" /></li></ul><h1 id="第3章-Data语意学"><a href="#第3章-Data语意学" class="headerlink" title="第3章 Data语意学"></a>第3章 Data语意学</h1><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711160518505.png" alt="" style="zoom:67%;" /><p>如上定义，X大小为1，Y、Z对象大小为4，A大小为8</p><ul><li>X对象虽然无数据，为了使得这一class的两个objects得以在内存中配置独一无二的地址，编译器会安插一个char</li><li>YZ大小受三个因素影响：<ul><li>语言本身所造成的额外负担：虚函数指针需要占4个字节</li><li>编译器对于特殊情况所提供的优化处理：有的编译器不会优化X所占的一个字节，有的会优化</li><li>Alignment的限制：为了更有效的存储，数据存储需要对齐</li></ul></li><li>A的大小由两个虚函数指针构成，X的一个占位字节会被优化</li></ul><p>C++对象模型把数据直接存放在每一个class object 之中。对于继承而来的nonstatic data members （不管是virtual还是nonvirtual）也是如此。不过并没有强制定义其间的排列顺序。</p><p>静态成员变量被放置在程序的一个global data segment 中，不会影响个别的class object的大小。在程序之中，不管该class被产生出多少个objects，静态成员变量永远只存在一份实例</p><h2 id="3-1-Data-Member的绑定"><a href="#3-1-Data-Member的绑定" class="headerlink" title="3.1 Data Member的绑定"></a>3.1 Data Member的绑定</h2><p><strong>应尽量将class成员变量定义在函数出现之前，即把变量定义在class起始处</strong></p><p>如下图所示，两个函数的length都会被判断为int，只有当length成员定义出现后，才会认为length是float类型</p><ul><li><p>注意，只有函数参数才会出现这种情况，函数内部不会（因为函数内部对类型进行分析是在整个class声明出现之后才进行）。</p></li><li><p>在下图中，如果打印val类型，经测试会输出int</p></li><li><p>远古时期如果定义一个全局变量和成员变量同名，那么成员变量没出现之前，class中的函数会使用全局变量。但这种情况已经得到修正。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711162911644.png" alt="" style="zoom:50%;" /><p><strong>对 member functions 本身的分析会直到整个 class 的声明都出现了才开始（函数参数会一出现就进行分析）</strong>。所以 class 的 member functions 可以引用声明在后面的成员，C 语言就做不到。</p><h2 id="3-2-Data-Member的布局"><a href="#3-2-Data-Member的布局" class="headerlink" title="3.2 Data Member的布局"></a>3.2 Data Member的布局</h2><p>非静态成员在class object中的排列顺序将和其被声明的顺序一样，任何中间介入的静态都不会被放进对象布局之中。</p><ul><li>在同一个access section（也就是private、public、protected等区段）中，members的排列只需符合“较晚出现的members在class object 中有较高的地址”这一条件即可，即各个members并不一定得连续排列。例如可能中间进行对齐。</li><li>C++Standard也允许编译器将多个access sections之中的data members自由排列，不必在乎它们出现在class声明中的顺序。但目前所有编译器都是依照声明的顺序进行排列，且例如多个private不会带来损耗，其会将所有private连成一个。</li></ul><h2 id="3-3-Data-Member的存取"><a href="#3-3-Data-Member的存取" class="headerlink" title="3.3 Data Member的存取"></a>3.3 Data Member的存取</h2><p>成员变量存取成本几何？对象存取变量和指针存取变量是否有差异？</p><p><strong>当变量是静态成员变量</strong></p><ul><li>每次取静态成员变量，会被内部转化为对该唯一extern实例的直接参考操作，不会有任何空间上或执行时间上的额外负担</li><li>通过指针或对象存取变量执行的指令完全相同，也是唯一完全相同的情况</li><li>即使该静态成员变量是由虚拟派生出来的，也是直接存取</li><li>静态成员变量是放在data segment中，因此需要对其进行重新命名以避免命名冲突</li></ul><p><strong>当变量非静态成员变量</strong></p><ul><li>欲对一个非静态成员变量进行存取操作，编译器需要把class object的起始地址加上data member的偏移位置</li><li>每个成员的偏移在编译即可获知，因此存取一个非静态成员，其效率和存取一个C struct member或一个nonderived class的member是一样的。</li><li><em>如果待存取成员是由virtual base class继承而来，使用对象和指针访问就存在巨大差异</em><ul><li>使用指针访问时无法确定该指针指向哪种类型，也就不知道偏移位置，所以这个存取操作必须延迟至执行期，经由一个额外的间接导引，才能够解决。</li><li>但如果使用对象进行存取，其偏移位置在编译时期就固定了，因此在编译时就知道存取哪个位置</li></ul></li></ul><h2 id="3-4-“继承”与Data-Member"><a href="#3-4-“继承”与Data-Member" class="headerlink" title="3.4 “继承”与Data Member"></a>3.4 “继承”与Data Member</h2><p>假设将一个类的成员变量分裂成三层结构，其通过继承得到，继承后的内存布局不会和直接在一个类中声明变量一样。</p><ul><li><p>例如如下将Concrete类分裂</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711194303670.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230717163719889.png" alt="" style="zoom:50%;" /></li><li><p>分裂后的concrete3对象会占据16字节，而原来的concrete只需要8个字节，其原因是不会将bit2和bit3成员变量填充到concrete1的填充上。内存布局如下图所示。</p><ul><li>不填充原因：如果填充了，那么当使用concrete1对象给concrete2对象进行复制操作时，bit2变量就会被指定一个数值，而这是不被期望的。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711194546570.png" alt="" style="zoom:50%;" /></li></ul><p><strong>C++ Standard 保证：“出现在派生类中的 base class subobject 有其完整原样性！”</strong> </p><ul><li>子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节 也是父类的一部分，也是不可分割的。</li></ul><h3 id="加上多态"><a href="#加上多态" class="headerlink" title="加上多态"></a><strong>加上多态</strong></h3><ul><li>使用虚函数会给类带来空间和存取时间上的额外负担：<ul><li>导入一个virtual table，用来存放它所声明的每一个virtual functions 的地址。这个table 的元素个数一般而言是被声明的virtual functions的个数，再加上一个或两个 slots（用以支持 runtime type identification）。</li><li>在每一个class object中导入一个vptr，提供执行期的链接，使每一个object能够找到相应的 virtual table。</li><li>加强 constructor，使它能够为 vptr 设定初值，让它指向 class 所对应的virtual table。</li><li>加强 destructor，使它能够抹消“指向 class之相关 virtual table”的 vptr。</li></ul></li><li>在早期vptr通常放在尾端，这保留了C的兼容性，允许在C程序代码中也能使用。后来是把vptr放在首段，是的不需要计算vptr的偏移，代价就是丧失了C语言兼容性。</li></ul><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a><strong>多重继承</strong></h3><ul><li>把一个派生类指定给一个基类，在实现上会按照基类在派生类中的内存布局加上偏移进行赋值</li><li>c++标准并未规定各基类的布局</li><li>多重继承中，可能会有多个 vptr 指针，视其继承体系而定：<strong>派生类中 vptr 的数目最等于所有基 类的 vptr 数目的总和</strong>。</li></ul><h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a><strong>虚拟继承</strong></h3><ul><li><p>iostream是最常见的虚拟继承例子，实现虚拟继承要找到一个足够有效的方法，将istream和ostream各自维护的一个ios subobject，折叠成为一个由iostream维护的单一 ios subobject，并且还可以保存 base class 和 derived class 的指针之间的多态指定操作</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711200602246.png" alt="" style="zoom:50%;" /></li><li><p><em>一般的实现方法</em>：Class 如果内含一个或多个 virtual base class subobjects，例如istream将被分割为两部分：一个不变区域和一个共享区域。不变区域中的数据，不管后继如何衍化，总是拥有固定的offset（从object的开头算起），所以这一部分数据可以被直接存取。至于共享区域，所表现的就是virtual base class subobject。这一部分的数据，其位置会因为每次的派生操作而有变化，所以它们只可以被间接存取。各家编译器实现技术之间的差异就在于间接存取的方法不同，以下两种主流策略：</p><ol><li><strong>一种做法是直接使用一个指针指向虚基类</strong>。先安排好derived class的不变部分，然后再建立其共享部分。在每一个derived class object中安插一些指针，每个指针指向一个virtual base class，以此存取共享部分。<ul><li>缺点：每一个对象必须针对其每一个 virtual base class 背负一个额外的指针；由于虚拟继承串链的加长，导致间接存取层次的增加。</li><li>缺点解决方法：通过设置一个virtual base class table或在virtual function table中放置virtual base class的offset（而不是地址）;第二个问题通过将不断嵌套的虚拟基类指针拷贝到派生类中，从而得到固定时间存取。</li></ul></li><li><strong>另一种做法是在 vtable 中放置 virtual base class 的 offset</strong><ul><li>这种方式好处在于： vptr 是已经存在的成本，而 vtable 是 class 的所有 objects 所共享的成本。对于每一个 class object 没有引入任何的额外成本，仅仅在 vtable 多 存储了一个 slot 布局，而前一种方式却对每一个 object 都引了两个指针的巨大成本。</li></ul></li></ol></li><li><p>这两种虚基类方式都是把虚基类放在内存中模型中的最后面，然后借由一层间接性（指针或 offset）来 访问。</p></li><li><p>一个使用指针指向虚基类的例子内存布局如下：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711202559012.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711202609004.png" alt="" style="zoom:67%;" /></li></ul><h2 id="3-5-对象成员的效率"><a href="#3-5-对象成员的效率" class="headerlink" title="3.5 对象成员的效率"></a>3.5 对象成员的效率</h2><p>在简单的类封装测试中，如果把优化打开，封装不会带来执行期的效率成本</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711203410103.png" alt="" style="zoom:50%;" /><p>单一继承应该不会影响效率，因为 members 被连续存储于 derived class object中，并且其offset在编译时期就已知了。而虚拟继承则通过会通过一个间接层访问，因此带来效率下降。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711203637859.png" alt="" style="zoom: 50%;" /><h2 id="3-6-指向Data-Members的指针"><a href="#3-6-指向Data-Members的指针" class="headerlink" title="3.6 指向Data Members的指针"></a>3.6 指向Data Members的指针</h2><p>取某个成员变量的地址会得到其在class中的偏移，但是结果会比真实结果多1，原因下面解释。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711203842598.png" alt="" style="zoom: 80%;" /><p>而以下则是取一个“绑定于真正class object身上的data member”的地址，将会得到该member在内存中的真正地址</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711204825218.png" alt="" style="zoom:80%;" /><p><strong>如何区分一个“没有指向任何data me mber”的指针，和一个指向“第一个data member”的指针？</strong></p><ul><li>考虑这样的例子：</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711204608316.png" alt="" style="zoom:50%;" /><ul><li>为了区分p1和p2，每一个真正的member offset值都被加上1。因此，在真正使用该值以指出一个 member 之前，先减掉1。</li></ul><h1 id="第4章-Function语意学"><a href="#第4章-Function语意学" class="headerlink" title="第4章 Function语意学"></a>第4章 Function语意学</h1><p>当调用虚函数、普通函数、静态函数时，通过对象调用和通过指针调用可能会有不同。</p><h2 id="4-1-Member-的各种调用方式"><a href="#4-1-Member-的各种调用方式" class="headerlink" title="4.1 Member 的各种调用方式"></a>4.1 Member 的各种调用方式</h2><p><strong>非静态成员函数</strong></p><ul><li>其调用开销和非成员函数一样</li><li>编译器会将每个成员函数转换为非成员函数，过程如下：<ol><li>改写函数参数列表，添加一个相应类的this指针</li><li>将每一个对 nonstatic data member 的存取操作改为经由 this指针来存取</li><li>将 member function重新写成一个外部函数。将函数名称经过“mangling”处理（将类名编译进去）</li><li>将该函数调用处进行转换，由obj.fun形式改成func(obj)形式</li></ol></li></ul><blockquote><p><strong>名称的特殊处理</strong></p><ul><li>member的名称前面会被加上class名称，形成独一无二的命名（避免派生时出现同名变量）</li><li>member functions 可以被重载化，所以将参数类型添加到函数名中</li></ul></blockquote><p><strong>虚拟成员函数</strong></p><ul><li><p>如果normalize（）是一个virtual member function，那么以下的调用会被如下转化：</p><ul><li>vptr表示由编译器产生的指针，指向 virtual table。1是 virtual table slot的索引值，关联到 normalize（）函数。 第二个 ptr表示 this指针。</li><li>事实上，vptr 的名称会被加上 mangled，因为对于一个复杂的派生体系，可能会有多个 vptr</li><li>但使用对象进行调用时，由于已经确定调用哪个类的函数，因此没必要再使用虚函数表来间接访问</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711221328144.png" alt="" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711221334457.png" alt="" style="zoom:67%;" /></li></ul><p><strong>静态成员函数</strong></p><ul><li><p>如果normalize（）是一个static member function，以下两个调用操作，将被转换为一般的nonmember函数调用</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711221753421.png" alt="" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230711221759273.png" alt="" style="zoom:67%;" /></li><li><p>静态成员函数的主要特性就是它没有this指针，以下的次要特性统统根源于其主要特性：</p><ul><li>它不能够直接存取其 class中的 nonstatic members。</li><li>它不能够被声明为 const、volatile或 virtual。</li><li>它不需要经由 class object 才被调用——虽然大部分时候它是这样被调用的！</li></ul></li></ul><h2 id="4-2-Virtual-Member-Functions（虚拟成员函数）"><a href="#4-2-Virtual-Member-Functions（虚拟成员函数）" class="headerlink" title="4.2 Virtual Member Functions（虚拟成员函数）"></a>4.2 Virtual Member Functions（虚拟成员函数）</h2><p>这节主要是将虚函数表的必要以及作用</p><p>多态时，使用指针调用函数，无法知道指向的是哪个函数，需要额外信息才能正确调用相应函数。因此，在每个具有虚函数的类前添加一个虚函数表指针，其指向的虚函数表存储的是函数地址。</p><ul><li><p>每一个virtual table内含其对应之class object 中所有active virtual functions函数实例的地址，包括：</p><ol><li><p>这一 class 所定义的函数实例。它会改写一个可能存在的base class virtual function函数实例。</p></li><li><p>继承自 base class 的函数实例。这是在 derived class 决定不改写 virtual function时才会出现的情况。</p></li><li><p>一个 pure_virtual_called（）函数实例，它既可以扮演 pure virtual function的空间保卫者角色，也可以当做执行期异常处理函数。</p></li></ol></li><li><p>每一个virtual function都被指派一个固定的索引值，这个索引在整个继承体系中保持与特定的virtual function的关系。</p></li><li><p>虚函数表编号0的位置存储的是对应类的信息（type_info，RTTI）</p></li><li><p>因此，对于指针调用函数可以被转化如下，vptr表示编译器所安插的指针，指向virtual table；4表示z（）被指派的slot编号</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712103348842.png" alt="" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712103402268.png" alt="" style="zoom:80%;" /></li></ul><h3 id="多重继承下的-Virtual-Functions"><a href="#多重继承下的-Virtual-Functions" class="headerlink" title="多重继承下的 Virtual Functions"></a><strong>多重继承下的 Virtual Functions</strong></h3><p>单继承下对于基类指针指向派生类时，无需移动指针。而多继承下，第二个基类及之后的指针指向的派生类时，无论是调用虚函数，还是delete对象（其实也是虚函数）都需要移动指针（加上或减去一个offset）</p><ul><li>比如对于简单的 delete 操作： deleta base2;由于 base2 可能没有指向对象的起始地址，这样简单的删除操作会引发灾难，所以需要对 base2 做执行期 的调整才能正确的 delete 对象。</li></ul><p>上述移动offset需要记录，使用了一种名叫thunk的技术，一个示例如下（其实就是预置了一个offset）。虚函数表中存储的既可以是虚函数地址，也可以存储一个thunk地址。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712112033531.png" alt="" style="zoom:67%;" /><p>可能是通过派生类（或第一个base class）指针调用，也可能是通过第二个base class指针调用，同一函数在virtual table中可能需要多笔对应的slots，因此多重继承下会有多个虚函数表。</p><ul><li><p>在多重继承之下，一个derived class内含n-1个额外的virtual tables，n表示其上一层base classes的个数（因此，单一继承将不会有额外的virtual tables）</p></li><li><p>一个示例如下，注意第一个虚拟表中多了一个mumble函数（derived类中只重写了析构函数和clone函数）</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712112503789.png" alt="" style="zoom:67%;" /></li></ul><blockquote><p>多个vptr不是放置一起的，应该是放置在各subclass首部或末尾</p></blockquote><h3 id="虚拟继承下的-Virtual-Functions"><a href="#虚拟继承下的-Virtual-Functions" class="headerlink" title="虚拟继承下的 Virtual Functions"></a><strong>虚拟继承下的 Virtual Functions</strong></h3><ul><li><p>在虚拟继承下，即使只继承一个class，也会存在两个虚函数表，也需要调整this指针位置</p></li><li><p>下面内存布局应该就是虚继承下的基于offset指向基类的布局（另一种是基于指针指向基类）</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712113201347.png" alt="" style="zoom:80%;" /></li></ul><blockquote><p>Lippman 建议：<strong>不要在一个 virtual base class 中声明 nonstatic data members</strong>。如果一 定要这么做，那么你会距离复杂的深渊愈来愈近，终不可拔。</p></blockquote><h2 id="4-3-函数的效能"><a href="#4-3-函数的效能" class="headerlink" title="4.3 函数的效能"></a>4.3 函数的效能</h2><h2 id="4-4-指向Member-Function的指针Pointer-to-Member-Functions"><a href="#4-4-指向Member-Function的指针Pointer-to-Member-Functions" class="headerlink" title="4.4 指向Member Function的指针Pointer-to-Member Functions"></a>4.4 指向Member Function的指针Pointer-to-Member Functions</h2><p>取一个nonstatic member function的地址，如果该函数是nonvirtual，得到的结果是它在内存中真正的地址。但是仍然需要this指针才能调用该函数。</p><h3 id="支持“指向-Virtual-Member-Functions”的指针"><a href="#支持“指向-Virtual-Member-Functions”的指针" class="headerlink" title="支持“指向 Virtual Member Functions”的指针"></a><strong>支持“指向 Virtual Member Functions”的指针</strong></h3><ul><li><p><strong>对一个 virtual member function 取其地址，所能获得的只是一个 vtable 中的索引值。</strong></p></li><li><p>对于虚函数取地址得到的指针，也可以通过调用执行该函数，其在编译时期会被转化</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712161836240.png" alt="" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712161843601.png" alt="" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712162225187.png" alt="" style="zoom: 67%;" /></li><li><p>对一个virtual function取地址，其地址在编译时期是未知的，所能知道的仅是在virtual table中的索引值。因此，对一个virtual member function取其地址，所能获得的只是一个索引值。</p></li><li><p>那么编译器如何知道该指针到底是索引值还是一个地址？</p><ul><li><p>cfront中通过判断其大小，如果小于等于128，则视为索引值，否则视为地址</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712162021772.png" alt="" style="zoom:50%;" /></li></ul></li></ul><h3 id="在多重继承之下，指向-Member-Functions的指针"><a href="#在多重继承之下，指向-Member-Functions的指针" class="headerlink" title="在多重继承之下，指向 Member Functions的指针"></a><strong>在多重继承之下，指向 Member Functions的指针</strong></h3><ul><li><p>设置了一个单独结构体来存储信息，但这会使得每个指针调用开销变大，微软使用了一个vcall thunk来解决</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712163152150.png" alt="" style="zoom:67%;" /></li></ul><h3 id="“指向-Member-Functions之指针”的效率"><a href="#“指向-Member-Functions之指针”的效率" class="headerlink" title="“指向 Member Functions之指针”的效率"></a><strong>“指向 Member Functions之指针”的效率</strong></h3><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712163331440.png" alt="" style="zoom:50%;" /><h2 id="4-5-Inline-Functions"><a href="#4-5-Inline-Functions" class="headerlink" title="4.5 Inline Functions"></a>4.5 Inline Functions</h2><p>处理一个inline函数，有两个阶段：</p><ol><li>分析函数定义，以决定函数的“intrinsic inline ability”。如果函数因其复杂度，或因其建构问题，被判断不可成为inline，它会被转为一个<em>static函数</em></li><li>真正的 inline函数扩展操作是在调用的那一点上。这会带来参数的求值操作（evaluation）以及临时性对象的管理。</li></ol><h3 id="形式参数（Formal-Arguments）"><a href="#形式参数（Formal-Arguments）" class="headerlink" title="形式参数（Formal Arguments）"></a><strong>形式参数（Formal Arguments）</strong></h3><ul><li><p>在inline扩展期间，每一个形式参数都会被对应的实际参数取代。</p><ul><li>如果实际参数是一个常量表达式，可以在替换之前先完成其求值操作，然后就可以把常量直接“绑”上去。</li><li>如果既不是个常量表达式，也不是个带有副作用的表达式，那么就直接代换之。</li><li>如果是一个会带来副作用的实际参数（例如函数），通常都需要引入临时性对象。</li></ul></li><li><p>inline 函数扩展时的实际参数取代形式参数的过程，会聪明地引入临时变量来避免重复求值。</p></li><li><p>例子如下：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712164704158.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712164711655.png" alt="" style="zoom:50%;" /><img src="C:\Users\MyPC\AppData\Roaming\Typora\typora-user-images\image-20230712164742328.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712164751816.png" alt="" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712164812153.png" alt="" style="zoom:50%;" /></li></ul><h3 id="局部变量（Local-Variables）"><a href="#局部变量（Local-Variables）" class="headerlink" title="局部变量（Local Variables）"></a><strong>局部变量（Local Variables）</strong></h3><ul><li><p>inline函数中的每一个局部变量都必须被放在函数调用的一个封闭区段中，拥有一个独一无二的名称</p></li><li><p>如果inline函数在同一位置被扩展多次，则每次扩展都需要自己的一组局部变量。如果inline函数不同地方被扩展多次，那么只需一组局部变量，就可以重复使用（这里翻译有点迷）</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230712165142950.png" alt="" style="zoom:50%;" /></li></ul><blockquote><p>inline 中再调用 inline 函数，可能使得表面上一个看起来很平凡的 inline 却因连锁的复杂性而 没有办法扩展开来。</p></blockquote><h1 id="第5章-构造、析构、拷贝语意学"><a href="#第5章-构造、析构、拷贝语意学" class="headerlink" title="第5章 构造、析构、拷贝语意学"></a>第5章 构造、析构、拷贝语意学</h1><p><strong>C++隐式生成的 4 大成员函数，在不是真正需要的情况下都不要自己去声明</strong>。 </p><ul><li>因为如果是 trivial 的，这些函数不会被真正的合成出来（只存在于概念上），当然也就没有调 用的成本了，去提供一个 trivial 的成员反而是不符合效率的。</li></ul><h2 id="5-1-“无继承”情况下的对象构造"><a href="#5-1-“无继承”情况下的对象构造" class="headerlink" title="5.1 “无继承”情况下的对象构造"></a>5.1 “无继承”情况下的对象构造</h2><h3 id="纯虚函数的存在"><a href="#纯虚函数的存在" class="headerlink" title="纯虚函数的存在"></a><strong>纯虚函数的存在</strong></h3><ul><li>纯虚函数也可以被实现和调用。纯虚函数不能在类的声明中提供实现，只能在类声明的外部来提供默认的实现；</li><li>基类的纯虚函数的默认实现必须由派生类显式的要求调用；</li><li>派生类不会自动继承这个纯虚函数的定义，如果派生类未实现纯虚函数，那么其依然是一个抽 象类型； </li><li>这种 pure virtual 函数还提供实现的方案比较好的应用场景为：基类提供了一个默认的实现， 但是不希望自动的继承给派生类使用，除非派生类明确的要求。</li><li>还需要注意这个纯虚函数为析构函数的情况。C++语言保证继承体系中的每一个 class object 的 destructors 都会被调用。所以<strong>编译器一定会扩展派生类的析构函数去显式地调 用基类的析构函数</strong>。 </li><li>另外一个重要的应用场景：有些情况下会把析构函数声明为纯虚。这时，必须为纯虚析构函 数提供一个默认的实现。否则，派生类的析构函数由于编译器的扩展而显式的调用基类的析 构函数时会找不到定义。同时编译器也无法为已经声明为纯虚的析构函数生成一个默认的实 现。</li></ul><h3 id="虚函数中的-const-哲学："><a href="#虚函数中的-const-哲学：" class="headerlink" title="虚函数中的 const 哲学："></a><strong>虚函数中的 const 哲学</strong>：</h3><p><strong>一个虚函数该不该被定义为 const 呢？</strong></p><ul><li>一个虚函数在基类中不需要修改 data member 并不意味着派生类改写它时一定不会修改 data member</li></ul><p>观念上，编译器会为每一个类产生 4 个函数： dafault constructor, destructor, copy constructor, copy assignment operator。 但是，切记这仅仅是观念上的，<strong>trivial 的函数不会被真正的产生出来</strong>。</p><p>理论上：A *pa1 &#x3D; new A; 和 A *pa2 &#x3D; new A(); 之间是有差别的，前一个应该不会调用默认构造函数而后一个会。但是在 GCC 和 VS2010 的实验中发现，这 2 个写法是完全没有区别的， 默认的构造函数都被调用了。</p><p><strong>对于可以视为 POD 的 class（ 没有声明构造函数、没有 virtual 机制等等），就可以使用 POD 结构特有的 initialization list 进行初始化。</strong></p><p><strong>引入 virtual function 会给对象的构造、拷贝和析构等过程带来的负担</strong>如下： </p><ul><li>constructor 必须被安插一些代码以便将 vptr 正确的初始化，这些代码需要被安插在任何 base class constructors 的调用之后，但必须在任何 user code 的代码之前； </li><li>合成 copy constructor 和 copy assignment operator，因为它们不再是 trivial 的了， 它们必须安插代码以正确的设置 vptr；</li></ul><p><strong>C++S tandard要求编译器尽量延迟nontrivial members 的实际合成操作，直到真正遇到其使用场合为止。</strong></p><p>当需要以传值方式（by value）传回一个local class object，那么提供一个copy constructor就比较合理——甚至即使default memberwise语意已经足够。它的出现会触发NRV优化。</p><h2 id="5-2-继承体系下的对象构造"><a href="#5-2-继承体系下的对象构造" class="headerlink" title="5.2 继承体系下的对象构造"></a>5.2 继承体系下的对象构造</h2><p><strong>编译器扩充每一个constructor的操作</strong>如下：</p><ol><li>记录在 member initialization list中的 data members初始化操作会被放进constructor的函数本体，并以members的声明顺序为顺序。</li><li>如果有一个 member并没有出现在 member initialization list之中，但它有一个 default constructor，那么该 default constructor必须被调用。</li><li>在那之前，如果 class object 有vptr，必须被设定初值，指向适当的virtual table。</li><li>在那之前，所有上一层的 base class constructors必须被调用，以 base class的声明顺序为顺序。使用 member initialization list 或者调用默认构造函数，同时如果 base class 是多重继承下的非第 1 基类，还需要调整 this 指针（需要调用this指针进行构造，因此需要调整到相应位置）；</li><li>在那之前，所有的 virtual base class constructors 必须被调用，从左到右，从深到浅。class中的每一个virtual base class subobject的偏移位置（offset）必须在执行期可被存取， 并同时设置好 virtual base class 所需要使用的各种机制；<ul><li>“virtual base class constructors的被调用”有着明确的定义：只有当一个完整的 class object 被定义出来（例如origin）时，它才会被调用；如果object只是某个完整object的subobject，它就不会被调用</li></ul></li><li>即处理顺序为：virtual base classes → base class → vptr → member</li></ol><p>赋值运算符中切记要记得进行自我检查。</p><p><strong>虚拟继承时，共享基类必须由最底层的 class 负责初始化操作</strong>： 这是虚拟继承时非常重要的一点，共享基类的初始化操作必须由最底层的类来负责，中层层次的类调用这个共享基类初始化的操作会被编译器所压抑掉。</p><ul><li>其通过对中层层次类的构造安插一个额外的参数__most_derived 来解决的。</li></ul><h3 id="vptr初始化语意学"><a href="#vptr初始化语意学" class="headerlink" title="vptr初始化语意学"></a>vptr初始化语意学</h3><p>在一个 class的constructor（和destructor）中，经由构造中的对象来调用一个virtual function，其函数实例应该是在此class中有作用的那个</p><ul><li>即使是派生类调用基类的构造有使用虚函数，也还是会调用基类相应的函数，因为此时派生类对象并未构造完成，其成员可能并未初始化</li><li>为了达到上述目的，先不更改当前对象虚指针的指向，当虚基类构造完成后再进行更改。因此，vptr的初始化操作处理时机为：<em>在 base class constructors调用操作之后，但是在程序员供应的代码或是“member initialization list中所列的 members初始化操作”之前。</em>（<strong>这是构造函数中没有多态性的根本原因！</strong>）</li></ul><p><strong>constructor的执行算法</strong>如下：</p><ol><li>在 derived class constructor中，“所有 virtual base classes”及“上一层base class”的constructors会被调用。</li><li>上述完成之后，对象的 vptr（s）被初始化，指向相关的 virtual table（s）。</li><li>如果有member initialization list的话，将在constructor体内扩展开来。这必须在vptr被设定之后才做，以免有一个virtual member function被调用。</li><li>最后，执行程序员所提供的代码。</li></ol><blockquote><p><strong>在class的constructor的member initialization list中调用该class的一个虚拟函数，安全吗？</strong></p><ul><li>将此函数施行于其class’s da ta me mber的初始化行动中，总是安全的。这是因为，vptr保证能够在member initialization list 被扩展之前，由编译器正确设定好。但是在语意上这可能是不安全的，因为函数本身可能还得依赖未被设立初值的members。</li></ul><p><strong>在一个class的虚基类的构造函数中传递该class的虚拟函数安全吗</strong></p><ul><li>不安全，此时vptr未被设定好，会指向错误的class</li></ul><p><strong>一个很容易犯的错误</strong>：使用了派生类的成员方法去初始化基类，注意在这个时候派生类还没有开始构造，调用它的成员 方法的行为当然是未定义的</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>， <span class="token function">valueA</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> valueA<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">int</span> valueA<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="5-3-对象复制语意学"><a href="#5-3-对象复制语意学" class="headerlink" title="5.3 对象复制语意学"></a>5.3 对象复制语意学</h2><p>如果class拥有bitwise copy语意，所以implicit copy assignment operator被视为毫无用处，也根本不会被合成出来。</p><blockquote><p>一个class对于默认的copy assignment operator，在以下情况，不会表现出bitwise copy语意：</p><ol><li>当class内含一个member object，而其class有一个copy assignment operator时。</li><li>当一个 class的 base class有一个 copy assignment operator时。</li><li>当一个 class声明了任何 virtual functions （一定不要拷贝右端 class object的 vptr地址，因为它可能是一个 derived class object）时。</li><li>当 class 继承自一个 virtual base class （不论此 base class 有没有 copy operator）时。</li></ol><p>不表示bitwise copy semantics则是nontrivial</p></blockquote><p><strong>注意，应尽可能提供一个 copy constructor，为的是把 name return value （NRV）优化打开。copy constructor的出现并不意味着也一定要提供一个copy assignment operator。</strong></p><p><strong>C++语言中的虚继承时 copy assignment operator 弱点</strong>： </p><ul><li>C++ 标准没有规定在虚继承时 copy assignment operator 中是否会多次调用共享基类的 copy assignment operator。这样就有可能造成共享基类被赋值多次，造成一些错误，所以 程序员应该在使用了 virtual base class 时小心检验 copy assignment operator 里的代码 （以确保这样的多次赋值没有问题或者查看编译器是否已经提供了解决方案）。<ul><li>这是因为没有类似member initialization list的东西member assignment list，来抑制上一层base class的copy operators被调用</li></ul></li><li>因此，尽可能不要允许一个 virtual base class 的拷贝操作，甚至根本不在要任何 virtual base class 中声明数据。</li></ul><h2 id="5-4-对象的效能"><a href="#5-4-对象的效能" class="headerlink" title="5.4 对象的效能"></a>5.4 对象的效能</h2><p>在一般的单继承或多继承中（非虚继承），如果表现出bitwise copy语义，那么继承不会给复制带来性能损耗。</p><p>当使用虚拟继承，由于不在具有bitwise copy语意，合成型的inline copy constructor和copy assignment operator于是被产生出来，并被派上用场，这导致效率成本上的一个重大增加（时间加了3倍，还只是一层虚拟继承）。</p><p>即使不使用任何继承，只是增加一个虚函数，同样导致合成型的inline copy constructor和copy assignment operator于是被产生出来，会增加40%～50%消耗。</p><h2 id="5-5-析构语意学"><a href="#5-5-析构语意学" class="headerlink" title="5.5 析构语意学"></a>5.5 析构语意学</h2><p>如果class没有定义destructor，那么只有在class内含的member object （或class自己的base class）拥有destructor的情况下，编译器才会自动合成出一个来。否则，destructor被视为不需要，也就不需被合成（当然更不需要被调用）</p><blockquote><p>构造函数（显式或隐式）必须存在是因为无法判断一个class是否被初始化，而delete一个对象却不一定需要将其数据清除，因此，也就不一定需要一个destructor（甚至根本不被合成）</p></blockquote><p><strong>析构函数的执行顺序</strong>（ 这里侯捷认为的顺序是错误的，而 Lippman 的才是正确的）：</p><ol><li>如果 object 内带有 vptr，那么首先重设相关的 vtable； </li><li>destructor 函数本身现在会被执行， 也就是说 vptr 会在程序员的代码执行之前被重设； </li><li>以声明顺序的相反顺序调用 members 的析构函数； </li><li>如果有任何直接的（上一层）nonvirtual base classed 拥有 destructor，那么会以其声 明顺序的相反顺序被调用； </li><li>如果有任何 virtual base classes 拥有 destructor，而当前讨论的这个 class 是最尾端的， 那么它们会以其原来的构造顺序的相反顺序被调用</li></ol><blockquote><p>由于析构函数中的重设 vptr 会在任何代码之前被执行，这样就保证了在析构函数中也不具有多 态性，从而不会调用子类的函数。因为此时派生类已经不完整了，派生类中的成员已经不存在了，而 派生类的函数有可能需要使用这些成员。</p></blockquote><p><strong>构造函数和析构函数中都不具有多态性</strong>：这并不是语言的弱点，而是正确的语意所要求的（因 为那个时候的对象不完整）。</p><h1 id="第6章-执行期语意学"><a href="#第6章-执行期语意学" class="headerlink" title="第6章 执行期语意学"></a>第6章 执行期语意学</h1><h2 id="6-1-对象的构造和析构"><a href="#6-1-对象的构造和析构" class="headerlink" title="6.1 对象的构造和析构"></a>6.1 对象的构造和析构</h2><p>一般而言会把object尽可能放置在使用它的那个程序区段附近，这么做可以节省非必要的对象产生操作和摧毁操作。</p><ul><li>因为如果都在开始处定义变量，那么在使用该变量前，如果中间代码有return之类操作，那么又会销毁该变量，造成不必要的消耗。</li></ul><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><ul><li>C++保证：全局变量会在第一次用到之前构造好，在 main()结束之前析构掉</li><li>C++程序中所有的 Global object 都放置在程序的 data segment 中并清 0（有指定初始值则不清零），但是它的 constructor 在程序激活时才会被调用。</li><li>Lippman 建议不要使用那些需要使用静态初始化的 global object （ Google C++编程规范也 是如此建议的）。</li><li>因为，如果exception handling 被支持，那些objects将不能够被放置于try区段之内，任何的 throw 操作将必然触发 exception handling library默认的terminate（）函数。</li></ul><h3 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h3><p>现在的 C++ Standard 已经强制要求局部静态对象在第一次被使用时才被构造出来。 而且在程序结束时会被以构造的相反次序被摧毁。</p><p>局部静态对象的构造和析构会多设置一个静态指针来保护（初始化为0）：</p><ul><li>当需要构造时，如果指针为0，则调用构造函数，并将指针指向对象地址，不为0则不调用构造函数</li><li>而在析构时，同样也会判断该指针决定是否调用析构函数</li></ul><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><p>对象的数组初始化和析构都是通过编译器安插一个vec_new函数调用的代码来实现的：</p><ul><li>vec_new之所以传进了析构函数的指针，是为了在构造函数抛出异常时，把已经构造好的对象给析构掉</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Point knots<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">vec_new</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> <span class="token comment">// address of start of array</span> size_t elem_size<span class="token punctuation">,</span> <span class="token comment">// size of each class object</span> <span class="token keyword">int</span> elem_count<span class="token punctuation">,</span> <span class="token comment">// number of elements in array</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>constructor<span class="token punctuation">)</span><span class="token punctuation">(</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">//构造函数的指针</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//析构函数的指针</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">vec_delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> <span class="token comment">// address of start of array</span> size_t elem_size<span class="token punctuation">,</span> <span class="token comment">// size of each class object</span> <span class="token keyword">int</span> elem_count<span class="token punctuation">,</span> <span class="token comment">// number of elements in array</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果knots提供一个或多个初值给数组，那么对于提供初值的元素会调用相应构造函数初始化，而未提供的元素则仍然通过vec_new初始化，只需要将array地址增加，元素个数减小即可。</p><h3 id="Default-Constructors和数组"><a href="#Default-Constructors和数组" class="headerlink" title="Default Constructors和数组"></a>Default Constructors和数组</h3><p>由于经由一个指针来启动 constructor，将无法（不被允许）存取default argument values。因此</p><ul><li>对于那些声明了默认参数从而实际上拥有无参构造函数的类，编译器会产生一个绝对无参的构造函数，再从这个构造函数里调用这个默认参数的构造函数。</li><li>这样，编译器实际上违反了语言的 规定，拥有了 2 个没有参数的构造函数，但是这样的特例只能由编译器自己来违反</li></ul><h2 id="6-2-new-和delete运算符"><a href="#6-2-new-和delete运算符" class="headerlink" title="6.2 new 和delete运算符"></a>6.2 new 和delete运算符</h2><p><strong>new运算符</strong>由两个步骤完成的：</p><ul><li>通过适当的 new运算符（__new)函数实例，配置所需的内存</li><li>将配置得来的对象设立初值（或调用构造）</li></ul><p><strong>delete运算符</strong>同理，但会判断指针是否为空：</p><ul><li>调用析构函数</li><li>释放内存（使用__delete函数）</li></ul><p><strong>一般的 library 对 new 运算符的实现</strong>如下，有两个精妙之处：</p><ul><li>new 操作符至少会返回 1 个字节的内存（语言要求每一次对 new 的调用都必须传回一个独一无二的指针，即使写出new T[0]这样的代码）</li><li>允许用户提供_new_handler ，会给内存分配不足时以补救的机会。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token operator">*</span>last_alloc<span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>last_alloc <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_new_handler<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>_new_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">return</span> last_alloc<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然 C++ Standard 并没有规定，但是实际上的 new 运算符都是以 C malloc()完成；同样 delete 运算符也都是以 C free()完成的。</p><h3 id="针对数组的-new语意"><a href="#针对数组的-new语意" class="headerlink" title="针对数组的 new语意"></a>针对数组的 new语意</h3><p>当使用new申请对象数组时，如果要分配的数组的类型并没有定义默认构造函数，那么不会调用vec_new函数进行初始化。只有在定义了默认构造函数时，vec_new 才需要被调用起来。</p><p><strong>delete 和 delete []</strong></p><ul><li>寻找数组维度给 delete 运算符带来了效率上的影响，所以出现了这个妥协。只有在 []出现时，编 译器才会去寻找数组的维度，否则它就假设只有一个 object 需要被删除</li><li>delete 数组时，只有第 1 个元素会被删除；</li><li>delete [] 单个对象时，1 个元素都不会被删除，没有任何析构函数被调用。</li></ul><blockquote><p>数组的大小会被编译器记录在某个地方，所以编译器能够直接查询出来某个数组的大小。</p></blockquote><p><strong>数组和多态行为的天生不兼容性：</strong></p><ul><li>永远不要把数组和多态扯到一起，他们天生是不兼容的。当你对一个指向派生类的基类指针进行 delete [] pbase; 操作时，它是不会有正确的语意的。</li><li>这是由于 delete []实际上会使用 vec_delete()类似的函数调用代替，而在 vec_delete()的参 数中已经传递了元素的大小，在 vec_delete 中的迭代删除时，会在删除一个指针之后将指针向 后移动 item_size 个位置，如果 DerivedClass 的 size 比 BaseClass 要大的话（通常都是如 此），指针就已经指向了一个未知的区域了（如果 Derived 与 Base 大小相同，那碰巧不会发生 错误，delete []可以正确的执行）。</li><li>如果一定要基类指针指向派生类数组然后进行删除，那么只能通过遍历该数组，逐个删除内存。</li></ul><blockquote><p>vec_new实现原型如下，其每次调用构造函数后，会将指针移动size大小然后再调用构造函数，而vec_delete实现也类似，因此会造成与多态的兼容问题。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230714123205506.png" alt="" style="zoom:67%;" /></blockquote><h3 id="Placement-Operator-new的语意"><a href="#Placement-Operator-new的语意" class="headerlink" title="Placement Operator new的语意"></a>Placement Operator new的语意</h3><p>有一个预先定义好的重载的new运算符，称为placement operator new。它需要二个参数，第一个为大小，第二个为void*。调用方式如下：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230714151527383.png" alt="" style="zoom:67%;" /><ul><li><p>arena是一个指针，指向一个内存区块</p></li><li><p>Point2w是需要放置在arena的类型</p></li><li><p>其内部操作会被解释为：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230714151742649.png" alt="" style="zoom:67%;" /></li></ul><p>如果placement operator在原已存在的一个object上构造新的object，而该既存的object有个destructor，这个destructor并不会被调用。</p><ul><li>可以使用delete，其会调用析构函数，但同时也会释放内存空间。因此，应该显式地调用destructor并保留存储空间以便再使用。</li><li>在原已存在的一个object上构造新的object，会将新object构造于原已存在的object之上</li></ul><p><strong>placement operator new 并不支持多态</strong>，因为 Derived Class 往往比 Base Class 要大，已经存在的类型为 Base 内存并不一定能够容纳 Derived 类型的对象。</p><blockquote><p>一个晦涩隐暗的问题：以下代码是安全的，大部分编译器调用base::f()，因为 b 是 一个对象而不是指针或者引用不具有多态性。如果将b改成指针就会调用Derived::f()</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230714152234533.png" alt="" style="zoom:67%;" /></blockquote><h2 id="6-3-临时性对象"><a href="#6-3-临时性对象" class="headerlink" title="6.3 临时性对象"></a>6.3 临时性对象</h2><p>C++ Standard 允许编译器对临时性对象的产生有完全的自由度</p><p><strong>临时对象的摧毁时机</strong>： 摧毁临时对象应该在产生它的 完整的表达式的最后一个步骤。</p><ul><li>切记是完整的表达式，比如一连串的逗号或一堆的括号，只有在完整的表达式最后才能保证这个 临时对象在后面不会再被引用到。</li></ul><p>临时性对象的生命规则有两个例外：</p><ul><li>第一个例外发生在表达式产生的临时对象被用来初始化一个object时：<ul><li>临时对象应该存留到object的初始化操作完成为止</li></ul></li><li>第二个例外是“当一个临时性对象被一个 reference绑定”时：<ul><li>如果一个临时性对象被绑定于一个 reference，对象将残留，直到被初始化之reference 的生命结束，或直到临时对象的生命范畴（scope）结束——视哪一种情况先到达而定。</li></ul></li></ul><p><em><strong>总结</strong>：临时性对象的确在一些场合、一定程度上影响了 C++的效率。但是这些影响完全可以通 过良好的编码和编译器的积极优化而解决掉临时性对象带来的问题（至少在很大的程度上），所 以对临时性对象的影响不能大意但也不必太放在心上。</em></p><h1 id="第7章-站在对象模型的尖端"><a href="#第7章-站在对象模型的尖端" class="headerlink" title="第7章 站在对象模型的尖端"></a>第7章 站在对象模型的尖端</h1><h2 id="7-1-Template"><a href="#7-1-Template" class="headerlink" title="7.1 Template"></a>7.1 Template</h2><h3 id="Template的“实例化”行为"><a href="#Template的“实例化”行为" class="headerlink" title="Template的“实例化”行为"></a>Template的“实例化”行为</h3><p>编译器在看到一个模板的声明时会做出什么反映呢？实际上编译器没有任何反映！编译器的反映只有在真正具现化时才会发生。</p><ul><li>明白了这个，就明白了为什么在模板内部有明显的语法错误，编译器也不会报错，除非你要具现化出这个模板的一具实体时编译器才会发出抱怨。</li></ul><p>实例化规则：</p><ul><li>即使定义的变量与模板类别无关，每次实例化时也会被产生出来，并且访问此变量同样需要加模版类别进行访问</li><li>同上，与类别无关的静态成员变量，每次实例都会产生出来</li><li><strong>声明一个模板类型的指针是不会引起模板的具现化操作的，因为仅仅声明指针不需要知道 class 的实际内存布局。</strong></li><li>而声明一个模板类型的引用会引起模板的具现化操作</li><li>只有在某个 member function 真正被使用时，它才会被真正的具现化出来，这样的延迟具现化 至少有 2 个好处： <ul><li>空间和时间上的效率；</li><li>如果使用的类型并不完全支持所有的函数，但是只需要不去用那些不支持函数，这样的部分 具现化就能得以通过编译。</li></ul></li></ul><blockquote><p>int 和 long 在大多数的机器上都是相同的，但是目前的所有编译器都会具现化 2 个实体。</p></blockquote><h3 id="Template的错误报告"><a href="#Template的错误报告" class="headerlink" title="Template的错误报告"></a>Template的错误报告</h3><p>涉及 Template 时的错误检查太弱了，template 中那些与语法无关的错误，程序员可能认为十 分明显，编译器却放它通过了，只有在特定的实体被具现化时，编译器才发出抱怨，这是目前实现技术上的一个大问题（二阶段查找的必然结果）。</p><h3 id="Template中的名称决议法"><a href="#Template中的名称决议法" class="headerlink" title="Template中的名称决议法"></a>Template中的名称决议法</h3><blockquote><p>Template 中的名称决议方式：scope of the template definition（定义模板的地方） 和 scope of the template instantiation（具现出模板实体的地方）。</p></blockquote><p>template在定义处和实例化处如果有相同函数名该怎么调用？</p><ul><li>Template 中，对于一个 nonmember name 的决议结果是根据这个 name 的使用是否与“用以具现出该 template 的参数类型 有关而决定的。<ul><li>例如决议使用哪个函数，则判断此函数使用的变量是否与实例化类相关。</li></ul></li><li>情况 1：如果其使用互不相关，那就在scope of template declaration 中来决议 name； </li><li>情况 2：如果其使用互有关系，那就在scope of template instantiation中来决议 name；<ul><li>而如果在此scope中有重载函数，那么会优先调用参数类别与实例化类别相同的函数，如果都不同那么就不知道调用哪个</li></ul></li><li>注意！只要决定了在哪个scope中决议name，那么即使搜索不到也不会去另一个scope中决议</li></ul><blockquote><p>这种决议方式可以理解为：非依赖示例类别的就在模板定义处查找，而依赖的则在实例化处超找</p><p>这种决议方式好处：给予了一个调用者可以进行自定义的机会。 模板的使用者往往可以在使用时，根据具体的调用类型来提供一个更好的函数给模板</p></blockquote><p>示例如下：</p><ul><li>如果调用invariant函数，那么其内部会调用scope of the template definition中的foo函数，因为val与实例化类别无关</li><li>而如果调用type_dependent函数，那么其内部会调用scope of the template instantiation中的foo函数，因为member与实例化类别相关</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// scope of the template definition</span><span class="token keyword">extern</span> <span class="token keyword">double</span> <span class="token function">foo</span> <span class="token punctuation">(</span> <span class="token keyword">double</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">type</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">ScopeRules</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token function">invariant</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//情况 1</span> _member <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span> _val <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> type <span class="token function">type_dependent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//情况 2</span> <span class="token keyword">return</span> <span class="token function">foo</span><span class="token punctuation">(</span> _member <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token keyword">int</span> _val<span class="token punctuation">;</span> type _member<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//scope of the template instantiation</span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>ScopeRules<span class="token operator">&lt;</span> <span class="token keyword">int</span> <span class="token operator">></span> sr0<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Member-Function的实例化行为"><a href="#Member-Function的实例化行为" class="headerlink" title="Member Function的实例化行为"></a>Member Function的实例化行为</h3><p>Member Function实例化时，编译器设计者必须回答的三个主要问题：</p><ol><li>编译器如何找出函数的定义？<ul><li>一种方法是像头文件一样包含模板定义文件</li><li>另一种方法是基于文件命名规则，在Point.h文件中发现的函数声明，其template program text一定要放置于文件Point.C或Point.cpp中</li></ul></li><li>编译器如何能够只实例化程序中用到的 member functions？<ul><li>解决办法之一就是，根本忽略这项要求，把一个已经实例化的 class 的所有member functions 都产生出来</li><li>另一种策略就是模拟链接操作，检测看看哪一个函数真正需要，然后只为它（们）产生实例</li></ul></li><li>编译器如何阻止 member definitions在多个.o文件中都被实例化呢？<ul><li>解决办法之一就是产生多个实例，然后从链接器中提供支持，只留下其中一个实例</li><li>另一个办法就是由使用者来导引“模拟链接阶段”的实例化策略，决定哪些实例（instances）才是所需求的</li></ul></li></ol><p><strong>一种具现化的策略</strong>：先不具现任何的 member function，链接器会登记缺少哪些函数的定义， 然后再重新调用编译器把登记在册的缺乏的定义重写编译出来，最后在把这些缺乏的定义和以前 的链接结果链接起来形成最后的可执行文件或者库。</p><p><strong>如果 vtable 被具现出来，那么每一个 virtual function 也都必须被具现</strong>。 </p><ul><li>这就是为什么 C++ Standard 中有如下的描述： 如果一个 “ 虚函数被具现出来，其具现点紧跟 在其 class 的具现点之后 。（ ” 也就是说，virtual function 是一口气被具现出来的）</li></ul><h2 id="7-2-异常处理"><a href="#7-2-异常处理" class="headerlink" title="7.2 异常处理"></a>7.2 异常处理</h2><blockquote><p>一般而言，exception handling 机制需要与编译器所产生的数据结构以及执行期的一个 exception library 紧密合作而实现。</p><p>如果要支持异常处理，那么在程序大小和执行速度之间，编译器必须有所抉择：</p><ul><li>为了维护执行速度，编译器可以在编译时期建立起用于支持的数据结构。这会使程序的大小发生膨胀，但编译器可以几乎忽略这些结构，直到有个 exception被抛出来。</li><li>为了维护程序大小，编译器可以在执行期建立起用于支持的数据结构。这会影响程序的执行速度，但意味着编译器只有在必要的时候才建立那些数据结构（并且可以抛弃之）。</li></ul></blockquote><p><strong>exception 处理过程</strong>：</p><ul><li>当一个exception 被抛出去时，控制权会从函数调用中被释放出来，并寻找一个吻合的catch子句。如果都没有吻合者，那么默认的处理例程terminate（）会被调用。</li><li>当控制权被放弃后，堆栈中的每一个函数调用也就被弹出（popped up）。这个动作称为unwinding the stack。在每一个函数被推离堆栈之前，函数的local class objects的destructor会被调用（这意味着会析构栈上的变量而不会析构堆上变量）。</li></ul><p><strong>当一个exception发生时，编译系统必须完成以下事情</strong>：</p><ol><li>检验发生 throw操作的函数。</li><li>决定 throw操作是否发生在 try区段中。</li><li>若是，编译系统必须把 exception type拿来和每一个 catch子句进行比较。</li><li>如果比较后吻合，流程控制应该交到 catch子句手中。</li><li>如果 throw的发生并不在 try区段中，或没有一个 catch子句吻合，那么系统必须（a）摧毁所有 active local objects，（b）从堆栈中将目前的函数“unwind”掉，（c）进行到程序堆栈的下一个函数中去，然后重复上述步骤 2～5。</li></ol><p>对于每一个被丢出的 exception，编译器必须产生一个类型描述器，对 exception 类型进行编 码。如果那是一个 derived type，则编码内容还必须包括其所有 base class 的类型信息。</p><p><strong>当一个实际对象在程序执行时被抛出，会发生什么事？</strong></p><ul><li>当一个 exception 被丢出时， exception object 会被产生出来并通常放置在相同形式的 exception 数据堆栈中。从 throw 端传染给 catch 子句的是 exception object 的地址、类型 描述器（或是一个函数指针，该函数会返回该 exception type 有关的类型描述器对象），以及 有可能还有的 exception object 的析构函数的地址（如果有的话）</li></ul><p><strong>以值类型抛出异常，以引用类型进行捕获</strong>：</p><ul><li>被抛出的异常类型，一定会被先复制一份，真正被抛出的实际上是这份复制器（引用类型是全局变量，也会被复制一份）； </li><li>即使是以值类型来进行捕获异常也可以捕获该值类型和其派生类的异常，但是在 catch 语句中会 引发切割。</li></ul><p>C++ 对异常机制所付出的代价大概为：空间 10% 、时间 5%</p><h2 id="7-3-执行期类型识别（RTTI）"><a href="#7-3-执行期类型识别（RTTI）" class="headerlink" title="7.3 执行期类型识别（RTTI）"></a>7.3 执行期类型识别（RTTI）</h2><p>由于具备多态性质的 class 都已经含有一个 vptr 指向 vtable 了，C++把类型信息放在 vtable 的第 1 个 slot 中（一个 type_info 的指针指向一个表示当前类型的 type_info 对象），从而几 乎没有付出代价的支持了 RTTI。</p><ul><li>由于 RTTI 所需要的信息放在 vtable 中，自然的：只有含有 vptr 的类才支持 RTTI</li></ul><p><strong>dynamic_cast运算符</strong></p><ul><li><p>dynamic_cast运算符可以在执行期决定真正的类型：</p><ul><li>如果downcast是安全的（也就是说，如果base type pointer指向一个derived class object），这个运算符会传回被适当转换过的指针。</li><li>如果downcast不是安全的，这个运算符会传回0。</li></ul></li><li><p>dynamic_cast是通过比较需转换指针指向的对象对应的类型描述器与需转换的类型是否相同，来保证安全性。</p></li><li><p>取得指针指向对象的对应类型描述器操作如下：</p><ul><li>type_info是C++Standard所定义的类型描述器的class名称，该class中放置着待索求的类型信息</li><li>virtual table 的第一个 slot 内含 type_info object 的地址；此type_info object与pt所指的class type有关</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230716144814752.png" alt="" style="zoom:67%;" /></li></ul><p><strong>在 dynamic_cast 中使用指针和引用的区别在于当转型失败时</strong>：</p><ul><li>指针版本会返回 0，使用者需要进行检查； </li><li>引用的版本会抛出一个 bad_cast exception（因为没有空引用）</li></ul><h3 id="Typeid运算符"><a href="#Typeid运算符" class="headerlink" title="Typeid运算符"></a>Typeid运算符</h3><ul><li><p>typeid运算符返回对象的type_info，其传回一个const reference，类型为type_info。</p></li><li><p>type_info 类型的 copy 构造函数和 operator&#x3D;操作符都被声明为私有，禁止了赋值和拷贝操作。 而且只提供了一个受保护的带有一个 const char *参数的构造函数，因为不能直接得到 type_info 对象，只能通过 typeid()运算符来得到这类对象。</p></li><li><p>可以使用typeid运算符先判断引用的类型，从而使得dynamic_cast引用时不抛出异常</p></li><li><p>RTTI 只适用于多态类型（RTTI 信息存于 vtable 的原因），事实上 type_info object 也适用 于非多态类型。</p><ul><li>typeid()使用于非多态类型时的差异在于，这时候的 type_info object 是<strong>静态</strong> 取得的（编译器直接给扩展了），而非像多态类型一样在执行期通过 vtable 动态取得。</li></ul></li></ul><h2 id="7-4-效率有了，弹性呢？"><a href="#7-4-效率有了，弹性呢？" class="headerlink" title="7.4 效率有了，弹性呢？"></a>7.4 效率有了，弹性呢？</h2><p>class的大小及其每一个直接（或继承而来）的members的偏移位置（offset）都在编译时期就已经固定（虚拟继承的members除外）。这虽然带来了效率，却在二进制层面（binary level）阻碍了弹性。如果 object 布局改变，应用程序就必须重新编译。</p><p>当一个shared library 被加载时，它在内存中的位置由runtime linker 决定。然而，在C++对象模型中，当一个动态的shared library支持一个class object，其中含有virtual functions（被放在shared memory中）时，想要经由这个shared object附着并调用一个virtual function”的第二个或更后继的进程，就会导致错误（没看太懂）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试问题</title>
      <link href="/2023/06/20/c++/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
      <url>/2023/06/20/c++/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>深度探索C++对象模型，阅读笔记</p><h1 id="迭代器失效情况"><a href="#迭代器失效情况" class="headerlink" title="迭代器失效情况"></a>迭代器失效情况</h1><p>参考<a href="https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers">1</a>、<a href="https://www.cnblogs.com/zhchoutai/p/8449786.html">2</a></p><p><strong>失效情况：</strong></p><ul><li><code>erase()</code><ul><li>当序列容器调用<code>erase()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效。<ul><li>C++03: deque在头尾删除，只会使得被删除迭代器和引用无效。而在其他位置删除会使得所有迭代器和引用都失效。c++11中有一点改变，见参考2.<ul><li>因为在其他位置删除或插入会移动之后或之后的元素，从而使得所有迭代器和引用失效。</li></ul></li></ul></li><li>当关联容器调用<code>erase()</code>方法后，只会使当前迭代器失效，不会造成其他迭代器失效</li></ul></li><li><code>insert()</code><ul><li>当序列容器调用<code>insert()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效。<ul><li>C++11: deque在头尾插入，可能会使得所有迭代器无效但引用不受影响（因为map可能重新分配空间）。而在其他位置插入会使得所有迭代器和引用都失效。</li></ul></li><li>当关联容器调用<code>insert()</code>方法后，，不会造成其他迭代器失效</li></ul></li><li>如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/qgST0.png" alt="qgST0"></p><h1 id="容器间的对比"><a href="#容器间的对比" class="headerlink" title="容器间的对比"></a>容器间的对比</h1><p><strong>vector 插入删除操作和list有什么区别</strong></p><ul><li>vector插入删除操作需要进行元素的移动，如果vector所存储的对象很大或者构造函数比较复杂，则开销较大，如果是简单的小数据效率优于list </li><li>list插入删除操作需要遍历当前数据，但在首部插入效率很高</li></ul><p><strong>什么情况下用list,什么情况下用vector</strong></p><ul><li>当数据对象简单，对象数量变化不大，需要频繁的随机访问时，用vector</li><li>当数据对象复杂，对象的数量频繁变化，频繁的进行插入和删除操作时，用list</li></ul><p><strong>deque和vector的区别</strong></p><ul><li>vector是单向开口的连续区间，deque是双向开口的连续区间（可以在头尾两端进行插入和删除操作）</li><li>deque提供随机访问迭代器，但是迭代器比vector复杂很多</li><li>deque没有提供空间保留功能，也就是没有capacity这个概念，而vector提供了空间保留功能。即vector有capacity和reserve函数，deque 和 list一样，没有这两个函数。</li></ul><p><strong>vector，list，deque对比</strong></p><ul><li>vector数据在内存中连续排列，所以随机存取元素的速度最快。但是在除尾部以外的位置删除或者添加元素的时候速度很慢</li><li>list数据是链式存储，不能随机存取。其优势在于在任意位置添加和删除元素</li><li>deque通过链接若干片连续的数据实现的，均衡了以上两容器的特点</li></ul><p><strong>hash_map和map的区别？什么时候用map,什么时候用hash_map</strong></p><ul><li>构造函数：hash_map需要hash function以及等于函数，map需要比较函数</li><li>存储结构：hash_map以hashtable为底层，map以红黑树为底层</li><li>查找速度：总体来说，hash_map查找速度比map快，而且查找速度基本和数据量的大小无关，属于常数级别；map的查找速度是(logn)级别。并不一定常数级别就比（logn）小，hash_map的hash function也会耗时</li><li>二者如何选择：如果考虑效率，特别是元素达到一定的数量级时，用hash_map；如果考虑内存，或者元素比较少时，用map</li></ul><p><strong>hashtable,hash_set,hash_map的区别</strong></p><ul><li>hash_set以hashtable为底层，不具有排序功能，能快速查找，其键值就是实值</li><li>hash_map以hashtable为底层，不具有自动排序功能，能快速查找，每一个元素同时拥有键值和实值</li></ul><p><strong>map和set的区别</strong></p><ul><li>相同点：map和set都是c++的关联容器，底层都是红黑树实现的</li><li>元素： map的元素是key-value（键值—实值）对，关键字起到索引的作用，值表示与索引相关联的数据；set的元素是键值，没有实值</li><li>迭代器：map的迭代器既不是const也不是mutable，map允许修改value实值，不允许修改key键值；set的迭代器是const的，不允许修改键值。其原因在于map和set是根据关键字来保证其有序性的，如果允许修改键值，那么首先要删除该键，调节平衡，然后再插入修改后的键值，调节平衡，这样一来破坏了map和set的结构，导致iterator失效。</li><li>下标操作：map支持下标操作，用关键字作为下标访问关键字对应的值，如果关键字不存在，他会自动将该关键字插入；set不支持下标操作</li></ul><h1 id="map和set的相关问题"><a href="#map和set的相关问题" class="headerlink" title="map和set的相关问题"></a>map和set的相关问题</h1><p>为什么map和set插入和删除效率比其他容器高？</p><ul><li>不需要内存的拷贝和移动</li></ul><p>为什么map和set每次insert后，以前保存的迭代器不会失效？</p><ul><li>因为插入操作只是节点的指针的交换，节点并没有改变，节点的内存没有改变，指向内存的指针也不会改变。（红黑树迭代器只是一个指向节点的指针，插入和删除不会改变节点内存，只可能改变节点的父子节点）</li></ul><p>当数据元素增多时（从10000增加到20000）,map和set的查找速度会怎样？</p><ul><li>二者的底层是基于红黑树来实现的，查找的时间复杂度为logn,数据量从10000增加到20000，查找的次数从log10000 &#x3D; 14 增加到 log20000 &#x3D; 15，只是增加了1次</li></ul><p>为什么map和set不能像vector一样有个reserve函数来预分配数据</p><ul><li>map和set内部存储的已经不是元素本身了，而是包含元素的一个节点。他们内部使用的配置器不是在声明的时候传入的alloc而是转换后的alloc。</li><li>个人认为应该是不需要做预分配，因为每插入一个节点直接申请内存即可，插入节点也不会影响原有迭代器</li></ul>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>407. 接雨水 II</title>
      <link href="/2023/06/20/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-407-%E6%8E%A5%E9%9B%A8%E6%B0%B4II-diffcult/"/>
      <url>/2023/06/20/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-407-%E6%8E%A5%E9%9B%A8%E6%B0%B4II-diffcult/</url>
      
        <content type="html"><![CDATA[<h1 id="407-接雨水-II"><a href="#407-接雨水-II" class="headerlink" title="407. 接雨水 II"></a><a href="https://leetcode.cn/problems/trapping-rain-water-ii/description/">407. 接雨水 II</a></h1><p>First：没做出来，和2D接雨水的按列求思路有点类似，但和单调栈差异巨大，因为单调栈只能处理2d的</p><hr><p><strong>方法1</strong>：<strong>最小堆</strong></p><p>在2d接雨水中，使用了左右两个最高墙，而此题就需要维护一个圈（不能只是简单上下左右四个方向）。</p><p>首先将最外围的柱子添加进最小堆中，然后弹出一个最小高度值，由于此柱子高度最低，水只可能往这流出，然后判断此柱子上下左右四个柱子，若已经遍历过则跳过，将其插入到最小堆中，其高度值应该为弹出柱子和当前柱子的最大值（相当于更新了围墙），若能装水则加到结果上。</p><p>使用一个vision数组来记录是否已经遍历</p><p>总结：水只可能从围墙的最低处流出，因此遍历最低处周围的柱子，并更新围墙。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    struct Node&#123;        int x_,y_,h_;        Node(int x,int y,int h):x_(x),y_(y),h_(h)&#123;&#125;        bool operator &lt; (const Node &amp;a) const&#123;            return h_&gt;a.h_;        &#125;    &#125;;public:    int trapRainWater(vector&lt;vector&lt;int&gt;&gt;&amp; heightMap) &#123;        if(heightMap.size()&lt;&#x3D;1) return 0;        int m&#x3D;heightMap.size(),n&#x3D;heightMap[0].size();        vector&lt;vector&lt;int&gt;&gt; vision(m,vector&lt;int&gt;(n,0));        priority_queue&lt;Node&gt; pq;        for(int i&#x3D;0;i&lt;m;++i)&#123;            for(int j&#x3D;0;j&lt;n;++j)&#123;                if(i&#x3D;&#x3D;0||i&#x3D;&#x3D;m-1||j&#x3D;&#x3D;0||j&#x3D;&#x3D;n-1)&#123;                    pq.push(&#123;i,j,heightMap[i][j]&#125;);                &#125;            &#125;        &#125;        int ans&#x3D;0;        while(!pq.empty())&#123;            Node t&#x3D;pq.top();            pq.pop();            auto func&#x3D;[&amp;](int x,int y)&#123;                if(x&gt;0&amp;&amp;x&lt;m-1&amp;&amp;y&gt;0&amp;&amp;y&lt;n-1&amp;&amp;vision[x][y]&#x3D;&#x3D;0)&#123;                    pq.push(&#123;x,y,max(t.h_,heightMap[x][y])&#125;);                    if(t.h_-heightMap[x][y]&gt;0) ans+&#x3D;t.h_-heightMap[x][y];                    vision[x][y]&#x3D;1;                &#125;            &#125;;            func(t.x_-1,t.y_);            func(t.x_+1,t.y_);            func(t.x_,t.y_-1);            func(t.x_,t.y_+1);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. 寻找两个正序数组的中位数</title>
      <link href="/2023/06/12/leetcode/%E6%95%B0%E7%BB%84/leetcode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-diffcult/"/>
      <url>/2023/06/12/leetcode/%E6%95%B0%E7%BB%84/leetcode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-diffcult/</url>
      
        <content type="html"><![CDATA[<h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">4. 寻找两个正序数组的中位数</a></h1><p>First：没做出来</p><hr><p><strong>方法1</strong>：<strong>二分查找</strong></p><p>参考<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/258842/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">1</a></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230612153408529.png" alt="image-20230612153408529"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230612153557096.png" alt="image-20230612153557096"></p><ul><li>时间复杂度：O(log(m+n))</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int getKthElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2,int k)&#123;        int m&#x3D;nums1.size(),n&#x3D;nums2.size();        int index1&#x3D;0,index2&#x3D;0;        while(1)&#123;            if(index1&#x3D;&#x3D;m)&#123;                return nums2[index2+k-1];            &#125;            if(index2&#x3D;&#x3D;n)&#123;                return nums1[index1+k-1];            &#125;            if(k&#x3D;&#x3D;1)&#123;                return min(nums1[index1],nums2[index2]);            &#125;            int newindex1&#x3D;min(index1+k&#x2F;2-1,m-1);            int newindex2&#x3D;min(index2+k&#x2F;2-1,n-1);            if(nums1[newindex1]&lt;&#x3D;nums2[newindex2])&#123;                k-&#x3D;newindex1-index1+1;                index1&#x3D;newindex1+1;                            &#125;else&#123;                k-&#x3D;newindex2-index2+1;                index2&#x3D;newindex2+1;            &#125;        &#125;    &#125;    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        double ans&#x3D;0;        int size&#x3D;nums1.size()+nums2.size();        if(size%2&#x3D;&#x3D;1)&#123;            ans&#x3D;getKthElement(nums1,nums2,(size+1)&#x2F;2);        &#125;else&#123;            int pre&#x3D;getKthElement(nums1,nums2,size&#x2F;2);            int last&#x3D;getKthElement(nums1,nums2,size&#x2F;2+1);            ans&#x3D;(pre+last)&#x2F;2.0;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP详解，卷1：协议阅读笔记</title>
      <link href="/2023/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71-%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCPIP%E8%AF%A6%E8%A7%A3%E5%8D%B71-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.52im.net/topic-tcpipvol1.html"><em>TCP&#x2F;IP详解，卷1：协议</em> </a>阅读笔记</p><h1 id="第1章-概-述"><a href="#第1章-概-述" class="headerlink" title="第1章 概 述"></a>第1章 概 述</h1><p><strong>基础知识</strong>：</p><ul><li>传输层协议TCP和UDP采用16 bit的端口号来识别应用程序，而知名的程序端口已被固定分配。</li><li>底层向上传送数据时，每层协议都要去检查报文首部中的协议标识，以确定接收数据的上层协议，这个过程称作分用<ul><li>例如IP协议中首部有个8bit的数字，表示上层协议名字，6表示TCP协议</li></ul></li><li>RFC(Request For Comment) 中TCP&#x2F;IP协议族每一层的稳健性原则：<strong>自由地接收，保守地发送</strong></li><li>网络层和运输层之间的区别：网络层（IP）提供点到点的服务，而运输层（TCP和UDP）提供端到端的服务。这也是为什么将网络层和运输层划分开的原因。</li></ul><p><strong>FTP发送消息示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230609202737930.png"></p><p>本书要讨论的协议</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230609113755572.png"></p><p><strong>几类IP地址</strong>（注意比较，网络号的规则是逐渐加一个字节）：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230609202849943.png"></p><h1 id="第2章-链路层"><a href="#第2章-链路层" class="headerlink" title="第2章 链路层"></a>第2章 链路层</h1><p>链路层主要有三个目的：、</p><ul><li>（1）为IP模块发送和接收IP数据报；</li><li>（2）为ARP模块发送ARP请求和接收ARP应答；</li><li>（3）为RARP发送RARP请求和接收RARP应答</li></ul><h2 id="2-1-以太网和IEEE-802封装"><a href="#2-1-以太网和IEEE-802封装" class="headerlink" title="2.1 以太网和IEEE 802封装"></a>2.1 以太网和IEEE 802封装</h2><p>以太网和IEEE802帧格式稍有不同：</p><ul><li>在802中，长度字段是指它后续数据的字节长度，但不包括CRC检验码，类型字段则由后续的子网接入协议的首部给出。以太网的类型字段定义了后续数据的类型。</li><li>802.3规定数据部分必须至少为38字节，而对于以太网，则要求最少要有46字节。为了保证这一点，必须在不足的空间插入填充（pad）字节。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620103016456.png"></p><h2 id="2-2-SLIP：串行线路IP"><a href="#2-2-SLIP：串行线路IP" class="headerlink" title="2.2 SLIP：串行线路IP"></a>2.2 SLIP：串行线路IP</h2><p><strong>SLIP协议帧格式</strong>：</p><ul><li>IP数据报以一个称作END（0xc0）的特殊字符结束。同时，为了防止数据报到来之前的线路噪声被当成数据报内容，大多数实现在数据报的开始处也传一个END字符（如果有线路噪声，那么END字符将结束这份错误的报文。这样当前的报文得以正确地传输，而前一个错误报文交给上层后，会发现其内容毫无意义而被丢弃）。</li><li>如果IP报文中某个字符为END，那么就要连续传输两个字节0xdb和0xdc来取代它。0xdb这个特殊字符被称作SLIP的ESC字符，但是它的值与ASCII码的ESC字符（0x1b）不同。</li><li>如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620104831921.png"></li></ul><p><strong>SLIP缺陷</strong>：</p><ul><li>每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。</li><li>数据帧中没有类型字段（类似于以太网中的类型字段）。如果一条串行线路用于SLIP，那么它不能同时使用其他协议。</li><li>SLIP没有在数据帧中加上检验和，只能通过上层协议来发现错误。因此IP首部和TCP首部及其数据始终都有检验和，UDP首部及其数据的检验和却是可选的。</li></ul><p><strong>压缩SLIP（SCLIP）</strong></p><ul><li>SLIP线路上有许多小的TCP分组进行交换，为了传送1个字节的数据需要20个字节的IP首部和20个字节的TCP首部，总数超过40个字节，整体效率很低</li><li>CSLIP一般能把上面的40个字节压缩到3或5个字节。它能在CSLIP的每一端维持多达16个TCP连接，并且知道其中每个连接的首部中的某些字段一般不会发生变化。</li></ul><h2 id="2-3-PPP：点对点协议"><a href="#2-3-PPP：点对点协议" class="headerlink" title="2.3 PPP：点对点协议"></a>2.3 PPP：点对点协议</h2><p>PPP，点对点协议修改了SLIP协议中的所有缺陷。PPP包括以下三个部分：</p><ol><li>在串行链路上封装IP数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式，还支持面向比特的同步链接。</li><li>建立、配置及测试数据链路的链路控制协议（LCP：Link Control Protocol）。它允许通信双方进行协商，以确定不同的选项。</li><li>针对不同网络层协议的网络控制协议（NCP：Network Control Protocol）体系。IP NCP允许双方商定是否对报文首部进行压缩，类似于CSLIP。</li></ol><p><strong>PPP帧格式</strong></p><ul><li><p>每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。</p></li><li><p>当遇到字符0x7e时，需连续传送两个字符：0x7d和0x5e，以实现标志字符的转义。当遇到转义字符0x7d时，需连续传送两个字符：0x7d和0x5d，以实现转义字符的转义。</p></li><li><p>利用链路控制协议，大多数的产品通过协商可以省略标志符和地址字段，并且把协议字段由2个字节减少到1个字节。PPP只增加了3个额外的字节：1个字节留给协议字段，另2个给CRC字段使用。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620113229094.png"></p></li></ul><p><strong>PPP优点</strong></p><ul><li>(1)PPP支持在单根串行线路上运行多种协议，不只是IP协议；</li><li>(2)每一帧都有循环冗余检验；</li><li>(3)通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；</li><li>(4)与CSLIP类似，对TCP和IP报文首部进行压缩；</li><li>(5)链路控制协议可以对多个数据链路选项进行设置。</li></ul><h2 id="2-4-环回接口"><a href="#2-4-环回接口" class="headerlink" title="2.4 环回接口"></a>2.4 环回接口</h2><p>大多数的产品都支持环回接口（Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过TCP&#x2F;IP进行通信。A类网络号127就是为环回接口预留的。根据惯例，大多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。</p><p>大多实现照样完成传输层和网络层的所有过程，只是当IP数据报离开网络层时把它返回给自己。</p><ul><li>传给环回地址（一般是127.0.0.1）的任何数据均作为IP输入。</li><li>传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是因为广播传送和多播传送的定义包含主机本身。</li><li>任何传给该主机IP地址的数据均送到环回接口。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620113700866.png"></p><h2 id="2-5-最大传输单元MTU"><a href="#2-5-最大传输单元MTU" class="headerlink" title="2.5 最大传输单元MTU"></a>2.5 最大传输单元MTU</h2><p>以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特性称作MTU ,最大传输单元。</p><p>如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大,那么IP层就需要进行分片（fragmentation），把数据报分成若干片，这样每一片都小于MTU。</p><p>点到点的链路层（如SLIP和PPP）的<strong>MTU并非指的是网络媒体的物理特性，而是一个逻辑限制</strong>，目的是为交互使用提供足够快的响应时间。</p><p><strong>路径MTU</strong>：两台通信主机路径中的最小MTU</p><h1 id="第3章-IP-网际协议"><a href="#第3章-IP-网际协议" class="headerlink" title="第3章 IP:网际协议"></a>第3章 IP:网际协议</h1><h2 id="3-1-IP首部"><a href="#3-1-IP首部" class="headerlink" title="3.1 IP首部"></a>3.1 <strong>IP首部</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230611190424255.png"></p><p>网络数据传输采用<strong>大端字节序</strong>，也称网络字节序（即先传输左边的高位）。IP首部各字段作用：</p><ul><li>首部长度：指首部占32 bit字（4字节）的数目。其是一个4比特字段，因此首部最长为60个字节。</li><li>服务类型（TOS）字段：包括一个3bit的优先权子字段（现已被忽略），4bit的TOS子字段和1bit未用位但必须置0。<ul><li>4bit的TO S分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4bit中只能置其中1bit。均为0则为一般服务。</li></ul></li><li>总长度字段：指整个IP数据报的长度，以字节为单位。利用首部长度字段，可以知道IP数据报中数据内容的起始位置和长度。<ul><li>以太网有最小帧长限制，需要对数据进行填充，因此必须有总长度字段才能知道IP数据包的内容。</li></ul></li><li>标识字段：唯一地标识主机发送的每一份数据报，每发送一份报文它的值就会加1。</li><li>片偏移：用于分片和重组</li><li>TTL：数据报可以经过的最多路由器数，每经过一个路由器此值减1</li><li>首部检验和：根据IP首部计算的检验和码（不包括数据，因为ICMP、TCP等均含有同时覆盖首部和数据的检验和码）<ul><li>检验和生成：把检验和字段置为0，对首部中每个16 bit进行二进制反码求和</li><li>检验和校验：校验也是对首部中每个16 bit进行二进制反码求和（包括检验字段），因此结果应该全为1.</li></ul></li><li>选项字段：可选时间戳等，是一个变长字段。一直都是以32 bit作为界限，在必要的时候插入值为0的填充字节</li></ul><h2 id="3-2-IP路由选择"><a href="#3-2-IP路由选择" class="headerlink" title="3.2 IP路由选择"></a>3.2 IP路由选择</h2><p>当IP层从TCP等或一个网络接口收到数据报并进行发送时，会先搜索路由表（每一份数据报都搜索）。</p><p>如果从网口收到数据，则检查目的IP地址是否为本机的IP地址之一或者IP广播地址，是则送到指定协议模块处理，不是则根据主机设定进行转发或丢弃（主机可以设定是否进行路由功能）</p><p>路由表中的每一项都包含以下信息：</p><ul><li>目的IP地址：一个主机地址或网络地址，由一个标志字段决定</li><li>下一站（或下一跳）路由器的IP地址，或者有直接连接的网络IP地址</li><li>标志：一个指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口</li><li>数据报的传输指定一个网络接口</li></ul><p>P路由选择是逐跳地进行的，IP并不知道到达任何目的的完整路径。IP路由选择规则：</p><ul><li>先寻找能与目的IP地址完全匹配的表目，若没找到则寻找能与目的网络号相匹配的表目，还是没找到则寻找标为“默认（default）”的表目。</li></ul><h2 id="3-3-子网掩码"><a href="#3-3-子网掩码" class="headerlink" title="3.3 子网掩码"></a>3.3 子网掩码</h2><p><strong>子网好处</strong>：可以将主机数巨大的地址空间划分为多个子网；由于划分子网对外界是透明的，因此相比将其分为C类地址，可以显著减少路由条目</p><p>子网掩码是一个32 bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230612155526100.png"></p><blockquote><p>0表示所有的比特位全为0；-1表示所有的比特位全为1；netid、subnetid和hostid分别表示不为全0或全1的对应字段。子网号栏为空表示该地址没有进行子网划分。</p></blockquote><h1 id="第4章-ARP-地址解析协议"><a href="#第4章-ARP-地址解析协议" class="headerlink" title="第4章 ARP:地址解析协议"></a>第4章 ARP:地址解析协议</h1><p>在链路层进行数据传输需要有硬件地址（一个48 bit的值），ARP为IP地址到对应的硬件地址之间提供动态映射。</p><p><strong>ARP高速缓存</strong>：每个主机上都有一个ARP高速缓存，存放了最近IP地址到硬件地址之间的映射记录，每一项的生存时间一般为20分钟。</p><p><strong>ARP请求或应答格式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230612161939294.png"></p><p>字段说明：</p><ul><li>以太网的源地址和目的地址：目的地址为全1，表示广播帧</li><li>帧类型：表示后面数据的类型，ARP该值为0x0806</li><li>硬件类型：表示硬件地址的类型，值为1即表示以太网地址</li><li>协议类型：表示要映射的协议地址类型，值为0x0800即表示IP地址</li><li>硬件地址长度和协议地址长度：分别指出硬件地址和协议地址的长度，以字节为单位。当为ARP时，值分别为6和4。</li><li>操作：四种操作类型，ARP请求（1）、ARP应答（2）、RARP请求（3）和RARP应答（4）</li><li>最后四个字段分别为发送接收端IP地址和以太网地址，注意这里硬件地址有所重复。</li></ul><p>ARP请求：除目的端硬件地址外的所有其他的字段都有填充值。</p><p>ARP接受：当系统收到一份目的端为本机的ARP请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为2，最后把它发送回去。（注意是处理请求部分，这里逻辑感觉有点不清楚，难道目的两个地址不进行更改？）</p><blockquote><p>如果查询的主机已关机或不存在，那么ARP会不断重传报文，如果超过时间限制则结束，而此时上层协议也会因超时等原因传输失败</p></blockquote><p><strong>ARP代理</strong>：如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求</p><ul><li>这样可以欺骗发起ARP请求的发送端，使它误以为路由器就是目的主机，而事实上目的主机是在路由器的“另一边”。路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。</li></ul><p><strong>免费ARP</strong>：指主机发送ARP查找自己的IP地址。通常发生在系统引导期间进行接口配置的时候。其作用如下：</p><ul><li>可以通过其来确定另一个主机是否设置了相同的IP地址。</li><li>如果发送免费ARP的主机正好改变了硬件地址，那么就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。</li></ul><h1 id="第5章-RARP-逆地址解析协议"><a href="#第5章-RARP-逆地址解析协议" class="headerlink" title="第5章 RARP:逆地址解析协议"></a>第5章 RARP:逆地址解析协议</h1><blockquote><p>具有本地磁盘的系统引导时，一般是从磁盘上的配置文件中读取IP地址。但是无盘机，如X终端或无盘工作站，则需要采用其他方法来获得IP地址。（为啥不用DHCP获取？引导镜像需要发送TFTP请求进行读取，可能DHCP较复杂）</p></blockquote><p><strong>RARP的分组格式</strong>：与ARP分组基本一致。主要差别是RARP请求或应答的帧类型代码为0x8035，且RARP请求的操作代码为3，应答操作代码为4。</p><ul><li>RARP请求以广播方式传送，而RARP应答一般是单播传送的（RAP应答也是单播）。</li><li>同样，RARP也会超时重发</li></ul><p>RARP服务器的复杂性在于</p><ul><li>由于需要提供硬件地址到IP地址的映射，而此映射一般在磁盘文件中。由于内核一般不读取和分析磁盘文件，因此RARP服务器的功能就由用户进程来提供</li><li>由于发送和接收这些数据帧与系统有关，因此RARP服务器的实现是与系统捆绑在一起的。</li></ul><h1 id="第11章-UDP-用户数据报协议"><a href="#第11章-UDP-用户数据报协议" class="headerlink" title="第11章 UDP:用户数据报协议"></a>第11章 UDP:用户数据报协议</h1><h2 id="11-1-UDP首部"><a href="#11-1-UDP首部" class="headerlink" title="11.1 UDP首部"></a>11.1 UDP首部</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230613151945659.png"></p><ul><li><p>端口号：表示发送和接收进程</p></li><li><p>UDP长度：指的是UDP首部和UDP数据的字节长度，最小值为8字节，因此可以发送一个0字节报文。且此字段是冗余的，可以通过IP长度字段求得此字段</p></li><li><p>UDP校验和：覆盖UDP首部和UDP数据。计算方法和IP首部校验相同，只是由于该算法是将16bit相加，不足处补0。</p><ul><li>且计算时还存在一个12字节长的伪首部，用于检查数据是否已经到达了正确的目的地<ul><li>比如IP头部的目的ip地址在传输过程中被错误的改变了，这个分组就会到达错误ip地址的主机。</li><li>比如IP头部的协议号被错误的改变了（本来是TCP，现在却错改成UDP），这个分组就会到达UDP协议栈，但实际上这个分组不应该被UDP处理。</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230613152618515.png" style="zoom:50%;" /></li></ul><h2 id="11-2-IP分片"><a href="#11-2-IP分片" class="headerlink" title="11.2 IP分片"></a>11.2 IP分片</h2><p>物理网络层一般要限制每次发送数据帧的最大长度，当IP数据报长度超过其MTU时，就会进行分片（发生在原始发送端或中间路由器）</p><p>当分片到达目的地才进行重新组装（是<strong>在下一站就进行重装</strong>，而不是最终目的地），重新组装由目的端的IP层来完成。</p><p>分片过程：</p><ul><li>每份IP数据报都有唯一标识，分片时会复制到分片中。</li><li>标志字段用其中一个比特来表示“更多的片”，除最后一片外该值都要置1</li><li>片偏移字段指的是该片偏移原始数据报开始处的位置（以8字节为单位）。当数据报被分片后，每个片的总长度值要改为该片的长度值。</li><li>标志字段中有一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片</li><li>注意，除最后一片外,其他片中的数据长度均要求为8字节的整数倍</li></ul><blockquote><p><strong>判断到达目的端的路途中最小MTU方法：</strong></p><ul><li>不断增大数据报长度，且在IP首部设置不分片（DF）的标志比特，那么当路由器遇见此种情况就会发送一个ICMP差错报文。</li></ul></blockquote><h2 id="11-3-UDP和ARP之间的交互作用"><a href="#11-3-UDP和ARP之间的交互作用" class="headerlink" title="11.3 UDP和ARP之间的交互作用"></a>11.3 UDP和ARP之间的交互作用</h2><p>当使用UDP发送一个8192字节的数据报（会产生6个分片），并将ARP缓存清空。此时会发生以下情况：</p><ul><li>由于产生分片速度更快，在第一个ARP请求未响应前，每个分片都会产生一个ARP请求，共产生6个请求。</li><li>在接收到第一个ARP应答时，只发送最后一个数据报片，看来似乎将前5个数据报片全都丢弃了<ul><li>这是ARP的正常操作。在大多数的实现中，在等待一个ARP应答时，只将最后一个报文发送给特定目的主机。</li></ul></li><li>还有一个无法解释的现象是会收到7个ARP解答，而不是6个</li></ul><h2 id="11-4-最大UDP数据报长度"><a href="#11-4-最大UDP数据报长度" class="headerlink" title="11.4 最大UDP数据报长度"></a>11.4 最大UDP数据报长度</h2><p>IP数据报的最大长度是65535字节，这是由IP首部16比特总长度字段所限制的。去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节。但真实UDP最大长度有以下限制：</p><ul><li>可能会受到其程序接口的限制，如设置接收和发送缓存的长度会影响最大UDP长度</li><li>另外的限制来自于TCP&#x2F;IP的内核实现。可能存在一些实现特性（或差错），使IP数据报长度小于65535字节。</li></ul><blockquote><p>UDP编程接口允许应用程序指定每次返回的最大字节数。如果接收到的数据报长度大于应用程序所能处理的长度，那么会发生什么情况呢？</p><ul><li>取决于编程接口和实现，有的会丢弃多余数据，有的超出部分数据在后面的读取中返回</li></ul></blockquote><h2 id="11-5-习题"><a href="#11-5-习题" class="headerlink" title="11.5 习题"></a>11.5 习题</h2><ol><li>为什么除最后一片外,其他片中的数据长度均要求为8字节的整数倍?<ul><li>因为片偏移量是以8字节为单位</li></ul></li><li>分片后再分片？<ul><li>可以进行，仍然以片偏移字段进行恢复，其值是指当前分片在最初IP数据报中的位置</li></ul></li><li>UDP数据报因分片直接收到1、2、3，而未接受到4。那么当重传时，原来的123片能否使用重传的4重组？<ul><li>不能，每个分片都有唯一标识</li></ul></li><li>TCP检验和差错被丢弃20个，但UDP检验和差错而被丢弃的数据报一份也没有。请说明两个方面的原因<ul><li>如果输出UDP的检验和没有被使用，就不会验证一个进入UDP的检验和</li><li>大多数的UDP通信量都是本地的，而不是WAN的，因此没有服从所有的WAN特征。</li></ul></li><li>分片时IP首部中的选项是否也要被复制到每个数据报片中，或者只留在第一个数据报片中？<ul><li>不严格的和严格的源站选路选项被复制到每一个数据报片中。</li><li>时间戳选项和记录路由选项没有被复制到每一个数据报片中—它们只出现在第1个数据报片中。</li></ul></li></ol><h1 id="第17章-TCP：传输控制协议"><a href="#第17章-TCP：传输控制协议" class="headerlink" title="第17章 TCP：传输控制协议"></a>第17章 TCP：传输控制协议</h1><p><strong>TCP提供一种面向连接的、可靠的字节流服务</strong></p><p>TCP通过下列方式来提供可靠性：</p><ul><li>应用数据被分割成TCP认为最适合发送的数据块。而UDP则保持应用产生的数据报长度不变。</li><li>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li><li>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒</li><li>TCP将检测它首部和数据的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段</li><li>TCP将对收到的数据进行重新排序，以正确的顺序交给应用层</li><li>IP数据报会发生重复，TCP的接收端必须丢弃重复的数据</li><li>TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</li></ul><h2 id="17-1-TCP的首部"><a href="#17-1-TCP的首部" class="headerlink" title="17.1 TCP的首部"></a>17.1 <strong>TCP的首部</strong></h2><p>如果不计任选字段，首部通常是20个字节</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230613200442824.png"></p><ul><li>端口号：用于寻找发端和收端应用进程<ul><li>一个IP地址和一个端口号也称为一个插口（socket）。插口对（socketpair）(包含客户IP地址、客户端口号、服务器IP地址和服务器端口号的四元组)可唯一确定互联网络中每个TCP连接的双方。</li></ul></li><li>序号：标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节<ul><li>序号超过最大值后会从0开始</li></ul></li><li>确认序号：发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加1。只有ACK标志为1时确认序号字段才有效。</li><li>首部长度：首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的，最多有60字节的首部（(2^4-1)*4)。</li><li>6个标志比特:<ul><li>URG：紧急指针有效</li><li>ACK：确认序号有效</li><li>PSH：接收方尽快将这个保温段交给应用层</li><li>RST：重建连接</li><li>SYN：同步序号用来发起一个链接</li><li>FIN：发端完成发送任务</li></ul></li><li>窗口大小：用于流量控制</li><li>检验和：覆盖了整个TCP报文段，是强制性的，由发端计算和存储，并由收端进行验证。TCP检验和的计算和UDP检验和的计算相似。</li><li>紧急指针：是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。只有当URG标志置1时紧急指针才有效。</li><li>可选字段：最常见的是最长报文大小，通常在连接建立时发送</li></ul><h2 id="17-2-习题"><a href="#17-2-习题" class="headerlink" title="17.2 习题"></a>17.2 <strong>习题</strong></h2><ol><li>各种协议检验和包括IP数据报中的哪些部分，以及该检验和是强制的还是可选的？<ul><li>除了UDP的检验和，其他都是必需的。IP检验和只覆盖了IP首部，而其他字段都包含首部和数据。</li></ul></li><li>为什么我们已经讨论的所有Internet协议（IP,ICMP,IGMP,UDP,TCP）收到有检验和错的分组都仅作丢弃处理？<ul><li>源IP地址、源端口号或者协议字段可能被破坏了</li></ul></li><li>TCP提供了一种字节流服务，而收发双方都不保持记录的边界。应用程序如何提供它们自己的记录标识？<ul><li>使用特定字符或数据长度</li></ul></li><li>为什么在TCP首部的开始便是源和目的的端口号？<ul><li>一个ICMP差错报文必须至少返回引起差错的IP数据报中除了IP首部的前8个字节。当TCP收到一个ICMP差错报文时，它需要检查两个端口号以决定差错对应于哪个连接。因此，端口号必须包含在TCP首部的前8个字节里。</li></ul></li><li>为什么TCP首部有一个首部长度字段而UDP首部中却没有？<ul><li>TCP首部的最后有一些选项，但UDP首部中没有选项。（但其实也能通过IP报文长度字段推导出来）</li></ul></li></ol><h1 id="第18章-TCP连接的建立与终止"><a href="#第18章-TCP连接的建立与终止" class="headerlink" title="第18章 TCP连接的建立与终止"></a>第18章 TCP连接的建立与终止</h1><p> TCP的状态变迁图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614161733356.png"></p><h2 id="18-1-连接建立"><a href="#18-1-连接建立" class="headerlink" title="18.1 连接建立"></a>18.1 连接建立</h2><p>建立一条TCP连接，即<strong>三次握手</strong>：</p><ol><li>请求端发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN）。这个SYN段为报文段1。<ul><li>ISN随时间而变化，可看作是一个32比特的计数器，每4ms加1（有的地方又写每0.5秒增加64000）</li></ul></li><li>服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个序号。</li><li>客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认（报文段3）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614160138378.png"></p><p><strong>连接建立超时</strong>：当发送请求长时间未收到应答则会重传，当重传一定次数或时间则结束此次请求</p><p><strong>最大报文段长度</strong>：在建立连接时，连接的双方都要通告各自的MSS（TCP的可选字段），如未收到则默认536字节。在没有分段发生情况下，通常越大越好。</p><h2 id="18-2-连接终止"><a href="#18-2-连接终止" class="headerlink" title="18.2 连接终止"></a>18.2 连接终止</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614170223488.png"></p><p><strong>半关闭</strong>：连接的一端在结束它的发送后还能接收来自另一端数据</p><ul><li>如果应用程序不调用close而调用shutdown，且第2个参数值为1，则插口的API支持半关闭</li><li>为什么要有半关闭？如RSH命令需要向远程传输数据并接受返回结果，如果没有半关闭功能，则还需要采取其他方式通知数据已经传输完毕。</li></ul><blockquote><p>当四次挥手时，如果收到一个SYN会如何处理？</p><ul><li>发送一个带ACK的SYN（进入SYN_RCVD）。然后如果收到一个RST，而不是一个ACK，便又回到LISTEN状态并等待另一个连接请求的到来</li></ul></blockquote><p><strong>2MSL等待状态</strong>：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）</p><ul><li>2MSL会使得该端口不可用，但可以使用SO_REUSEADDR来重用（注意，这是实现所支持的，但TCP不能允许一个新的连接建立在相同的插口对，即四元组）</li></ul><p><strong>平静时间</strong>：TCP在重启动后的MSL秒内不能建立任何连接，即为平静时间</p><p> <strong>FIN_WAIT_2状态</strong>：只有收到另一端的FIN，才会从FIN_WAIT_2状态进入TIME_WAIT状态，也就意味着可能永远保持这个状态。另一端也将处于CLOSE_WAIT状态，并一直保持这个状态直到应用层决定进行关闭。</p><ul><li>在实现中，如果进行全关闭，则设置一个定时器，如果这个连接空闲10分钟75秒，TCP将进入CLOSED状态。</li></ul><p><strong>复位报文段</strong>：无论何时一个报文段发往四元组连接出现错误，TCP都会发出一个复位报文段，注意收到RST不会产生任何响应。有如下情况：</p><ul><li>到不存在的端口的连接请求。例如UDP发送到一个未使用的端口，则产生ICMP信息；而TCP则使用复位。</li><li>异常终止一个连接。通常有以下优点：<ul><li>丢弃任何待发数据并立即发送复位报文段；</li><li>RST的接收方能区分另一端执行的是异常关闭还是正常关闭。</li></ul></li><li>检测半打开连接。<ul><li>如果一方已经关闭或异常终止连接而另一方却还不知道，这样的TCP连接称为半打开</li><li>例如因掉电而重启，服务端已经丢失原来连接信息，此时客户端发送一个消息，服务端则以复位作为应答。</li></ul></li></ul><p><strong>两方同时发送建立连接</strong>：这种情况只会建立一条连接（注意两方必须属于同一四元组）</p><ul><li>两端几乎在同时发送SYN，并进入SYN_SENT状态。</li><li>当每一端收到SYN时，状态变为SYN_RCVD，同时它们都再发SYN并对收到的SYN进行确认。</li><li>当双方都收到SYN及相应的ACK时，状态都变迁为ESTABLISHED。</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614192431876.png"></li></ul><p><strong>两方同时关闭连接</strong>：</p><ul><li><p>当应用层发出关闭命令时，两端均从ESTABLISHED变为FIN_WAIT_1</p></li><li><p>双方各发送一个FIN，双方收到FIN后，状态由FIN_WAIT_1变迁到CLOSING，并发送最后的ACK</p></li><li><p>当收到最后的ACK时，状态变化为TIME_WAIT（有点不太理解为啥不直接closed，此时已经接收到ack了，如果是为了保证对方能正确接收到ack，难道对方超时后会重新发送FIN吗）</p><blockquote><p>如果最后ack丢失怎么办？重新发送FIN？</p></blockquote></li></ul><p><strong>TCP选项</strong>：</p><ul><li>每个选项的开始是1字节kind字段，说明选项的类型。kind字段为0和1的选项仅占1个字节。其他的选项在kind字节后还有len字节。它说明的长度是指总长度，包括kind字节和len字节。</li><li>设置无操作选项的原因在于允许发方填充字段为4字节的倍数。</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230614195305445.png"></li></ul><blockquote><p><strong>习题</strong></p><ol><li>半打开连接和半关闭连接的区别是什么？<ul><li>在一个半关闭的连接上，一个端点已经发送了一个FIN，正等待另一端的数据或者一个FIN。一个半打开的连接是当一个端点崩溃了，而另一端还不知道的情况。</li></ul></li><li>如果启动sock程序作为一个服务器程序，然后终止它（还没有客户进程与它相连接），我们能立即重新启动这个服务器程序。这意味着它没有经历2MSL等待状态。<ul><li>一个连接只有经过了已建立状态才能进入2MSL等待状态。</li></ul></li><li>主动关闭方因超时而从FIN_WAIT_2变为CLOSED，如果此时被关闭方发送一个FIN，该如何处理？<ul><li>在一个已经关闭的连接上到达了一个FIN，会发送了一个复位报文（但如果还是TIME_WAIT状态则会重新开始2msl定时）。</li></ul></li><li>为什么服务器不将对客户FIN的ACK与自己的FIN合并，从而将报文段数减少为3个？<ul><li>服务器对客户的FIN的确认一般不会被延迟，而是在FIN到达后立即发送。</li><li>服务器收到客户的FIN后，并不一定要关闭它这一端的连接。</li></ul></li><li>假定MSL为120秒，试问系统能够初始化一个新连接然后进行主动关闭的最大速率是多少？<ul><li>最大数目的TCP端口号（65536-1024&#x3D;64512，忽略知名端口）除以TIME_WAIT状态的2MSL。</li></ul></li><li>分析处于TIME_WAIT状态的主机收到使其进入此状态的重复的FIN时所发生的情况<ul><li>重复的FIN会得到确认，2MSL定时器重新开始。</li></ul></li><li>分析处于TIME_WAIT状态的主机收到一个RST时所发生的情况。<ul><li>在TIME_WAIT状态中收到一个RST引起状态过早地终止，这就叫作TIME_WAIT断开。有RFC提出的简单的修改就是在TIME_WAIT状态时忽略RST段。</li></ul></li><li>在图1-8中，我们曾提到到来的TCP报文段可根据其目的端口号进行分用，请问这种说法是否正确？<ul><li>错误，只能根据四元组进行分用</li></ul></li></ol></blockquote><h1 id="第19章-TCP的交互数据流"><a href="#第19章-TCP的交互数据流" class="headerlink" title="第19章 TCP的交互数据流"></a>第19章 TCP的交互数据流</h1><p>通常TCP在接收到数据时并不立即发送ACK而是推迟发送，以便将ACK与需要沿该方向发送的数据一起发送。绝大多数实现TCP将以最大200 ms的时延等待是否有数据一起发送。在等待时，如果有数据则立即发送。</p><p><strong>Nagle算法</strong>：该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组（微小TCP报文），在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去<em>（TCP本来就是流，相当于积存较多的数据一起发送）</em>。</p><ul><li>有时也需要关闭Nagle算法。如小消息（鼠标移动）必须无时延地发送，</li></ul><p><strong>窗口大小通告</strong>：发送报文时会填写通告窗口大小，其值为当前缓冲区可用大小</p><h1 id="第20章-TCP的成块数据流"><a href="#第20章-TCP的成块数据流" class="headerlink" title="第20章 TCP的成块数据流"></a>第20章 TCP的成块数据流</h1><p><strong>滑动窗口</strong>：滑动窗口大小由对方指定的窗口值（和拥塞窗口中最小值）确定，因此可能会变大或变小</p><ul><li>称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。</li><li>当窗口右边沿向右移动时将允许发送更多的数据，称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时（此时报文中的窗口值变大）。</li><li>如果接收到一个指示窗口左边沿向左移动的ACK，则它被认为是一个重复ACK</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230615194408439.png"></p><p><strong>PUSH标志</strong>：使用该标志通知接收方将所收到的数据全部提交给接收进程。这里的数据包括与PUSH一起传送的数据以及接收方TCP已经为接收进程收到的其他数据。</p><ul><li>如果待发送数据将清空发送缓存，则大多数的源于伯克利的实现能够自动设置PUSH标志。而源于伯克利的实现一般从不将接收到的数据推迟交付给应用程序</li></ul><p><strong>慢启动</strong>：慢启动为发送方的TCP增加了拥塞窗口，记为cwnd。拥塞窗口被初始化为1个报文段（连接建立时发送的MSS值），每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加），因此经过一次RTT，cwnd会倍增。<strong>发送方取拥塞窗口与通告窗口中的最小值作为发送上限。</strong></p><ul><li>拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。</li></ul><p><strong>带宽时延乘积</strong>：一般窗口等于带宽时延积较好，如果小于则不能充分利用带宽，大于则好像浪费？</p><ul><li>时延是指往返时间。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230615204904420.png"></p><p><strong>紧急方式</strong>：它使一端可以告诉另一端有些具有某种方式的“紧急数据”已经放置在普通的数据流中。可以通过设置TCP首部URG比特为1，并且一个16bit的紧急指针被置为一个正的偏移量（该偏移量必须与TCP首部中的序号字段相加，以便得出紧急数据的<em>最后一个字节</em>的序号）</p><ul><li>作用：可以在滑动窗口为0时，通过发送紧急指针和URG标志来将紧急信息发给对方，使得对方能优先接收处理。</li><li>例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行。因此用户从键盘发出中断命令（Ctrl+C）。如果不使用紧急指针数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用程序。</li></ul><blockquote><p><strong>习题</strong></p><ol><li>如果API提供一种方法，使得发送方可以告诉其TCP打开PUSH标志，而接收方可以查询一个接收的报文段是否被设置了PUSH标志，试问该标志能否被用作一个记录标记？<ul><li>不，因为TCP超时之后可能重新对数据进行分组</li></ul></li><li>在一个Usenet记录中，有人抱怨说美国和日本之间的一个128 ms时延、速率为256 000 b&#x2F;s的链路吞吐量为120 000 b&#x2F;s（利用率为47%），而当链路通过卫星时其吞吐量则为33 000 b&#x2F;s（利用率为13％）。试问在这两种情况下窗口大小各为多少（假定卫星链路的时延为500 ms）？卫星链路的窗口大小应该如何调整？<ul><li>第一种情况是1920字节，卫星的情况是2062字节。直接将吞吐量和时延相乘即可。</li></ul></li></ol></blockquote><h1 id="第21章-TCP的超时与重传"><a href="#第21章-TCP的超时与重传" class="headerlink" title="第21章 TCP的超时与重传"></a>第21章 TCP的超时与重传</h1><p>TCP通过在发送时设置一个定时器来解决这种问题，当定时器溢出时还没有收到确认，它就重传该数据。通常重传时间每失败一次都会倍增，如2、4、8。</p><ul><li><p>当超时发生，先使用以下公式计算一个避退指数，一般A为0，D为当前RTT的一半。因此下一次超时时间为2*RTO，再下一次是4 *RTO</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230619172145792.png"></p></li><li><p>但是在习题21.1中给的答案又非如此，如第一次6，第二次2*6&#x3D;12，第三次4 *12&#x3D;48（可见答案，可能答案错误）。</p></li></ul><p>对每个连接，TCP管理4个不同的定时器：</p><ul><li>重传定时器使用于当希望收到另一端的确认。</li><li>坚持(persist)定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。第22章讨论。</li><li>保活(keepalive)定时器可检测到一个空闲连接的另一端何时崩溃或重启。</li><li>2MSL定时器测量一个连接处于TIME_WA IT状态的时间。</li></ul><h2 id="21-1-往返时间测量"><a href="#21-1-往返时间测量" class="headerlink" title="21.1 往返时间测量"></a>21.1 <strong>往返时间测量</strong></h2><ul><li><p>M为RTT，<em>A</em>是被平滑的RTT，D则是被平滑的均值偏差，<em>Err</em>是刚得到的测量结果与当前的RTT估计器之差。<em>A</em>和<em>D</em>均被用于计算下一个重传时间（RTO）。增量g起平均作用，取为1&#x2F;8（0.125）。偏差的增益是<em>h</em>，取值为0.25。当RTT变化时，较大的偏差增益将使<em>RTO</em>快速上升。</p></li><li><p>变量<em>A</em>和<em>D</em>分别被初始化为0和3秒</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230616114652804.png"></p></li><li><p>注意，每个时间只有一个定时器进行测量，例如报文3启动一个定时器，而在报文3的确认为返回前，其他报文都不会启动定时器（也就不测量往返时间）。有的实现中，测量时间值并非真实往返值，而是时钟滴答次数（见21.4.1）</p></li></ul><blockquote><p>分组重传，然后收到一个确认。那么这个ACK是针对第一个分组的还是针对第二个分组呢？</p><p><strong>Karn算法</strong>：</p><ul><li>对于超时重传的数据报的确认，不更新RTT。</li><li>重传的情况下，採用“指数退避”的方式。当第一次超时时，使用上面的公式计算一个初始避退指数，然后每超时一次则避退倍乘，下一次传送就使用这个避退指数。</li><li>重传数据确认之后。再次发送的数据假设正常被确定，则使用重传之前的RTO进行更新。</li></ul></blockquote><h2 id="21-2-拥塞避免算法"><a href="#21-2-拥塞避免算法" class="headerlink" title="21.2 拥塞避免算法"></a>21.2 <strong>拥塞避免算法</strong></h2><ul><li><p>拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点。</p></li><li><p>拥塞避免算法和慢启动算法需要对每个连接维持两个变量：一个拥塞窗口<em>cwnd</em>和一个慢启动门限<em>ssthresh</em>。这样得到的算法的工作过程如下：</p><ul><li>对一个给定的连接，初始化<em>cwnd</em>为1个报文段（连接建立时发送的MSS值），<em>ssthresh</em>为65535个字节。</li><li>TCP的输出不能超过<em>cwnd</em>和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。</li><li>当拥塞发生时（超时或收到重复确认），<em>ssthresh</em>被设置为当前窗口大小的一半（<em>cwnd</em>和接收方通告窗口大小的最小值，但<em>最少为2个报文段</em>）。此外，如果是超时引起了拥塞，则<em>cwnd</em>被设置为1个报文段（这就是慢启动）。</li><li>当新的数据被对方确认时，就增加<em>cwnd</em>。如果<em>cwnd</em>小于或等于<em>ssthresh</em>，则正在进行慢启动，否则正在进行拥塞避免。慢启动一直持续到回到当拥塞发生时所处位置的半时候才停止，然后转为执行拥塞避免。</li><li>拥塞避免算法每收到一个ACK确认时将<em>cwnd</em>增加1&#x2F;<em>cwnd</em>（cwnd指的是报文段个数），而慢启动则是大致增加一个报文段MSS；</li></ul><blockquote><p>查看21.8拥塞实例解开了许多疑惑</p><ul><li>cwnd指的是报文段MSS个数，但实现中使用的是字节，因此算法中都是指MSS个数</li><li>慢启动时，每收到一个ACK，cwnd则+1，一次RTT会发送cwnd个报文段，因此cwnd会倍增</li><li>拥塞避免时，没收到一个ACK，cwnd增加1&#x2F;cwnd，同理一次RTT后，cwnd加1，也就增加一个报文段。<ul><li>计算公式如下，这公式中的cwnd指的字节，而非报文段个数。但没弄明白为啥会有segsize&#x2F;8，网上解释是这只是一个补充量，不在算法描述横纵。</li><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230619163800347.png"></li></ul></li></ul></blockquote></li></ul><h2 id="21-3-快速重传与快速恢复算法"><a href="#21-3-快速重传与快速恢复算法" class="headerlink" title="21.3 快速重传与快速恢复算法"></a>21.3 <strong>快速重传与快速恢复算法</strong></h2><ul><li>如果一连串收到3个或3个以上的重复ACK，就非常可能是一个报文段丢失了。于是就重传丢失的数据报文段，这就是快速重传算法。接下来执行的不是慢启动算法而是拥塞避免算法，这就是快速恢复算法。</li><li>具体算法流程如下：<ul><li>当收到第3个重复的ACK时，将<em>ssthresh</em>设置为当前拥塞窗口<em>cwnd</em>的一半。设置<em>cwnd</em>为<em>ssthresh</em>加上3倍的报文段大小（MSS）。</li><li>每次收到另一个重复的ACK时，<em>cwnd</em>增加1个报文段大小并发送1个分组（如果新的<em>cwnd</em>允许发送）。</li><li>当下一个确认新数据的ACK到达时，设置<em>cwnd</em>为<em>ssthresh</em>（在第1步中设置的值）。这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。</li></ul></li></ul><blockquote><p>当一个TCP连接关闭时，如果已经发送了16个窗口的数据，即得到16个RTT采样，那么被平滑的RTT、被平滑的均值偏差以及慢启动门限保存在路由表项中以备下次使用，下次就使用这些值进行初始化。</p></blockquote><h2 id="21-4-ICMP的差错处理"><a href="#21-4-ICMP的差错处理" class="headerlink" title="21.4 ICMP的差错处理"></a>21.4 <strong>ICMP的差错处理</strong></h2><ul><li>一个接收到的源站抑制引起拥塞窗口<em>cwnd</em>被置为1个报文段大小来发起慢启动，但是慢启动门限<em>ssthresh</em>没有变化，所以窗口将打开直至它或者开放了所有的通路（受窗口大小和往返时间的限制）或者发生了拥塞。</li><li>一个接收到的主机不可达或网络不可达实际上都被忽略，因为这两个差错都被认为是短暂现象。（这有可能是由于中间路由器被关闭而导致选路协议要花费数分钟才能稳定到另一个替换路由）</li></ul><p><strong>重新分组</strong></p><ul><li>当TCP超时并重传时，不一定要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能（不能够超过接收方声明的MSS）。</li></ul><p>参考<a href="https://blog.csdn.net/weixin_52244492/article/details/124274114">1</a></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230619164538648.png"></p><h1 id="第22章-TCP的坚持定时器"><a href="#第22章-TCP的坚持定时器" class="headerlink" title="第22章 TCP的坚持定时器"></a>第22章 TCP的坚持定时器</h1><p>当发送方窗口为0时，如果接收方更新窗口大小的ACK报文丢失（TCP不对ACK报文段进行确认），则双方就有可能因为等待对方而使连接终止：</p><ul><li>接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新。</li></ul><p>为防止这种死锁情况的发生，发送方使用一个坚持定时器来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为<strong>窗口探查</strong>。</p><ul><li>探查每隔60秒发送一次，这个过程将持续到或者窗口被打开，或者应用进程使用的连接被终止。</li></ul><p><strong>糊涂窗口综合症</strong>：其现象是交换的数据段大小不是全长而是一些较小的数据。由于每个数据段的有用数据（数据部分）较少，因而消耗的资源也更多，相应的传输效率也更低。</p><ul><li>产生原因：接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告），而发送方也可以发送少量的数据（而不是等待其他的数据以便发送一个大的报文段）。</li><li>解决办法：<ul><li>接收端：接收方不通告小窗口。通常的算法是接收方不通告一个比当前窗口大的窗口（可以为0），除非窗口可以增加一个报文段大小（也就是将要接收的MSS）或者可以增加接收方缓存空间的一半，不论实际有多少。</li><li>发送端：只有以下条件之一满足时才发送数据：(a)可以发送一个满长度的报文段；(b)可以发送至少是接收方通告窗口大小一半的报文段；(c)可以发送任何数据并且不希望接收ACK（也就是说，没有还未被确认的数据）或者该连接上不能使用Nagle算法</li></ul></li></ul><h1 id="第23章-TCP的保活定时器"><a href="#第23章-TCP的保活定时器" class="headerlink" title="第23章 TCP的保活定时器"></a>第23章 TCP的保活定时器</h1><p>保活并不是TCP规范中的一部分，但许多实现提供了保活计时器。</p><p>服务器向客户发送一个探查报文段，客户主机必须处于以下4个状态之一：</p><ul><li>客户主机依然正常运行，并从服务器可达。服务器在两小时以后将保活定时器复位。如果交换了数据，则定时器在交换数据后的未来2小时再复位。</li><li>客户主机已经崩溃，并且关闭或者正在重新启动。服务器将不能够收到对探查的响应，并在75秒后超时。服务器总共发送10个这样的探查，每个间隔75秒。认为客户主机已经关闭并终止连接。</li><li>客户主机崩溃并已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。</li><li>客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。</li></ul><p>保活功能：</p><ul><li>优点：激活keepalive选项比显式地编写应用程序探测报文更容易；keepalive探测报文比应用程序探测报文占用更少的网络带宽（因为keepalive探测报文和应答不包含任何数据)；如果连接不是空闲的，就不会发送探测报文。</li><li>缺点：keepalive选项可能会由于一个临时性的网络中断而引起一个非常好的连接断开；发送探测报文的间隔（2小时）一般不可以根据应用程序进行配置；会耗费带宽</li></ul><h1 id="第24章-TCP的未来和性能"><a href="#第24章-TCP的未来和性能" class="headerlink" title="第24章 TCP的未来和性能"></a>第24章 TCP的未来和性能</h1><h2 id="24-1-路径MTU发现"><a href="#24-1-路径MTU发现" class="headerlink" title="24.1 路径MTU发现"></a>24.1 路径MTU发现</h2><p><strong>TCP的路径MTU发现过程：</strong></p><ul><li>在连接建立时，TCP使用输出接口或对端声明的MSS中的最小MTU作为起始的报文段大小。路径MTU发现不允许TCP超过对端声明的MSS。如果对端没有指定一个MSS，则默认为536。</li><li>在该连接上的所有被TCP发送的IP数据报都将被设置DF比特。如果某个中间路由器需要对一个设置了DF标志的数据报进行分片，它就丢弃这个数据报，并产生一个ICMP的“不能分片”差错。</li><li>如果收到这个ICMP差错，TCP就减少段大小并进行重传。如果路由器产生的是一个较新的该类ICMP差错，则报文段大小被设置为下一跳的MTU减去IP和TCP的首部长度。如果是一个较旧的该类ICMP差错，则必须尝试下一个可能的最小MTU。<strong>当由这个ICMP差错引起的重传发生时，拥塞窗口不需要变化，但要启动慢启动。</strong></li></ul><p><strong>分组大小选择</strong>：并非越大越好，因为路由器需要接收整个分组才会进行发送，如果过大则导致接受分组耗时过多。当分组足够大也就和报文交换类似，这也是报文交换的缺点。</p><h2 id="24-2-长肥管道"><a href="#24-2-长肥管道" class="headerlink" title="24.2 长肥管道"></a>24.2 长肥管道</h2><p>具有大的带宽时延乘积的网络被称为长肥网络（Long Fat Network），其会出现以下问题：</p><ol><li>TCP首部中窗口大小为16 bit，从而将窗口限制在65535个字节内。窗口扩大选项可以解决这个问题。</li><li>在一个长肥网络LFN内的分组丢失会使吞吐量急剧减少。如果只有一个报文段丢失，利用快速重传和快速恢复算法来使管道避免急剧减少。但是即使使用这些算法，在一个窗口内发生的多个分组丢失也会典型地使管道急剧减少</li><li>TCP实现对每个窗口的RTT仅进行一次测量。它们并不对每个报文段进行RTT测量。在一个长肥网络LFN上需要更好的RTT测量机制</li><li>TCP对每个字节数据使用一个32 bit无符号的序号来进行标识，长肥管道足够快以至于在不到一个MSL的时候序号就发生了回绕。使用TCP的时间戳选项的PAWS(Protection Against Wrapped Sequence numbers)算法解决。</li></ol><h2 id="24-3-窗口扩大选项"><a href="#24-3-窗口扩大选项" class="headerlink" title="24.3 窗口扩大选项"></a>24.3 窗口扩大选项</h2><p>窗口扩大选项使TCP的窗口定义从16 bit增加为32 bit。通过定义一个一字节的移位记数器实现对16 bit的扩大操作来完成的。于是TCP在内部将实际的窗口大小维持为32 bit的值（最大的窗口是65535×2^14，而不是2 ^16×2 ^14，）。</p><p>算法过程：</p><ul><li>这个选项只能够出现在一个SYN报文段中，因此当连接建立起来后，在每个方向的扩大因子是固定的。</li><li>为了使用窗口扩大，两端必须在它们的SYN报文段中发送这个选项。主动建立连接的一方在其SYN中发送这个选项，但是被动建立连接的一方只能够在收到带有这个选项的SYN之后才可以发送这个选项。每个方向上的扩大因子可以不同。</li><li>如果主动连接的一方发送一个非零的扩大因子，但是没有从另一端收到一个窗口扩大选项，它就将发送和接收的移位记数器置为0。这就实现了新旧系统的兼容。</li><li>假定发送移位记数为S，而接收移位记数则为R。从另一端收到的每一个16 bit的通告窗口将被左移R位以获得实际的通告窗口大小。每次当我们向对方发送一个窗口通告的时候，我们将实际的32 bit窗口大小右移S比特，然后用它来替换TCP首部中的16 bit的值。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230619203724446.png"></p><h2 id="24-4-时间戳选项"><a href="#24-4-时间戳选项" class="headerlink" title="24.4 时间戳选项"></a>24.4 时间戳选项</h2><p>时间戳选项使发送方在每个报文段中放置一个32 bit的时间戳值。接收方在确认中返回这个数值，从而允许发送方为每一个收到的ACK计算RTT。</p><p>在连接建立阶段，主动发起连接的一方在它的SYN中指定选项。只有在它从另一方的SYN中收到了这个选项之后，该选项才会在以后的报文段中进行设置。</p><blockquote><p><strong>如果接收方发送一个确认了两个报文段的ACK，那么哪一个收到的时间戳应当放入回显应答字段中来发回去呢？</strong></p></blockquote><p>解决方法：对于每个连接只保持一个时间戳的数值。选择何时更新这个数值的算法非常简单：</p><ol><li>TCP跟踪下一个ACK中将要发送的时间戳的值（一个名为<em>tsrecent</em>的变量）以及最后发送的ACK中的确认序号（一个名为<em>lastack</em>的变量）。这个序号就是接收方期望的序号。</li><li>当一个包含有字节号<em>lastack</em>的报文段到达时，则该报文段中的时间戳被保存在<em>tsrecent</em>中。</li><li>无论何时发送一个时间戳选项，<em>tsrecent</em>就作为时间戳回显应答字段被发送，而序号字段被保存在<em>lastack</em>中。</li><li>简单来说：接收方采用包含最后确认的报文段的时间戳发送</li></ol><h2 id="24-5-PAWS：防止回绕的序号"><a href="#24-5-PAWS：防止回绕的序号" class="headerlink" title="24.5 PAWS：防止回绕的序号"></a>24.5 PAWS：防止回绕的序号</h2><p>假定使用了时间戳选项，发送方指定的时间戳对每个将要发送的窗口加1</p><p>PAWS算法不需要在发送方和接收方之间进行任何形式的时间同步。接收方所需要的就是时间戳的值应该单调递增，并且每个窗口至少增加1。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>470. 用 Rand7() 实现 Rand10()</title>
      <link href="/2023/06/01/leetcode/other/leetcode-470-%E7%94%A8Rand7()%20%E5%AE%9E%E7%8E%B0%20Rand10()-middle/"/>
      <url>/2023/06/01/leetcode/other/leetcode-470-%E7%94%A8Rand7()%20%E5%AE%9E%E7%8E%B0%20Rand10()-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="470-用-Rand7-实现-Rand10"><a href="#470-用-Rand7-实现-Rand10" class="headerlink" title="470. 用 Rand7() 实现 Rand10()"></a><a href="https://leetcode.cn/problems/implement-rand10-using-rand7/description/">470. 用 Rand7() 实现 Rand10()</a></h1><p>FIrst：没做出来，有个固定公式</p><hr><p><strong>方法1</strong>：</p><p>直接将两个rand7加或乘会导致得到的数字概率不一样，因此需要找到一种求得概率相同的方法：(rand_X() - 1) × Y + rand_Y() &#x3D;&#x3D;&gt; 可以等概率的生成[1, X * Y]范围的随机数。</p><p>这里就使用(rand7()-1)*7+rand7()来生成1~49的随机数，但直接求10的余数会导致概率不等，因此需要拒绝大于40的数。</p><p>进一步优化：通过减少需要拒绝的数从而减少拒绝概率，以致于少调用rand7.</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int rand10() &#123;        int ans&#x3D;41;        while(1)&#123;            ans&#x3D;(rand7()-1)*7+rand7();            if(ans&lt;&#x3D;40) return ans%10+1;        &#125;                return 0;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>减少rand7调用的优化代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rand10</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">41</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token operator">=</span><span class="token punctuation">(</span><span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">7</span><span class="token operator">+</span><span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token operator">&lt;=</span><span class="token number">40</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token operator">%</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            ans<span class="token operator">-=</span><span class="token number">40</span><span class="token punctuation">;</span> <span class="token comment">//rand9</span>            ans<span class="token operator">=</span><span class="token punctuation">(</span>ans<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">7</span><span class="token operator">+</span><span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//rand63</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token operator">&lt;=</span><span class="token number">60</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token operator">%</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            ans<span class="token operator">-=</span><span class="token number">60</span><span class="token punctuation">;</span> <span class="token comment">//rand3</span>            ans<span class="token operator">=</span><span class="token punctuation">(</span>ans<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">7</span><span class="token operator">+</span><span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//rand21</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token operator">&lt;=</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token operator">%</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HJ16 购物单</title>
      <link href="/2023/04/18/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/HJ-16-%E8%B4%AD%E7%89%A9%E5%8D%95-middle/"/>
      <url>/2023/04/18/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/HJ-16-%E8%B4%AD%E7%89%A9%E5%8D%95-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="HJ16-购物单"><a href="#HJ16-购物单" class="headerlink" title="HJ16 购物单"></a><a href="https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=37&difficulty=&judgeStatus=&tags=&title=&gioEnter=menu"><strong>HJ16</strong> <strong>购物单</strong></a></h1><p>First：做了快两个小时，但还是有个测试用例没过。开始读题时还以为有一个物品数量限制。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>和01背包类似，只是此题多了一个条件，即必须选了主件才能选附件且每个物品只能选一次，解决办法就是将主件和附件可能的组合都列举出来，由于只能选一次，那么遍历组合得到dp最大的。</p><p>使用二维dp数组来记录状态，dp[i] [j] 表示i个物品（主件才算一个物品）j元满意度最大值。</p><p>01背包中，每个物品只需判断一次即可，而此题中每个物品会有多种组合，因此需要判断多次，找到最大值即可。</p><p>初始值皆为0</p><p>从上到下从左到右遍历</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123;    int N, m;    while (cin &gt;&gt; N &gt;&gt; m) &#123; &#x2F;&#x2F; 注意 while 处理多个 case        vector&lt;vector&lt;int&gt;&gt; prices(m,vector&lt;int&gt;(4,-1));        vector&lt;vector&lt;int&gt;&gt; values(m,vector&lt;int&gt;(4,0));        for(int i&#x3D;0;i&lt;m;++i)&#123;            int a,b,c;            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;                  a&#x2F;&#x3D;10;                  if(c&#x3D;&#x3D;0) &#123;                prices[i][0]&#x3D;a;                values[i][0]&#x3D;b;            &#125;            else &#123;                int idx&#x3D;prices[c-1][1]&#x3D;&#x3D;-1?1:2;                prices[c-1][idx]&#x3D;a;                values[c-1][idx]&#x3D;b;            &#125;                    &#125;        vector&lt;vector&lt;int&gt;&gt; pricesN,valuesN;        for(int i&#x3D;0;i&lt;prices.size();++i)&#123;                        if(prices[i][0]&#x3D;&#x3D;-1) continue;            vector&lt;int&gt; pricesTem,valuesTem;            pricesTem.push_back(prices[i][0]);            valuesTem.push_back(prices[i][0]*values[i][0]);            if(prices[i][1]!&#x3D;-1)&#123;                pricesTem.push_back(prices[i][0]+prices[i][1]);                valuesTem.push_back(prices[i][0]*values[i][0]+prices[i][1]*values[i][1]);            &#125;            if(prices[i][2]!&#x3D;-1)&#123;                pricesTem.push_back(prices[i][0]+prices[i][2]);                valuesTem.push_back(prices[i][0]*values[i][0]+prices[i][2]*values[i][2]);                pricesTem.push_back(prices[i][0]+prices[i][1]+prices[i][2]);                valuesTem.push_back(prices[i][0]*values[i][0]+prices[i][1]*values[i][1]+prices[i][2]*values[i][2]);            &#125;            pricesN.push_back(pricesTem);            valuesN.push_back(valuesTem);        &#125;        &#x2F;&#x2F; for(int i&#x3D;0;i&lt;pricesN.size();++i)&#123;        &#x2F;&#x2F;     for(int j&#x3D;0;j&lt;pricesN[i].size();++j)&#123;        &#x2F;&#x2F;         cout&lt;&lt;pricesN[i][j]&lt;&lt;&quot; &quot;&lt;&lt;valuesN[i][j]&lt;&lt;endl;        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; &#125;        N&#x2F;&#x3D;10;        vector&lt;vector&lt;int&gt;&gt; dp(pricesN.size()+1,vector&lt;int&gt;(N+1,0));        for(int i&#x3D;1;i&lt;&#x3D;pricesN.size();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;N;++j)&#123;                for(int k&#x3D;0;k&lt;pricesN[i-1].size();++k)&#123;                        if(j&gt;&#x3D;pricesN[i-1][k])                                         dp[i][j]&#x3D;max(max(dp[i-1][j],dp[i-1][j-pricesN[i-1][k]]+valuesN[i-1][k]),dp[i][j]);                &#125;                     &#x2F;&#x2F; cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;            &#125;            &#x2F;&#x2F; cout&lt;&lt;endl;        &#125;        cout&lt;&lt;dp[pricesN.size()][N]*10&lt;&lt;endl;    &#125;&#125;&#x2F;&#x2F; 64 位输出请用 printf(&quot;%lld&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此用例还未通过：</p><pre class="line-numbers language-none"><code class="language-none">4500 12100 3 0400 5 0300 5 01400 2 0500 2 0800 2 41400 5 4300 5 01400 3 8500 2 01800 4 0440 5 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确值为16700</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>887. 鸡蛋掉落</title>
      <link href="/2023/04/17/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD-difficult/"/>
      <url>/2023/04/17/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a><a href="https://leetcode.cn/problems/super-egg-drop/description/">887. 鸡蛋掉落</a></h1><p>First：没做出来</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>此题是在知道鸡蛋个数和层数确定f最小操作次数，可以转换下思路，若知道操作次数和鸡蛋个数能确定多大的层数，选择满足层数要求的最小操作次数即可。</p><p>使用二维dp数组来记录状态，dp[i] [j]表示i个操作次数和j个鸡蛋情况能确定的最大层数。</p><p>dp[i] [j]如果在某一层抛出，只会有两种结果：鸡蛋碎了，此时f一定在此层下面，因此用剩余的操作次数和鸡蛋可以在下面确定dp[i-1] [j-1]层；如果没碎，说明f在此层上面，因此用剩余的操作次数和鸡蛋可以在上面确定dp[i-1] [j]层。因此dp[i] [j]&#x3D;1+dp[i-1] [j-1] +dp[i-1] [j]。</p><p>由dp定义可知，dp[1] [k]皆为1，dp[k] [1]皆为k，其余初始化为0；</p><p>从递推公式可以看出是从上到下从左到右进行遍历</p><ul><li>时间复杂度：O(kn) </li><li>空间复杂度：O(kn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int superEggDrop(int k, int n) &#123;        int t&#x3D;n;&#x2F;&#x2F;t为操作次数        vector&lt;vector&lt;int&gt;&gt; dp(t+1,vector&lt;int&gt;(k+1,0));        for(int i&#x3D;0;i&lt;dp.size();++i) dp[i][1]&#x3D;i;        for(int j&#x3D;1;j&lt;&#x3D;k;++j) dp[1][j]&#x3D;1;        for(int i&#x3D;1;i&lt;&#x3D;t;++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;k;++j)&#123;                dp[i][j]&#x3D;1+dp[i-1][j]+dp[i-1][j-1];                            &#125;            if(dp[i][k]&gt;&#x3D;n) return i;        &#125;        return n;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划 + 二分查找</strong></p><p>使用二维dp数组来记录状态，dp[k] [n]表示k个鸡蛋和n层确定f所需最小操作次数。</p><p>dp[k] [n]如果在某x层抛出，只会有两种结果：鸡蛋碎了，此时f一定在此层下面，因此剩余的鸡蛋k-1和层数x-1确定f需要dp[k-1] [x-1]；如果没碎，说明f在此层上面，因此剩余的鸡蛋k和层数n-x确定f需要dp[k] [n-x]。由于不知道在哪一层抛出好，因此需要遍历小于j的每一层选择最小值，因此:</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230417143725709.png" alt="image-20230417143725709"></p><p>由于每次都需要遍历所有层，导致复杂度上升，而dp[k-1] [x-1]随x增大而增大，dp[k] [n-1]随x增大而减小，那么只有在两条曲线交汇点两段才能取到最小值，因此可以使用二分法来进行寻找。</p><p>由dp定义可知，dp[1] [k]皆为1，dp[k] [1]皆为k，其余初始化为0；</p><p>从递推公式可以看出是从上到下从左到右进行遍历</p><ul><li>时间复杂度：O(knlogn) </li><li>空间复杂度：O(kn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 19. 正则表达式匹配</title>
      <link href="/2023/04/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%89%91%E6%8C%87Offer-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-difficult/"/>
      <url>/2023/04/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%89%91%E6%8C%87Offer-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a><a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/description/">剑指 Offer 19. 正则表达式匹配</a></h1><p>First：没做出来，有一二十个用例没过，因为没注意到s的0个字符可以和p的多个字符匹配，初始化没做好</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示字符串s的前i-1个和字符串p的前j-1个是否匹配。</p><p>首先，如果s[i-1]和p[j-1]能够匹配（相等或p[j-1]&#x3D;’.’都算匹配），那么此时dp[i] [j]&#x3D;dp[i-1] [j-1]；如果p[j-1]&#x3D;’*’，由于’ *’前的字符可以出现0次或多次，那么当s[i-1]&#x3D;&#x3D;p[j-2]时，dp[i] [j]&#x3D;dp[i-1] [j] （出现多次）||dp[i] [j-2] (出现0次)，而不相等时，可以假设为出现0次，因此dp[i] [j] &#x3D;dp[i] [j-2]。</p><p>由dp定义可知，初始化为0，dp[0] [0] &#x3D;1，dp第一行若与 * 字符匹配，那么dp[0] [j]&#x3D;dp[0] [j-2];</p><p>从递推公式可以看出是从上到下，从左到右进行遍历</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isMatch(string s, string p) &#123;        int m&#x3D;s.size(),n&#x3D;p.size();        if(m&#x3D;&#x3D;0&amp;&amp;n&#x3D;&#x3D;0) return true;        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));        dp[0][0]&#x3D;1;        for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;            if(p[j-1]&#x3D;&#x3D;&#39;*&#39;) dp[0][j]&#x3D;dp[0][j-2];        &#125;        for(int i&#x3D;1;i&lt;&#x3D;m;++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;                if(p[j-1]&#x3D;&#x3D;&#39;*&#39;)&#123;                    dp[i][j]&#x3D;dp[i][j-2];                    if((s[i-1]&#x3D;&#x3D;p[j-2]||p[j-2]&#x3D;&#x3D;&#39;.&#39;)) dp[i][j]|&#x3D;dp[i-1][j];                                    &#125;else if((s[i-1]&#x3D;&#x3D;p[j-1]||p[j-1]&#x3D;&#x3D;&#39;.&#39;))&#123;                    dp[i][j]&#x3D;dp[i-1][j-1];                &#125;            &#125;        &#125;        return dp[m][n];            &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>638. 大礼包</title>
      <link href="/2023/04/14/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-638-%E5%A4%A7%E7%A4%BC%E5%8C%85-middle/"/>
      <url>/2023/04/14/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-638-%E5%A4%A7%E7%A4%BC%E5%8C%85-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="638-大礼包"><a href="#638-大礼包" class="headerlink" title="638. 大礼包"></a><a href="https://leetcode.cn/problems/shopping-offers/description/">638. 大礼包</a></h1><p>First：就直接回溯</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>先排除不能优惠的大礼包，即总价比直接买还贵的礼包。然后先计算按普通购买需要多少钱，不断遍历看能否使用大礼包，找到使用大礼包最多能节省多少钱</p><p>中止条件：当礼包idx值大于等于礼物数时终止</p><p>遍历过程：从小到大遍历，不断遍历每个礼包</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    int nospecial&#x3D;0;    int ans;public:    int shoppingOffers(vector&lt;int&gt;&amp; price, vector&lt;vector&lt;int&gt;&gt;&amp; special, vector&lt;int&gt;&amp; needs) &#123;        vector&lt;vector&lt;int&gt;&gt; filterSpecial;        for(int i&#x3D;0;i&lt;special.size();++i)&#123;            int sum&#x3D;0;            for(int j&#x3D;0;j&lt;special[i].size()-1;++j)&#123;                sum+&#x3D;price[j]*special[i][j];            &#125;            if(sum&gt;&#x3D;special[i].back()) &#123;                special[i].push_back(sum-special[i].back());                filterSpecial.push_back(special[i]);            &#125;        &#125;                for(int i&#x3D;0;i&lt;needs.size();++i) nospecial+&#x3D;price[i]*needs[i];        ans&#x3D;nospecial;        DFS(filterSpecial,needs,0,0);        return ans;    &#125;    void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; special, vector&lt;int&gt;&amp; needs,int idx,int save)&#123;        if(idx&gt;&#x3D;special.size()) return;        for(int i&#x3D;idx;i&lt;special.size();++i)&#123;            int flag&#x3D;1;            for(int j&#x3D;0;j&lt;special[i].size()-2;++j)&#123;                if(special[i][j]&gt;needs[j]) &#123;                    ans&#x3D;min(ans,nospecial-save);                    flag&#x3D;0;                    break;                &#125;            &#125;            if(flag&#x3D;&#x3D;0) continue;            for(int j&#x3D;0;j&lt;special[i].size()-2;++j)&#123;                needs[j]-&#x3D;special[i][j];            &#125;            DFS(special,needs,idx,save+special[i].back());            for(int j&#x3D;0;j&lt;special[i].size()-2;++j)&#123;                needs[j]+&#x3D;special[i][j];            &#125;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1504. 统计全 1 子矩形</title>
      <link href="/2023/04/10/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1504-%E7%BB%9F%E8%AE%A1%E5%85%A8%201%20%E5%AD%90%E7%9F%A9%E5%BD%A2-middle/"/>
      <url>/2023/04/10/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1504-%E7%BB%9F%E8%AE%A1%E5%85%A8%201%20%E5%AD%90%E7%9F%A9%E5%BD%A2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="1504-统计全-1-子矩形"><a href="#1504-统计全-1-子矩形" class="headerlink" title="1504. 统计全 1 子矩形"></a><a href="https://leetcode.cn/problems/count-submatrices-with-all-ones/description/">1504. 统计全 1 子矩形</a></h1><p>First：这道题折腾了好久</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示到第i行j列个网格在当前行向左最大矩形长度。</p><p>当前格子的dp值可由左边值推导，所以dp[i] [j]&#x3D;dp[i] [j-1]+1;    </p><p>初始值皆为0；从左到右从上到下遍历得到所有dp值。</p><p>当得到所有dp值后，以当前格子作为矩形的右下角，能得到的矩形数量即为当前格子上方所有格子的dp值相加，但是上方的格子的dp值并非单调增加，当单调递减时，那么无论上方dp值多大也只有最小那个值有用。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230410150532990.png" alt="image-20230410150532990" style="zoom: 80%;" /><ul><li>时间复杂度：O(mn^2) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numSubmat(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123;        if(mat.size()&#x3D;&#x3D;0) return 0;        int m&#x3D;mat.size(),n&#x3D;mat[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));        int ans&#x3D;0;        for(int i&#x3D;1;i&lt;&#x3D;m;++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;                           if(mat[i-1][j-1]&#x3D;&#x3D;1)&#123;                    dp[i][j]&#x3D;dp[i][j-1]+1;                    int col&#x3D;dp[i][j];                    for(int k&#x3D;i;k&gt;0;--k)&#123;                        col&#x3D;min(col,dp[k][j]);                        ans+&#x3D;col;                    &#125;                &#125;                          &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划+单调栈</strong></p><p>和方法1类似，先计算每个格子的dp值。在方法1中是对当前格子上方所有值进行遍历得到结果，这会导致进行许多重复运算。例如dp值都是单调增加时，直接在后面加上上次的和即可，但dp值也会存在一部分递减，对于此类情况，上方dp值无论多大，都取决于先遇到的最小值。</p><p>因此，使用一个单调递增栈来存储值，存储的是以当前dp值作为宽所能组成的最大矩形的长+宽（处理递减情况）。对于dp数组，从上到下进行处理，如果栈顶值大于当前dp值，则将其弹出，且当前矩形的高度height应该加上弹出值的高度。由于栈存储的是dp值并未存储上方值的和，因此使用一个sum来存储上方dp和，当遇见需要弹出栈顶值时，那么sum也应该减去栈顶元素所有矩形大小值。最后sum加上当前dp*height即可。</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numSubmat</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> mat<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>mat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m<span class="token operator">=</span>mat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token operator">=</span>mat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                           <span class="token keyword">if</span><span class="token punctuation">(</span>mat<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                                    <span class="token punctuation">&#125;</span>                                          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            stack<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">>></span> st<span class="token punctuation">;</span>            <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> height<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token operator">></span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    height<span class="token operator">+=</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>                    sum<span class="token operator">-=</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token operator">*</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sum<span class="token operator">+=</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">*</span>height<span class="token punctuation">;</span>                ans<span class="token operator">+=</span>sum<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                                <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32. 最长有效括号</title>
      <link href="/2023/04/04/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7-difficult/"/>
      <url>/2023/04/04/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h1><p>First：很久以前做过</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[i] 表示以s[i]结束能形成的最长括号长度。</p><p>括号长度可以由两种类型增加，第一种是获取到匹配符号如<code>)</code>匹配到<code>(</code>。第二种就是<code>()()</code>，当匹配成功后还需要看左括号的左边字符，如果是<code>)</code>，则说明有并行括号。因此递推公式：</p><ul><li>当s[i]&#x3D;&#x3D;’)’且s[i-dp[i-1]-1] &#x3D;&#x3D;’(‘时，此时dp[i]&#x3D;dp[i-1]+2; 如果此时s[i-dp[i-1]-2] &#x3D;&#x3D;’)’，则dp[i]+&#x3D;dp[i-dp[i-1]-2];</li></ul><p>由dp定义可知，初始化皆为0；</p><p>从递推公式可以看出是从左到右进行遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int longestValidParentheses(string s) &#123;        int n&#x3D;s.size();        vector&lt;int&gt; dp(n,0);        int ans&#x3D;0;        for(int i&#x3D;1;i&lt;n;++i)&#123;         if(s[i]&#x3D;&#x3D;&#39;)&#39;&amp;&amp;i-dp[i-1]-1&gt;&#x3D;0&amp;&amp;s[i-dp[i-1]-1]&#x3D;&#x3D;&#39;(&#39;)&#123;             dp[i]&#x3D;dp[i-1]+2;             if(i-dp[i-1]-2&gt;&#x3D;0&amp;&amp;s[i-dp[i-1]-2]&#x3D;&#x3D;&#39;)&#39;) dp[i]+&#x3D;dp[i-dp[i-1]-2];             ans&#x3D;max(ans,dp[i]);         &#125;           &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>877. 石子游戏</title>
      <link href="/2023/04/01/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-middle/"/>
      <url>/2023/04/01/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="877-石子游戏"><a href="#877-石子游戏" class="headerlink" title="877. 石子游戏"></a><a href="https://leetcode.cn/problems/stone-game/description/">877. 石子游戏</a></h1><p>First：没做出来，解析也理解的不透</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示石头下标i到下标j先手与后手最大差值。在dp数组中不用管谁是先手，反正取了一个数之后，剩余区间一定是其后手，最后只需要判断每个区间的值就行，因为区间长度确定也能确定这个区间是谁在取数（固定alice先手）。</p><p>在区间为i j时，可以取左边或者右边，如果取左边值则dp[i] [j]&#x3D;piles[i]-dp[i+1] [j]（这是因为取了一个数之后剩余的一定是其后手），同理取右边也一样，因此dp[i] [j]&#x3D;max(piles[i]-dp[i+1] [j],piles[j]-dp[i] [j-1]);</p><p>当i&#x3D;&#x3D;j时，只有一堆石头，因此dp[i] [j]&#x3D;piles[i]，其余都为0；</p><p>由递推公式可知，遍历是从下到上、从左到右。</p><ul><li>时间复杂度：O(nn) </li><li>空间复杂度：O(nn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool stoneGame(vector&lt;int&gt;&amp; piles) &#123;        int n&#x3D;piles.size();        vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(n,0));        for(int i&#x3D;0;i&lt;n;++i) dp[i][i]&#x3D;piles[i];        for(int i&#x3D;n-1;i&gt;&#x3D;0;--i)&#123;            for(int j&#x3D;i+1;j&lt;n;++j)&#123;                dp[i][j]&#x3D;max(piles[i]-dp[i+1][j],piles[j]-dp[i][j-1]);            &#125;        &#125;        return dp[0][n-1]&gt;0;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>583. 两个字符串的删除操作</title>
      <link href="/2023/03/30/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-712-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8FASCII%E5%88%A0%E9%99%A4%E5%92%8C-middle/"/>
      <url>/2023/03/30/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-712-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8FASCII%E5%88%A0%E9%99%A4%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="712-两个字符串的最小ASCII删除和"><a href="#712-两个字符串的最小ASCII删除和" class="headerlink" title="712. 两个字符串的最小ASCII删除和"></a><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/">712. 两个字符串的最小ASCII删除和</a></h1><p>First：和583题类似，只是代价变了</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示word1前i+1个字符和word2前j+1个字符变成相等所需最小步骤。</p><p>递推公式：</p><ul><li><p>当s1[i]&#x3D;&#x3D;s2[j]时，此时无需修改字符，所以dp[i] [j]&#x3D;dp[i-1] [j-1]；</p></li><li><p>当s1[i]!&#x3D;s2[j]时，此时有两种操作可以使得字符相等，要么s1删除第i个字符变成dp[i-1] [j]一样的情况，要么s2删除第j个字符变成和dp[i] [j-1]一样情况。因此，dp[i][j]&#x3D;min(dp[i-1][j]+s1[i-1],dp[i][j-1]+s2[j-1]);</p></li></ul><p>由dp定义可知，dp[i] [0]&#x3D;dp[i-1] [0]+s1[i-1]，dp[0] [j]&#x3D;dp[0] [j-1]+s2[j-1];其余皆为0；</p><p>从递推公式可以看出是从左上方推导出当前结果，因此需要先外层从小到大遍历s1，再内层从小到大遍历s2</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minimumDeleteSum(string s1, string s2) &#123;        int m&#x3D;s1.size(),n&#x3D;s2.size();        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));        for(int i&#x3D;1;i&lt;&#x3D;m;++i) dp[i][0]+&#x3D;dp[i-1][0]+s1[i-1];        for(int j&#x3D;1;j&lt;&#x3D;n;++j) dp[0][j]+&#x3D;dp[0][j-1]+s2[j-1];        for(int i&#x3D;1;i&lt;&#x3D;m;++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;                if(s1[i-1]&#x3D;&#x3D;s2[j-1]) dp[i][j]&#x3D;dp[i-1][j-1];                else dp[i][j]&#x3D;min(dp[i-1][j]+s1[i-1],dp[i][j-1]+s2[j-1]);            &#125;        &#125;        return dp[m][n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小林coding-MySQL-笔记</title>
      <link href="/2023/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-MySQL-%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-MySQL-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>总结知识点，以便以后快速复习。</p><p><em>参考小林coding-MySQL</em>, <a href="https://www.xiaolincoding.com/mysql/">地址</a></p><h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><p>MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong></p><ul><li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。索引数据结构就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230324113843556.png" style="zoom:80%;" /><h2 id="1-1-执行一条-select-语句，期间发生了什么？"><a href="#1-1-执行一条-select-语句，期间发生了什么？" class="headerlink" title="1.1 执行一条 select 语句，期间发生了什么？"></a>1.1 执行一条 select 语句，期间发生了什么？</h2><h3 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h3><p>第一步要先连接 MySQL 服务，然后才能执行 SQL 语句。MySQL 是<strong>基于 TCP 协议</strong>进行传输的。</p><p><strong>连接器的工作</strong></p><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><blockquote><ol><li><p><strong>如何查看 MySQL 服务被多少个客户端连接了？</strong></p><p>执行 <code>show processlist</code> 命令</p></li><li><p><strong>空闲连接会一直占用着吗？</strong></p><p>不会，MySQL 使用 <code>wait_timeout</code> 参数控制最大空闲时长，默认值是 8 小时，如果空闲连接超过了这个时间，连接器就会自动将它断开。</p><p>一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候</p></li><li><p><strong>MySQL 的连接数有限制吗？</strong></p><p>MySQL 服务支持的最大连接数由 max_connections 参数控制，默认是 151 </p></li><li><p><strong>怎么解决长连接占用内存的问题？</strong></p><ul><li>定期断开长连接</li><li>客户端主动重置连接，客户端可以使用mysql_reset_connection 函数来重置连接，达到释放内存的效果，会将连接恢复到刚刚创建完时的状态</li></ul></li></ol></blockquote><hr><h3 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h3><ul><li>MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段</li><li>如果 SQL 是查询语句，MySQL 就会先去查询缓存里查找缓存数据。查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果</li><li>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果没有命中，就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</li></ul><blockquote><p>这里说的查询缓存是 server 层的</p><p>对于更新比较频繁的表，查询缓存的命中率很低的，因此MySQL 8.0 版本直接将查询缓存删掉了</p></blockquote><hr><h3 id="第三步：解析-SQL"><a href="#第三步：解析-SQL" class="headerlink" title="第三步：解析 SQL"></a>第三步：解析 SQL</h3><p>解析器会做如下两件事情。</p><ul><li><strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</li><li><strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断输入的 SQL 语句是否满足 MySQL 语法。</li></ul><blockquote><p>注意，表不存在或者字段不存在，并不是在解析器里做的。解析器只负责构建语法树和检查语法</p></blockquote><hr><h3 id="第四步：执行-SQL"><a href="#第四步：执行-SQL" class="headerlink" title="第四步：执行 SQL"></a>第四步：执行 SQL</h3><p>每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p><ul><li><strong>预处理阶段</strong><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列</li></ul></li><li><strong>优化阶段</strong>：优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</li><li><strong>执行阶段</strong>：由「执行器」完成，在执行的过程中，执行器会和存储引擎交互，交互是以记录为单位的。执行器和存储引擎的交互过程有以下三种方式：<ul><li>主键索引查询</li><li>全表扫描</li><li>索引下推</li></ul></li></ul><h2 id="1-2-MySQL-一行记录是怎么存储的？"><a href="#1-2-MySQL-一行记录是怎么存储的？" class="headerlink" title="1.2 MySQL 一行记录是怎么存储的？"></a>1.2 MySQL 一行记录是怎么存储的？</h2><p>当创建一个名为my_test的数据库，并在其中创建一张t_order表后，首先会在&#x2F;var&#x2F;lib&#x2F;mysql文件夹下创建一个my_test文件夹，其中包含3个文件：</p><ul><li><strong>db.opt</strong>：用来存储当前数据库的默认字符集和字符校验规则。</li><li><strong>t_order.frm</strong> ：用来保存每个表的元数据信息的，主要包含表结构定义。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是。</li><li><strong>t_order.ibd</strong>：t_order 的<strong>表数据</strong>会保存在这个文件。<ul><li>表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd），这个行为是由参数 innodb_file_per_table 控制的</li></ul></li></ul><hr><h3 id="表空间文件的结构"><a href="#表空间文件的结构" class="headerlink" title="表空间文件的结构"></a>表空间文件的结构</h3><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>：</p><p><strong>行</strong>：数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p><ul><li><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。Redundant太古老，另外三种格式十分相似，是紧凑的行格式。</p></li><li><p><strong>COMPACT 行格式</strong>：分为「记录的额外信息」和「记录的真实数据」两个部分</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230324163842422.png"></p><ul><li><p><strong>记录的额外信息</strong></p><ul><li><p><strong>变长字段长度列表</strong>：有些表字段设置的不定长，需要记录其字段实际存储长度，如varchar。注意此列表中只会存放不定长字段长度，且按照列的顺序<strong>逆序存放</strong>。</p><blockquote><p><strong>为什么「变长字段长度列表」的信息要按照逆序存放？</strong></p><p>因为「记录头信息」中指向下一个记录的指针，如果逆序存放那么真实数据和字段长度是关于记录头对称。使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率。</p><p><strong>每个数据库表的行格式都有「变长字段字节数列表」吗？</strong></p><p>变长字段长度列表」只出现在数据表有变长字段的时候</p></blockquote></li><li><p><strong>NULL 值列表</strong>：如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序<strong>逆序排列</strong>。</p><ul><li>值为1时代表该列为NULL，否则不为NULL。</li><li>NULL 值列表必须用整数个字节的位表示，如果二进制位个数不足整数个字节，则在左边补 <code>0</code></li><li>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表</li></ul></li><li><p><strong>记录头信息</strong></p><ul><li>delete_mask ：标识此条数据是否被删除。执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li><li>next_record：下一条记录的位置，记录与记录之间是通过链表组织的。指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li></ul></li></ul></li><li><p><strong>记录的真实数据</strong>：记录真实数据部分除了定义的字段，还有三个隐藏字段：</p><ul><li>row_id：如果指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_idrow_id不是必需的，占用 6 个字节。</li><li>trx_id：事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</li><li>roll_pointer：这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。</li></ul></li></ul></li><li><p><strong>页</strong>：记录是按照行来存储的，为了效率，<strong>数据库的读取以页为单位</strong>。默认每个页的大小为 16KB。</p></li><li><p><strong>区</strong>：索引分配空间按照区为单位分配，默认每个区包含64页，这样区中的每个页的物理位置时相邻的，就能使用顺序 I&#x2F;O 了。</p></li><li><p><strong>段</strong>：表空间是由各个段组成的，段是由多个区组成的</p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合</li></ul></li></ul><blockquote><p><strong>varchar(n) 中 n 最大取值为多少？</strong></p><ul><li><strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</li><li>在单字段情况下：<ul><li>如果字符集是ascii，那么变长列表要占2字节，NULL列表占1字节，因此varchar(n) 中 n 最大值 &#x3D; 65535 - 2 - 1 &#x3D; 65532。</li><li>在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532&#x2F;3 &#x3D; 21844。</li></ul></li><li>同理，多字段下所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535</li></ul><p><strong>行溢出后，MySQL 是怎么处理的？</strong></p><ul><li>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据末尾处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</li><li>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时：<ul><li>记录的真实数据处不会存储一部分数据，只存储 20 个字节的指针来指向溢出页</li></ul></li></ul></blockquote><h1 id="二、索引篇"><a href="#二、索引篇" class="headerlink" title="二、索引篇"></a>二、索引篇</h1><h2 id="2-1-索引基础"><a href="#2-1-索引基础" class="headerlink" title="2.1 索引基础"></a>2.1 索引基础</h2><p><strong>什么是索引？</strong></p><p>帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong>。</p><p>存储引擎，就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p><p><strong>InnoDB 存储引擎创建索引的选择</strong>：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li><li>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</li></ul><p><strong>B+Tree如何存储索引？</strong></p><blockquote><ul><li>B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，且每个节点里的数据是<strong>按主键顺序存放</strong>。</li><li>每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息</li><li>每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表（下图有误，叶子节点是双向链表）。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230324194955025.png" style="zoom:67%;" /></blockquote><hr><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul><li><p>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</p><blockquote><p><strong>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</strong></p><ul><li><em><strong>B+Tree vs B Tree</strong></em><ul><li>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</li><li>B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</li></ul></li><li><em><strong>B+Tree vs 二叉树</strong></em>：同样的数据二叉树层数会高很多，需要的磁盘IO也更多</li><li><em><strong>B+Tree vs Hash</strong></em>：Hash 表不适合做范围查询，它更适合做等值的查询</li></ul></blockquote></li><li><p>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</p><ul><li><p><strong>主键索引的 B+Tree 和二级索引的 B+Tree 区别</strong>：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul></li><li><p><strong>二级索引查询商品数据的过程</strong>：</p><ol><li>会先检二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值</li></ol></li></ul><ol start="2"><li>再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫<strong>「回表」</strong>，也就是说要查两个 B+Tree 才能查到数据。</li></ol><blockquote><p>当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查，如只查询主键列</p><p>这种在二级索引的 B+Tree 就能查询到结果的过程就叫作<strong>「覆盖索引」</strong>，也就是只需要查一个 B+Tree 就能找到数据。</p></blockquote></li><li><p>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</p><ul><li><p><strong>主键索引</strong>：建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值，使用<code>PRIMARY KEY</code>指定。</p></li><li><p><strong>唯一索引</strong>：建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值，使用<code>UNIQUE KEY</code>指定。</p></li><li><p><strong>普通索引</strong>：普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INDEX</span><span class="token punctuation">(</span>index_column_1<span class="token punctuation">,</span>index_column_2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>前缀索引</strong>:对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p><ul><li>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> table_name<span class="token punctuation">(</span>    column_list<span class="token punctuation">,</span>    <span class="token keyword">INDEX</span><span class="token punctuation">(</span>column_name<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</p><ul><li><p><strong>联合索引</strong>：通过将多个字段组合成一个索引，该索引就被称为联合索引。</p><ul><li><strong>联合索引存在最左匹配原则</strong>，即按照最左优先的方式进行索引的匹配，在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效</li></ul></li></ul></li><li><p>即如果创建了一个 <code>(a, b, c)</code> 联合索引，那么存储是会先按a进行排序，再a相同情况下对b进行排序，再ab都相同情况下对c排序，因此b和c在全局看都是无序的。<br>- 如果此时sql语句不查询a，那么就无法利用联合索引</p></li><li><p>其联合索引示意图如下，注意叶子节点应为双向链表</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328133805834.png"></p><blockquote><p><strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</strong></p></blockquote><p><strong>索引下推</strong></p><ul><li>在使用联合索引时，可能只会用到一个字段，而判断另一个字段是否满足条件是在联合索引里面判断还是回主键索引判断？</li><li>在Mysql5.6之前只能到主键索引」上找出数据行，再对比字段条件。</li><li>MySQL 5.6 引入的<strong>索引下推优化</strong>： 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li></ul><p><strong>索引区分度</strong>：建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。区分度就是某个字段 column 不同值的个数「除以」表的总行数。</p><hr><h3 id="什么时候需要-x2F-不需要创建索引？"><a href="#什么时候需要-x2F-不需要创建索引？" class="headerlink" title="什么时候需要 &#x2F; 不需要创建索引？"></a>什么时候需要 &#x2F; 不需要创建索引？</h3><p><strong>索引缺点：</strong></p><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li></ul><p><strong>什么时候适用索引？</strong></p><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的</li></ul><p><strong>什么时候不需要创建索引？</strong></p><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段无需创建索引</li><li>索引区分度不高的字段</li><li>表数据太少的时候，不需要创建索引；</li><li>经常更新的字段不用创建索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的</li></ul><hr><h3 id="有什么优化索引的方法？"><a href="#有什么优化索引的方法？" class="headerlink" title="有什么优化索引的方法？"></a>有什么优化索引的方法？</h3><p>常见优化索引的方法：</p><ul><li><strong>前缀索引优化</strong>：使用某个字段中字符串的前几个字符建立索引。<ul><li>优点：可以减小索引字段大小，从而增加一个索引页中存储的索引值，提高索引的查询速度</li><li>缺点：order by 就无法使用前缀索引；无法把前缀索引用作覆盖索引；</li></ul></li><li><strong>覆盖索引优化</strong>：指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。<ul><li>优点：不需要查询出包含整行记录的所有信息，也就减少了大量的 I&#x2F;O 操作</li></ul></li><li><strong>主键索引最好是自增的</strong>：若主键是自增的，每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。<ul><li>如果不是自增的，那么需要移动数据，甚至需要从一个页面复制数据到另外一个页面，影响效率</li></ul></li><li><strong>索引最好设置为 NOT NULL</strong>：原因如下：<ul><li>索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂</li><li>NULL 值是一个没意义的值，但是它会占用物理空间，例如InnoDB中需要占用至少一字节来存储</li></ul></li><li><strong>防止索引失效</strong>：发生索引失效的情况：<ul><li>当使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式会造成索引失效；</li><li>当在查询条件中对索引列做了计算、函数、类型转换操作，会造成索引失效；</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul></li></ul><h2 id="2-2-从数据页的角度看-B-树"><a href="#2-2-从数据页的角度看-B-树" class="headerlink" title="2.2 从数据页的角度看 B+ 树"></a>2.2 从数据页的角度看 B+ 树</h2><h3 id="InnoDB-是如何存储数据的？"><a href="#InnoDB-是如何存储数据的？" class="headerlink" title="InnoDB 是如何存储数据的？"></a>InnoDB 是如何存储数据的？</h3><p>InnoDB 的数据是<strong>按「数据页」为单位来读写</strong>的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。</p><p>每个数据页包含七个部分，作用如下：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230326211244266.png" style="zoom:67%;" /><p>数据页内包含用户记录，<strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。</p><p>数据页中的<strong>页目录</strong>，是当前页用户记录的索引，创建页目录过程如下：</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽，<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li></ol><hr><h3 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+ 树是如何进行查询的？"></a>B+ 树是如何进行查询的？</h3><p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下。</p><ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230326211937085.png" style="zoom:80%;" /><p>查找一个主键为6的记录过程如下：</p><ul><li>从根节点开始，通过二分法快速定位到页 30 中查找更详细的目录项；</li><li>在非叶子节点（页30）中，继续定位到叶子节点（页16）查找记录；</li><li>接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。</li></ul><p><strong>一张表只能有一个聚簇索引</strong>，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引&#x2F;辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p><blockquote><p>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「<strong>回表</strong>」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「<strong>索引覆盖</strong>」，也就是只需要查一个 B+ 树就能找到数据</p></blockquote><h2 id="2-3-为什么-MySQL-采用-B-树作为索引？"><a href="#2-3-为什么-MySQL-采用-B-树作为索引？" class="headerlink" title="2.3 为什么 MySQL 采用 B+ 树作为索引？"></a>2.3 为什么 MySQL 采用 B+ 树作为索引？</h2><blockquote><p>要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I&#x2F;0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I&#x2F;0 的操作次数内完成。</p></blockquote><p>MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：</p><ul><li><strong>B+ 树的非叶子节点不存放实际的记录数据</strong>，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</li><li><strong>B+ 树有大量的冗余节点</strong>（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li><li><strong>B+ 树叶子节点之间用链表连接了起来，有利于范围查询</strong>，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li></ul><h2 id="2-4-MySQL-单表不要超过-2000W-行，靠谱吗"><a href="#2-4-MySQL-单表不要超过-2000W-行，靠谱吗" class="headerlink" title="2.4 MySQL 单表不要超过 2000W 行，靠谱吗"></a>2.4 MySQL 单表不要超过 2000W 行，靠谱吗</h2><p><strong>单表数量限制</strong>：主键的大小可以限制表的上限。如主键声明 <code>int</code> 类型，也就是 32 位，那么支持 2^32-11条；</p><p>索引的数据存储是使用类似多叉树来存储，只在叶子节点存储数据，在非叶子节点存储索引，因此假设：</p><ul><li>非叶子节点内指向其他页的数量为 x</li><li>叶子节点内能容纳的数据行数为 y</li><li>B+ 数的层数为 z</li></ul><p>那么总存储记录个数为<strong>x^(z-1) *y</strong></p><p>每个页中，除页结构等大概还剩15k：</p><ul><li>在非叶节点中，主要记录的是主键与页号，主键我们假设是 Bigint (8 byte), 而页号也是固定的（4Byte）, 那么索引页中的一条数据也就是 12byte。那么x&#x3D;1280行。</li><li>在叶节点中，由于数据大小与设计的表结构有关，并不固定，假设一条数据1k，那么y&#x3D;15条；</li></ul><p>在存储中，B+树一般最多三层，那么总存储记录个数&#x3D;（1280 ^2） *15 &#x3D; 24576000 （约 2.45kw）</p><p>因此，<strong>在保持相同的层级（相似查询性能）的情况下，在行数据大小不同的情况下，其实这个最大建议值也是不同的</strong></p><p>MySQL 为了提高性能，会将表的索引装载到内存中，在 InnoDB buffer size 足够的情况下，<strong>只要索引能完成全加载进内存</strong>，那么超过2000万的查询也不会有问题。</p><h2 id="2-5-索引失效有哪些？"><a href="#2-5-索引失效有哪些？" class="headerlink" title="2.5 索引失效有哪些？"></a>2.5 索引失效有哪些？</h2><p>不同索引的查询过程：</p><ul><li>在使用「主键索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么就会在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后直接读取要查询的数据。</li><li>在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树：<ul><li>先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；</li><li>然后用上一步获取的主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后获取要查询的数据。</li></ul></li></ul><p><strong>索引失效情况如下：</strong></p><ul><li><p><strong>对索引使用左或者左右模糊匹配</strong>：当使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。而<code>like xx%</code>不会造成索引失效。</p><ul><li>这是因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</li></ul></li><li><p><strong>对索引使用函数</strong>：如果查询条件中对索引字段使用函数，就会导致索引失效。例如<code>where length(name)=6</code>。</p><ul><li>这是因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</li><li>但从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引</li></ul></li><li><p><strong>对索引进行表达式计算</strong>：在查询条件中对索引进行表达式计算，也是无法走索引的。例如<code>where id+1=10</code>不能走索引，而<code>where id=10-1</code>可以走索引。</p><ul><li>这是因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</li></ul></li><li><p><strong>对索引隐式类型转换</strong>：如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，在执行计划中这条语句会走全表扫描。（但是如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。）</p><ul><li>这是因为<strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong></li><li>第一个例子中，会自动使用一个函数把索引转换为一个整数，因此索引失效。而第二个例子中，会把字符串条件转换为整数，因此不会失效。</li></ul></li><li><p><strong>联合索引非最左匹配</strong>：联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，如果不能就不会走索引。</p><ul><li><p>这是因为在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p><blockquote><p>由于优化器的存在，字段排列顺序不重要，但必须有</p></blockquote></li></ul></li><li><p><strong>WHERE 子句中的 OR</strong>：在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><ul><li>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</li></ul></li></ul><blockquote><p><strong>MySQL 使用 like “%x“，索引一定会失效吗？</strong></p><p>不一定，如果表中除了主键之外就只有一个索引字段或联合索引，那么会通过全扫描二级索引的 B+ 树的方式查询到数据。</p><ul><li>原因：二级索引树的记录东西很少，就只有「索引列+主键值」，而聚簇索引记录的东西会更多，并且需要查询的数据在二级索引中都存在，不需要回表操作，因此优化器选择「全扫描二级索引树」的方式查询数据。</li><li>如果加上了一个非索引段，且查询的数据包括这个非索引段，那么会变成走全表扫描</li><li>同理，联合索引也存在不遵循最左匹配而全盘扫描索引树的情况</li></ul></blockquote><h2 id="2-6-count-和-count-1-有什么区别？哪个性能最好？"><a href="#2-6-count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="2.6 count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>2.6 count(*) 和 count(1) 有什么区别？哪个性能最好？</h2><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230404155345245.png" style="zoom:50%;" /><p><strong>count() 是什么？</strong></p><ul><li><p>该函数作用是统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。</p></li><li><p>函数的参数不仅可以是字段名，也可以是其他任意表达式。</p></li><li><p>下面语句是统计「 t_order 表中，1 这个表达式不为 NULL 的记录」有多少个。1 这个表达式就是单纯数字，它永远都不是 NULL，所以上面这条语句，其实是在统计 t_order 表中有多少个记录</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">from</span> t_order<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>count(主键字段) 执行过程是怎样的？</strong></p><ul><li>在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。</li><li>server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。</li></ul><blockquote><p>如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。</p><p>但是，如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。</p><ul><li>这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I&#x2F;O 成本比遍历聚簇索引的 I&#x2F;O 成本小，因此「优化器」优先选择的是二级索引。</li></ul></blockquote><p><strong>count(1) 执行过程是怎样的？</strong></p><ul><li>如果表里只有主键索引，没有二级索引时。InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，<strong>但是不会读取记录中的任何字段的值</strong>，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。</li><li>如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引</li></ul><p><strong>count(*) 执行过程是怎样的？</strong></p><ul><li>count(*) 其实等于 count(0)，当使用 count(*) 时，MySQL 会将 * 参数转化为参数 0 来处理。</li><li>所以，count(*) 执行过程跟 count(1) 执行过程基本一样的，性能没有什么差异。</li></ul><p><strong>count(字段) 执行过程是怎样的？</strong></p><ul><li>相比其他三种，此方式执行效率最差，会采用全表扫描的方式来计数。</li></ul><p><strong>为什么要通过遍历的方式来计数？</strong></p><ul><li>上述执行都是基于 Innodb 存储引擎，但是在 MyISAM 存储引擎里，执行 count 函数的方式是不一样的，通常在没有任何查询条件下的 count(*)，MyISAM 的查询速度要明显快于 InnoDB。而当带上 where 条件语句之后，MyISAM 也需要扫描表来进行记录个数的统计。</li><li>使用 MyISAM 引擎时，执行 count 函数只需要 O(1 )复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息存储了row_count值，由表级锁保证一致性，所以直接读取 row_count 值就是 count 函数的执行结果。</li><li>而 InnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的（因为在事务中可能会插入数据），所以无法像 MyISAM一样，只维护一个 row_count 变量。</li></ul><p><strong>如何优化 count(*)？</strong></p><ul><li><strong>近似值</strong>：如果对于统计个数不需要很精确，使用 show table status 或者 explain 命令来表进行估算。执行 explain 命令效率是很高的，因为它并不会真正的去查询</li><li><strong>额外表保存计数值</strong>：如果是想精确的获取表的记录总数，可以将这个计数值保存到单独的一张计数表中。在新增和删除操作时，需要额外维护这个计数表。</li></ul><h1 id="三、事务篇"><a href="#三、事务篇" class="headerlink" title="三、事务篇"></a>三、事务篇</h1><h2 id="3-1-事务隔离级别是怎么实现的？"><a href="#3-1-事务隔离级别是怎么实现的？" class="headerlink" title="3.1 事务隔离级别是怎么实现的？"></a>3.1 事务隔离级别是怎么实现的？</h2><p>在操作前先开启事务，等所有数据库操作执行完成后，才提交事务，对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，如果中途发生发生中断或错误，那么该事务期间对数据库所做的修改将会被回滚到没执行该事务之前的状态。</p><h4 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a><strong>事务有哪些特性？</strong></h4><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h4 id="InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？"><a href="#InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？" class="headerlink" title="InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？"></a><strong>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</strong></h4><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><h4 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h4><ul><li><p><strong>脏读</strong>：如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</p></li><li><p><strong>不可重复读</strong>：在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</p><ul><li>例如 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取数据，然后继续执行代码逻辑处理，在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</li></ul></li><li><p><strong>幻读</strong>：在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</p><ul><li>例如事务A在处理开始时查询了记录数量，而之后又有一个事务插入了数据，当事务A再次查询数据时会发现数据不一样，此现象称为幻读。</li></ul><blockquote><ul><li>脏读：读到其他事务未提交的数据；</li><li>不可重复读：前后读取的数据不一致；</li><li>幻读：前后读取的记录数量不一致。</li></ul><p><strong>这三个现象的严重性排序如下： 脏读 &gt; 不可重复读 &gt; 幻读</strong></p></blockquote></li></ul><h4 id="事务的隔离级别有哪些？"><a href="#事务的隔离级别有哪些？" class="headerlink" title="事务的隔离级别有哪些？"></a>事务的隔离级别有哪些？</h4><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下（隔离级别从上到下依次增高）：</p><ul><li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p>不同的隔离级别可能发生的现象如下：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230404165514197.png" style="zoom:50%;" /><p>MySQL与SQL 标准中规定的各级隔离级别允许发生的现象却有些出入，在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。</p><p><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象</strong>，解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><p><strong>四种隔离级别实现</strong></p><ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在<strong>「每个语句执行前」</strong>都会重新生成一个 Read View，而「可重复读」隔离级别是<strong>「启动事务时</strong>」生成一个 Read View，然后整个事务期间都在用这个 Read View。</li></ul><p>注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：</p><ul><li>第一种：begin&#x2F;start transaction 命令；执行此命令后并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；</li><li>第二种：start transaction with consistent snapshot 命令；只要执行此命令，就会马上启动事务</li></ul><hr><h4 id="Read-View-在-MVCC-里如何工作的"><a href="#Read-View-在-MVCC-里如何工作的" class="headerlink" title="Read View 在 MVCC 里如何工作的"></a>Read View 在 MVCC 里如何工作的</h4><p>Read View 有四个重要的字段：</p><ul><li><strong>m_ids</strong> ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。</li><li><strong>min_trx_id</strong> ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。</li><li><strong>max_trx_id</strong> ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；</li><li><strong>creator_trx_id</strong> ：指的是创建该 Read View 的事务的事务 id。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230404191137819.png" style="zoom:50%;" /><p>对于使用 InnoDB 存储引擎的数据库表，它的<strong>聚簇索引记录中都包含下面两个隐藏列</strong>：</p><ul><li><p><strong>trx_id</strong>，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里。记录中的 trx_id 对读取它的事务来说可以分为三种情况：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230404191749752.png" style="zoom:33%;" /></li><li><p><strong>roll_pointer</strong>，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针</strong>，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。</p></li></ul><p>一个事务去访问记录的时候，有这几种情况：</p><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>max_trx_id如果记录的 trx_id 值在 Read View 的min_trx_id和之间，需要判断 trx_id 是否在 m_ids 列表中：<ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）</strong></p><hr><h4 id="可重复读是如何工作的？"><a href="#可重复读是如何工作的？" class="headerlink" title="可重复读是如何工作的？"></a>可重复读是如何工作的？</h4><ul><li><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p></li><li><p>每次事务去读时都是将记录的trx_id与read view的min_trx_id 比较：</p><ul><li>如果比min_trx_id 小，则说明修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的。</li><li>如果在min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录，</li></ul></li><li><p><a href="https://www.xiaolincoding.com/mysql/transaction/mvcc.html#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">例子</a></p></li></ul><h4 id="读提交是如何工作的？"><a href="#读提交是如何工作的？" class="headerlink" title="读提交是如何工作的？"></a>读提交是如何工作的？</h4><ul><li><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</li><li>原理和可重复读一样，只是「<strong>每个语句执行前</strong>」都会重新生成一个 Read View</li><li><a href="https://www.xiaolincoding.com/mysql/transaction/mvcc.html#%E8%AF%BB%E6%8F%90%E4%BA%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">例子</a></li></ul><h2 id="3-2-MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#3-2-MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="3.2 MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>3.2 MySQL 可重复读隔离级别，完全解决幻读了吗？</h2><p><strong>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读</strong>。</p><p><strong>当前读是如何避免幻读的？</strong></p><ul><li>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</li><li>Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了<strong>间隙锁</strong>。<ul><li>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</li></ul></li></ul><p><strong>发生幻读现象场景</strong></p><ol><li>对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。<ul><li>事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，此时没有id&#x3D;5的记录，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。接着，事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。<a href="https://www.xiaolincoding.com/mysql/transaction/phantom.html#%E5%B9%BB%E8%AF%BB%E8%A2%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%97">例子</a></li></ul></li><li>对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。<ul><li>事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。然后事务 B 往插入一个 id&#x3D; 200 的记录并提交；事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。<a href="https://www.xiaolincoding.com/mysql/transaction/phantom.html#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%91%E7%94%9F%E5%B9%BB%E8%AF%BB%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%9C%BA%E6%99%AF">例子</a></li><li><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</li></ul></li></ol><h1 id="四、锁篇"><a href="#四、锁篇" class="headerlink" title="四、锁篇"></a>四、锁篇</h1><h2 id="4-1-MySQL-有哪些锁？"><a href="#4-1-MySQL-有哪些锁？" class="headerlink" title="4.1 MySQL 有哪些锁？"></a>4.1 MySQL 有哪些锁？</h2><p>MySQL有全局锁、表级锁、行级锁：</p><ul><li><p><strong>全局锁</strong></p><ul><li><p>开启与释放全局锁：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span><span class="token keyword">unlock</span> <span class="token keyword">tables</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>开启全局锁后，<strong>整个数据库就处于只读状态了</strong>，他线程执行对数据的增删改操作或对表结构的更改操作都会被阻塞</p></li><li><p>全局锁应用场景：主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p></li><li><p>全局锁缺点：整个数据库都是只读状态。业务只能读数据，而不能更新数据，这样会造成业务停滞。</p></li></ul><blockquote><p>备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</p><ul><li>如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</li></ul></blockquote></li><li><p><strong>表级锁</strong>，MySQL 表级别锁有以下几种：</p><ul><li><p><strong>表锁</strong>；</p><ul><li><p>对t_student表加锁和释放锁操作如下</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">lock</span> <span class="token keyword">tables</span> t_student <span class="token keyword">read</span><span class="token punctuation">;</span><span class="token comment">//表级别的共享锁，也就是读锁；</span><span class="token keyword">lock</span> <span class="token keyword">tables</span> t_stuent <span class="token keyword">write</span><span class="token punctuation">;</span><span class="token comment">//表级别的独占锁，也就是写锁；</span><span class="token keyword">unlock</span> <span class="token keyword">tables</span> <span class="token comment">//释放当前会话的所有表锁</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>注意，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p></li></ul></li><li><p><strong>元数据锁（MDL）</strong>;</p><ul><li>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</li><li>不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL；对一张表进行 CRUD 操作时，加的是 MDL 读锁；对一张表做结构变更操作的时候，加的是 MDL 写锁；</li><li>释放时机：在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</li><li>注意，在执行长事务期间，MDL一直会被占用，如果此时有线程要修改表结构其会被阻塞，但是如果后续有对该表的读操作也会被阻塞。如果大量读操作到来，那么线程会爆满。<ul><li>这是因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁</li></ul></li></ul></li><li><p><strong>意向锁</strong>；</p><ul><li>当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。因此可分为意向共享锁和意向独占锁。</li><li><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁和独占表锁发生冲突。</strong></li><li>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</li><li><strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</li></ul></li><li><p><strong>AUTO-INC 锁</strong></p><ul><li>表里的主键通常都会设置成自增的，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</li><li>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。但大量插入数据时会影响性能。</li><li>在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增<ul><li>在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。</li><li>但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生数据不一致的问题。</li></ul></li></ul></li></ul></li><li><p><strong>行级锁</strong></p><ul><li><strong>Record Lock</strong>，记录锁，也就是仅仅把一条记录锁上，分为独占锁和共享锁</li><li><strong>Gap Lock</strong>，间隙锁，锁定一个范围，但是不包含记录本身（是前开后开区间）；<ul><li>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</li></ul></li><li><strong>Next-Key Lock</strong>：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。是前开后闭区间。<ul><li>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。</li></ul></li></ul><blockquote><p><strong>插入意向锁</strong></p><ul><li>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁</li><li>如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止，在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</li><li>插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。</li><li>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁</li></ul></blockquote></li></ul><blockquote><p><strong>为什么间隙锁与间隙锁之间是兼容的？</strong></p><ul><li>间隙锁的意义只在于阻止区间被插入，因此是可以共存的。一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁。</li><li>但是next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。</li></ul></blockquote><h2 id="4-2-MySQL-是怎么加锁的？"><a href="#4-2-MySQL-是怎么加锁的？" class="headerlink" title="4.2 MySQL 是怎么加锁的？"></a>4.2 MySQL 是怎么加锁的？</h2><p><strong>什么 SQL 语句会加行级锁？</strong></p><ul><li><p>直接加锁语句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span><span class="token comment">//对读取的记录加共享锁(S型锁)</span><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span class="token comment">//对读取的记录加独占锁(X型锁)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。</p></li></ul><h3 id="MySQL-是怎么加行级锁的？"><a href="#MySQL-是怎么加行级锁的？" class="headerlink" title="MySQL 是怎么加行级锁的？"></a><strong>MySQL 是怎么加行级锁的？</strong></h3><p><strong>加锁的对象是索引，加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，next-key lock 是前开后闭区间，而间隙锁是前开后开区间。</p><p>next-key lock 在一些场景下会退化成记录锁或间隙锁：在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成退化成记录锁或间隙锁。</p><p>不同索引等值或范围查询加锁规则不同：</p><ul><li><p><strong>唯一索引等值查询</strong></p><ul><li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。</li><li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong>。加锁右边界为第一条大于的记录，左边界为右边界的上一条记录。<ul><li>为什么不可以针对不存在的记录加记录锁？锁是加在索引上的，自然就没办法锁住这条不存在的记录。</li></ul></li><li>如果唯一索引是主键索引，那么加锁只加在主键上。但如果是二级索引，除了会对二级索引项加行级锁，还会对查询到的记录的主键索引项上加「记录锁」</li></ul></li><li><p><strong>唯一索引范围查询</strong></p><ul><li><p>当唯一索引进行范围查询时，<strong>会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁</strong>：</p><ul><li><p>情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会<strong>退化成记录锁</strong>。</p></li><li><p>情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：</p><ul><li>当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li><li>当条件值的记录在表中，如果是「小于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li></ul><blockquote><p>为什么大于等于查询会退化成记录锁，而小于等于查询不会？</p><p>因为扫描记录时是从左到右进行扫描的，而next-key和间隙锁都不回对左边界进行加锁。而小于等于查询且记录存在时，如果使用记录锁，会使得其前面部分会被插入数据。</p></blockquote></li></ul></li></ul></li><li><p><strong>非唯一索引等值查询</strong></p><ul><li>因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这<strong>两个索引都加锁</strong>，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁。</li><li>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是<strong>非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁</strong>。</li><li>当查询的记录「不存在」时，<strong>扫描到第一条不符合条件的二级索引记录（大于该条件），该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁</strong>。</li></ul></li><li><p><strong>非唯一索引范围查询</strong></p><ul><li>非唯一索引和主键索引的范围查询不同之处在于<strong>非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况</strong></li></ul><blockquote><p><strong>在 age &gt;&#x3D; 22 的范围查询中，明明查询 age &#x3D; 22 的记录存在并且属于等值查询，为什么不会像唯一索引那样，将 age &#x3D; 22 记录的二级索引上的 next-key 锁退化为记录锁？</strong></p><p>因为 age 字段是非唯一索引，不具有唯一性，所以如果只加记录锁（记录锁无法防止插入，只能防止删除或者修改），就会导致其他事务插入一条 age &#x3D; 22 的记录，这样前后两次查询的结果集就不相同了，出现了幻读现象。</p></blockquote></li><li><p><strong>没有加索引的查询</strong></p><ul><li>如果没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，<strong>每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表</strong>，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。</li><li>因此，在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了</li></ul></li></ul><blockquote><p><strong>如何避免update 没加索引会锁全表这种事故的发生？</strong></p><ul><li>可以将 MySQL 里的 <code>sql_safe_updates</code> 参数设置为 1，开启安全更新模式。当设置后，update 语句必须满足如下条件之一才能执行成功：<ul><li>使用 where，并且 where 条件中必须有索引列；</li><li>使用 limit；</li><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul></li><li>delete 语句必须满足以下条件能执行成功：<ul><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul></li><li>如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患</li></ul><p><strong>MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</strong></p><ul><li>针对当前读的语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。</li></ul></blockquote><h2 id="4-3-MySQL-死锁了，怎么办？"><a href="#4-3-MySQL-死锁了，怎么办？" class="headerlink" title="4.3 MySQL 死锁了，怎么办？"></a>4.3 MySQL 死锁了，怎么办？</h2><p>假设有两个事务都是先执行查询记录是否存在，然后插入记录。如果两个事务在查询记录时加的间隙锁位置相同或包含，插入数据时需要先申请一个插入意向锁，若插入位置已经有间隙锁，那么会被阻塞，此时会形成死锁。</p><p><strong>Insert 语句是怎么加行级锁的？</strong></p><ul><li>Insert 语句在正常执行时是不会生成锁结构的，它是靠聚簇索引记录自带的 trx_id 隐藏列来作为隐式锁来保护记录的。</li><li>隐式锁就是在 Insert 过程中不加锁，只有以下特殊情况下，才会将隐式锁转换为显示锁：<ul><li>如果记录之间加有间隙锁，为了避免幻读，此时是不能插入记录的；<ul><li>当需要插入一条记录时，需要查看待插入记录的下一个记录是否有间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（<em>PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</em>）</li></ul></li><li>如果 Insert 的记录和已有记录存在唯一键冲突，此时也不能插入记录；<ul><li>如果主键索引重复，插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加 S 型记录锁</strong>。</li><li>如果唯一二级索引重复，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录<strong>添加 S 型 next-key 锁</strong>。</li></ul></li></ul></li></ul><p><strong>如何避免死锁？</strong></p><ul><li>设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚。InnoDB 的<code>innodb_lock_wait_timeout</code> 用来设置超时时间。</li><li>开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。参数 <code>innodb_deadlock_detect</code> 设置为 on表示开启。</li></ul><h1 id="五、日志篇"><a href="#五、日志篇" class="headerlink" title="五、日志篇"></a>五、日志篇</h1><h2 id="5-1-MySQL-日志：undo-log、redo-log、binlog-有什么用？"><a href="#5-1-MySQL-日志：undo-log、redo-log、binlog-有什么用？" class="headerlink" title="5.1 MySQL 日志：undo log、redo log、binlog 有什么用？"></a>5.1 MySQL 日志：undo log、redo log、binlog 有什么用？</h2><p><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</p><p><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</p><p><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</p><hr><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230407191425152.png" style="zoom: 50%;" /><p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p><ul><li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li><li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li><li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li></ul><p>每个undo log 都有一个 roll_pointer 指针和一个 trx_id 事务id：</p><ul><li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li><li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</li></ul><p><strong>undo log 两大作用：</strong></p><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><blockquote><p><strong>undo log 是如何持久化到磁盘？</strong></p><ul><li>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。</li><li>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。</li></ul></blockquote><hr><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>redo log存在原因：Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p><p>redo log 是物理日志，记录了某个数据页做了什么修改，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><ul><li>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</li><li>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</li></ul><p>redo log 是为了防止 Buffer Pool 中的脏页丢失而设计的，那么如果随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了。因此redo log 是循环写的方式。</p><blockquote><p><strong>修改 Undo 页面，需要记录对应 redo log 吗？</strong></p><ul><li>需要的。在内存修改该 Undo 页面后，需要记录对应的 redo log。</li></ul><p><strong>WAL （Write-Ahead Logging）技术</strong>。<strong>指MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p></blockquote><p><strong>redo log 和 undo log 区别</strong>：</p><ul><li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li><li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230407192922396.png" style="zoom:50%;" /><p><strong>产生的 redo log 是直接写入磁盘的吗？</strong></p><ul><li>执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作</li><li>redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘</li></ul><p><strong>redo log 什么时候刷盘？</strong></p><ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，细节<a href="https://www.xiaolincoding.com/mysql/log/how_update.html#redo-log-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%B7%E7%9B%98">见此</a>）。</li></ul><hr><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p><ul><li>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。</li></ul><blockquote><p><strong>为什么有了 binlog， 还要有 redo log？</strong></p><ul><li>历史原因，MySQL自带的MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。所以InnoDB 使用 redo log 来实现 crash-safe 能力。</li></ul></blockquote><p><strong>binlog 什么时候刷盘</strong></p><ul><li>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。</li><li>一个事务的 binlog 是不能被拆开的，因此无论这个事务有多大（比如有很多条语句），也要保证一次性写入。这是因为一个线程只能同时有一个事务在执行，如果被分开就破坏了原子性</li></ul><p><strong>redo log 和 binlog 区别</strong></p><ol><li>适用对象不同<ul><li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li><li>redo log 是 Innodb 存储引擎实现的日志；</li></ul></li><li>文件格式不同<ul><li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。 STATEMENT 有动态函数的问题，比如用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li><li>ROW：记录行数据最终被修改成什么样了，不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录</li><li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li></ul></li><li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li></ul></li><li>写入方式不同<ul><li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li><li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li></ul></li><li>用途不同<ul><li>binlog 用于备份恢复、主从复制；</li><li>redo log 用于掉电等故障恢复。</li></ul></li></ol><blockquote><p><strong>如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？</strong></p><ul><li>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。</li><li>因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。</li><li>binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。</li></ul></blockquote><p><strong>主从复制是怎么实现？</strong></p><ul><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li><li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li><li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230407194533560.png" style="zoom:50%;" /><p><strong>MySQL 主从复制还有哪些模型？</strong></p><ul><li><strong>同步复制</strong>：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式的可用性和性能较差，基本上没法用</li><li><strong>异步复制</strong>（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。</li><li><strong>半同步复制</strong>：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分从库复制成功响应回来就行。这种<strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong>。</li></ul><hr><h3 id="update-语句中三种日志执行过程"><a href="#update-语句中三种日志执行过程" class="headerlink" title="update 语句中三种日志执行过程"></a>update 语句中三种日志执行过程</h3><ol><li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li><li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘，这就是 **WAL 技术。</li><li>至此，一条记录更新完了。在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li><li>事务提交，剩下的就是「两阶段提交」。</li></ol><hr><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p><strong>为什么需要两阶段提交？</strong></p><ul><li>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现有的提交不成功，这样就造成两份日志之间的逻辑不一致。</li></ul><p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p><p><strong>两阶段提交的过程</strong>：将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog，具体如下：</p><ul><li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘；</li><li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功</li></ul><p><strong>两阶段提交异常重启会出现什么现象？</strong></p><ul><li>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：<ul><li>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务。对应时刻 A 崩溃恢复的情况。</li><li>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务。对应时刻 B 崩溃恢复的情况。</li></ul></li></ul><p><strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong></p><p><strong>两段提交缺点</strong>：</p><ul><li>磁盘 I&#x2F;O 次数高：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li><li>锁竞争激烈：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li></ul><h4 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h4><p>MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I&#x2F;O 的次数</p><p>引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：</p><ul><li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；</li><li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；</li><li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit 操作；</li></ul><blockquote><p><strong>MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？</strong></p><ul><li>设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。</li><li>将 sync_binlog 设置为大于 1 的值，表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。</li><li>将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache</li></ul></blockquote><h2 id="5-2-Buffer-Pool"><a href="#5-2-Buffer-Pool" class="headerlink" title="5.2 Buffer Pool"></a>5.2 Buffer Pool</h2><p>Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能：</p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘</li></ul><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。uffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 <code>128MB</code> 。</p><p>Buffer Pool 除了缓存「<strong>索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息</strong>等</p><p>为了管理在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。</p><blockquote><p><strong>查询一条记录，就只需要缓冲一条记录吗？</strong></p><ul><li>查询一条记录时，会把整个页的数据加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。</li></ul></blockquote><p><strong>如何管理空闲页？</strong></p><ul><li>为了能够快速找到空闲的缓存页，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）。</li><li>Free 链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。</li><li>Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，所以相当于 Free 链表节点都对应一个空闲的缓存页。</li><li>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。</li></ul><p><strong>如何管理脏页？</strong></p><ul><li>跟 Free 链表类似，使用<strong>Flush 链表</strong>来管理脏页，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</li></ul><p><strong>如何提高缓存命中率？</strong></p><ul><li>Buffer Pool 里有三种页和链表来管理数据：<ul><li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li><li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。</li><li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。脏页同时存在于 LRU 链表和 Flush 链表。</li></ul></li><li>MySQL改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。young 区域在 LRU 链表的前半部分，old 区域则是在后半部分。</li><li>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部。</li></ul><p><strong>什么是 Buffer Pool 污染？</strong></p><ul><li>当某一个 SQL 语句扫描了大量的数据时，在 Buffer Pool 空间比较有限的情况下，可能会将 Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 Buffer Pool 污染。</li><li><strong>解决办法</strong>：在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：<ul><li>如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该缓存页就不会被从 old 区域移动到 young 区域的头部；</li><li>如果后续的访问时间与第一次访问的时间不在某个时间间隔内，那么该缓存页移动到 young 区域的头部；</li><li>也就是，只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</li></ul></li></ul><p><strong>脏页什么时候会被刷入磁盘？</strong></p><ul><li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li><li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li><li>MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；</li><li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>264. 丑数 II</title>
      <link href="/2023/03/23/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-264-%E4%B8%91%E6%95%B0II-middle/"/>
      <url>/2023/03/23/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-264-%E4%B8%91%E6%95%B0II-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a><a href="https://leetcode.cn/problems/ugly-number-ii/description/">264. 丑数 II</a></h1><p>First：用set方法做出来了，但没想到用动态规划</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>set</strong></p><p>使用一个set来存储已经找到的丑数，由于set自带排序，因此set的第一个数是其中最小的数。不断弹出第一个数，知道找到第n个数为止。</p><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int nthUglyNumber(int n) &#123;        if(n&#x3D;&#x3D;1) return 1;        set&lt;long long&gt; st;        st.insert(2);        st.insert(3);        st.insert(5);        int count&#x3D;1;        while(!st.empty())&#123;            long long cur&#x3D;*st.begin();            st.erase(st.begin());            count++;            &#x2F;&#x2F; cout&lt;&lt;cur&lt;&lt;&quot; &quot;;            if(count&#x3D;&#x3D;n) return cur;            st.insert(cur*2);            st.insert(cur*3);            st.insert(cur*5);        &#125;        return 0;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>使用一维数组存储已经找到的丑数，dp[i]表示第i个丑数。</p><p>由于已经找到的每一个数都可以推导出3个丑数，因此使用3个指针p2,p3,p5记录当前能分别与2、3、5进行相乘的下标。dp[i] &#x3D;min(dp[p2]*2, dp[p3] *3, dp[p5] *5)；</p><p>这里三个指针和三个数相乘并没有严格对应关系，因为后面的丑数必定是由前面的丑数推导得到，而每一个值都可以推导三个丑数，如果新推导出的丑数等于当前丑数乘以2、3、5中一个，那么就说明其对应指针应该+1，这是因为不需要其再当前值再进行推导，否则会出现重复。</p><p>第一个丑数是1，因此三个指针皆初始化为1.</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int ans&#x3D;INT_MIN;        int count&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            count+&#x3D;nums[i];            ans&#x3D;max(ans,count);            if(count&lt;0) count&#x3D;0;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
            <tag> Alg-三指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>152. 乘积最大子数组</title>
      <link href="/2023/03/22/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-152%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84-middle/"/>
      <url>/2023/03/22/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-152%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组</a></h1><p>First：以前做过，顺利做出来，但还是想了一阵</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [0]表示以i结尾的最大子数组乘积，dp[i] [1]表示以i结尾的最小子数组乘积。</p><p>由于负数再乘以一个负数就可以得到一个正数，因此最大值可能是由前一个最小值乘以当前值得到，也可能由前一个最大值乘以当前值得到，也可能是当前值得到。所以dp[i] [0]&#x3D;max(dp[i-1] [0]*nums[i], max(dp[i-1] [1] *nums[i], nums[i]))；同理，dp[i] [1]&#x3D;max(dp[i-1] [0] *nums[i], max(dp[i-1] [1] *nums[i], nums[i]))；</p><p>初始值任意即可。</p><p>有递推公式可知，只能从前向后遍历。</p><p>还可优化为常数空间</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; dp(2,nums[0]);        int ans&#x3D;nums[0];        for(int i&#x3D;1;i&lt;nums.size();++i)&#123;            int tmp&#x3D;dp[0];            dp[0]&#x3D;max(dp[0]*nums[i],max(dp[1]*nums[i],nums[i]));            dp[1]&#x3D;min(tmp*nums[i],min(dp[1]*nums[i],nums[i]));            ans&#x3D;max(ans,max(dp[0],dp[1]));                &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>221. 最大正方形</title>
      <link href="/2023/03/22/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2-middle/"/>
      <url>/2023/03/22/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/description/">221. 最大正方形</a></h1><p>First：以前做过，顺利做出来</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示到以matrix[i-1] [j-1]作为右下角所能围城的最大正方形。</p><p>观察可知，当前位置所能围城的最大正方形由左边第一个值、上方第一个值、左上方第一个值决定，因此dp[0] [0]&#x3D;min(dp[i-1] [j],min(dp[i-1] [j-1],dp[i][j-1]))+1;。</p><p>只能向右或向下移动，那么要知道当前方格最大正方形就需要知道上方方格和左边方格，因此从左到右遍历由上到下遍历。</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;        int m&#x3D;matrix.size(),n&#x3D;matrix[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));        int ans&#x3D;0;        for(int i&#x3D;1;i&lt;&#x3D;m;++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;                if(matrix[i-1][j-1]&#x3D;&#x3D;&#39;0&#39;) continue;                     dp[i][j]&#x3D;min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1]))+1;                           ans&#x3D;max(ans,dp[i][j]);                            &#125;        &#125;        return ans*ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>140. 单词拆分 II</title>
      <link href="/2023/03/22/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86II-difficult/"/>
      <url>/2023/03/22/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86II-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="140-单词拆分-II"><a href="#140-单词拆分-II" class="headerlink" title="140. 单词拆分 II"></a><a href="https://leetcode.cn/problems/word-break-ii/description/">140. 单词拆分 II</a></h1><p>First：直接用回溯就行，效率也挺高能打败100%，感觉配不上困难。不过答案记忆化搜索好像有剪枝之类的方法还没细看。</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>使用一个idx记录当前回溯位置，如果在idx位置开始能匹配任意一个单词，则将匹配单词加入到path中，并递归遍历idx+words.size()的情况。</p><p>中止条件：当idx等于s.size()，则将path加入到ans中。</p><p>遍历过程：对于wordDict中的每个单词，都查看当前位置是否能匹配，若能匹配则将当前单词加入到path中，然后递归遍历新位置。</p><p>剪枝：无</p><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;string&gt; ans;    string path;public:    void dealWord(string &amp;s, vector&lt;string&gt;&amp; wordDict,int idx)&#123;        if(idx&#x3D;&#x3D;s.size())&#123;            path.pop_back();            ans.push_back(path);            path+&#x3D;&#39; &#39;;            return;        &#125;        for(string &amp;words:wordDict)&#123;            if(idx+words.size()&gt;s.size()) continue;            string tmp&#x3D;s.substr(idx,words.size());            if(tmp&#x3D;&#x3D;words)&#123;                path+&#x3D;tmp+&#39; &#39;;                dealWord(s,wordDict,idx+words.size());                path&#x3D;path.substr(0,path.size()-tmp.size()-1);            &#125;        &#125;    &#125;    vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;        dealWord(s,wordDict,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>120. 三角形最小路径和</title>
      <link href="/2023/03/21/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-middle/"/>
      <url>/2023/03/21/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode.cn/problems/triangle/description/">120. 三角形最小路径和</a></h1><p>First：傻了，开始以为和树深度遍历差不多，后来才发现树每个节点只有一个父节点，而这题每个节点却可能有两个父节点。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j+1]表示到第i行j列节点的最小路径</p><p>由题中可知，当前节点的父节点可能是其上方节点或上方节点的左边一个节点，因此dp[i] [j]&#x3D;min(dp[i-1] [j],dp[i-1] [j-1])+triangle[i] [j-1];。</p><p>到第0行第0列个节点的路径为triangle[0] [0]，所以dp[0] [1]&#x3D;1。</p><p>由递推公式只，其由左上方推导得到，因此从上到下遍历，从左到右遍历。另外，此题还可优化为常数空间。</p><ul><li>时间复杂度：O(n^2) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;        vector&lt;int&gt; dp(triangle.size()+1,INT_MAX);        dp[1]&#x3D;triangle[0][0];        for(int i&#x3D;1;i&lt;triangle.size();++i)&#123;            for(int j&#x3D;triangle[i].size();j&gt;0;--j)&#123;                dp[j]&#x3D;min(dp[j],dp[j-1])+triangle[i][j-1];            &#125;        &#125;        int ans&#x3D;INT_MAX;        for(int i&#x3D;0;i&lt;dp.size();++i) ans&#x3D;min(ans,dp[i]);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91. 解码方法</title>
      <link href="/2023/03/18/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95-middle/"/>
      <url>/2023/03/18/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode.cn/problems/decode-ways/description/">91. 解码方法</a></h1><p>First：思想较简单，但还是错了一次。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[i] 表示到s前i-1个字符的解码总数。</p><p>由于编码长度只有2，那么dp[i]只会与dp[i-1]和dp[i-2]有关，分为两种长度分为进行判断。、</p><ul><li>当s[i-1]!&#x3D;0时，最末尾字符属于编码集，那么dp[i]+&#x3D;dp[i-1]。</li><li>当s[i-2]&#x3D;1或 s[i-2]&#x3D;’2’&amp;&amp;s[i-1]&gt;&#x3D;’0’&amp;&amp;s[i-1]&lt;&#x3D;’6’时，此时末尾两位字符也是在编码集中，那么dp[i]+&#x3D;dp[i-2]</li></ul><p>当s[0]&#x3D;&#x3D;0时，无法存在正确解码，所有只有当s[0]!&#x3D;0时，将dp[0]和dp[1]初值设为1；</p><p>dp[i]需要由前面的dp得到，因此从左到右遍历。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numDecodings(string s) &#123;        int n&#x3D;s.size();        vector&lt;int&gt; dp(n+1,0);        if(s[0]!&#x3D;&#39;0&#39;) &#123;            dp[1]&#x3D;1;            dp[0]&#x3D;1;        &#125;                for(int i&#x3D;2;i&lt;&#x3D;n;++i)&#123;                        if(s[i-1]!&#x3D;&#39;0&#39;) dp[i]+&#x3D;dp[i-1];            if(s[i-2]&#x3D;&#x3D;&#39;1&#39;||(s[i-2]&#x3D;&#x3D;&#39;2&#39;&amp;&amp;s[i-1]&gt;&#x3D;&#39;0&#39;&amp;&amp;s[i-1]&lt;&#x3D;&#39;6&#39;)) dp[i]+&#x3D;dp[i-2];        &#125;        return dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 66. 构建乘积数组</title>
      <link href="/2023/03/18/leetcode/%E6%95%B0%E7%BB%84/leetcode-%E5%89%91%E6%8C%87Offer66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84-middle/"/>
      <url>/2023/03/18/leetcode/%E6%95%B0%E7%BB%84/leetcode-%E5%89%91%E6%8C%87Offer66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a><a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/description/">剑指 Offer 66. 构建乘积数组</a></h1><p>FIrst：顺利做出，以前好像做过</p><hr><p><strong>方法1</strong>：<strong>左右乘积列表</strong></p><p>由于不能使用除法，因此对于每个数的乘积结果只需要知道其左边乘积和右边乘积即可。</p><p>使用两个数组left和right分别记录当前位置左边乘积和右边乘积，最后将两个数组对应位置相乘即可。</p><p>优化空间为O(1)：由于答案不计为空间复杂度，先使用ans数据记录左边乘积，然后从右边进行遍历，定义一个变量t来记录乘积，即可优化为常数空间。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; constructArr(vector&lt;int&gt;&amp; a) &#123;        int n&#x3D;a.size();        vector&lt;int&gt; left(n,1),right(n,1),ans(n,1);        for(int i&#x3D;1,j&#x3D;n-2;i&lt;n;++i,--j)&#123;            left[i]&#x3D;left[i-1]*a[i-1];            right[j]&#x3D;right[j+1]*a[j+1];        &#125;        for(int i&#x3D;0;i&lt;n;++i)&#123;            ans[i]&#x3D;left[i]*right[i];        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>316. 去除重复字母</title>
      <link href="/2023/03/17/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D-middle/"/>
      <url>/2023/03/17/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316. 去除重复字母"></a><a href="https://leetcode.cn/problems/remove-duplicate-letters/description/">316. 去除重复字母</a></h1><p>First：磕磕绊绊还是做出来了，但错了几次</p><hr><p><strong>方法1</strong>：<strong>栈+哈希表</strong></p><p>要想找到字典序最小的结果，那么不重复的字母不能被删除，重复的字母如果其后面有比它小的字母那么就要将其删除，否则不能删。因此可以使用栈来做。</p><p>首先遍历所有字母得到每个字母出现的次数，然后使用一个栈st来存储当前入栈字母，使用一个set来快速找到某字母是否入栈。依次遍历元素，如果当前元素未入栈，那么就不断弹出比其大且在气候有重复的字母，然后将其入栈。如果当前元素已入栈，就将重复数减1即可（为了避免后面的数字要弹出栈中的数字，如bba）。最后弹出栈中所有元素并逆序即为答案。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string removeDuplicateLetters(string s) &#123;        unordered_map&lt;char,int&gt; map;        unordered_set&lt;char&gt; mset;&#x2F;&#x2F;用于存储已经放入栈中的元素        for(char c:s) ++map[c];        stack&lt;char&gt; st;        for(int i&#x3D;0;i&lt;s.size();++i)&#123;                        if(mset.count(s[i])&#x3D;&#x3D;0)&#123;                while(!st.empty()&amp;&amp;s[i]&lt;&#x3D;st.top()&amp;&amp;map[st.top()]&gt;1)&#123;                    --map[st.top()];                    mset.erase(st.top());                    st.pop();                    &#125;                st.push(s[i]);                mset.insert(s[i]);            &#125;else --map[s[i]];         &#125;        string ans;        while(!st.empty())&#123;            ans+&#x3D;st.top();            st.pop();        &#125;        reverse(ans.begin(),ans.end());        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1128. 等价多米诺骨牌对的数量</title>
      <link href="/2023/03/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-1128-%E7%AD%89%E4%BB%B7%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F-simple/"/>
      <url>/2023/03/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-1128-%E7%AD%89%E4%BB%B7%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="1128-等价多米诺骨牌对的数量"><a href="#1128-等价多米诺骨牌对的数量" class="headerlink" title="1128. 等价多米诺骨牌对的数量"></a><a href="https://leetcode.cn/problems/number-of-equivalent-domino-pairs/description/">1128. 等价多米诺骨牌对的数量</a></h1><p>First：开始想用哈希表来做，但还要自己写哈希函数就改为使用排序来做，但效率有点低。看了答案才知对数字大小有限制，可以设计一种哈希方法来做。</p><hr><p><strong>方法1</strong>：<strong>排序</strong></p><p>先将数组中的所有值都变成前小后大，然后对其进行排序，最大统计相同元素的个数count，count个相同元素可以组成count*(count-1)&#x2F;2对，将所有结果相加即可。</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) &#123;        for(int i&#x3D;0;i&lt;dominoes.size();++i)&#123;            if(dominoes[i][0]&gt;dominoes[i][1]) swap(dominoes[i][0],dominoes[i][1]);        &#125;        sort(dominoes.begin(),dominoes.end(),[](vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)&#123;            return a[0]&lt;b[0]||(a[0]&#x3D;&#x3D;b[0]&amp;&amp;a[1]&lt;b[1]);        &#125;);                int ans&#x3D;0;        int idx&#x3D;0,count&#x3D;1;        while(idx&lt;dominoes.size()-1)&#123;            if(dominoes[idx][0]&#x3D;&#x3D;dominoes[idx+1][0]&amp;&amp;dominoes[idx][1]&#x3D;&#x3D;dominoes[idx+1][1])&#123;                ++count;                            &#125;else&#123;                ans+&#x3D;count*(count-1)&#x2F;2;                count&#x3D;1;            &#125;            ++idx;        &#125;        if(count!&#x3D;1) ans+&#x3D;count*(count-1)&#x2F;2;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>哈希表 + 计数</strong></p><p>仍然交换每一对数值，使其变成前小后大。由于数字都小于9，因此可以设计一种哈希函数投影到长度为100的数组中，即x*10+y为投影函数。</p><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) &#123;        int nums[100]&#x3D;&#123;0&#125;;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;dominoes.size();++i)&#123;            if(dominoes[i][0]&gt;dominoes[i][1]) swap(dominoes[i][0],dominoes[i][1]);            ++nums[dominoes[i][0]*10+dominoes[i][1]];        &#125;        for(int i&#x3D;0;i&lt;100;++i)&#123;            ans+&#x3D;nums[i]*(nums[i]-1)&#x2F;2;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>85. 最大矩形</title>
      <link href="/2023/03/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2-diffcult/"/>
      <url>/2023/03/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2-diffcult/</url>
      
        <content type="html"><![CDATA[<h1 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a><a href="https://leetcode.cn/problems/maximal-rectangle/description/">85. 最大矩形</a></h1><p>First：没做出来，看了解析才知是柱状图最大矩形的拓展题</p><hr><p><strong>方法1</strong>：<strong>单调栈</strong></p><p>对于矩阵中的每个为1数字，都可以求得其左边连续1的个数，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230315153448196.png" alt="image-20230315153448196"></p><p>当按上述方法求得所有值后，然后按每一列来进行看待，这么一列就可以看成一组柱状图，然后求其最大矩形即可。最后求得所有列中最大矩形的值作为答案即可。</p><p>而求柱状图中最大举行可参考84题，使用单调栈即可。</p><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int getMaxSize(vector&lt;vector&lt;int&gt;&gt; &amp;lens,int idx)&#123;        stack&lt;int&gt; mst;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;lens.size();++i)&#123;            while(!mst.empty()&amp;&amp;lens[mst.top()][idx]&gt;lens[i][idx])&#123;                int cur&#x3D;mst.top();                mst.pop();                ans&#x3D;max(ans,lens[cur][idx]*(i-mst.top()-1));            &#125;            mst.push(i);        &#125;        return ans;    &#125;    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;        int m&#x3D;matrix.size(),n&#x3D;matrix[0].size();        vector&lt;vector&lt;int&gt;&gt; lens(m,vector&lt;int&gt;(n,0));        for(int i&#x3D;0;i&lt;m;++i)&#123;            for(int j&#x3D;0;j&lt;n;++j)&#123;                if(matrix[i][j]&#x3D;&#x3D;&#39;1&#39;)&#123;                    if(j&gt;0) lens[i][j]&#x3D;lens[i][j-1]+1;                    else lens[i][j]&#x3D;1;                &#125;            &#125;        &#125;        lens.insert(lens.begin(),vector&lt;int&gt;(n,0));        lens.push_back(vector&lt;int&gt;(n,0));        int ans&#x3D;0;        for(int idx&#x3D;0;idx&lt;n;++idx)&#123;            ans&#x3D;max(ans,getMaxSize(lens,idx));        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. 最长回文子串</title>
      <link href="/2023/03/01/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-middle/"/>
      <url>/2023/03/01/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5. 最长回文子串</a></h1><p>First：用动态规划和中心扩展都可以，解析里的那个O(n)解法还没看</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示以s以位置i开头位置j结尾所形成的字符串是否是回文，因此选最长的回文返回。</p><p>递推公式：</p><ul><li>当j-i&#x3D;1时，此时只有两个数字，因此直接比较是否是回文</li><li>当j-i&gt;1时，此区间是否是回文与j+1和i-1区间有关，且和s[i]&#x3D;&#x3D; s[j]有关，因此 dp[i][j]&#x3D;dp[i+1][j-1]&amp;&amp;s[i]&#x3D;&#x3D;s[j];</li></ul><p>dp除i&#x3D;&#x3D;j初始化为1外，其余皆初始化为0</p><p>从递推公式可以看出是从左下方推导出当前结果，因此需要先外层从大到小遍历s，再内层从小到大遍历s</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n^2^)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ansl<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>ansr<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">-</span>i<span class="token operator">></span>ansr<span class="token operator">-</span>ansl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    ansr<span class="token operator">=</span>j<span class="token punctuation">;</span>                    ansl<span class="token operator">=</span>i<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>ansl<span class="token punctuation">,</span>ansr<span class="token operator">-</span>ansl<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>对于S中的每个字符都向左右进行扩展，然后得到最大扩展回文子串。注意，每个字符串只需要两种扩展，第一种是以当前字符为中心，第二种是以当前字符和左边字符进行扩展。</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">getLongRes</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>left<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>right<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token operator">--</span>left<span class="token punctuation">;</span>                <span class="token operator">++</span>right<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">++</span>left<span class="token punctuation">;</span>        <span class="token operator">--</span>right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ansl<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>ansr<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> left<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token function">getLongRes</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">></span>ansr<span class="token operator">-</span>ansl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ansr<span class="token operator">=</span>right<span class="token punctuation">;</span>                ansl<span class="token operator">=</span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            left<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>right<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">getLongRes</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">></span>ansr<span class="token operator">-</span>ansl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ansr<span class="token operator">=</span>right<span class="token punctuation">;</span>                ansl<span class="token operator">=</span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>ansl<span class="token punctuation">,</span>ansr<span class="token operator">-</span>ansl<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2：Manacher算法</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>153. 寻找旋转排序数组中的最小值</title>
      <link href="/2023/02/28/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-middle/"/>
      <url>/2023/02/28/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="475-供暖器"><a href="#475-供暖器" class="headerlink" title="475. 供暖器"></a><a href="https://leetcode.cn/problems/heaters/description/">475. 供暖器</a></h1><p>First：较为复杂，考虑了四种情况来讨论，但看解析考虑两种情况即可</p><hr><p><strong>方法1</strong>：<strong>二分查找</strong></p><p>还是使用常规二分查找，只是边界更新判定不同。假设旋转后数组可表示为[旋转部分，原来部分]可分为以下情况</p><ul><li>如果nums[mid]&gt;&#x3D;nums[left]：<ul><li>且nums[mid]&lt;nums[right]:则说明此时此区间是有序的，因此将right&#x3D;mid即可</li><li>且nums[mid]&gt;&#x3D;nums[right]:则说明mid处于旋转部分，因此需要将left&#x3D;mid+1</li></ul></li><li>如果nums[mid]&lt;nums[left]<ul><li>且nums[mid]&gt;nums[right]:不存在此种情况</li><li>且nums[mid]&lt;&#x3D;nums[right]:则说明mid位于原来部分，因此将right&#x3D;mid；</li></ul></li></ul><p>对于上述四种情况，其实可以合并为第2种和第4种情况两种情况，因此只需判断这两种情况即可。</p><ul><li>时间复杂度：O(logn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findMin(vector&lt;int&gt;&amp; nums) &#123;        int left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;right)&#123;            int mid&#x3D;left+(right-left)&#x2F;2;            if(nums[mid]&gt;&#x3D;nums[left])&#123;                if(nums[mid]&lt;nums[right]) right&#x3D;mid;                else left&#x3D;mid+1;            &#125;else &#123;                if(nums[mid]&gt;nums[right]) left&#x3D;mid+1;                else right&#x3D;mid;            &#125;        &#125;        return nums[left];    &#125;&#125;;&#x2F;&#x2F;简化情况后class Solution &#123;public:    int findMin(vector&lt;int&gt;&amp; nums) &#123;        int left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;right)&#123;            int mid&#x3D;left+(right-left)&#x2F;2;            if(nums[mid]&lt;&#x3D;nums[right]) right&#x3D;mid;            else left&#x3D;mid+1;        &#125;        return nums[left];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>215. 数组中的第K个最大元素</title>
      <link href="/2023/02/28/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-middle/"/>
      <url>/2023/02/28/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h1><p>First：先使用的最小堆来做，后面用基于快速排序的方法时边界条件弄了挺久</p><hr><p><strong>方法1</strong>：<strong>基于快速排序的查找</strong></p><p>快速排序每次可以确定一个值的最终位置，利用此点，使用快速排序+二分查找的方法来找结果</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;right)&#123;            int pos&#x3D;left;            int lt&#x3D;left,rt&#x3D;right;            while(lt&lt;rt)&#123;                                while(nums[lt]&lt;&#x3D;nums[pos]&amp;&amp;lt&lt;rt) ++lt;                while(nums[rt]&gt;nums[pos]&amp;&amp;lt&lt;rt) --rt;                swap(nums[rt],nums[lt]);            &#125;            if(nums[pos]&gt;&#x3D;nums[lt])&#123;                swap(nums[pos],nums[lt]);                pos&#x3D;lt;            &#125;else&#123;                swap(nums[pos],nums[lt-1]);                pos&#x3D;lt-1;            &#125;            if(pos&#x3D;&#x3D;nums.size()-k) return nums[pos];            else if(pos&gt;nums.size()-k) right&#x3D;pos-1;            else left&#x3D;pos+1;                    &#125;        return nums[nums.size()-k];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法2</strong>：<strong>最小堆</strong></p><p>使用一个容量为k的最小堆，不断向堆中加入数据，如果堆容量大于k则弹出一个数据，最后取堆顶数据即为答案。</p><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; mque;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(mque.size()&lt;k)&#123;                mque.push(nums[i]);            &#125;else&#123;                if(mque.top()&lt;nums[i])&#123;                    mque.pop();                    mque.push(nums[i]);                &#125;            &#125;        &#125;        return mque.top();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
      <link href="/2023/02/27/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-middle/"/>
      <url>/2023/02/27/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h1><p>First：主要是细节上的边界判定，查找上边界和下边界分别写了，而解析综合在一起了。关于二分查找边界设定可见代码随想录的<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#_704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a></p><hr><p><strong>方法1</strong>：<strong>二分查找</strong></p><p>分别查找上边界和下边界，注意上下边界的不同主要是使用等于target时的边界更新规则。</p><ul><li>时间复杂度：O(logn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">searchRange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>target<span class="token punctuation">)</span> left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> right<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">>=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid<span class="token operator">=</span>left<span class="token operator">+</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token punctuation">)</span> left<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> right<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">>=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">!=</span>target<span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>二分查找两种写法</strong></p><ul><li><p>若while(left&lt;&#x3D;right)，则说明是一个左闭右闭的，如果nums[mid]&gt;target，此时right&#x3D;mid-1，因为nums[mid]一定不是target，</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 定义target在左闭右闭的区间里，[left, right]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span>            <span class="token keyword">int</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 防止溢出 等同于(left + right)/2</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                right <span class="token operator">=</span> middle <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在左区间，所以[left, middle - 1]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在右区间，所以[middle + 1, right]</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// nums[middle] == target</span>                <span class="token keyword">return</span> middle<span class="token punctuation">;</span> <span class="token comment">// 数组中找到目标值，直接返回下标</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 未找到目标值</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>若while(left&lt;right)，则说明是一个左闭右开的，如果nums[mid]&gt;target，此时right&#x3D;mid，因为区间是左闭右开的</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定义target在左闭右开的区间里，即：[left, right)</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span>            <span class="token keyword">int</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                right <span class="token operator">=</span> middle<span class="token punctuation">;</span> <span class="token comment">// target 在左区间，在[left, middle)中</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在右区间，在[middle + 1, right)中</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// nums[middle] == target</span>                <span class="token keyword">return</span> middle<span class="token punctuation">;</span> <span class="token comment">// 数组中找到目标值，直接返回下标</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 未找到目标值</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注意！两种写法left更新都是mid+1；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>856. 括号的分数</title>
      <link href="/2023/02/23/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-856-%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%95%B0-middle/"/>
      <url>/2023/02/23/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-856-%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%95%B0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="856-括号的分数"><a href="#856-括号的分数" class="headerlink" title="856. 括号的分数"></a><a href="https://leetcode.cn/problems/score-of-parentheses/description/">856. 括号的分数</a></h1><p>First：用两个栈实现了。</p><hr><p><strong>方法1</strong>：<strong>双栈</strong></p><p>此题主要是需要判断括号中是否有括号，使用一个特殊字符来标记当前匹配括号中是否有括号</p><p>使用两个栈：st1存储压入栈的左括号，为了判断当前匹配的括号情况，因此对于每匹配成功一个括号，则像st1中压入一个特殊字符N，然后在栈st2中压入此括号得分。</p><p>当遍历到右括号时，不断弹出st1中栈顶的N字符，并同时st2中栈顶数字，并将数字相加得到add。如果add等于0，则说明当前匹配括号中无子括号，则当前括号得分1，否则得到为add*2，最后向st1中压入N，向st2中压入当前得分。最后将st2中的所有值相加即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">scoreOfParentheses</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> stNum<span class="token punctuation">;</span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>add<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'('</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> add<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token char">'('</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    add<span class="token operator">+=</span>stNum<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    stNum<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token char">'N'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>add<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>add<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stNum<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token operator">+=</span>stNum<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stNum<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1498. 满足条件的子序列数目</title>
      <link href="/2023/02/22/leetcode/%E6%95%B0%E7%BB%84/leetcode-1498-%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/"/>
      <url>/2023/02/22/leetcode/%E6%95%B0%E7%BB%84/leetcode-1498-%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1498-满足条件的子序列数目"><a href="#1498-满足条件的子序列数目" class="headerlink" title="1498. 满足条件的子序列数目"></a><a href="https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/">1498. 满足条件的子序列数目</a></h1><p>First：在细节上纠结了挺久，最后发现如果不预处理数的话对于大数据很难处理</p><hr><p><strong>方法1</strong>：<strong>双指针</strong> </p><p>由于是计算子序列数目，因此元素顺序对子序列无影响。先对数组进行从小到大排序，对于每一个小于等于target的数cur，都使用二分查找一个最大值K，使得cur+K&lt;&#x3D;target，由此可以得到[cur,K]中得到的子序列皆满足要求，不断遍历将结果相加即可。</p><p>为避免区间较大时计算幂会溢出，使用一个数组来存储从1到n的2次幂结果，且每个结果皆会除以1e9+7。这样预处理当数据较大时也能节约时间。</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numSubseq(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;unsigned int&gt; powNum(nums.size(),1);        for(int i&#x3D;1;i&lt;powNum.size();++i)&#123;            powNum[i]&#x3D;powNum[i-1]*2%(int(1e9)+7);        &#125;        sort(nums.begin(),nums.end());        unsigned long long  count&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(nums[i]&gt;target) break;            int idx&#x3D;upper_bound(nums.begin(),nums.end(),target-nums[i])-nums.begin();            if(idx&gt;&#x3D;nums.size()||nums[idx]&gt;target-nums[i]) --idx;            if(idx&gt;&#x3D;i)count+&#x3D;powNum[idx-i];        &#125;        return count%(int(1e9)+7);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++知识点总结</title>
      <link href="/2023/02/20/c++/c++%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/20/c++/c++%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>C++八股总结。参考<a href="https://zhuanlan.zhihu.com/p/92901691?utm_id=0">1</a>、<a href="https://github.com/imarvinle/interview-1#newdelete">2</a></p><hr><hr><h1 id="C-与C的不同点："><a href="#C-与C的不同点：" class="headerlink" title="C++与C的不同点："></a>C++与C的不同点：</h1><p>C++基本兼容C的语法，但相比C多了：</p><ul><li>支持面向对象的编程思想</li><li>支持运算符重载</li><li>支持泛型编程、模板</li><li>支持异常处理</li><li>类型检查严格</li></ul><h1 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h1><p>使用名字空间是为了避免独立开发时造成的命名冲突。</p><p>名字空间内部可以再定义名字空间，内层的名字空间与外层的名字空间的成员，可以重名，内层会屏蔽外层的同名标识符。</p><p>可以给名字空间取别名</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">空间名<span class="token double-colon punctuation">::</span>标识符 <span class="token comment">// 有名名字空间中的成员</span><span class="token double-colon punctuation">::</span>标识符 <span class="token comment">//无名名字空间中的成员，且通过此访问被屏蔽的全局变量</span><span class="token keyword">namespace</span> n123 <span class="token operator">=</span> n1<span class="token double-colon punctuation">::</span>n2<span class="token double-colon punctuation">::</span>n3<span class="token punctuation">;</span> <span class="token comment">//名字空间取别名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h1><p>使用struct和class定义一个类的区别是：</p><ul><li>默认的继承访问权限。struct 是 public 的，class 是 private 的。</li><li>struct成员默认为public；class成员默认为private。</li></ul><p>class可以用于template定义类型，而struct不行</p><p>在C++中，class就是利用struct实现的。</p><blockquote><p>在C++中定义一个类后，如果定义同名函数，则此同名函数会隐藏同名类，而C中则不会，因为其定义一个变量是<code>struct T a</code></p></blockquote><h1 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h1><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员(像访问普通变量一样)</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><h1 id="void"><a href="#void" class="headerlink" title="void*"></a>void*</h1><p>C语言中void* 可以与任意类型指针 自动转换。<br>C++中void* 不能给其他类型的指针直接赋值，必须强制类型转换，但其他类型的指针可以自动给void*赋值(为了类型检查，更加安全）。</p><h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><p>assert断言，是宏，而非函数。其作用是如果它的条件返回错误，则终止程序执行。</p><p>断言assert 是仅在Debug 版本起作用的宏，它用于检查”不应该”发生的情况。</p><h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h1><ul><li>sizeof 对数组，得到整个数组所占空间大小。</li><li>sizeof 对指针，得到指针本身所占空间大小。</li></ul><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">volatile</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可能会被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化（如多次连续赋值不能优化为一次赋值）。</li><li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是 volatile</li></ul><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>const有两重语义：变量只读(如修饰形参），修饰常量（定义变量），因此会导致优化不彻底，C++11提出了constexpr。</p><p>const可分为顶层const（变量本身是个常量）和底层const（指针所指对象是个常量）：</p><ul><li>当执行对象的拷贝操作时：<ul><li>拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换（一般来说，非常量可以转化为常量，反之不行）。</li><li>如果拷出对象是一个变量且是顶层const，那么拷入对象（引用或指针）必须有底层const</li></ul></li><li>重载时：<ul><li>顶层 const 不影响传入函数的对象，一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参区分开</li><li>底层const会影响重载，如果形参是某种类型的指针或引用，则通过区分其是否指向的是常量对象还是非常量对象可以实现函数重载。</li></ul></li></ul><p>const作用：</p><ul><li>修饰变量，说明该变量不可以被改变（顶层const）；</li><li>修饰指针，分为指向常量的指针（底层const）和指针常量（顶层const）；</li><li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改（底层const，注意引用本身已经是一个顶层const，其底层实现是一个指针常量）；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ul><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li><p>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</p></li><li><p>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。</p></li><li><p>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</p><ul><li>经过static修饰的类成员会变成静态成员，其单独存储在data内存段中，所有的类对象共享</li><li>静态成员在类内声明，但必须在类外定义、初始化。初始化时需要加“类名::”限定符表示它属于哪个类，但无需增加 static</li></ul></li><li><p>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，这种成员没有this指针,因此在 static 函数内不能访问非静态成员。但可以直接访问静态成员变量、静态成员函数</p><blockquote><p>静态成员变量、函数依然受访问控制限定符的影响</p></blockquote></li></ul><h1 id="using"><a href="#using" class="headerlink" title="using"></a>using</h1><p><strong>using作用</strong>：</p><ul><li><p>引入命名空间成员</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> namespace_name<span class="token double-colon punctuation">::</span>name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使得某个特定命名空间中所有名字都可见</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> namespace_name name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>派生类中使用using，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span></span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>using和typedef区别</strong></p><ul><li><p>声明函数指针时using更易理解</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//typedef</span><span class="token keyword">using</span> FP <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//别名声明</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>using相比typedef最大一个特点是可以被模板化，而typedef定义模板别名只能嵌套进模板化的struct（其如果用来定义对象时又使用了模板形参，则定义对象时需要加typename）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                            <span class="token comment">//MyAllocList&lt;T>是</span><span class="token keyword">using</span> MyAllocList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">;</span>   <span class="token comment">//std::list&lt;T, MyAlloc&lt;T>>的同义词</span>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span> lw<span class="token punctuation">;</span>                         <span class="token comment">//用户代码</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                            <span class="token comment">//MyAllocList&lt;T>是</span><span class="token keyword">struct</span> <span class="token class-name">MyAllocList</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">//std::list&lt;T, MyAlloc&lt;T>></span>    <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span> type<span class="token punctuation">;</span>      <span class="token comment">//的同义词  </span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token double-colon punctuation">::</span>type lw<span class="token punctuation">;</span>                   <span class="token comment">//用户代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="C-实现-C-类"><a href="#C-实现-C-类" class="headerlink" title="C 实现 C++ 类"></a>C 实现 C++ 类</h1><p>需要实现三大特性：封装、继承、多态，<a href="https://zhuanlan.zhihu.com/p/352015650">参考</a></p><p><strong>实现封装</strong>：</p><ul><li>封装就是类将属性和属性操作封装在一个不可分割的独立实体，只提供对外访问属性的操作方法。用户无需知道对象的内部实现细节，但能通过对外提供的接口访问内部属性数据。</li><li>用C的函数指针模仿C++实现简单的封装。C++中调用成员变量都是通过this指针，因此定义函数时需要多加一个当前类变量指针来模拟this指针，然后调用变量时使用此指针来访问成员变量。</li><li>模拟构造和析构：C的结果体变量创建和销毁时不会自动调用函数，因此需要手动定义用于构造和析构的连个函数，然后在结构体变量定义后调用函数进行初始化和销毁</li></ul><p><strong>实现继承</strong>：</p><ul><li>直接在子类首部定义一个父类变量，并在构造和析构时调用父类的构造析构函数（只能实现共有继承）。</li></ul><p><strong>实现多态</strong>：</p><ul><li>C++实现多态是使用一个虚函数表和一直指向其的指针</li><li>由于实现封装时使用的函数指针实现，因此定义子类时将父类的函数指针指向新函数即可。</li></ul><h1 id="内存对齐和pragma-pack-n"><a href="#内存对齐和pragma-pack-n" class="headerlink" title="内存对齐和pragma pack(n)"></a>内存对齐和pragma pack(n)</h1><p>现在计算机内存空间都是按照byte字节划分的，理论上讲对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址上访问，这就需要各种数据类型按照一定的规则在空间上排列，而不是一个接一个的排放，这就是<strong>内存对齐</strong>。</p><ul><li>cpu对内存的读取不是连续的而是分块读取的，块的大小只能是2^i^个字节数，从cpu的读取性能和效率来考虑，若读取的数据未对齐，则需要两次总线周期来访问内存，因而效率会大打折扣</li></ul><p><strong>内存对齐规则</strong></p><ul><li>结构体第一个变量的地址（起始地址）能够被其最宽的成员大小整除</li><li>结构体每个成员相对于起始地址的偏移能够被其自身大小和对齐系数的较小值整除，如果不能则在前一个成员后面补充字节</li><li>结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节</li></ul><p>在32位系统中，默认对齐系数是4，而64位默认对齐系数是8。</p><p>可通过**pragma pack(n)**来修改对齐系数</p><blockquote><p>变量顺序也会影响对齐大小</p></blockquote><h1 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h1><p><strong>位域</strong>：在结构体定义时，可以指定某个（非静态）成员变量所占用的二进制位数（Bit）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">bs</span><span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> n<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>:</code>后面的数字用来限定成员变量占用的位数。</li></ul><p>语言标准规定：</p><ul><li>位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度，<code>:</code>后面的数字不能超过这个长度。</li><li>只有有限的几种数据类型可以用于位域，即整型（<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>long long</code>）和枚举型</li></ul><p>注意：</p><ul><li>位域在内存中的布局是与机器有关的</li><li>带符号类型中的位域的行为将因具体实现而定</li><li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域（因为地址最小单位是字节）</li></ul><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>重载规则：</p><ul><li>函数名必须相同</li><li>参数列表不同(个数不同、类型不同、参数排列顺序不同等)</li><li>函数的返回类型可以相同也可以不相同</li><li>若两个函数只有返回类型不同，而参数列表完全相同，则不能称为重载函数</li></ul><p>重载实现的机制：</p><ul><li>C++代码在编译时会把函数的参数类型添加到参数名中，借助这个方式来实现函数重载。因此，C++代码不能调用C函数（C语言编译器编译出的函数）</li></ul><p><code>extern &quot;C&quot;</code>:</p><ul><li>告诉C++编译器按照C语言的方式声明函数，这样就可以实现C和C++混合编程</li></ul><p>重载解析：</p><ul><li>实参的类型和形参的匹配情况有三种：<ol><li>编译器找到与实参最佳的匹配函数，编译器将生成调用代码。</li><li>编译找不到匹配函数，编译器将给出错误信息。</li><li>编译器找到多个匹配函数，但没有一个最佳的，这种错误叫二义性（如果编译器没有找到一个最佳调用版本，则会进行类型提升，就可能产生二义性错误）。</li></ol></li><li>选择匹配函数规则：<ul><li>优先每个参数都完全匹配的方案，其次参数完全匹配的个数，再其次是浪费内存的字节数</li></ul></li></ul><p>注意：</p><ul><li>函数的重载关系发生在同一作用域下，不同作用域下的同名函数，构成隐藏关系</li><li>C++函数的形参如果是指针类型，编译时函数名中会追加Px</li></ul><h1 id="默认形参"><a href="#默认形参" class="headerlink" title="默认形参"></a>默认形参</h1><ul><li>C++中函数的形参可以设置默认值，调用函数时如果没有提供实参数，则使用默认形参。</li><li>若某个参数设置了默认值，则其后面所有参数必须设置默认值</li><li>函数的默认形参是在编译阶段确定的，因此只能使用常量、常量表达式、全局变量数据作为默认值。</li><li>默认形参可能会对函数重载造成二义性问题，需慎重</li><li>如果函数的声明和定义需要分开，那么只需要在声明中定义，实现中不定义否则编译器可能报错</li></ul><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>内联函数就把函数编译好的二进制指令直接复制到函数的调用位置，相当于不用执行进入函数的步骤，直接执行函数体。</p><p><strong>编译器对 inline 函数的处理步骤</strong>：</p><ol><li>将 inline 函数体复制到 inline 函数调用点处；</li><li>为所用 inline 函数中的局部变量分配内存空间；</li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><p><strong>优缺点</strong>：</p><ul><li><p>优点：</p><ul><li>无需函数跳转，因此可以提高运行速度</li></ul></li><li><p>缺点：</p><ul><li>可执行文件增大，本质是牺牲空间来换取时间</li></ul></li></ul><p><strong>宏函数和内联函数区别</strong>：</p><ul><li>宏函数在预处理阶段进行代码替换，而内联函数是在编译阶段插入代码</li><li>宏定义没有类型检查，而内联函数有类型检查</li><li>宏函数不是真正的函数，只是代码替换，不会有参数压栈、出栈以及返回值，也不会检查参数类型，因此所有类型都能使用，但会有安全隐患。</li><li>内联函数是真正的函数，被调用时会进行传参，省去了参数压栈、栈帧开辟与回收，可以有返回值，并会严格检查参数类型</li></ul><p><strong>内联适用的条件</strong>：</p><ul><li>由于内联会造成可执行文件变大，并增加内存开销，因此只有频繁调用的简单函数适合作为内联。</li><li>带有递归特性和动态绑定特性的函数，无法实施内联，因此编译器会忽略声明部分的inline关键字。</li></ul><p><strong>注意</strong></p><ul><li>“inline”只是对编译器的建议：被”inline”修饰的函数不一定被内联</li><li>不能包含循环、递归、switch 等复杂操作</li><li>虚函数（virtual）可以是内联函数（inline）吗？<ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul></li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用就是取别名，声明一个标识符为引用，就表示该标识符是另一个对象的外号。</p><p>在C++中引用底层是使用一个指针常量来实现的</p><p>引用特性：</p><ul><li>引用必须初始化，不存在空引用，但有悬空引用（变量死了，名还留着）</li><li>可以引用无名对象（临时对象），但必须定义为常引用</li><li>引用不能更换目标</li><li>引用目标如果具有const属性，引用也需要具有const属性</li></ul><p>指针和引用的相同点和不同点：</p><ul><li>相同点：跨函数共享变量，优化传参效率，避免传参的时候调用拷贝构造</li><li>不同点：<ul><li>引用时一种取别名的机制，而C语言中的指针是一种数据类型（代表内存编号的无符号整数），但由于引用底层是指针实现，因此占用内存大小相同</li><li>指针可以为空，引用不可以为空</li><li>指针可以不初始化，引用必须初始化</li><li>指针可以改变指向，引用不能引用其他对象（可以定义指针的指针，不能定义引用的引用。可以定义指针的引用，不能定义引用的指针。可以定义指针的数组，但不能定义引用的数组。可以定义数组的引用）</li></ul></li></ul><h1 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h1><ul><li><p>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</p></li><li><p>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</p></li><li><p>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</p></li></ul><h1 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a>enum 枚举类型</h1><p>enum可分为限域和非限域：</p><ul><li><p>未限域<code>enum</code>，枚举名的名字属于包含这个<code>enum</code>的作用域，这意味着作用域内不能含有相同名字的其他东西</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Color</span> <span class="token punctuation">&#123;</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">//black, white, red在Color所在的作用域</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>限域<code>enum</code>，枚举名的名字属于<code>enum</code>作用域</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color</span> <span class="token punctuation">&#123;</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//black, white, red//限制在Color域内</span><span class="token comment">//默认情况下，限域枚举的底层类型是int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>限域<code>enum</code>优点：</p><ul><li><p>减少命名空间污染</p></li><li><p>在作用域中，枚举名是强类型。未限域<code>enum</code>中的枚举名会隐式转换为整型</p></li><li><p>可以被前置声明，而非限域不行（除非指定底层类型，但编译器实现时需要知道所有枚举值从而选择一个最小的底层类型）</p></li></ul><h1 id="C-的内存管理"><a href="#C-的内存管理" class="headerlink" title="C++的内存管理"></a>C++的内存管理</h1><p><strong>new、delete</strong></p><ul><li><p>new &#x2F; new[]：完成两件事，先底层调用 malloc 分了配内存，然后调用构造函数（创建对象）。</p></li><li><p>delete&#x2F;delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</p></li><li><p>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</p></li></ul><p><strong>new&#x2F;delete和malloc&#x2F;free的相同点和不同点</strong>：</p><ul><li><p>相同点：都能管理堆内存，都不能重复释放内存</p></li><li><p>不同点：</p><table><thead><tr><th align="center"></th><th align="center">new&#x2F;delete</th><th align="center"><strong>malloc&#x2F;free</strong></th></tr></thead><tbody><tr><td align="center"><strong>身份</strong></td><td align="center">运算符</td><td align="center">标准库函数</td></tr><tr><td align="center"><strong>计算类型大小</strong></td><td align="center">自动计算</td><td align="center">需手动计算申请字节数</td></tr><tr><td align="center"><strong>返回值</strong></td><td align="center">带类型的地址</td><td align="center">void*地址</td></tr><tr><td align="center"><strong>构造析构函数</strong></td><td align="center">自动调用</td><td align="center">不会自动调用</td></tr><tr><td align="center"><strong>出错处理</strong></td><td align="center">抛出异常</td><td align="center">返回nULL</td></tr></tbody></table></li></ul><p>注意：</p><ul><li>new&#x2F;delete与malloc&#x2F;free不能混用，因为new和delete会自动调用类、结构的构造函数、析构函数。</li><li>delete&#x2F;delete[]不能重复释放同一块内存</li><li>delete&#x2F;delete[]释放野指针的后果不确定，但释放空指针是安全的</li></ul><blockquote><ul><li><p>malloc、calloc、realloc、alloca区别</p></li><li><p>定位 new(placement new)：在用户指定的内存位置上（这个内存是已经预先分配好的）构建新的对象，因此这个构建过程不需要额外分配内存，只需要调用对象的构造函数在该内存位置上构造对象即可</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Object <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token function">ClassConstruct</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//address：placement new所指定的内存地址</span><span class="token comment">//ClassConstruct：对象的构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>delete this 合法吗？合法，但：</p><ul><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证 <code>delete this</code> 后没有人使用了</li></ul></li></ul></blockquote><h1 id="类的访问控制"><a href="#类的访问控制" class="headerlink" title="类的访问控制"></a>类的访问控制</h1><ul><li>private：声明为 private 的类成员只能由类的成员函数和友元（类或函数）使用。</li><li>protected：声明为 protected 的类成员可由类的成员函数和友元（类或函数）使用。 此外，它们还可由派生自该类的类使用。</li><li>public：声明为 public 的类成员可由任意函数使用。</li></ul><p>类继承时，遵循private&gt;protected&gt;public将父类成员权限转换。</p><h1 id="类的创建过程"><a href="#类的创建过程" class="headerlink" title="类的创建过程"></a>类的创建过程</h1><ol><li>分配类型所需要空间，无论栈还是堆。</li><li>根据继承表依次调用父类的构造函数</li><li>根据定义成员变量的顺序依次调用成员变量的构造函数。</li><li>执行构造函数体中的代码。</li></ol><h1 id="构造函数与初始化列表"><a href="#构造函数与初始化列表" class="headerlink" title="构造函数与初始化列表"></a>构造函数与初始化列表</h1><p><strong>构造函数</strong></p><ul><li>构造函数可以被重载</li><li>缺省构造是编译器自动生成的一个什么都不做的构造函数（其实不是真正语法意义上的函数，而是功能意义上的函数，编译器作为可执行指令的生成者，它会直接生成具有某项功能的二进制指令，不需要借助高级语言语义上的函数完成此任务）</li><li>无参构造未必无参，当给有参构造的所有参数设置默认形参，调用这种构造函数就不需要传参。</li><li>如果一个类是其他类的成员变量，那么一定要保证它有一个无参构造</li><li>如果构造函数的参数只有一个，那么Test t &#x3D; n语句就不会出错，它会自动调用单参构造来达到类型转换的效果。如果想禁止这种类型转换需要在单参构造前加 explicit。</li><li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li></ul><p><strong>初始化列表</strong></p><ul><li><p>更高效：少了一次调用默认构造函数的过程。</p></li><li><p>有些场合必须要用初始化列表：</p><ol><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。</li></ol></li><li><p>用花括号初始化器列表列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">S</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">v</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructed with a "</span> <span class="token operator">&lt;&lt;</span> l<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"-element list\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><blockquote><p>explicit 修饰的构造函数可用来防止隐式转换</p></blockquote><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><ul><li>析构函数没有参数、没有返回值、不能重载</li><li>析构函数会在销毁对象时自动调用，在对象的整个生命周期内最多被调用一次</li><li>析构函数执行过程：<ol><li>先执行析构函数本身代码</li><li>调用成员类的析构函数</li><li>调用父类的析构函数</li></ol></li><li>如果类中没有动态资源，也不需要做善后工作，缺省析构就完全共用了，不需要再实现新析构函数</li><li>类对象的创建过程与释放对比：<ul><li>创建：分配内存（对象）-&gt; 父类构造-&gt; 成员构造-&gt; 自己构造<ul><li>父类构造：按照继承表从左到右依次构造。</li><li>成员构造：按照声明顺序从上至下依次构造。</li></ul></li><li>释放：自己析构-&gt; 成员析构-&gt; 父类析构-&gt; 释放内存（对象）<ul><li>成员析构：按照声明顺序从下到上依次构造。</li><li>父类析构：按照继承表从右到左依次构造。</li></ul></li></ul></li></ul><p><strong>虚析构函数</strong>：虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p><h1 id="拷贝构造和赋值构造"><a href="#拷贝构造和赋值构造" class="headerlink" title="拷贝构造和赋值构造"></a>拷贝构造和赋值构造</h1><p>拷贝构造：</p><ul><li><p>拷贝构造的参数应该加 const 保护，但编译器并没有强行限制。</p><pre class="line-numbers language-none"><code class="language-none">类名(类&amp; )&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>赋值构造：</p><ul><li><p>当一类对象给另一个类对象赋值时，就会调用赋值构造</p></li><li><p>定义一个类时使用&#x3D;操作符是调用拷贝构造，并非赋值构造</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> opeator <span class="token operator">=</span> <span class="token punctuation">(</span>类<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>T a<span class="token operator">=</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>什么情况下需要实现拷贝构造和赋值构造？</p><ul><li>当类成员中有指针成员，需要深拷贝时</li></ul><p>注意：</p><ul><li>一旦为一个类实现了拷贝构造，那么也一定要实现赋值构造。</li><li>缺省的拷贝构造、赋值构造函数不光会拷贝本类的数据，也会调用成员类对象和父类的拷贝构造和赋值构造</li></ul><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><p><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。</p><ul><li><p><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值</p><ul><li>在函数的参数列表与函数体之间有const修饰的函数，这个const其实就是在修饰this指针,<code>this</code> 指针的类型为：<code>const ClassName* const</code>，因此不能修改成员变量（mutable修饰的变量能被修改），但能修改传入的参数（<strong>普通函数不能声明为常函数</strong>）。</li></ul></li><li><p>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</p></li><li><p>成员函数是如何区别调用它的是哪个类对象的？</p><ul><li>借助了this指针，类的每个成员函数都有一个隐藏的参数this指针，它指向类对象。</li></ul></li><li><p>类的构造函数中也同样有this指针，指向的就是正在构造的这个对象。</p></li><li><p><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址</p></li></ul><h1 id="友元类和友元函数"><a href="#友元类和友元函数" class="headerlink" title="友元类和友元函数"></a>友元类和友元函数</h1><p><strong>友元函数</strong>：在定义一个类的时候，可以把一些函数（包括全局函数和其他类的成员函数）声明为“友元”，这样那些函数就成为该类的友元函数，在友元函数内部就可以访问该类对象的私有成员</p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">friend</span>  返回值类型  函数名<span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">friend</span>  返回值类型  其他类的类名<span class="token double-colon punctuation">::</span>成员函数名<span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>不能把其他类的私有成员函数声明为友元</li></ul><p><strong>友元类</strong>：一个类 A 可以将另一个类 B 声明为自己的友元，类 B 的所有成员函数就都可以访问类 A 对象的私有成员</p> <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">friend  class  类名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：</p><ul><li>友元关系在类之间不能传递，即类 A 是类 B 的友元，类 B 是类 C 的友元，并不能导出类 A 是类 C 的友元</li><li>友元关系是单向性的</li><li>友元声明数量不受限制</li></ul><h1 id="操作符函数重载"><a href="#操作符函数重载" class="headerlink" title="操作符函数重载"></a>操作符函数重载</h1><p>不能修改操作符的参数个数，不能发明新的操作符。不能重载的操作符有：</p><ul><li>域限定符 ::</li><li>直接成员访问操作符 .</li><li>三目操作符 ?:</li><li>字节长度操作符 sizeof</li><li>类型信息操作符 typeid</li></ul><p>重载操作符不能修改操作符的优先级，且无法重载所有基本类型的操作符运算</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>子类的指针或引用可以隐式转换成父类的指针或引用，这是一种缩小类型的转换；父类的指针或引用不可以转换成子类的指针或引用，这是一种扩大类型的转换。</li><li>子类会隐藏父类的同名成员，可以通过域限定符 父类::隐藏成员 进行访问父类中的隐藏成员（或使用父类的指针或引用来指向子类对象，然后访问父类中的隐藏成员）</li><li>子类以私有或保护方式继承父类，会禁止向上造型（子类的指针或引用不能隐式转换成父类的指针或引用，<strong>要想实现多态只能以公开方式继承父类</strong>）。</li><li>在C++中一个子类可以有多个父类，在继承表中按照顺序继承多个父类中的属性和行为，并按照顺序表，调用父类的构造函数（当子类指针转换成父类的隐式指针时候，编译器会自动计算父类中的内容在子类中的位置，地址会自动进行偏移计算）。</li></ul><p><strong>砖石继承</strong>：一个子类继承多个父类，这些父类有一个共同的祖先</p><ul><li>钻石继承不会导致继承错误，但访问祖先类中的成员时每次需要使用 类名::成员名 ，重点是这种继承会造成冗余</li></ul><p><strong>虚继承</strong>：当进行钻石继承时，祖先类中的内容会有冗余，而进行虚继承后，在子类中的内容只会保留一份</p><ul><li>一旦进行了虚继承祖先类的构造函数只执行一次，由孙子类直接调用，祖先类的有参构造也需要在孙子类中显示调用</li><li>在虚拟继承（钻石）中祖先类拷贝构造也由孙子类直接调用</li></ul><blockquote><p>虚继承和虚函数异同：</p><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移</li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul></blockquote><h1 id="覆盖和多态"><a href="#覆盖和多态" class="headerlink" title="覆盖和多态"></a>覆盖和多态</h1><p>重载（静态多态）、隐藏、覆盖（重写）的区别：</p><ul><li><p>重载：同一作用域下的同名函数，函数签名不同（类型、个数、顺序、常函数等），构成重载关系。</p></li><li><p>覆盖的条件：</p><ul><li><p>必须是虚函数</p></li><li><p>必须是父子类之间</p></li><li><p>函数签名必须相同（参数列表完全一致，const属性也会影响覆盖的结果）</p></li><li><p>返回值必须是同类型或父子类（子类的返回值要能向父类隐式转换）</p></li><li><p>访问属性不会影响覆盖</p></li><li><p>常函数属性也会影响覆盖</p></li></ul></li><li><p>隐藏：父子类之间的同名成员如果没有形成覆盖，且能通过编译，必定构成隐藏。</p></li></ul><p><strong>动态多态</strong>：当子类覆盖了父类的虚函数时，通过父类指针指向子类对象时，调用虚函数，会根据具体的对象是谁来决定执行谁的函数</p><p>动态多态的条件</p><ul><li>父子类之间有的函数是覆盖关系。</li><li>父类的指针或引用指向子类的对象。</li></ul><p>注意：</p><ul><li>在父类的构造函数中调用虚函数，此时子类还没有创建完成，因此只能调用父类的虚函数，而不是覆盖版本的虚函数。</li><li>在父类的析构函数中调用虚函数，此时子类已经释放完成，因此只能调用父类的虚函数，而不是覆盖版本的虚函数。</li></ul><h1 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h1><p>纯虚函数：在虚函数的声明的后面添加&#x3D;0，无需实现。</p><ul><li>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</li></ul><p>抽象类：成员函数中有纯虚函数，这种类叫抽象类，抽象类不能实例化</p><ul><li>抽象类必须被继承且纯虚函数被覆盖后，由子类实例化对象</li><li>如果继承抽象类，但没有覆盖纯虚函数，那么子类也将成为抽象类，不能实例化</li></ul><p>纯抽象类：所有成员函数都是纯虚函数，这种只能被继承的类叫纯抽象类。</p><h1 id="虚函数表和虚析构"><a href="#虚函数表和虚析构" class="headerlink" title="虚函数表和虚析构"></a>虚函数表和虚析构</h1><p>虚函数表：</p><ul><li>在C++的类中，一旦成员函数中有虚函数，这个类中就会多一个虚函数表指针，这个指针指向一个虚函数表，表里面记录了<br>这个类中所有的虚函数，</li><li>当这个类被继承，它的子类中也会有一个虚函数表（不管子类中有没有虚函数），如果子类的成员函数中有函数签名与父<br>类的虚函数一样，就会用子类中的函数替换它在虚函数表中的位置，这样就达到了覆盖的效果。</li><li>当通过类指针或引用调用函数时，会根据对象中实际的虚函数表记录来调用函数，这样就达到了多态的效果。</li><li>多态类中的虚函数表建立在编译阶段。</li></ul><p>虚析构：</p><ul><li>当使用delete释放一个父类指针时，不管实际指向的对象是子类还是父类都只会调用父类的析构函数（多态肯定会出现的问题）。如果子类的析构函数有需要负责释放的内存，就会造成内存泄漏</li><li>为了解决这个问题，可以把父类的析构函数设置为虚函数，<em>析构函数进行覆盖时不会比较函数名</em>。</li><li>当父类的析构函数为虚函数时，通过父类指针或引用释放子类对象时，会自动调用子类的析构函数，子类的析构函数执行完成后也会调用父类的析构函数。</li></ul><h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><p>C++中为了兼容C语言，<code>(目标类型)源类型</code> 依然可以继续使用，但C语言的强制类型转换安全性差，因此建议使用C++中的强制类型转换。</p><p>数据类型转换的本质：数据类型转换，就是对数据所占用的二进制位做出重新解释。</p><p>C++提供四种强制类型转换，且没有很大安全隐患：</p><ul><li><p>static_cast&lt;目标类型&gt;(data)   </p><ul><li>静态转换的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。</li><li>用于具体类型之间的转换，也可以用于具体类型指针和void指针之间的转换</li><li>但不能在两个具体类型的指针之间进行转换,不能将整数转换为指针类型</li></ul></li><li><p>dynamic_cast&lt;目标类型&gt;(data)  </p><ul><li>用于将多态基类的<strong>指针或引用</strong>强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。</li><li>既允许向上转型（派生类到基类），也允许向下转型（基类到派生类）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。</li><li>dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数；static_cast 在编译期间完成类型转换，能够更加及时地发现错误。</li><li>dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用</li><li>reinterpret_cast也能用于转换为派生类的指针，但不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。</li></ul></li><li><p>const_cast&lt;目标类型&gt;(data)    </p><ul><li><p>仅用于进行去除 const 属性和volatile 属性，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。</p></li><li><p>注意，<strong>变量本身的const属性是不能去除的</strong>，要想修改变量的值，一般是去除指针（或引用）的const属性，再进行间接修改（这里使用了编译时的常量折叠）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> string s <span class="token operator">=</span> <span class="token string">"Inception"</span><span class="token punctuation">;</span>string<span class="token operator">&amp;</span> p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span> <span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">&amp;</span><span class="token operator">></span></span></span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>string<span class="token operator">*</span> ps <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span> <span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">*</span><span class="token operator">></span></span></span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// &amp;s 的类型是 const string*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>reinterpret_cast&lt;目标类型&gt;(data)  </p><ul><li>用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个比特复制的操作。</li><li>高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换</li></ul></li></ul><h1 id="如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="如何定义一个只能在堆上（栈上）生成对象的类？"></a>如何定义一个只能在堆上（栈上）生成对象的类？</h1><p><a href="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618">参考</a></p><p><strong>只能在堆上</strong>:</p><ul><li>方法：将析构函数设置为私有</li><li>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</li><li>为啥不将构造函数设为私有？因为会导致栈上也无法建立对象</li></ul><p><strong>只能在栈上</strong>:</p><ul><li>方法：将 new 和 delete 重载为私有</li><li>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</li></ul><h1 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h1><p>I&#x2F;O流的打开模式：</p><ul><li>ios::in     以读权限打开文件，不存在则失败，存在不清空</li><li>ios::out    以写权限打开文件，不存在则创建，存在则清空</li><li>ios::app    打开文件用于追加，不存在则创建，存在不清空</li><li>ios::binary 以二进制模式进行读写 </li><li>ios::ate    打开时定位到文件末尾</li><li>ios::trunc  打开文件时清空</li></ul><p>fstream&#x2F;ifstream&#x2F;ofstream 类用于进行文件操作，其函数：</p><ul><li>构造函数或成员函数 open 用于打开文件</li><li>good成员函数检查流是否可用</li><li>eof成员函数用于输入流是否结束</li></ul><p>二进制读写：read&#x2F;write：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">read</span> <span class="token punctuation">(</span>char_type <span class="token operator">*</span>__s<span class="token punctuation">,</span>streamsize __n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span> <span class="token punctuation">(</span>char_type <span class="token operator">*</span>__s<span class="token punctuation">,</span>streamsize __n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="运行时类型信息-RTTI"><a href="#运行时类型信息-RTTI" class="headerlink" title="运行时类型信息 (RTTI)"></a>运行时类型信息 (RTTI)</h1><p><strong>dynamic_cast</strong>：用于多态类型的转换</p><p><strong>类型信息typeid</strong>：用于获取数据的类型信息，返回一个 type_info 对象的引用</p><ul><li>其name成员函数，可以获取类型的名字，内建类型名字使用缩写</li><li>同时还支持 &#x3D;&#x3D; !&#x3D; 用来比较是否是同一种类型</li><li>如果用于判断父子类的指针或引用，它不能准确判断出实际的对象类型。但可以判断出具有多态继承关系的父子类的指针或引用的实际对象</li><li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li></ul><p><strong>type_info</strong>：类描述编译器在程序中生成的类型信息。 </p><ul><li>此类的对象可以有效存储指向类型的名称的指针。 </li><li>type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。</li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>  可以抛出异常的代码  <span class="token keyword">throw</span> 数据<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>类型 变量名<span class="token punctuation">)</span>  <span class="token comment">// 根据数据类型进行捕获</span><span class="token punctuation">&#123;</span>  处理异常，如果无法处理可以继续抛出异常<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意:</p><ul><li>不能抛出局部对象的指针或引用（构造函数和析构函数不能抛出异常）</li><li>如果异常没有被捕获处理，程序就会停止。</li><li>捕获异常的顺序是自上而下的，而不是最精准的匹配，针对子类异常捕获时要放在父类的前面。</li><li>函数的异常声明： 返回值类型 函数名(参数列表)throw(类型1,类型2,…)<ul><li>如果不写异常声明表示什么类型的异常都可能抛出。</li><li>如果写了异常声明表示只抛出某些类型的异常，一旦超出异常声明的范围，程序会直接停止，无法捕获。</li><li>throw() 表示什么类型都不会抛出</li></ul></li></ul><h1 id="迭代器失效情况"><a href="#迭代器失效情况" class="headerlink" title="迭代器失效情况"></a>迭代器失效情况</h1><p>参考<a href="https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers">1</a>、<a href="https://www.cnblogs.com/zhchoutai/p/8449786.html">2</a></p><p><strong>失效情况：</strong></p><ul><li><code>erase()</code><ul><li>当序列容器调用<code>erase()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效。<ul><li>C++03: deque在头尾删除，只会使得被删除迭代器和引用无效。而在其他位置删除会使得所有迭代器和引用都失效。c++11中有一点改变，见参考2.</li></ul></li><li>当关联容器调用<code>erase()</code>方法后，只会使当前迭代器失效，不会造成其他迭代器失效</li></ul></li><li><code>insert()</code><ul><li>当序列容器调用<code>insert()</code>方法后，当前位置到容器末尾元素的所有迭代器全部失效。<ul><li>C++11: deque在头尾插入，会使得所有迭代器无效但引用不受影响。而在其他位置插入会使得所有迭代器和引用都失效。</li></ul></li><li>当关联容器调用<code>insert()</code>方法后，，不会造成其他迭代器失效</li></ul></li><li>如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/qgST0.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能MySQL-第三版笔记</title>
      <link href="/2023/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/"/>
      <url>/2023/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/</url>
      
        <content type="html"><![CDATA[<p>学习《高性能MySQL-第三版》笔记</p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性</title>
      <link href="/2023/02/15/c++/C++11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2023/02/15/c++/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p><em><strong>C++11新特性</strong>，<a href="https://www.bilibili.com/video/BV1bX4y1G7ks?p=1&vd_source=7135ae3a4d6506056ac51c05382c2a25">bilibili视频地址</a>, <a href="https://subingwen.cn/cplusplus/#C-11">博客地址</a>。</em></p><hr><hr><h1 id="1-原始字面量"><a href="#1-原始字面量" class="headerlink" title="1. 原始字面量"></a>1. 原始字面量</h1><p>编程过程中，使用的字符串中常带有一些特殊字符，如\t等符号，导致输入路径时输入\需要输入\</p><p>C++11 中提供了定义原始字符串的字面量，定义方式如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">R“<span class="token function">xxx</span><span class="token punctuation">(</span>原始字符串<span class="token punctuation">)</span>xxx”<span class="token comment">//（）两边的字符串用于说明字符串含义，其可以省略，即使（）两边写了字符也不会被打印出来</span>string str2 <span class="token operator">=</span> <span class="token raw-string string">R"(D:\hello\world\test.text)"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li>（1）在R “xxx(raw string)xxx” 中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且加的字符串必须在括号两边同时出现。</li><li>（2）xxx部分不能加 ( 或 )</li></ul><h1 id="2-指针空值类型-nullptr"><a href="#2-指针空值类型-nullptr" class="headerlink" title="2. 指针空值类型 - nullptr"></a>2. 指针空值类型 - nullptr</h1><blockquote><p>C++11以前，给指针赋空置使用的是NULL，但是在C++中，NULL就是0，这有时会使程序出现健壮性问题。</p><p>比如函数重载时，函数调用的是一个空指针，但由于空指针就是0，则编译器会选择调用int型重载函数，而非指针型重载函数。</p></blockquote><p>C++11引入了关键字 nullptr，其专门用于初始化空类型指针。也就是以前给一个指针赋NULL，那么这个指针其实是0，其类型变为了int，但现在给指针赋nullptr，那么这个指针就是真的一个空指针，<strong>其类型是指针，而不是int</strong>。</p><p><strong>注意</strong></p><ul><li>（1）nullptr 无法隐式转换为整形，但是可以隐式匹配指针类型</li></ul><h1 id="3-常量表达式修饰符-constexpr"><a href="#3-常量表达式修饰符-constexpr" class="headerlink" title="3. 常量表达式修饰符 - constexpr"></a>3. 常量表达式修饰符 - constexpr</h1><p>const有两重语义：变量只读，修饰常量</p><p>变量只读：定义函数时，形参前有const修饰，此时表示此形参只读</p><p>修饰常量：定义常量</p><p>C++11 中添加了一个新的关键字 constexpr，其用来修饰常量表达式（也就只有修饰常量这一种语义）。<strong>常量表达式</strong>，指的就是由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式。</p><p>在定义常量时，const 和 constexpr 是等价的</p><p><strong>建议</strong>：凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。</p><h2 id="3-1-常量表达式函数"><a href="#3-1-常量表达式函数" class="headerlink" title="3.1 常量表达式函数"></a>3.1 常量表达式函数</h2><p><strong>修饰函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>constexpr修饰函数时，需满足以下条件（常量表达式函数就表示编译时就能将函数计算出来，因此有以下许多限制）：</p><ul><li>（1）函数必须要有返回值，并且 return 返回的表达式必须是常量表达式。</li><li>（2）函数在使用之前，必须有对应的定义语句。</li><li>（3）整个函数的函数体中，不能出现非常量表达式之外的语句（using 指令、typedef 语句以及 static_assert 断言、return 语句除外）。</li></ul><h2 id="3-2-修饰模板函数"><a href="#3-2-修饰模板函数" class="headerlink" title="3.2 修饰模板函数"></a>3.2 修饰模板函数</h2><p>constexpr 可以修饰函数模板</p><p>如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p><p>如果满足，则模板函数实例化为常量表达式函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 定义函数模板</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">constexpr</span> T <span class="token function">dispaly</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">struct</span> <span class="token class-name">Person</span> ret <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//由于参数 p 是变量，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> ret1 <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-修饰构造函数"><a href="#3-3-修饰构造函数" class="headerlink" title="3.3 修饰构造函数"></a>3.3 修饰构造函数</h2><p>如果想用直接得到一个常量对象，也可以使用 constexpr 修饰一个构造函数，这样就可以得到一个常量构造函数了。</p><p>常量构造函数有一个要求：<strong>构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">constexpr</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>C++构造函数体内初始化与列表初始化的区别</strong></p><ul><li>（1）类成员初始化总在构造函数执行之前</li><li>（2）成员是常量或引用：成员无法赋值，只能被初始化</li><li>（3）如果在类构造函数里赋值：在成员初始化时会调用一次其默认的构造函数，在类构造函数里又会调用一次成员的构造函数再赋值</li><li>（4）如果在类构造函数使用初始化列表：仅在初始化列表里调用一次成员的构造函数并赋值</li><li>（5）如果成员中有的类型没有无参构造函数则必须使用列表初始化；因为不写列表的话会调用默认的无参构造函数；</li><li>（6）初始化列表的初始化顺序与列表顺序无关，只与声明的顺序有关；</li></ul><h1 id="4-自动类型推导：auto和decltype"><a href="#4-自动类型推导：auto和decltype" class="headerlink" title="4. 自动类型推导：auto和decltype"></a>4. 自动类型推导：auto和decltype</h1><h2 id="4-1-auto"><a href="#4-1-auto" class="headerlink" title="4.1 auto"></a>4.1 auto</h2><blockquote><p>在 C++11 之前 auto 和 static 是对应的，表示变量是自动存储的</p><p>在 C++11 中，auto能够自动推导出变量的实际类型</p></blockquote><p>使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在<strong>编译时</strong>将auto占位符替换为真正的类型。</p><p>auto 和指针、引用结合起来使用有以下规则：</p><ul><li>（1）当变量不是指针或者引用类型时，推导的结果中不会保留 const、volatile 关键字</li><li>（2）当变量是指针或者引用类型时，推导的结果中会保留 const、volatile 关键字</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">auto</span> a1 <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token comment">//auto被推导为int</span><span class="token keyword">auto</span> a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span><span class="token comment">//int</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>a3 <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token comment">//int</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>a4 <span class="token operator">=</span> a3<span class="token punctuation">;</span><span class="token comment">//const int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>auto 的限制</strong></p><ul><li><p>（1）不能作为函数参数使用。因为只有在函数调用的时候才会给函数参数传递实参，auto 要求必须要给修饰的变量赋值，因此二者矛盾。（auto是在编译时候就被推导出来）</p></li><li><p>（2）不能用于类的非静态成员变量的初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> v1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token comment">// error</span>    <span class="token keyword">static</span> <span class="token keyword">auto</span> v2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment">// error,类的静态非常量成员不允许在类内部直接初始化</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">auto</span> v3 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token comment">// ok</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>（3）不能使用 auto 关键字定义数组</p></li><li><p>（4）无法使用 auto 推导出模板参数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> t<span class="token punctuation">;</span>    Test<span class="token operator">&lt;</span><span class="token keyword">auto</span><span class="token operator">></span> t1 <span class="token operator">=</span> t<span class="token punctuation">;</span>           <span class="token comment">// error, 无法推导出模板类型</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>auto 的应用</strong></p></li><li><p>（1）用于STL的容器遍历。</p></li><li><p>（2）用于泛型编程，在使用模板的时候，很多情况下我们不知道变量应该定义为什么类型，可以用auto来占位自动推导。</p></li></ul><h2 id="4-2-decltype"><a href="#4-2-decltype" class="headerlink" title="4.2 decltype"></a>4.2 decltype</h2><p>C++提供了decltype关键字，用于推导一个表达式的类型来定义变量。这和打印类名有差别，C++中打印类名用的是 typeid(classname).name()</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">decltype</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>推导规则</strong></p><ul><li>（1）表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用 decltype 推导出的类型和表达式的类型是一致的。</li><li>（2）表达式是函数调用，使用 decltype 推导出的类型和函数返回值一致。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//函数声明</span><span class="token keyword">int</span> <span class="token function">func_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 返回值为 int</span><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">func_int_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 返回值为 int&amp;</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">func_int_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回值为 int&amp;&amp;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token function">func_cint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 返回值为 const int </span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">func_cint_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 返回值为 const int&amp;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">func_cint_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 返回值为 const int&amp;&amp;</span><span class="token keyword">const</span> Test <span class="token function">func_ctest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回值为 const Test</span><span class="token comment">//decltype类型推导</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> b <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  e <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_ctest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> g <span class="token operator">=</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//变量 a 被推导为 int 类型</span><span class="token comment">//变量 b 被推导为 int&amp; 类型</span><span class="token comment">//变量 c 被推导为 int&amp;&amp; 类型</span><span class="token comment">//变量 d 被推导为 int 类型 !!!!!!!!!!!!!!!!</span><span class="token comment">//变量 e 被推导为 const int &amp; 类型</span><span class="token comment">//变量 f 被推导为 const int &amp;&amp; 类型</span><span class="token comment">//变量 g 被推导为 const Test 类型</span>函数 <span class="token function">func_cint</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> 返回的是一个纯右值（在表达式执行结束后不再存在的数据，也就是临时性的数据），对于纯右值而言，只有自定义类类型的推导结果可以携带<span class="token keyword">const</span>、<span class="token keyword">volatile</span>限定符，除此之外（也就是内置类型）需要忽略掉这两个限定符，因此推导出的变量 d 的类型为 <span class="token keyword">int</span> 而不是 <span class="token keyword">const</span> <span class="token keyword">int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>（3）表达式是一个左值，或者被括号 ( ) 包围，使用 decltype 推导出的是表达式类型的引用（如果有 const、volatile 限定符不能忽略）。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> Test obj<span class="token punctuation">;</span>    <span class="token comment">//带有括号的表达式</span>    <span class="token keyword">decltype</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token comment">//加法表达式</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">decltype</span><span class="token punctuation">(</span>n <span class="token operator">+</span> m<span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">decltype</span><span class="token punctuation">(</span>n <span class="token operator">=</span> n <span class="token operator">+</span> m<span class="token punctuation">)</span> d <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//obj.num 为类的成员访问表达式，符合场景 1，因此 a 的类型为 int</span><span class="token comment">//obj.num 带有括号，符合场景 3，因此 b 的类型为 const int&amp;。</span><span class="token comment">//n+m 得到一个右值，符合场景 1，因此 c 的类型为 int</span><span class="token comment">//n=n+m 得到一个左值 n，符合场景 3，因此 d 的类型为 int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>decltype 的应用</strong></p><p>在模板类中，某些变量值的类型由输入决定，此时不能使用auto（因为对于非静态变量不能使用auto推导），则可以使用decltype来推导类型定义变量。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Container</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> c<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>m_it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> m_it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>m_it<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>m_it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span> m_it<span class="token punctuation">;</span>  <span class="token comment">// 这里不能确定迭代器类型</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">;</span>    Container<span class="token operator">&lt;</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> obj<span class="token punctuation">;</span>    obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//在问号处可以使用decltype来解决变量类型未知问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在问号处不能使用 T::iterator来定义变量，这是因为编译器不能确定iterator到底时类名还是变量，因此还需要在前面加上typename，typename T::iterator定义正确。</p><blockquote><p><strong>class和typename区别</strong>：</p><ul><li>在定义<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E6%A8%A1%E6%9D%BF&spm=1001.2101.3001.7020">类模板</a>或者函数模板时，<code>typename</code> 和 <code>class</code> 关键字等价</li><li>class不能用来指明某个字符串是类名</li><li>对于用于模板定义的依赖模板参数的名称，只有在实例化的参数中存在这个类型名，或者这个名称前面使用了typename关键字修饰，编译器才会将这个名字当做是类型。除了以上两种情况，编译器不会将它视为类型。</li><li>typename只能用于模板中</li></ul></blockquote><h2 id="4-3-返回类型后置"><a href="#4-3-返回类型后置" class="headerlink" title="4.3 返回类型后置"></a>4.3 返回类型后置</h2><blockquote><p>泛型编程中，返回值类型可能是由输入参数类型来决定，调用函数时由用户来决定类型是不安全的，且不优雅。</p></blockquote><p>c++11提供了一种通过输入参数来推导返回类型的方法：返回类型后置</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 符号 -> 后边跟随的是函数返回值的类型</span><span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">,</span> 参数<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>参数表达式<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如按上述所写，auto 会追踪 decltype() 推导出的类型。（这里不能直接在auto位置直接定义decltype()，这是因为变量还没定义，也就无法推导，可以理解成语法原因）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 返回类型后置语法</span><span class="token comment">//例1    </span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span>  <span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token operator">+</span>u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//例2</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">test</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">test</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-final和override"><a href="#5-final和override" class="headerlink" title="5. final和override"></a>5. final和override</h1><h2 id="5-1-fianl"><a href="#5-1-fianl" class="headerlink" title="5.1 fianl"></a>5.1 fianl</h2><p>final 关键字用来&#x3D;&#x3D;限制某个类不能被继承，或者某个虚函数不能被重写&#x3D;&#x3D;</p><p>如果使用 final 修饰函数，只能修饰虚函数</p><p>final关键字需放到类或者函数的后面</p><ul><li>如果使用 final 修饰函数（只能修饰虚函数），这样就能阻止子类重写父类的这个函数</li><li>使用 final 关键字修饰过的类是不允许被继承的，也就是说这个类不能有派生类。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//修饰函数</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">final</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//修饰类</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5-2-override"><a href="#5-2-override" class="headerlink" title="5.2 override"></a>5.2 override</h2><p>当类实现多态时，子类可以重写父类中的虚函数，override关键字可以确保重写虚函数的正确性和增加代码可读性。</p><p>override不是必须的，可以看成一种错误提示机制，当重写的函数不是虚函数时，如果函数后面有override关键字，则会提示错误。</p><p>override关键字需要写到函数后面</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="6-模板的优化"><a href="#6-模板的优化" class="headerlink" title="6. 模板的优化"></a>6. 模板的优化</h1><h2 id="6-1-模板的右尖括号优化"><a href="#6-1-模板的右尖括号优化" class="headerlink" title="6.1 模板的右尖括号优化"></a>6.1 模板的右尖括号优化</h2><p>c++11以前，模板实例时使用两个右尖括号（&gt;&gt;）会被编译器解析成右移操作符，而不是模板参数表的结束，需要在两个右尖括之间添加空格才能识别为模板结束。</p><p>C++11改进了编译器的解析规则，尽可能地将多个右尖括号（&gt;）解析成模板参数结束符</p><h2 id="6-2-默认模板参数"><a href="#6-2-默认模板参数" class="headerlink" title="6.2 默认模板参数"></a>6.2 默认模板参数</h2><p>在 C++98&#x2F;03 标准中，类模板可以有默认的模板参数，但是不支持函数的默认模板参数</p><p>在C++11中添加了对&#x3D;&#x3D;函数模板默认参数&#x3D;&#x3D;的支持</p><ul><li><p>当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。</p></li><li><p>但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随 &lt;&gt; 来实例化</p></li><li><p>函数模板的默认模板参数没有必须写在参数表最后的限制（不需要一定写在尾部）</p></li><li><p>模板参数类型的自动推导是根据模板函数调用时指定的实参进行推断的，没有实参则无法推导</p></li></ul><p><strong>当默认模板参数和模板参数自动推导同时使用时</strong></p><ul><li>如果可以推导出参数类型则使用推导出的类型</li><li>如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数</li><li>如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错</li><li><em>只要在&lt;&gt;中指定了参数类型，此优先级最高，会使用此参数类型</em></li></ul><p><strong>注意</strong></p><ul><li>当函数模板类型没有默认类型，而其对应的参数有指定默认值，此默认值不能用于反推其类型</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">char</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T arg1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> U arg2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用报错，此时本使用默认值100，但是默认值不能用于反推导变量类型</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//参数 T 被自动推导为 char 类型，U 使用的默认模板参数为 char 类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-using使用"><a href="#7-using使用" class="headerlink" title="7. using使用"></a>7. using使用</h1><p>c++11能使用using和typedef来为类型定义一个别名，被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字</p><p>类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名</p><p>使用typedef定义的别名和使用using定义的别名在语义上是等效的</p><p><strong>using和typedef重定义类型</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> 旧的类型名 新的类型名<span class="token punctuation">;</span><span class="token comment">// 使用举例</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> uint_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>using和typedef重定义函数指针</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 使用typedef定义函数指针</span><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用using定义函数指针</span><span class="token keyword">using</span> func_ptr1 <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>using相比typedef定义函数指针式，可读性更强更清晰</p><p><strong>using相比typedef的优点是能定义模板别名</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span> type<span class="token punctuation">;</span><span class="token comment">// error, 语法错误</span><span class="token comment">//只能使用定义一个类来变相使用</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token comment">// 定义外敷类</span><span class="token keyword">struct</span> <span class="token class-name">MyMap</span><span class="token punctuation">&#123;</span>    <span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span> type<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>using定义模板别名</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">using</span> mymap <span class="token operator">=</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li>using 语法和 typedef 一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名</li><li>using 相较于 typedef 的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名</li></ul><h1 id="8-委托构造函数和继承构造函数"><a href="#8-委托构造函数和继承构造函数" class="headerlink" title="8. 委托构造函数和继承构造函数"></a>8. 委托构造函数和继承构造函数</h1><h2 id="8-1-委托构造函数"><a href="#8-1-委托构造函数" class="headerlink" title="8.1 委托构造函数"></a>8.1 委托构造函数</h2><p> &#x3D;&#x3D;委托构造函数允许使用同一个类中的一个构造函数调用此类中定义的其它构造函数&#x3D;&#x3D;，从而简化相关变量的初始化</p><p><strong>注意</strong></p><ul><li><p>链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常</p></li><li><p><em>如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。</em></p></li><li><p>在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了。</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 错误, 使用了委托构造函数就不能再次m_max初始化了</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">,</span> <span class="token keyword">int</span> min<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Test</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_max</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token operator">-></span>m_min <span class="token operator">=</span> min <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> min <span class="token operator">&lt;</span> max <span class="token operator">?</span> min <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="8-2-继承构造函数"><a href="#8-2-继承构造函数" class="headerlink" title="8.2 继承构造函数"></a>8.2 继承构造函数</h2><p>C++11 中提供的&#x3D;&#x3D;继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数&#x3D;&#x3D;</p><p>在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写</p><p>没有继承构造函数之前的处理方式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>    string m_k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 通过使用  <code>using 类名::构造函数名</code> 来声明使用基类的构造函数,这样子类中可以直接使用基类的构造函数来构造派生类对象（注意所有构造函数都能在子类中使用了，因为构造函数名一样）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>    string m_k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果在子类中隐藏了父类中的同名函数，也可以通过 using 类名:函数名 的方式在子类中使用基类中的这些父类函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base class: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> string str<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base class: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">", str = "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>    string m_k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>func<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"child class: i'am luffy!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="9-列表初始化"><a href="#9-列表初始化" class="headerlink" title="9. 列表初始化"></a>9. 列表初始化</h1><blockquote><p> C++ 中的变量，数组，对象等都有不同的初始化方法，在这些繁琐的初始化方法中没有任何一种方式适用于所有的情况。</p><p>为了统一初始化方式，并且让初始化行为具有确定的效果，在 C++11 中提出了列表初始化的概念</p></blockquote><h2 id="9-1-统一的初始化"><a href="#9-1-统一的初始化" class="headerlink" title="9.1 统一的初始化"></a>9.1 统一的初始化</h2><blockquote><p>在 C++98&#x2F;03 中，对应普通数组和可以直接进行内存拷贝（memcpy ()）的对象是可以使用列表初始化来初始化数据的</p><p>在 C++11 中，列表初始化变得更加灵活</p></blockquote><p><strong>列表初始化即使没有定义构造函数在满足要求情况下也能初始化成功</strong>（其实质并不是一定要调用构造函数，只有不满足要求时才会转为调用构造函数来初始化，是否满足要求在下一节中叙述）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test <span class="token function">t1</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最中规中矩的初始化方式，通过提供的带参构造进行对象的初始化</span>    Test t2 <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span> <span class="token comment">//语法错误，因为提供的拷贝构造函数是私有的。如果拷贝构造函数是公共的，520 会通过隐式类型转换被 Test(int) 构造成一个匿名对象，然后再通过对这个匿名对象进行拷贝构造得到 t2（这个错误在 VS 中不会出现，在 Linux 中使用 g++ 编译会提示描述的这个错误）</span>    Test t3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">520</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//使用了 C++11 的初始化方式来初始化对象，效果和 t1 的方式是相同的</span>    Test t4<span class="token punctuation">&#123;</span> <span class="token number">520</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//使用了 C++11 的初始化方式来初始化对象，效果和 t1 的方式是相同的</span>    <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1314</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a2<span class="token punctuation">&#123;</span> <span class="token number">1314</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// C++11 中新添加的语法格式</span>    <span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// C++11 中新添加的语法格式</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>在初始时，{} 前面的等号是否书写对初始化行为没有任何影响</p></li><li><p>使用 new 操作符创建新对象的时候可以使用列表初始化进行对象的初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">&#123;</span><span class="token number">520</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token keyword">double</span><span class="token punctuation">&#123;</span><span class="token number">52.134</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>列表初始化还可以直接用在函数返回值上</p></li></ul><h2 id="9-2-初始化细节"><a href="#9-2-初始化细节" class="headerlink" title="9.2 初始化细节"></a>9.2 初始化细节</h2><p>对于自定义类型的初始化，会存在两种执行结果，如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">T1</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>a <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">321</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">T2</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token function">T2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>b <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">321</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a.x: "</span> <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">", a.y: "</span> <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b.x: "</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">", b.y: "</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">a<span class="token punctuation">.</span>x<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>y<span class="token operator">:</span> <span class="token number">321</span>b<span class="token punctuation">.</span>x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>y<span class="token operator">:</span> <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>执行差异原因如下</strong>：</p><ul><li><p>对象 a 是对一个自定义的聚合类型进行初始化，它将以拷贝的形式使用初始化列表中的数据来初始化 T1 结构体中的成员。</p></li><li><p>在结构体 T2 中自定义了一个构造函数，因此实际的初始化是通过这个构造函数完成的</p></li></ul><p>&#x3D;&#x3D;如果使用列表初始化对对象初始化时，还需要判断这个对象对应的类型是不是一个聚合体，如果是初始化列表中的数据就会拷贝到对象中&#x3D;&#x3D;</p><p>&#x3D;&#x3D;聚合体&#x3D;&#x3D;需要满足以下要求：</p><ul><li><p>无用户自定义的构造函数</p></li><li><p>无私有或保护的非静态数据成员（有私有或保护的静态成员是满足要求的，但不能初始化静态成员）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">T2</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">long</span> y<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span>， <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// error</span><span class="token keyword">struct</span> <span class="token class-name">T2</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">long</span> y<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// ok</span><span class="token comment">// 静态成员的初始化</span><span class="token keyword">int</span> T2<span class="token double-colon punctuation">::</span>z <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>无基类</p></li><li><p>无虚函数</p></li><li><p>类中不能有使用 {} 和 &#x3D; 直接初始化的非静态数据成员（ c++14 开始支持）</p></li></ul><p><strong>非聚合体</strong>：不满足上诉任一条件则为非聚合体</p><p>&#x3D;&#x3D;如果不满足聚合条件使用列表初始化方法：在类的内部自定义一个构造函数, 在构造函数中使用初始化列表对类成员变量进行初始化&#x3D;&#x3D;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">T1</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span>    <span class="token comment">// 在构造函数中使用初始化列表初始化类成员</span>    <span class="token function">T1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", y: "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> <span class="token string">", z: "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    T1 t<span class="token punctuation">&#123;</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token number">1314</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// ok, 基于构造函数使用初始化列表初始化类成员</span>    t<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li><p>聚合类型的定义并非递归的（当一个类的非静态成员是非聚合类型时，这个类也可能是聚合类型）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">T1</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">T2</span><span class="token punctuation">&#123;</span>    T1 t1<span class="token punctuation">;</span>    <span class="token keyword">long</span> x1<span class="token punctuation">;</span>    <span class="token keyword">double</span> y1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    T2 t2<span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//T1 并非一个聚合类型，因为它有一个 Private 的非静态成员。但是尽管 T2 有一个非聚合类型的非静态成员 t1，T2 依然是一个聚合类型，可以直接使用列表初始化的方式进行初始化</span><span class="token comment">//t2 对象的初始化过程，对于非聚合类型的成员 t1 做初始化的时候，可以直接写一对空的大括号 &#123;&#125;，这相当于调用是 T1 的无参构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>对于一个聚合类型，使用列表初始化相当于对其中的每个元素分别赋值，而对于非聚合类型，则需要先自定义一个合适的构造函数，此时使用列表初始化将会调用它对应的构造函数</strong></p></li></ul><h2 id="9-3-std-initializer-list"><a href="#9-3-std-initializer-list" class="headerlink" title="9.3 std::initializer_list"></a>9.3 std::initializer_list</h2><p>std::initializer_list能实现&#x3D;&#x3D;函数只定义一个形参变量，而可以传任意个相同类型的参数&#x3D;&#x3D;</p><p>其和vector来实现传任意个变量十分类似</p><p><strong>std::initializer_list特点</strong>：</p><ul><li>它是一个轻量级的容器类型，内部定义了迭代器 iterator 等容器必须的概念，遍历时得到的迭代器是只读的</li><li>对于 std::initializer_list<T> 而言，它可以接收任意长度的初始化列表，但是要求元素必须是<strong>同种类型 T</strong></li><li>在 std::initializer_list 内部有三个成员接口：size(), begin(), end()</li><li>std::initializer_list 对象只能被整体初始化或者赋值</li></ul><p>使用如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> list<span class="token punctuation">;</span>    list <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current list size: "</span> <span class="token operator">&lt;&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">traversal</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">////////////// 直接通过初始化列表传递数据 //////////////</span>    <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">16</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li>std::initializer_list拥有一个无参构造函数，因此，它可以直接定义实例，此时将得到一个空的</li><li>std::initializer_list，在遍历这种类型的容器的时候得到的是一个只读的迭代器，因此我们不能修改里边的数据，只能通过值覆盖的方式进行容器内部数据的修改（还没搞懂这里的覆盖，都是只读了为啥还能覆盖）</li><li>std::initializer_list的效率是非常高的，它的内部并不负责保存初始化列表中元素的拷贝，仅仅<strong>存储了初始化列表中元素的引用</strong>。</li></ul><h1 id="10-基于范围的for循环"><a href="#10-基于范围的for循环" class="headerlink" title="10. 基于范围的for循环"></a>10. 基于范围的for循环</h1><p>C++11 基于范围的 for 循环，语法格式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>declaration <span class="token operator">:</span> expression<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 循环体</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> value <span class="token operator">:</span> t<span class="token punctuation">)</span><span class="token comment">//t中的值会被拷贝到value中</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>value <span class="token operator">:</span> t<span class="token punctuation">)</span><span class="token comment">//value是t元素的引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>expression 是要遍历的对象，可以是表达式、容器、数组、初始化列表</p><blockquote><p>在遍历过程中，被遍历到的元素会被存储到declaration 中</p><p>在基于范围的for循环中，不需要再传递容器的两端，循环会自动以容器为范围展开，并且循环中也屏蔽掉了迭代器的遍历细节，直接抽取容器中的元素进行运算，使用这种方式进行循环遍历会让编码和维护变得更加简便。</p></blockquote><p><strong>细节</strong></p><ul><li>在关系型容器中<ul><li>使用普通的 for 循环方式（基于迭代器）遍历关联性容器， auto 自动推导出的是一个迭代器类型，需要使用迭代器的方式取出元素中的键值对</li><li>使用基于访问的 for 循环遍历关联性容器，auto 自动推导出的类型是容器中的 value_type，相当于一个对组（std::pair）对象</li></ul></li><li>元素只读型<ul><li>对应 set 容器来说，内部元素都是只读的，这是由容器的特性决定的，因此set 容器在 for 循环中 auto &amp; 会被视为 const auto &amp;</li><li>在遍历关联型容器时也会出现同样的问题，基于范围的for循环中，虽然可以得到一个std::pair引用，但是我们是不能修改里边的first值的，也就是key值。</li></ul></li><li>访问次数<ul><li>基于范围的 for 循环遍历的对象只会被访问一次</li></ul></li></ul><blockquote><p><strong>注意</strong></p><ul><li><p>对应基于范围的 for 循环来说，冒号后边的表达式只会被执行一次。在得到遍历对象之后会先确定好迭代的范围，基于这个范围直接进行遍历。如果是普通的 for 循环，在每次迭代的时候都需要判断是否已经到了结束边界。</p></li><li><p>对容器的遍历过程中，如果只是读数据，不允许修改元素的值，可以使用 const 定义保存元素数据的变量，在定义的时候建议使用 const auto &amp;，这样相对于 const auto 效率要更高一些</p></li></ul></blockquote><h1 id="11-可调用对象包装器、绑定器"><a href="#11-可调用对象包装器、绑定器" class="headerlink" title="11. 可调用对象包装器、绑定器"></a>11. 可调用对象包装器、绑定器</h1><h2 id="11-1可调用对象"><a href="#11-1可调用对象" class="headerlink" title="11.1可调用对象"></a>11.1可调用对象</h2><p><strong>可调用对象定义</strong>有以下几种：</p><ul><li>（1）是一个函数指针</li><li>（2）是一个具有operator()成员函数的类对象（仿函数）</li><li>（3）是一个<strong>可被转换为函数指针的类对象</strong></li><li>（4）是一个类成员函数指针或者类成员指针</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//1 函数指针</span><span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 定义函数指针</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>print<span class="token punctuation">;</span><span class="token comment">//2 具有operator()成员函数的类对象（仿函数）</span><span class="token keyword">struct</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>    <span class="token comment">// ()操作符重载</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>string msg<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"msg: "</span> <span class="token operator">&lt;&lt;</span> msg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test t<span class="token punctuation">;</span>    <span class="token function">t</span><span class="token punctuation">(</span><span class="token string">"我是要成为海贼王的男人!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 仿函数</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//3 可被转换为函数指针的类对象</span><span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> string b<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将类对象转换为函数指针</span>    <span class="token keyword">operator</span> <span class="token function">func_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> print<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//此函数表示将类对象转换为func_ptr类型的函数指针，可以视为仿函数的一层包装，使得仿函数更具有扩展性</span>    <span class="token comment">//调用时是直接使用 类名(参数) 来调用 </span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test t<span class="token punctuation">;</span>    <span class="token comment">// 对象转换为函数指针, 并调用</span>    <span class="token function">t</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"Monkey D. Luffy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//4 类成员函数指针或者类成员指针</span><span class="token keyword">struct</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> string b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> m_num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 定义类成员函数指针指向类成员函数</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span>Test<span class="token double-colon punctuation">::</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>print<span class="token punctuation">;</span><span class="token comment">//这里要不要&amp;符号都可，注意必须加Test::，否则函数指针定义失败</span>    <span class="token comment">//如果是静态成员函数可以不加Test::来定义函数指针   </span>    <span class="token comment">// 类成员指针指向类成员变量</span>    <span class="token keyword">int</span> Test<span class="token double-colon punctuation">::</span><span class="token operator">*</span>obj_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>m_num<span class="token punctuation">;</span>    Test t<span class="token punctuation">;</span>    <span class="token comment">// 通过类成员函数指针调用类成员函数</span>    <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"Monkey D. Luffy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注意这里函数调用形势，必须将前半部分括起来</span>    <span class="token comment">// 通过类成员指针初始化类成员变量</span>    t<span class="token punctuation">.</span><span class="token operator">*</span>obj_ptr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"number is: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述几种方式定义繁杂，且调用方法也不相同，C++11通过提供std::function 和 std::bind统一了可调用对象的各种操作</p><h2 id="11-2-可调用对象包装器"><a href="#11-2-可调用对象包装器" class="headerlink" title="11.2 可调用对象包装器"></a>11.2 可调用对象包装器</h2><p>std::function是可调用对象的包装器。</p><p>是一个类模板，可以容纳&#x3D;&#x3D;除了类成员（函数）指针&#x3D;&#x3D;之外的所有可调用对象。</p><p>通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和<strong>延迟</strong>执行它们。</p><p><strong>可调用对象包装器使用语法</strong>如下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span>返回值类型<span class="token punctuation">(</span>参数类型列表<span class="token punctuation">)</span><span class="token operator">></span> diy_name <span class="token operator">=</span> 可调用对象<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" - "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">-</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" * "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">*</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 绑定以静态类成员函数</span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> T1<span class="token double-colon punctuation">::</span>sub<span class="token punctuation">;</span>    <span class="token comment">// 绑定一个仿函数</span>    T2 t<span class="token punctuation">;</span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f3 <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token comment">//注意这里定义！！！！</span>    <span class="token comment">// 函数调用</span>    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">f3</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;std::function 可以将可调用对象进行包装，得到一个统一的格式&#x3D;&#x3D;，</p><p>包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用</p><p><strong>作为回调函数使用</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 构造函数参数是一个包装器对象</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">&amp;</span> f<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">callback</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token comment">//注意这里不会调用f函数，只是当成一个参数传递赋值</span>    <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用通过构造函数得到的函数指针</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> callback<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    A <span class="token function">a</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仿函数通过包装器对象进行包装</span>    a<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 std::function 作为函数的传入参数，可以将定义方式不相同的可调用对象进行统一的传递，这样大大增加了程序的灵活性。</p><p>注意：传入的函数形式需要与function&lt;&gt;中的函数形式一致才可</p><h2 id="11-3-绑定器"><a href="#11-3-绑定器" class="headerlink" title="11.3 绑定器"></a>11.3 绑定器</h2><p>std::bind用来将&#x3D;&#x3D;可调用对象与其参数一起进行绑定&#x3D;&#x3D;。</p><p>绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候</p><p><strong>作用：</strong></p><ul><li>将可调用对象与其参数一起绑定成一个&#x3D;&#x3D;仿函数&#x3D;&#x3D;。</li><li>将多元（参数个数为n，n&gt;1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数</li></ul><p><strong>绑定器函数使用语法格式如下：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 绑定非类成员函数/变量 </span><span class="token comment">//类静态函数也可使用此方法</span><span class="token keyword">auto</span> f <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>可调用对象地址<span class="token punctuation">,</span> 绑定的参数<span class="token operator">/</span>占位符<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 绑定类成员函/变量。类成员函数都有一个隐藏指针，其实有两个参数，需要指定this为第一个参数</span><span class="token keyword">auto</span> f <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>类函数<span class="token operator">/</span>成员地址<span class="token punctuation">,</span> 类实例对象地址<span class="token punctuation">,</span> 绑定的参数<span class="token operator">/</span>占位符<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function</p><p>在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了</p><p>提供占位符，<code>placeholders::_1</code> 是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代。</p><p><code>placeholders::_2</code>、<code>placeholders::_3</code>同理（&#x3D;&#x3D;注意&#x3D;&#x3D;，占位符是按位置去找的，<code>placeholders::_2</code>只会去找第二个数，即使只有一个数，且没有<code>placeholders::_1</code>也只会去找第二个数，那么就会找不到报错）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数</span>    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// error, 调用时没有第二个参数</span>     <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//！！！占位符是按位置去找的，不是按个数</span>    <span class="token comment">// 调用时第一个参数10被吞掉了，没有被使用</span>    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>绑定类成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", y: "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> m_number <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test t<span class="token punctuation">;</span>    <span class="token comment">// 绑定类成员函数</span>    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span>         <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>output<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 绑定类成员变量(公共) </span>    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>m_number<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里auto推导出的类型不是包装器类型而是仿函数</span>    <span class="token keyword">auto</span> f3 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>m_number<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用</span>    <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">1314</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2333</span><span class="token punctuation">;</span><span class="token comment">//注意还可这样调用</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t.m_number: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_number <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function&lt;**int&amp;**(void)&gt;的包装器对象f2中</p><p>其中&#x3D;&#x3D;int是绑定的类成员的类型&#x3D;&#x3D;，这里返回值是int&amp;的原因是：定义一个类成员的函数，那么就要能访问和修改它，因此类型为int&amp;</p><p>由于没有参数因此参数列表指定为void</p><p><strong>注意</strong></p><ul><li>函数如果使用绑定器制定了参数，即使后面函数调用时传参，那么也只会使用绑定器绑定时设置的数值。</li><li>绑定类成员变量时，必须是公有变量</li><li>包装器类成员的书写语法为function&lt;类成员类型&amp;(void)&gt;</li><li>使用auto推导出的绑定器类型是反函数，而使用包装器定义的绑定器的变量类型是包装器类型</li></ul><h1 id="12-Lambda表达式"><a href="#12-Lambda表达式" class="headerlink" title="12. Lambda表达式"></a>12. Lambda表达式</h1><blockquote><p>lambda 表达式是 C++11 最重要也是最常用的特性之一</p></blockquote><p>相比传统函数，lambda表达式特点是局部定义然后销毁</p><p><strong>优点</strong>：</p><ul><li>声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象</li><li>简洁：避免了代码膨胀和功能分散，让开发更加高效</li><li>在需要的时间和地点实现功能闭包，使程序更加灵活</li></ul><h2 id="12-1-基本使用"><a href="#12-1-基本使用" class="headerlink" title="12.1 基本使用"></a>12.1 基本使用</h2><p>&#x3D;&#x3D;lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量&#x3D;&#x3D;，语法形式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>capture<span class="token punctuation">]</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> opt <span class="token operator">-></span> ret <span class="token punctuation">&#123;</span>body<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 capture 是捕获列表，params 是参数列表，opt 是函数选项，ret 是返回值类型，body 是函数体。</p><ul><li>捕获列表 []: 捕获一定范围内的变量</li><li>参数列表 (): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写</li><li>opt 选项， 不需要可以省略<ul><li>mutable: 可以&#x3D;&#x3D;修改按值传递进来的拷贝&#x3D;&#x3D;（注意是能修改拷贝，而不是值本身）</li><li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ()</li></ul></li><li>返回值类型：在 C++11 中，lambda 表达式的返回值是通过返回值后置语法来定义的（能自动推导返回类型，可不写，但初始化返回类型时必须写）</li><li>函数体：函数的实现，这部分不能省略，但函数体可以为空</li></ul><h2 id="12-2-捕获列表"><a href="#12-2-捕获列表" class="headerlink" title="12.2 捕获列表"></a>12.2 捕获列表</h2><p>lambda 表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p><ul><li>[] - 不捕捉任何变量</li><li>[&amp;] - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (按引用捕获)</li><li>[&#x3D;] - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (按值捕获)<br>&#x3D;&#x3D;拷贝的副本在匿名函数体内部是只读&#x3D;&#x3D;的</li><li>[&#x3D;, &amp;foo] - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo</li><li>[bar] - &#x3D;&#x3D;按值捕获 bar 变量，同时不捕获其他变量&#x3D;&#x3D;</li><li>[&amp;bar] - 按引用捕获 bar 变量，同时&#x3D;&#x3D;不捕获其他变量&#x3D;&#x3D;</li><li>[this] - 捕获当前类中的 this 指针<ul><li>让 lambda 表达式拥有和当前类成员函数同样的访问权限</li><li>&#x3D;&#x3D;如果已经使用了 &amp; 或者 &#x3D;, 默认添加this指针&#x3D;&#x3D;</li></ul></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                      <span class="token comment">// error 没有捕获外部变量，不能使用类成员 m_number</span>        <span class="token keyword">auto</span> x2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>             <span class="token comment">// ok</span>        <span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>             <span class="token comment">// ok </span>        <span class="token keyword">auto</span> x4 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                  <span class="token comment">// ok</span>        <span class="token keyword">auto</span> x5 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>          <span class="token comment">// error 没有捕获到变量 x，y，因此不能访问</span>        <span class="token keyword">auto</span> x6 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// ok</span>        <span class="token keyword">auto</span> x7 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                <span class="token comment">// ok</span>        <span class="token keyword">auto</span> f8 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//error 显示捕获与默认匹配</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> m_number <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;默认状态下 lambda 表达式无法修改通过复制方式捕获外部变量&#x3D;&#x3D;</p><p>如果希望修改这些外部变量，需要通过引用的方式进行捕获。</p><h2 id="12-3-返回值"><a href="#12-3-返回值" class="headerlink" title="12.3 返回值"></a>12.3 返回值</h2><p>一般情况下，不指定 lambda 表达式的返回值，编译器会根据 return 语句自动推导返回值的类型</p><p>&#x3D;&#x3D;labmda表达式不能通过列表初始化自动推导出返回值类型&#x3D;&#x3D;</p><h2 id="12-4-函数本质"><a href="#12-4-函数本质" class="headerlink" title="12.4 函数本质"></a>12.4 函数本质</h2><p>使用mutable关键字修饰时，可以修改lambda表达式按值捕获的外部变量</p><p>被mutable修改是lambda表达式就算没有参数也要写明参数列表</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>              <span class="token comment">// error, 按值捕获外部变量, a是只读的</span><span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token comment">// ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按值捕获的外部变量是只读的原因：</p><ul><li>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数</li><li>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</li></ul><p><strong>可以使用std::function和std::bind来存储和操作lambda表达式</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 包装可调用函数</span>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 绑定可调用函数</span>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 没有捕获任何外部变量的匿名函数</span>func_ptr f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 函数调用</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1314</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li>包装器和绑定器定义的函数变量也只是个局部变量，一般是在同作用域下使用，此时也就不用关心捕获变量能不能捕捉到</li><li>可以在类函数中也定义lambda表达式。无论是普通函数还是类函数，定义的lambda表达式只能在<strong>定义函数中使用</strong>和<strong>定义函数中调用其他函数使用</strong>，因为此时函数还在栈中，地址已知</li><li>lambda是一个仿函数，但未捕获变量时可以转换为一个普通的函数指针</li><li>若<strong>定义lambda表达式时直接调用，在body后面加 () 即可</strong></li></ul><h1 id="13-右值引用"><a href="#13-右值引用" class="headerlink" title="13. 右值引用"></a>13. 右值引用</h1><blockquote><p>C++11以前，函数变量若想接受右值，则需要声明为const A &amp;，但是如此声明后在函数中A又不能改。如果声明为A&amp;，那么又不能接受右值。因此，右值引用应运而生。</p></blockquote><p>C++11 增加了一个新的类型，称为右值引用（ R-value reference），标记为 &amp;&amp;</p><h2 id="13-1-右值引用"><a href="#13-1-右值引用" class="headerlink" title="13.1 右值引用"></a>13.1 右值引用</h2><blockquote><p>自C++11开始，表达式的值分为<code>左值(lvalue, left value)</code>、<code>将亡值(xvalue, expiring value)</code>、<code>纯右值(pvalue, pure ravlue)</code>以及两种混合类别<code>泛左值(glvalue, generalized lvalue)</code>和<code>右值(rvalue, right value)</code>五种。</p><p>这五种类别的分类基于表达式的两个特征：</p><ul><li>具名(identity):可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的（直接或间接获得的）地址</li><li>可被移动：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式</li></ul><p>结合上述两个特征，对五种表达式值类别进行重新定义：</p><ul><li>lvalue:具名且不可被移动</li><li>xvaue:具名且可被移动</li><li>prvalue:不具名且可被移动</li><li>glvalue:具名，lvalue和xvalue都属于glvalue</li><li>rvalue:可被移动的表达式，prvalue和xvalue都属于rvalue</li></ul></blockquote><p><strong>左值和右值</strong>：</p><ul><li>lvalue 是 loactor value 的缩写，rvalue 是 read value 的缩写</li><li>左值是指存储在内存中、有明确存储地址（可取地址）的数据</li><li>右值是指可以提供数据值的数据（程序员不可取地址，而非编译器）</li></ul><p>区分左值与右值的便捷方法是：&#x3D;&#x3D;可以对表达式取地址（&amp;）就是左值，否则为右值&#x3D;&#x3D;</p><blockquote><p>C++11 中<strong>右值可以分为两种</strong>：一个是<strong>将亡值</strong>（ xvalue, expiring value），另一个则是<strong>纯右值</strong>（ prvalue, PureRvalue）：</p><ul><li>纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等</li><li>将亡值：与右值引用相关的表达式，比如，T&amp;&amp; 类型函数的返回值、 std::move 的返回值等</li></ul></blockquote><p><strong>右值引用</strong>就是对一个右值进行引用的类型</p><ul><li>无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名</li><li>通过右值引用的声明，该右值又“重获新生”，&#x3D;&#x3D;其生命周期与右值引用类型变量的生命周期一样&#x3D;&#x3D;，只要该变量还活着，该右值临时量将会一直存活下去</li><li>使用左值初始化一个右值引用类型是不合法的</li><li>右值不能给普通的左值引用赋值</li><li>&#x3D;&#x3D;常量左值引用是一个万能引用类型，它可以接受左值、右值、常量左值和常量右值&#x3D;&#x3D;。（const Test&amp; t &#x3D;  XXX）</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a1<span class="token punctuation">;</span>    <span class="token comment">//左值引用</span>    <span class="token keyword">int</span><span class="token operator">&amp;</span> b1 <span class="token operator">=</span> a1<span class="token punctuation">;</span>    <span class="token comment">//右值引用</span>    <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> c1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment">//常量左值引用</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> d1 <span class="token operator">=</span> a1<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> d2 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> d3 <span class="token operator">=</span> c1<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> d4 <span class="token operator">=</span> b1<span class="token punctuation">;</span>    <span class="token comment">//常量右值引用</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> e1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> e2 <span class="token operator">=</span> b1<span class="token punctuation">;</span> <span class="token comment">//error</span>    <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span>        <span class="token comment">// error</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>方便记忆</strong></p><ul><li>左值引用实质是一个指针常量，右值很多都是字面量，因此其不能使用右值赋值</li><li>左值引用是个指针常量，那么加上一个const就变为常量指针常量（常量指针常量可以不指向常量），当其指向右值时，编译器会自动创建一个左值绑定此右值，然后将引用指向此左值，因此也就能指向右值了</li><li>无论是左值引用还是右值引用，都表示其能取地址了，相当于左值化了，因此无论是左值引用还是常量左值引用都能使用各种引用来初始化</li><li>右值引用可以理解为一个必须指向右值的指针常量，因此其初始化只能未右值</li></ul></blockquote><p>总结：两种引用都是左值，左值引用可以简单理解为一个指针常量，右值引用可以简单理解为是一个只能指向右值的指针常量</p><h2 id="13-2-性能优化"><a href="#13-2-性能优化" class="headerlink" title="13.2 性能优化"></a>13.2 性能优化</h2><blockquote><p>C++在进行赋值操作时，有时会发生对象之间的深拷贝，但有些对象是临时对象，赋值后就要被销毁，那么可以利用这个临时对象的堆资源避免赋值对象再次申请资源</p><p>解决上述资源浪费的方法就是使用移动构造函数，利用右值引用的移动语义</p></blockquote><p>右值引用<strong>具有移动语义</strong>，移动语义可以将资源（堆、系统对象等）通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建、拷贝以及销毁</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_num</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct: my name is jerry"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_num</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">.</span>m_num<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy construct: my name is tom"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 添加移动构造函数</span>    <span class="token function">Test</span><span class="token punctuation">(</span>Test<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_num</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>m_num<span class="token punctuation">)</span><span class="token comment">//注意！！ 移动构造函数没有const 也不能加const</span>    <span class="token punctuation">&#123;</span>        a<span class="token punctuation">.</span>m_num <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//这里时为了避免临时对象销毁时释放原来堆资源</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"move construct: my name is sunny"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">delete</span> m_num<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destruct Test class ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span><span class="token operator">*</span> m_num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Test <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test t<span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test t <span class="token operator">=</span> <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自动调用移动构造函数</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t.m_num: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>t<span class="token punctuation">.</span>m_num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    Test<span class="token operator">&amp;&amp;</span> t1<span class="token operator">=</span><span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此种方法也会自动调用移动构造函数</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加移动构造函数后，由于返回的是右值（可移动），赋值操作时会优先调用移动构造函数进行赋值</p><p>&#x3D;&#x3D;移动构造函数只会重复利用了临时对象的堆资源，不会也不能利用栈上的变量&#x3D;&#x3D;</p><blockquote><p><strong>注意</strong></p><ul><li>对于需要动态申请大量资源的类，应该设计移动构造函数，以提高程序效率</li><li>一般在提供移动构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成还可以使用拷贝构造函数</li><li>默认调用移动构造函数的方式有两种（调不调用移动构造函数还是看返回值是否可移动）：<ul><li>Test t &#x3D; getObj()</li><li>Test&amp;&amp; t1&#x3D;getObj()</li></ul></li><li>对于一些简单的函数，编译器利用RVO和NRVO技术将其优化，而不使用（移动）拷贝构造函数，比如上述例子如不禁止优化则不会使用移动构造函数</li><li>移动构造函数声明里变量不加const</li><li>如果一个类中的类成员具有移动构造函数，在调用类移动构造函数初始化列表时，不会自动调用类成员的移动构造函数，需要如此初始化：A(A&amp;&amp; t):a(move(t.a))</li></ul></blockquote><h2 id="13-3-编译器优化：RVO和NRVO"><a href="#13-3-编译器优化：RVO和NRVO" class="headerlink" title="13.3 编译器优化：RVO和NRVO"></a>13.3 编译器优化：RVO和NRVO</h2><blockquote><p>当没有移动拷贝构造函数时，编译器有些情况下也会使用RVO和NRVO对代码进行优化。</p><p>此时表现就是返回的右值仍然可以直接用于初始化右值引用，相当于编译器直接将函数部分给省略了，而直接给右值引用那赋值。</p></blockquote><p><strong>RVO</strong></p><blockquote><p>RVO (Return Value Optimization)，是一种编译器优化技术，通过该技术，编译器可以减少函数返回时生成临时对象的个数，从某种程度上可以提高程序的运行效率，对需要分配大量内存的类对象其值复制过程十分友好。</p><ul><li>当一个未具名且未绑定到任何引用的临时变量被移动或复制到一个相同的对象时，拷贝和移动构造可以被省略</li><li>当这个临时对象在被构造的时候，他会直接被构造在将要拷贝&#x2F;移动到的对象</li><li>当未命名临时对象是函数返回值时，发生的省略拷贝的行为被称为RVO(返回值优化)。</li></ul></blockquote><p><strong>NRVO</strong></p><blockquote><p>NRVO，又名具名返回值优化 (Named Return Value Optimization)，为RVO的一个变种，也是一种编译器对于函数返回值优化的方式。此特性从C++11开始支持，也就是说C++98、C++03都是没有将此优化特性写到标准中的，与RVO的不同之处在于函数返回的临时值是具名的。</p><ul><li>NRVO与RVO的区别是返回的对象是具名的</li><li>既然返回的对象是具名的，那么对象是在return语句之前就构造完成。</li></ul></blockquote><p><strong>RVO和NRVO原理都是将返回一个类对象的函数的返回值当做该函数的参数来处理</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Test <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> Test<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//返回的是一个匿名的临时对象 编译器使用RVO技术优化</span>    <span class="token comment">//当没有移动拷贝构造函数时，此种类型应该是调用拷贝构造函数，但编译器会使用RVO技术优化</span><span class="token punctuation">&#125;</span>Test<span class="token operator">&amp;&amp;</span> <span class="token function">getObj1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> Test<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//RVO优化</span><span class="token punctuation">&#125;</span>Test <span class="token function">getObj2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test t<span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token comment">//NRVO优化</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Test<span class="token operator">&amp;&amp;</span> t2<span class="token operator">=</span><span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//RVO优化 相当于没有在函数部分创建临时变量了</span>    Test<span class="token operator">&amp;&amp;</span> t1<span class="token operator">=</span><span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//RVO优化 相当于没有在函数部分创建临时变量了</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>RVO和NRVO原理</strong></p><p>RVO优化的原理是消除函数返回时产生的一次临时对象</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Obj <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj <span class="token function">obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当面对上面代码时，编译器RVO会将其优化成：(注意，这种情况其实是适用于NRVO优化的，RVO优化对此没有好处。但是，不是说一段代码可以NRVO就不能RVO。<strong>NRVO相比于RVO，只是一种要求更为严格的优化方式</strong>)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span>Obj <span class="token operator">&amp;</span>_obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj <span class="token function">obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  _obj<span class="token punctuation">.</span><span class="token class-name">Obj</span><span class="token double-colon punctuation">::</span><span class="token function">Obj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝构造函数</span>  <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj<span class="token punctuation">;</span> <span class="token comment">// 仅定义不构造</span>  <span class="token function">fun</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码如果使用NRVO来优化则如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span>Obj <span class="token operator">&amp;</span>_obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   _obj<span class="token punctuation">.</span><span class="token class-name">Obj</span><span class="token double-colon punctuation">::</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj<span class="token punctuation">;</span>  <span class="token function">fun</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RVO适用于不具名的临时对象优化</p><p>面对以下代码时，RVO优化会非常彻底，只剩下一次构造</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Obj <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//RVO优化后</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span>Obj <span class="token operator">&amp;</span>_obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  _obj<span class="token punctuation">.</span><span class="token class-name">Obj</span><span class="token double-colon punctuation">::</span><span class="token function">Obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj<span class="token punctuation">;</span>  <span class="token function">fun</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>RVO和NRVO优化失效情况</strong></p><p>编译器并非智能的，对于某些复杂场景或者特殊场景，是不会启用优化的，这个时候就需要开发人员依赖具体的情况，进行具体分析，以达到优化的目的。</p><p>优化失效情况：</p><ul><li><p>运行时依赖(根据不同的条件分支，返回不同变量)</p><ul><li><p>当编译器无法单纯通过函数来决定返回哪个实例对象时，会禁用(N)RVO。</p></li><li><p>但是，下面这种情况例外，虽然其仍然依赖于具体的条件判断。这是因为，<code>对于单个对象以及多个函数出口的情况，编译器将多个出口优化为一个</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Obj <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">bool</span> flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  obj<span class="token punctuation">.</span>n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>返回全局变量(当返回的对象不是在函数内创建的时候，是无法执行返回值优化的。)</p></li><li><p>返回函数参数（与返回全局变量类似，当返回的对象不是在函数内创建的时候，是无法执行返回值优化的。）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Obj <span class="token function">fun</span><span class="token punctuation">(</span>Obj obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj o<span class="token punctuation">;</span>  Obj obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"in main "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>obj <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>返回成员变量（在某些特殊情况下，即使是未具名变量，也不能RVO）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Wraper</span> <span class="token punctuation">&#123;</span>   Obj obj<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Obj <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">Wraper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>obj<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>obj <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>存在赋值行为（(N)RVO只能在从返回值创建对象时发送，在现有对象上使用<code>operator=</code>而不是拷贝&#x2F;移动构造函数，这样是不会进行RVO操作的。）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Obj <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Obj obj<span class="token punctuation">;</span>  obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用std::move()返回（在返回值上调用std::move()进行返回是一种错误的方式。它会尝试强制调用移动构造函数，但这样会导致RVO失效。因为即使没有显示调用std::move()，编译器优化中也会执行move操作）</p></li></ul><h2 id="13-4-amp-amp-特性"><a href="#13-4-amp-amp-特性" class="headerlink" title="13.4 &amp;&amp;特性"></a>13.4 &amp;&amp;特性</h2><p>并不是所有情况下 &amp;&amp; 都代表是一个右值引用</p><p>两种场景下 &amp;&amp; 被称作未定的引用类型（也叫&#x3D;&#x3D;万能引用&#x3D;&#x3D;）：</p><ul><li>模板参数时指定为 T&amp;&amp;</li><li>自动类型推导时指定为 auto &amp;&amp;</li></ul><p>&#x3D;&#x3D;const T&amp;&amp; 表示一个右值引用&#x3D;&#x3D;，不是未定引用类型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传入的实参 10 是右值，因此 T&amp;&amp; 表示右值引用</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传入的实参是 x 是左值，因此 T&amp;&amp; 表示左值引用</span><span class="token function">f1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//参数是 const T&amp;&amp; 不是未定引用类型，不需要推导，本身就表示一个右值引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1314</span><span class="token punctuation">;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> v1 <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">//表示一个整形的左值引用</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> v2 <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span><span class="token comment">//表示一个整形的右值引用</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span> v3 <span class="token operator">=</span> y<span class="token punctuation">;</span>   <span class="token comment">// error decltype(x)&amp;&amp; 等价于 int&amp;&amp; 是一个右值引用不是未定引用类型，y 是一个左值，不能使用左值初始化一个右值引用类型。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当面对T&amp;&amp; 或者 auto&amp;&amp; 两种万能引用时时，会发生&#x3D;&#x3D;引用折叠&#x3D;&#x3D;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token operator">&amp;</span>  lref<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> rref<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>lref<span class="token operator">&amp;</span>  r1 <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// type of r1 is int&amp;</span>lref<span class="token operator">&amp;&amp;</span> r2 <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// type of r2 is int&amp;</span>rref<span class="token operator">&amp;</span>  r3 <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// type of r3 is int&amp;</span>rref<span class="token operator">&amp;&amp;</span> r4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// type of r4 is int&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>折叠规则总结</strong></p><ul><li>&#x3D;&#x3D;右值引用的右值引用折叠为右值引用&#x3D;&#x3D;</li><li>&#x3D;&#x3D;其他所有类型折叠为左值引用&#x3D;&#x3D;</li></ul><blockquote><p><strong>万能引用时折叠规则如下</strong>：</p><ul><li>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型（记住这个就可）</li><li>通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个左值引用类型</li></ul></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"l-value: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"r-value: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printValue</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>    <span class="token function">printValue</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token number">1314</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">forward</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//输出结果</span>l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">520</span>r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">250</span><span class="token comment">//k 变成了一个命名对象，编译器会将其当做左值来处理</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当面对上述传递一个右值但仍调用左值引用函数情况时，我们希望的是传入左值就调用左值引用函数，传入右值就调用右值引用函数</p><p>解决上述问题的方法就是&#x3D;&#x3D;完美转发std::forward&#x3D;&#x3D; ，它定义如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">></span>T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;</span> t <span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其原理就是<strong>折叠引用</strong>，其返回值类型是T&amp;&amp;</p><ul><li>当传入左值时，<strong>T&amp;&amp; &#x3D; A&amp; &amp;&amp; &#x3D; A&amp;</strong></li><li>当传入是const左值时，折叠引用后得到const A&amp;</li><li>当传入是右值时，<strong>T&amp;&amp; &#x3D; A&amp;&amp; &amp;&amp; &#x3D; A&amp;&amp;</strong></li></ul><p>使用如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">push</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值（有点歧义，还没搞懂这里）</li><li>auto&amp;&amp;或者函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型（上面有例子）</li><li>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型，其余都是左值引用类型</li><li>万能引用推导使用的是引用折叠规则，完美转发的原理也是使用的引用折叠</li></ul></blockquote><h1 id="14-转移和完美转发"><a href="#14-转移和完美转发" class="headerlink" title="14. 转移和完美转发"></a>14. 转移和完美转发</h1><h2 id="14-1-move"><a href="#14-1-move" class="headerlink" title="14.1 move"></a>14.1 move</h2><blockquote><p>在C++11中，如果想用左值来初始化右值引用是无法完成的，但有时又需要使用左值来初始化右值引用，比如函数返回一个左值</p><p>因此，C++11提供了std::move函数来将一个左值转换为右值</p></blockquote><p>std::move等同于类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue)</p><p>函数原型如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ty</span><span class="token operator">></span>_NODISCARD <span class="token keyword">constexpr</span> remove_reference_t<span class="token operator">&lt;</span>_Ty<span class="token operator">></span><span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>_Ty<span class="token operator">&amp;&amp;</span> _Arg<span class="token punctuation">)</span> _NOEXCEPT<span class="token punctuation">&#123;</span><span class="token comment">// forward _Arg as movable</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>remove_reference_t<span class="token operator">&lt;</span>_Ty<span class="token operator">></span><span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>_Arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用方法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Test t<span class="token punctuation">;</span>Test <span class="token operator">&amp;&amp;</span> v2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ok</span>list<span class="token operator">&lt;</span>string<span class="token operator">></span> ls<span class="token punctuation">;</span>ls<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ls<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token operator">&lt;</span>string<span class="token operator">></span> ls1 <span class="token operator">=</span> ls<span class="token punctuation">;</span>        <span class="token comment">// 需要拷贝, 效率低</span>list<span class="token operator">&lt;</span>string<span class="token operator">></span> ls2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中的move可以使得效率很高而无需拷贝，其根本原因是&#x3D;&#x3D;list容器实现了移动构造函数，move函数只是将ls转换为一个左值，使得自动调用移动构造函数&#x3D;&#x3D;</p><p><strong>注意</strong></p><ul><li>调用move函数赋值后，原来变量不能再使用，其资源已经被转移</li><li>move函数只是将变量类型做了个改变，并没有改变变量</li></ul><h2 id="14-2-forward"><a href="#14-2-forward" class="headerlink" title="14.2 forward"></a>14.2 forward</h2><p>引入forward的原因可见13.3节</p><p>使用std::forward () 函数可以将参数原来的类型转发到另一个函数</p><p>原型如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数原型</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span> <span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span> <span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">// 精简之后的样子</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其原理就是折叠引用，具体可见13.3节</p><h1 id="15-智能指针"><a href="#15-智能指针" class="headerlink" title="15. 智能指针"></a>15. 智能指针</h1><blockquote><p>在 C++ 中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针</p></blockquote><p>&#x3D;&#x3D;智能指针是存储指向动态分配（堆）对象指针的类&#x3D;&#x3D;，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。</p><p>&#x3D;&#x3D;智能指针的核心实现技术是引用计数&#x3D;&#x3D;，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</p><p>C++11 中提供了三种智能指针，使用这些智能指针时需要引用头文件 <memory></p><ul><li>std::shared_ptr：共享的智能指针</li><li>std::unique_ptr：独占的智能指针</li><li>std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视 shared_ptr 的。</li></ul><h2 id="15-1-shared-ptr指针"><a href="#15-1-shared-ptr指针" class="headerlink" title="15.1 shared_ptr指针"></a>15.1 shared_ptr指针</h2><p>&#x3D;&#x3D;共享智能指针是指多个智能指针可以同时管理同一块有效的内存&#x3D;&#x3D;</p><p>共享智能指针是一个变量，但是通过重载<code>-&gt;</code>符号使得其可以直接调用其原始指针的函数，从而看起来像一个指针</p><p>shared_ptr引用计数是线程安全的，但调用其资源并不是线程安全的</p><blockquote><p>共享智能指针 shared_ptr 是一个模板类，如果要进行初始化有四种方式：通过构造函数、（移动）拷贝函数、<code>std::make_shared</code> 辅助函数以及 reset 方法</p><p>共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存</p><p>如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数 use_count，函数原型如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。</span><span class="token keyword">long</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h3 id="15-1-1-shared-ptr原理"><a href="#15-1-1-shared-ptr原理" class="headerlink" title="15.1.1 shared_ptr原理"></a>15.1.1 shared_ptr原理</h3><p>shared_ptr 需要维护的信息有两部分：</p><ul><li>指向共享资源的指针。</li><li>引用计数等共享资源的控制信息——实现上是维护一个指向控制信息的指针（控制信息中包含ref count、weak ref count、deleter、ptr信息（这个ptr类别是共享资源类型，指向共享资源，是为了解决类继承））。</li></ul><p>shared_ptr 的 的 deleter 是保存在控制信息中，是否有自定义 deleter 不影响 shared_ptr 对象的大小。</p><p>shared_ptr中有一个指针指向共享资源，控制信息中也有一个指针指向共享资源，但是并不能减少其中任意一个，原因如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Fruit</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> juice<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Vegetable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fiber<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Tomato</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Fruit</span><span class="token punctuation">,</span> <span class="token class-name">Vegetable</span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sauce<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 由于继承的存在，shared_ptr 可能指向基类对象</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Tomato<span class="token operator">></span> tomato <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Tomato<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Fruit<span class="token operator">></span> fruit <span class="token operator">=</span> tomato<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Vegetable<span class="token operator">></span> vegetable <span class="token operator">=</span> tomato<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，tomato中的原始指针是一个Tomato类型指针，fruit中的原始指针是一个Fruit指针，vegetable中的原始指针是一个Vegetable，而其控制信息中指向资源的指针是一个Tomato类型指针</p><p>如果没有控制信息中指向资源的指针，其资源本来是Tomato类型的，当一个fruit共享指针指向这个Tomato资源时，如果我们拿fruit指针去初始化一个新的Tomato共享指针则会报错（资源是Tomato类型，不应该初始化失败）</p><p>shared_ptr重载了<code>*</code>和<code>-&gt;</code>符号，使得能直接调用原始指针的函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">*</span>m_pointer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> m_pointer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//对于 A->func()</span><span class="token comment">//注意！！->重载后，只有类对象调用->时才会重载，类指针调用->时不会使用此重载</span><span class="token comment">//当A是指针时，则编译直接解释为A->fun()，而不会管是否重载</span><span class="token comment">//当A时对象时，则编译器解释为A.operator->()->func(),这里才是真使用了->重载函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="15-1-2-shared-ptr初始化及使用"><a href="#15-1-2-shared-ptr初始化及使用" class="headerlink" title="15.1.2 shared_ptr初始化及使用"></a>15.1.2 shared_ptr初始化及使用</h3><p><strong>通过构造函数初始化</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// shared_ptr&lt;T> 类模板中，提供了多种实用的构造函数, 语法格式如下:</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> 智能指针名字<span class="token punctuation">(</span>创建堆内存<span class="token punctuation">)</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>如果智能指针被初始化了一块有效内存，那么这块内存的引用计数 + 1</p></li><li><p>如果智能指针没有被初始化或者被初始化为 nullptr 空指针，引用计数不会 + 1</p></li><li><p>&#x3D;&#x3D;不要使用一个原始指针初始化多个 shared_ptr&#x3D;&#x3D;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// error, 编译不会报错, 运行会出错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>通过拷贝和移动构造函数初始化</strong></p><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象</p><p>在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//调用拷贝构造函数</span>   shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr2</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr3 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span>   <span class="token comment">//调用移动构造函数</span>   shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr4</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr5 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加</li><li>如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化</li></ul><p><strong>通过 std::make_shared 初始化</strong></p><p>C++ 提供的 <code>std::make_shared()</code> 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args <span class="token operator">></span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_shared</span><span class="token punctuation">(</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//T：模板参数的数据类型</span><span class="token comment">//Args&amp;&amp;... args ：要初始化的数据，如果是通过 make_shared 创建对象，需按照构造函数的参数列表指定</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用方法</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">   <span class="token comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span>   shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> ptr2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> ptr3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//make_shared后面括号里的值是初始化参数，会自动调用对应的构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用 std::make_shared() 模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理</li><li>如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数</li></ul><p><strong>通过 reset 方法初始化</strong></p><p><code>std::shared_ptr::reset</code> 有两种用处：</p><ul><li>将指针重置，即不再指向原来那块内存</li><li>将指针指向新的内存</li></ul><p><code>std::shared_ptr::reset</code> 方法函数原型如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span> <span class="token operator">></span><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> Y<span class="token operator">*</span> ptr <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Deleter</span> <span class="token operator">></span><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> Y<span class="token operator">*</span> ptr<span class="token punctuation">,</span> Deleter d <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Deleter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">></span><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> Y<span class="token operator">*</span> ptr<span class="token punctuation">,</span> Deleter d<span class="token punctuation">,</span> Alloc alloc <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ptr：指向要取得所有权的对象的指针</span><span class="token comment">//d：指向要取得所有权的对象的指针</span><span class="token comment">//aloc：内部存储所用的分配器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用方法</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr4 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span>ptr4<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr5<span class="token punctuation">;</span>ptr5<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于一个未初始化的共享智能指针，可以通过 reset 方法来初始化</li><li>当智能指针中有值的时候，调用 reset 会使引用计数减 1</li></ul><p><strong>获取原始指针和调用原始指针的函数</strong></p><p>调用共享智能指针类提供的 get () 方法得到原始地址，其函数原型如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 得到指针的原始地址</span><span class="token keyword">char</span><span class="token operator">*</span> add <span class="token operator">=</span> ptr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ptr<span class="token operator">-></span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用原始指针的函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意获得原始指针的函数是用<code>.</code>，而调用原始指针函数是用<code>-&gt;</code></p><p><strong>指定删除器</strong></p><p>当智能指针管理的内存对应的引用计数变为 0 的时候，这块内存就会被智能指针析构掉</p><p>在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为&#x3D;&#x3D;删除器，删除器函数本质是一个回调函数&#x3D;&#x3D;</p><p>删除器函数可以是一个普通函数，也可以是一个lambda表达式</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteIntPtr</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int 型内存被释放了..."</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deleteIntPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>l&#x3D;&#x3D;ambda表达式的参数就是智能指针管理的内存的地址&#x3D;&#x3D;，有了这个地址之后函数体内部就可以完成删除操作</p><p>&#x3D;&#x3D;&#x3D;&#x3D;在 C++11 中使用 shared_ptr 管理动态数组时，需要指定删除器, 因为std::shared_ptr的默认删除器不支持数组对象&#x3D;&#x3D;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span>p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在C++14以后，也支持了shared_ptr管理动态数组</p><pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;int[]&gt; ptr(new int[10]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在删除数组内存时，除了自己编写删除器，也可以使用 C++ 提供的 std::default_delete<T>() 函数作为删除器</p><blockquote><p>这个函数内部的删除功能也是通过调用 delete 来实现的，要释放什么类型的内存就将模板类型 T 指定为什么类型即可。</p></blockquote><p><strong>enable_shared_from_this类</strong></p><blockquote><p>有时需要得到一个类对象的shared_ptr指针，直接定义一个函数来返回this指针初始化的shared_ptr违背了原始指针不能初始化多个智能指针的原则，会造成内存泄漏</p></blockquote><p>C++11 中提供了一个模板类叫做 <code>std::enable_shared_from_this&lt;T&gt;</code>，类中有一个方法叫做 <code>shared_from_this()</code>，通过这个方法可以返回一个共享智能指针，</p><p>在这个函数的内部就是使用 weak_ptr 来监测 this 对象，并通过调用 weak_ptr 的 lock() 方法返回一个 shared_ptr 对象。</p><p>其原理就是在类中定义了一个weak_ptr，在定义一个共享指针初始化时就同时初始化此weak_ptr指针</p><p>&#x3D;&#x3D;必须要定义一个shared_ptr指针，在此指针上调用shared_from_this()&#x3D;&#x3D;，否则会报错</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Test</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">Test</span><span class="token operator">></span></span><span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class Test is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Test<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> sp2 <span class="token operator">=</span> sp1<span class="token operator">-></span><span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在调用 enable_shared_from_this 类的 shared_from_this () 方法之前，必须要先初始化函数内部 weak_ptr 对象，否则该函数无法返回一个有效的 shared_ptr 对象</p><blockquote><p><strong>注意</strong></p><ul><li>原始指针不能初始化多个shared_ptr，否则会造成内存泄漏</li><li>不能返回类的this指针来初始化shared_ptr，原理同上</li><li>构造函数内部不能调用shared_from_this函数</li><li>循环引用问题：不能在两个类中互相定义指向对方的shared_ptr，解决方法是使用weak_ptr，可见weak_ptr章节</li></ul></blockquote><h2 id="15-2-unique-ptr指针"><a href="#15-2-unique-ptr指针" class="headerlink" title="15.2 unique_ptr指针"></a>15.2 unique_ptr指针</h2><p>std::unique_ptr 是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针</p><blockquote><p>无自定义 deleter 的 unique_ptr 只需要将裸指针用 RAII 的手法封装好就行，无需保存其它信息，所以它的开销和裸指针是一样的。</p><p>如果有自定义 deleter，还需要保存 deleter 的信息。</p><p>即使有deleter，也能通过优化使得内存消耗和原始指针相同</p></blockquote><p><strong>std::unique_ptr初始化</strong></p><p>可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个 unique_ptr 赋值给另一个 unique_ptr</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 通过构造函数初始化对象</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// error, 不允许将一个unique_ptr赋值给另一个unique_ptr</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>std::unique_ptr 不允许复制，但是可以通过函数返回给其他的 std::unique_ptr，还可以通过 std::move 来转译给其他的 std::unique_ptr</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 通过构造函数初始化</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 通过转移所有权的方式初始化</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr3 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>reset方法初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//reset原型</span><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> pointer ptr <span class="token operator">=</span> <span class="token function">pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解除对原始内存的管理</span>    ptr2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重新指定智能指针管理的原始内存</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似，调用 get () 方法可以获取独占智能指针管理的原始地址</p><p><strong>删除器</strong></p><blockquote><p>shared_ptr智能指针无需指定删除器类型</p></blockquote><p>unique_ptr 指定删除器的时候需要确定删除器的类型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    <span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> func_ptr<span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里能使用函数指针是因为lambda表达式没捕捉任何变量，其可以被直接转换为函数指针，这里内存消耗为16，两倍于原始指针</span><span class="token comment">//lambda表达式捕捉变量时需要使用包装器函数,但这样写内存开销会很大，测试时占了72字节！！！</span>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">>></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用decltype推导，这只占用8字节，达到和原始指针相同的内存消耗，这是由于做了EBO空基类优化，缺点就是需要单独定义lambda表达式</span>    <span class="token keyword">auto</span> fun <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Test<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">delete</span> p<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span>Test<span class="token punctuation">,</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>fun<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Test<span class="token punctuation">,</span> fun<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//仿函数优化，这里也是使用的EBO空基类优化，内存占用为8字节，和原始指针相同内存占用</span><span class="token keyword">struct</span> <span class="token class-name">FileCloserStruct</span> <span class="token punctuation">&#123;</span><span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> fp<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>FILE<span class="token punctuation">,</span> FileCloserStruct<span class="token operator">></span> <span class="token function">uptr1</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test_file.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;注意&#x3D;&#x3D;，unique_ptr有deleter定义函数类型时，尽量别使用function包装器，其内存消耗几倍于原始指针</p><p>应尽量使用仿函数和decltype推导lambda方法（<em>这两种方法的内销消耗和原始指针相同，这是因为这两种方式的deleter函数其实是一个空类，unique_ptr低层会直接继承这个空类而不是定义一个函数指针，再使用空基类优化达到原指针相同内存消耗</em>）</p><p>&#x3D;&#x3D;疑惑&#x3D;&#x3D;：空基类优化后是怎么知道deleter函数是哪个呢？？？？</p><p>这是因为这两种优化方法继承的类和deleter函数名字是一样的，调用<code>类名()</code>即为deleter函数</p><blockquote><p>内存消耗：function包装器&gt;普通函数指针&gt;仿函数&#x3D;decltype推导lambda</p></blockquote><h2 id="15-3-weak-ptr指针"><a href="#15-3-weak-ptr指针" class="headerlink" title="15.3 weak_ptr指针"></a>15.3 weak_ptr指针</h2><p><code>std::weak_ptr</code>是 <code>shared_ptr</code> 的助手，它不管理 <code>shared_ptr</code> 内部的指针</p><p>&#x3D;&#x3D;std::weak_ptr 没有重载操作符 * 和 -&gt;，因为它不共享指针，不能操作资源&#x3D;&#x3D;，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视 shared_ptr 中管理的资源是否存在。</p><blockquote><p>weak_ptr是使用的shared_ptr中的控制信息，在其控制信息中的weak ref count加1</p><p>当 shared_ptr 析构并释放共享资源的时候，只要 weak_ptr 对象还存在，控制块就会保留，weak_ptr 可以通过控制块观察到对象是否存活。</p></blockquote><p><strong>初始化</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 默认构造函数</span><span class="token keyword">constexpr</span> <span class="token function">weak_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">// 拷贝构造</span><span class="token function">weak_ptr</span> <span class="token punctuation">(</span><span class="token keyword">const</span> weak_ptr<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span> <span class="token function">weak_ptr</span> <span class="token punctuation">(</span><span class="token keyword">const</span> weak_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">// 通过shared_ptr对象构造</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span> <span class="token function">weak_ptr</span> <span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">//使用</span>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp1<span class="token punctuation">;</span><span class="token comment">//构造了一个空 weak_ptr 对象</span>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp2</span><span class="token punctuation">(</span>wp1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过一个空 weak_ptr 对象构造了另一个空 weak_ptr 对象</span>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp3</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过一个 shared_ptr 对象构造了一个可用的 weak_ptr 实例对象</span>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp4<span class="token punctuation">;</span>    wp4 <span class="token operator">=</span> sp<span class="token punctuation">;</span>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp5<span class="token punctuation">;</span>    wp5 <span class="token operator">=</span> wp3<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**use_count()**：获得当前所观测资源的引用计数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>**expired()**：判断观测的资源是否已经被释放</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>**lock()**：&#x3D;&#x3D;获取管理所监测资源的 shared_ptr 对象&#x3D;&#x3D;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>element_type<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>**reset()**：清空对象，使其不监测任何资源</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="15-3-1-解决循环引用问题"><a href="#15-3-1-解决循环引用问题" class="headerlink" title="15.3.1 解决循环引用问题"></a>15.3.1 解决循环引用问题</h3><p>智能指针如果循环引用会导致内存泄露，例子如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TA</span><span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span>TB<span class="token operator">></span> bptr<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">TA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class TA is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">TB</span><span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span>TA<span class="token operator">></span> aptr<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">TB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class TB is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">testPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span>TA<span class="token operator">></span> <span class="token function">ap</span><span class="token punctuation">(</span><span class="token keyword">new</span> TA<span class="token punctuation">)</span><span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>TB<span class="token operator">></span> <span class="token function">bp</span><span class="token punctuation">(</span><span class="token keyword">new</span> TB<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TA object use_count: "</span> <span class="token operator">&lt;&lt;</span> ap<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TB object use_count: "</span> <span class="token operator">&lt;&lt;</span> bp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    ap<span class="token operator">-></span>bptr <span class="token operator">=</span> bp<span class="token punctuation">;</span>    bp<span class="token operator">-></span>aptr <span class="token operator">=</span> ap<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TA object use_count: "</span> <span class="token operator">&lt;&lt;</span> ap<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TB object use_count: "</span> <span class="token operator">&lt;&lt;</span> bp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">testPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果</span>TA object use_count<span class="token operator">:</span> <span class="token number">1</span>TB object use_count<span class="token operator">:</span> <span class="token number">1</span>TA object use_count<span class="token operator">:</span> <span class="token number">2</span>TB object use_count<span class="token operator">:</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中，共享智能指针 ap、bp 对 TA、TB 实例对象的引用计数变为 2，在共享智能指针离开作用域之后引用计数只能减为1</p><p>&#x3D;&#x3D;使用 weak_ptr 可以解决这个问题&#x3D;&#x3D;，只要将类 TA 或者 TB 的任意一个成员改为 weak_ptr即可</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TA</span><span class="token punctuation">&#123;</span>    weak_ptr<span class="token operator">&lt;</span>TB<span class="token operator">></span> bptr<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">TA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class TA is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">TB</span><span class="token punctuation">&#123;</span>    shared_ptr<span class="token operator">&lt;</span>TA<span class="token operator">></span> aptr<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">TB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class TB is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//其余调用代码和上面类似</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面程序中，在对类 TA 成员赋值时 ap-&gt;bptr &#x3D; bp; 由于 bptr 是 weak_ptr 类型，这个赋值操作并不会增加引用计数，所以 bp 的引用计数仍然为 1，在离开作用域之后 bp 的引用计数减为 0，类 TB 的实例对象被析构。</p><p>在类 TB 的实例对象被析构的时候，内部的 aptr 也被析构，其对 TA 对象的管理解除，内存的引用计数减为 1，当共享智能指针 ap 离开作用域之后，对 TA 对象的管理也解除了，内存的引用计数减为 0，类 TA 的实例对象被析构。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake笔记</title>
      <link href="/2023/02/15/c++/cmake%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/15/c++/cmake%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://www.bilibili.com/video/BV1vR4y1u77h/?p=10&spm_id_from=pageDriver&vd_source=7135ae3a4d6506056ac51c05382c2a25">从零开始详细介绍CMake</a>，笔记也是在up主原笔记上修改</p><hr><hr><p>cmake的定义是什么 ？—–高级编译配置工具</p><p>当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了—–CMake！</p><p>所有操作都是通过编译CMakeLists.txt来完成的—简单</p><h1 id="1-CMake一个HelloWord"><a href="#1-CMake一个HelloWord" class="headerlink" title="1. CMake一个HelloWord"></a>1. CMake一个HelloWord</h1><p>1、步骤一，写一个HelloWord</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">main</span><span class="token expression"><span class="token punctuation">.</span>cpp</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span>  <span class="token string">"hello word"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、步骤二，写CMakeLists.txt</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#CMakeLists.txt</span><span class="token function">PROJECT</span> <span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">SET</span><span class="token punctuation">(</span>SRC_LIST main.cpp<span class="token punctuation">)</span><span class="token function">MESSAGE</span><span class="token punctuation">(</span>STATUS <span class="token string">"This is BINARY dir "</span> <span class="token punctuation">$&#123;</span><span class="token variable">HELLO_BINARY_DIR</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">MESSAGE</span><span class="token punctuation">(</span>STATUS <span class="token string">"This is SOURCE dir "</span><span class="token punctuation">$&#123;</span><span class="token variable">HELLO_SOURCE_DIR</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello <span class="token punctuation">$&#123;</span>SRC_LIST<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、步骤三、使用cmake，生成makefile文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile。</p><p>4、使用make命令编译</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@localhost cmake<span class="token punctuation">]</span><span class="token comment"># make</span>Scanning dependencies of target hello<span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Building CXX object CMakeFiles/hello.dir/main.cpp.oLinking CXX executable hello<span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Built target hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、最终生成了Hello的可执行程序</p><h1 id="2-CMake一个HelloWord-的语法介绍"><a href="#2-CMake一个HelloWord-的语法介绍" class="headerlink" title="2. CMake一个HelloWord-的语法介绍"></a>2. CMake一个HelloWord-的语法介绍</h1><h2 id="2-1-关键字"><a href="#2-1-关键字" class="headerlink" title="2.1 关键字"></a>2.1 关键字</h2><p><strong>PROJECT关键字</strong></p><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p>PROJECT (HELLO)   指定了工程的名字，并且支持所有语言—建议</p><p>PROJECT (HELLO CXX)      指定了工程的名字，并且支持语言是C++</p><p>PROJECT (HELLO C CXX)      指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个CMAKE的变量</p><p><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</p><p><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</p><p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：如果改了工程名，这两个变量名也会改变</p><p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><p><strong>SET关键字</strong></p><p>用来显示的指定变量的</p><p>SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p><p>也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><p><strong>MESSAGE关键字</strong></p><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。</li><li>SATUS，输出前缀为—的信息。</li><li>FATAL_ERROR，立即终止所有 cmake 过程.</li></ul><p><strong>ADD_EXECUTABLE关键字</strong></p><p>生成可执行文件</p><p>ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p><p>也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p><p>上述例子可以简化的写成</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello main.cpp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h2 id="2-2-语法的基本原则"><a href="#2-2-语法的基本原则" class="headerlink" title="2.2 语法的基本原则"></a>2.2 语法的基本原则</h2><ul><li><p>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</p></li><li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p><p>  就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</p></li></ul><h2 id="2-3-语法注意事项"><a href="#2-3-语法注意事项" class="headerlink" title="2.3 语法注意事项"></a>2.3 语法注意事项</h2><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不写，会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul><h1 id="3-内部构建和外部构建"><a href="#3-内部构建和外部构建" class="headerlink" title="3. 内部构建和外部构建"></a>3. 内部构建和外部构建</h1><ul><li>内部构建，产生临时文件特别多，不方便清理</li><li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</li></ul><p><strong>外部构建方式举例</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//例子目录，CMakeLists.txt和上面例子一致<span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span><span class="token comment"># pwd</span>/root/cmake<span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span><span class="token comment"># ll</span>total <span class="token number">8</span>-rw-r--r--. <span class="token number">1</span> root root <span class="token number">198</span> Dec <span class="token number">28</span> <span class="token number">20</span>:59 CMakeLists.txt-rw-r--r--. <span class="token number">1</span> root root  <span class="token number">76</span> Dec <span class="token number">28</span> 00:18 main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p><p>2、进入build，运行cmake ..    当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p><p>3、在build目录下，运行make来构建工程</p><p>注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR  还是工程路径</p><p>2、HELLO_BINARY_DIR   编译路径 也就是 &#x2F;root&#x2F;cmake&#x2F;bulid</p><h1 id="4-让Hello-World看起来更像一个工程"><a href="#4-让Hello-World看起来更像一个工程" class="headerlink" title="4. 让Hello World看起来更像一个工程"></a>4. 让Hello World看起来更像一个工程</h1><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT&#x2F;README 安装到&#x2F;usr&#x2F;share&#x2F;doc&#x2F;cmake&#x2F;</li></ul><h2 id="4-1-将目标文件放入构建目录的-bin-子目录"><a href="#4-1-将目标文件放入构建目录的-bin-子目录" class="headerlink" title="4.1 将目标文件放入构建目录的 bin 子目录"></a>4.1 将目标文件放入构建目录的 bin 子目录</h2><p>每个目录下都要有一个CMakeLists.txt说明</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span><span class="token comment"># tree</span><span class="token builtin class-name">.</span>├── build├── CMakeLists.txt└── src    ├── CMakeLists.txt    └── main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>外层CMakeLists.txt</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>src bin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>src下的CMakeLists.txt</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello main.cpp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>ADD_SUBDIRECTORY 指令</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>source_dir [binary_dir] [<span class="token property">EXCLUDE_FROM_ALL</span>]<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p></li><li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p></li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>  将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>  如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build&#x2F;src 目录</p></li></ul><p><strong>更改二进制的保存路径</strong></p><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">SET</span><span class="token punctuation">(</span><span class="token variable">EXECUTABLE_OUTPUT_PATH</span> <span class="token punctuation">$&#123;</span><span class="token variable">PROJECT_BINARY_DIR</span><span class="token punctuation">&#125;</span>/bin<span class="token punctuation">)</span><span class="token function">SET</span><span class="token punctuation">(</span><span class="token variable">LIBRARY_OUTPUT_PATH</span> <span class="token punctuation">$&#123;</span><span class="token variable">PROJECT_BINARY_DIR</span><span class="token punctuation">&#125;</span>/lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>思考：加载哪个CMakeLists.txt当中</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><h2 id="4-2-安装"><a href="#4-2-安装" class="headerlink" title="4.2 安装"></a>4.2 安装</h2><ul><li>一种是从代码编译后直接 make install 安装</li><li>一种是打包时的指定 目录安装。<ul><li>简单的可以这样指定目录：make install DESTDIR&#x3D;&#x2F;tmp&#x2F;test</li><li>稍微复杂一点可以这样指定目录：.&#x2F;configure –prefix&#x3D;&#x2F;usr</li></ul></li></ul><p><strong>如何安装HelloWord</strong></p><p>使用CMAKE一个新的指令：INSTALL</p><p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 目录树结构<span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span><span class="token comment"># tree</span><span class="token builtin class-name">.</span>├── build├── CMakeLists.txt├── COPYRIGHT├── doc│   └── hello.txt├── README├── runhello.sh└── src    ├── CMakeLists.txt    └── main.cpp<span class="token number">3</span> directories, <span class="token number">7</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>安装文件COPYRIGHT和README</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">INSTALL</span><span class="token punctuation">(</span>FILES COPYRIGHT README DESTINATION share/doc/cmake/<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>FILES：文件</p></li><li><p>DESTINATION：</p><ul><li><p>1、写绝对路径</p></li><li><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}&#x2F;&lt;DESTINATION 定义的路径&gt;</p></li></ul></li></ul><p>CMAKE_INSTALL_PREFIX  默认是在 &#x2F;usr&#x2F;local&#x2F;</p><p>cmake -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><p><strong>安装脚本runhello.sh</strong></p><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">INSTALL</span><span class="token punctuation">(</span>PROGRAMS runhello.sh DESTINATION bin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：实际安装到的是 &#x2F;usr&#x2F;bin</p><p><strong>从零开始详细介绍CMake</strong></p><ul><li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p></li><li><p>二、是直接在工程目录通过</p>   <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">INSTALL</span><span class="token punctuation">(</span>DIRECTORY doc/ DESTINATION share/doc/cmake<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc&#x2F;有很大的区别</p><p>目录名不以&#x2F;结尾：这个目录将被安装为目标路径下的</p><p>目录名以&#x2F;结尾：将这个目录中的内容安装到目标路径</p><p><strong>安装过程</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake <span class="token punctuation">..</span><span class="token function">make</span><span class="token function">make</span> instal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-静态库和动态库的构建"><a href="#5-静态库和动态库的构建" class="headerlink" title="5. 静态库和动态库的构建"></a>5. 静态库和动态库的构建</h1><p>任务：</p><p>１，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 </p><p>２，安装头文件与共享库。</p><p>静态库和动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li></ul><h2 id="5-1构建实例"><a href="#5-1构建实例" class="headerlink" title="5.1构建实例"></a>5.1构建实例</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost cmake2<span class="token punctuation">]</span><span class="token comment"># tree</span><span class="token builtin class-name">.</span>├── build├── CMakeLists.txt└── lib    ├── CMakeLists.txt    ├── hello.cpp    └── hello.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello.h中的内容</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HELLO_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Hello_H</span></span><span class="token keyword">void</span> <span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello.cpp中的内容</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hello.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>项目中的cmake内容</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>lib bin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>lib中CMakeLists.txt中的内容</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">SET</span><span class="token punctuation">(</span>LIBHELLO_SRC hello.cpp<span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>ADD_LIBRARY</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li><li>SHARED，动态库    STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul><h2 id="5-2-同时构建静态和动态库"><a href="#5-2-同时构建静态和动态库" class="headerlink" title="5.2 同时构建静态和动态库"></a>5.2 同时构建静态和动态库</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a<span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello <span class="token namespace">STATIC</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已<span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello_static <span class="token namespace">STATIC</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>SET_TARGET_PROPERTIES</strong></p><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">SET</span><span class="token punctuation">(</span>LIBHELLO_SRC hello.cpp<span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello_static <span class="token namespace">STATIC</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>//对hello_static的重名为hello<span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello_static <span class="token namespace">PROPERTIES</span>  <span class="token property">OUTPUT_NAME</span> <span class="token string">"hello"</span><span class="token punctuation">)</span>//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a<span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello_static <span class="token namespace">PROPERTIES</span> CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello <span class="token namespace">PROPERTIES</span>  <span class="token property">OUTPUT_NAME</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello <span class="token namespace">PROPERTIES</span> CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>动态库的版本号</strong></p><p>一般动态库都有一个版本号的关联</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.2</span>libhello<span class="token punctuation">.</span>so <span class="token operator">-></span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">-></span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h2 id="5-3-安装共享库和头文件"><a href="#5-3-安装共享库和头文件" class="headerlink" title="5.3 安装共享库和头文件"></a>5.3 安装共享库和头文件</h2><p>本例中我们将 hello 的共享库安装到<prefix>&#x2F;lib目录，</p><p>将 hello.h 安装到<prefix>&#x2F;include&#x2F;hello 目录</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">//文件放到该目录下<span class="token function">INSTALL</span><span class="token punctuation">(</span>FILES hello.h DESTINATION include/hello<span class="token punctuation">)</span>//二进制，静态库，动态库安装都用TARGETS//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。<span class="token function">INSTALL</span><span class="token punctuation">(</span>TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h2 id="5-4-使用外部共享库和头文件"><a href="#5-4-使用外部共享库和头文件" class="headerlink" title="5.4 使用外部共享库和头文件"></a>5.4 使用外部共享库和头文件</h2><p>准备工作，新建一个目录来使用外部共享库和头文件</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">[root@MiWiFi-R4CM-srv cmake3]<span class="token comment"># tree</span>.├── build├── CMakeLists.txt└── src    ├── CMakeLists.txt    └── main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;hello.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解决：make后头文件找不到的问题</strong></p><p>PS：include &lt;hello&#x2F;hello.h&gt;  这样include是可以，这么做的话，就没啥好讲的了</p><p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token property">INCLUDE_DIRECTORIES</span><span class="token punctuation">(</span>/usr/include/hello<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>解决：找到引用的函数问题</strong></p><p>报错信息：undefined reference to &#96;HelloFunc()’</p><p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p><p>指定第三方库所在路径</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token property">LINK_DIRECTORIES</span><span class="token punctuation">(</span>/home/myproject/libs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">TARGET_LINK_LIBRARIES</span><span class="token punctuation">(</span>main libhello.a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@MiWiFi-R4CM-srv bin<span class="token punctuation">]</span><span class="token comment"># ldd main </span>linux-vdso.so.1 <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span>0x00007ffedfda4000<span class="token punctuation">)</span>libhello.so <span class="token operator">=</span><span class="token operator">></span> /lib64/libhello.so <span class="token punctuation">(</span>0x00007f41c0d8f000<span class="token punctuation">)</span>libstdc++.so.6 <span class="token operator">=</span><span class="token operator">></span> /lib64/libstdc++.so.6 <span class="token punctuation">(</span>0x00007f41c0874000<span class="token punctuation">)</span>libm.so.6 <span class="token operator">=</span><span class="token operator">></span> /lib64/libm.so.6 <span class="token punctuation">(</span>0x00007f41c0572000<span class="token punctuation">)</span>libgcc_s.so.1 <span class="token operator">=</span><span class="token operator">></span> /lib64/libgcc_s.so.1 <span class="token punctuation">(</span>0x00007f41c035c000<span class="token punctuation">)</span>libc.so.6 <span class="token operator">=</span><span class="token operator">></span> /lib64/libc.so.6 <span class="token punctuation">(</span>0x00007f41bff8e000<span class="token punctuation">)</span>/lib64/ld-linux-x86-64.so.2 <span class="token punctuation">(</span>0x00007f41c0b7c000<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><p><strong>特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</strong></p><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(&#x2F;usr&#x2F;include&#x2F;hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH&#x3D;&#x2F;usr&#x2F;include&#x2F;hello</p><p>补充：生产debug版本的方法：<br>cmake .. -DCMAKE_BUILD_TYPE&#x3D;debug</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><h2 id="6-1-常用命令"><a href="#6-1-常用命令" class="headerlink" title="6.1 常用命令"></a>6.1 常用命令</h2><p>&#x3D;&#x3D;<strong>(1) project命令：</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法:<span class="token keyword">project</span><span class="token punctuation">(</span>&lt;projectname<span class="token punctuation">></span> [languageName1 languageName2 ...]<span class="token punctuation">)</span>命令简述:用于指定项目的名称和支持语言使用范例:<span class="token keyword">project</span><span class="token punctuation">(</span>Main CXX<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(2) cmake_minimum_required命令:</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法:<span class="token function">cmake_minimum_requried</span><span class="token punctuation">(</span><span class="token property">VERSION</span> major[.minor[.patch<span class="token punctuation">)</span>命令简述:用于指定需要的CMake的最低版本使用范例:<span class="token function">cmake_minimum_requried</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">2.8.3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(3) aux_source_directory命令:</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法:<span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>&lt;dir<span class="token punctuation">></span> &lt;variable<span class="token punctuation">></span><span class="token punctuation">)</span>命令简述:用于包含源文件目录，dir目录下的所有源文件的名字保存在变量variable中使用范例：<span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span><span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">&#125;</span>/src  DIR_SRCS<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(4) add_executable命令:</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">add_executable</span><span class="token punctuation">(</span>&lt;name<span class="token punctuation">></span> [<span class="token variable">WIN32</span>] [<span class="token property">MACOSX_BUNDLE</span>][<span class="token property">EXCLUDE_FROM_ALL</span>] source1 source2 … sourceN<span class="token punctuation">)</span>命令简述:用于指定从一组源文件source1 source2 ... sourceN 编译出一个可执行文件且命名为name使用范例:<span class="token keyword">add_executable</span><span class="token punctuation">(</span>Main $<span class="token punctuation">(</span>DIR_SRCS<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(5) add_library命令:</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">add_library</span><span class="token punctuation">(</span>[<span class="token namespace">STATIC</span> | <span class="token namespace">SHARED</span> | MODULE] [<span class="token property">EXCLUDE_FROM_ALL</span>] source1source2 … sourceN<span class="token punctuation">)</span>命令简述：用于指定从一组源文件 source1 source2 ... sourceN编译出一个库文件且命名为name使用范例：<span class="token keyword">add_library</span><span class="token punctuation">(</span>Lib $<span class="token punctuation">(</span>DIR_SRCS<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(6) add_dependencies命令:</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">add_dependencies</span><span class="token punctuation">(</span>target-name depend-target1 depend-target2 …<span class="token punctuation">)</span>命令简述：用于指定某个目标（可执行文件或者库文件）依赖于其他的目标。        这里的目标必须是add_executable、add_library、add_custom_target命令创建的目标<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(7) add_subdirectory命令:</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>source_dir [binary_dir] [<span class="token property">EXCLUDE_FROM_ALL</span>]<span class="token punctuation">)</span>命令简述:用于添加一个需要进行构建的子目录使用范例:<span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>Lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(8) target_link_libraries命令:</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>&lt;target<span class="token punctuation">></span> [item1 [item2 […]]][[debug|optimized|general] ] …<span class="token punctuation">)</span>命令简述:用于指定target需要链接item1 item2 ...。这里target必须已经被创建，链接的item可以是已经存在的target（依赖关系会自动添加）使用范例:<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>Main Lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(9) set命令：</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令简述：用于设定变量 variable 的值为 value。如果指定了 <span class="token variable">CACHE</span> 变量将被放入 Cache（缓存）中。命令语法：<span class="token keyword">set</span><span class="token punctuation">(</span>&lt;variable<span class="token punctuation">></span> &lt;value<span class="token punctuation">></span> [[<span class="token variable">CACHE</span> &lt;type<span class="token punctuation">></span>&lt;docstring<span class="token punctuation">></span> [FORCE]] | PARENT_SCOPE]<span class="token punctuation">)</span>使用范例：<span class="token keyword">set</span><span class="token punctuation">(</span>ProjectName Main<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(10) unset命令：</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">unset</span><span class="token punctuation">(</span>&lt;variable<span class="token punctuation">></span> [<span class="token variable">CACHE</span>]<span class="token punctuation">)</span>命令简述：用于移除变量 variable。如果指定了 <span class="token variable">CACHE</span> 变量将被从 Cache 中移除。使用范例：<span class="token keyword">unset</span><span class="token punctuation">(</span>VAR <span class="token variable">CACHE</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(11) message命令：</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">message</span><span class="token punctuation">(</span>[STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] “message todisplay”…<span class="token punctuation">)</span>命令简述:用于输出信息使用范例:<span class="token keyword">message</span><span class="token punctuation">(</span>“Hello World”<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(12) include_directories命令：</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">include_directories</span><span class="token punctuation">(</span>[AFTER|BEFORE] [SYSTEM] dir1 dir2 …<span class="token punctuation">)</span>命令简述：用于设定目录，这些设定的目录将被编译器用来查找 include 文件使用范例：<span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">$&#123;</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">&#125;</span>/lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(13) find_path命令：</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">find_path</span><span class="token punctuation">(</span>&lt;VAR<span class="token punctuation">></span> name1 [path1 path2 …]<span class="token punctuation">)</span>命令简述：用于查找包含文件name1的路径，如果找到则将路径保存在VAR中（此路径为一个绝对路径），如果没有找到则结果为&lt;VAR<span class="token punctuation">></span>-NOTFOUND.默认情况下，VAR会被保存在Cache中，这时候我们需要清除VAR才可以进行下一次查询（使用unset命令）<span class="token keyword">find_path</span><span class="token punctuation">(</span>LUA_INCLUDE_PATH lua.h <span class="token punctuation">$&#123;</span>LUA_INCLUDE_FIND_PATH<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">NOT</span> LUA_INCLUDE_PATH<span class="token punctuation">)</span>     <span class="token keyword">message</span><span class="token punctuation">(</span>SEND_ERROR <span class="token string">"Header file lua.h not found"</span><span class="token punctuation">)</span><span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(14) find_library命令：</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">find_library</span><span class="token punctuation">(</span>&lt;VAR<span class="token punctuation">></span> name1 [path1 path2 …]<span class="token punctuation">)</span>命令简述：用于查找库文件 name1 的路径，如果找到则将路径保存在 VAR 中（此路径为一个绝对路径），        如果没有找到则结果为 &lt;VAR<span class="token punctuation">></span>-NOTFOUND。        一个类似的命令 link_directories 已经不太建议使用了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(15) add_definitions命令：</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">add_definitions</span><span class="token punctuation">(</span>-DFOO -DBAR …<span class="token punctuation">)</span>命令简述：用于添加编译器命令行标志（选项），通常的情况下我们使用其来添加预处理器定义使用范例：<span class="token keyword">add_definitions</span><span class="token punctuation">(</span>-D_UNICODE -DUNICODE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(16) file命令：</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令简述：此命令提供了丰富的文件和目录的相关操作（这里仅说一下比较常用的）使用范例：<span class="token comment"># 目录的遍历</span><span class="token comment"># GLOB 用于产生一个文件（目录）路径列表并保存在variable 中</span><span class="token comment"># 文件路径列表中的每个文件的文件名都能匹配globbing expressions（非正则表达式，但是类似）</span><span class="token comment"># 如果指定了 RELATIVE 路径，那么返回的文件路径列表中的路径为相对于 RELATIVE 的路径</span><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB variable [RELATIVE path][globbing expressions]...<span class="token punctuation">)</span> <span class="token comment"># 获取当前目录下的所有的文件（目录）的路径并保存到 ALL_FILE_PATH 变量中</span><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB ALL_FILE_PATH ./*<span class="token punctuation">)</span><span class="token comment"># 获取当前目录下的 .h 文件的文件名并保存到ALL_H_FILE 变量中</span><span class="token comment"># 这里的变量CMAKE_CURRENT_LIST_DIR 表示正在处理的 CMakeLists.txt 文件的所在的目录的绝对路径（2.8.3 以及以后版本才支持）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x3D;&#x3D;<strong>(17) find_package命令：</strong>&#x3D;&#x3D;</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">命令语法：<span class="token keyword">find_package</span><span class="token punctuation">(</span>&lt;Name<span class="token punctuation">></span><span class="token punctuation">)</span>命令简述：用于查找包（通常是使用三方库），并返回关于包的细节（使用包所依赖的头文件、库文件、编译选项、链接选项等）使用范例：<span class="token keyword">find_package</span><span class="token punctuation">(</span>Boost<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(18) link_directories命令 :</strong></p><pre class="line-numbers language-none"><code class="language-none">命令语法：link_directories(&lt;dir&gt;)命令简述：用于指定第三方库所在路径使用范例：link_directories(&#x2F;home&#x2F;myproject&#x2F;libs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="6-2-使用第三方库"><a href="#6-2-使用第三方库" class="headerlink" title="6.2 使用第三方库"></a>6.2 使用第三方库</h2><p><strong>方法一：</strong></p><p>先包含第三方库头文件</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token property">INCLUDE_DIRECTORIES</span><span class="token punctuation">(</span>/usr/include/hello<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定第三方库静态库或动态库文件位置</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token property">LINK_DIRECTORIES</span><span class="token punctuation">(</span>/home/myproject/libs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接第三方库的静态或动态库</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">TARGET_LINK_LIBRARIES</span><span class="token punctuation">(</span>main libhello.a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>方法二：</strong></p><p>使用find_libary</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Modern C++</title>
      <link href="/2023/02/15/c++/Effective_Modern_C++/"/>
      <url>/2023/02/15/c++/Effective_Modern_C++/</url>
      
        <content type="html"><![CDATA[<p>记录<a href="https://github.com/CnTransGroup/EffectiveModernCppChinese">《**Effective Modern C++**》</a>阅读笔记</p><hr><hr><h1 id="CHAPTER1-Deducing-Types"><a href="#CHAPTER1-Deducing-Types" class="headerlink" title="CHAPTER1 Deducing Types"></a><strong>CHAPTER1 Deducing Types</strong></h1><p>C++98有⼀套⽤于模板类型推导的规则，C++11修改了其中的⼀些规则并为<strong>auto</strong>和<strong>decltype</strong>添加了新的规则。</p><h2 id="1-理解模板类型推导"><a href="#1-理解模板类型推导" class="headerlink" title="1. 理解模板类型推导"></a>1. 理解模板类型推导</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParamType param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//从expr中推导T和ParamType</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基于上述模板，有三种情况：</p><p><strong>(1)ParamType是一个指针或引用，但不是通用引用</strong></p><p>推导规则：</p><ul><li>如果expr的类型是⼀个引⽤，忽略引⽤（包括右值引用）</li><li>然后剩下的部分决定T，然后T与形参匹配得出最终ParamType</li></ul><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//param是⼀个引⽤</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">;</span> <span class="token comment">//x是int</span><span class="token keyword">const</span> <span class="token keyword">int</span> cx<span class="token operator">=</span>x<span class="token punctuation">;</span> <span class="token comment">//cx是const int</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> rx<span class="token operator">=</span>cx<span class="token punctuation">;</span> <span class="token comment">//rx是指向const int的引⽤</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T是int，param的类型是int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T是const int，param的类型是const int &amp;</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T是const int，param的类型是const int &amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此类情况右值和左值同等对待</p><p><strong>(2)ParamType是⼀个通⽤引⽤</strong></p><p>推导规则：</p><ul><li>如果<strong>expr</strong>是左值，T和ParamType都会被推导为左值引⽤。这⾮常不寻常：<ul><li>第⼀，这是模板类型推导中<strong>唯⼀⼀种T和ParamType都被推导为引⽤</strong>的情况。（&amp; &amp;&amp;会折叠为&amp;）</li><li>第⼆，虽然ParamType被声明为右值引⽤类型，但是最后推导的结果它是左值引⽤。</li></ul></li><li>如果<strong>expr</strong>是右值，就使⽤（1）的推导规则</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//param现在是⼀个通⽤引⽤类型</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">;</span> <span class="token comment">//如之前⼀样</span><span class="token keyword">const</span> <span class="token keyword">int</span> cx<span class="token operator">=</span>x<span class="token punctuation">;</span> <span class="token comment">//如之前⼀样</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> rx<span class="token operator">=</span>cx<span class="token punctuation">;</span> <span class="token comment">//如之前⼀样</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//x是左值，所以T是int&amp; //param类型也是int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//cx是左值，所以T是const int &amp; //param类型也是const int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//rx是左值，所以T是const int &amp; //param类型也是const int&amp;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//27是右值，所以T是int //param类型就是int&amp;&amp;      ！！！！！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(3)ParamType既不是指针也不是引⽤</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//以传值的⽅式处理param</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这意味着⽆论传递什么param都会成为它的⼀份拷⻉——⼀个完整的新对象！！此性质决定了可以舍弃自身的const属性，因为<strong>expr</strong>不可修改并不意味着他的拷⻉也不能被修改。</p><p>推导规则：</p><ul><li>如果expr的类型是⼀个引⽤，忽略这个引⽤部分（如果是指针则不会被忽略）</li><li>如果忽略引⽤之后expr是⼀个const，那就再忽略const。如果它是volatile，也会被忽略（注意！const int* const 类型只会舍弃自身const属性，即第二个const）</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">;</span> <span class="token comment">//如之前⼀样</span><span class="token keyword">const</span> <span class="token keyword">int</span> cx<span class="token operator">=</span>x<span class="token punctuation">;</span> <span class="token comment">//如之前⼀样</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> rx<span class="token operator">=</span>cx<span class="token punctuation">;</span> <span class="token comment">//如之前⼀样</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T和param都是int</span><span class="token function">f</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T和param都是int</span><span class="token function">f</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//T和param都是int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常量指针常量情况，最终T会被推导为<strong>const char*</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传值</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr <span class="token operator">=</span> <span class="token string">" Fun with pointers"</span><span class="token punctuation">;</span><span class="token comment">//ptr是⼀个常量指针，指向常量对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>解引⽤符号（*）的右边的const表⽰ptr本⾝是⼀个const：ptr不能被修改为指向其它地址，也不能被设置为null</p><p>解引⽤符号左边的const表⽰ptr指向⼀个字符串，这个字符串是const，因此字符串不能被修改</p></blockquote><p><strong>数组</strong></p><p>c++中数组和指针并非一种类型，只是有数组退化为指针的规则。</p><p>当ParamType既不是指针也不是引⽤时，数组推导时会被视为指针，如果是个常量数组，推导出来的类型会是一个常量指针</p><p>注意！虽然函数不能接受真正的数组，但是可以接受指向数组的引⽤！下述示例中param被推导为为<strong>const char(&amp;)[13]</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"J. P. Briggs"</span><span class="token punctuation">;</span> <span class="token comment">//name的类型是const char[13]</span><span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传数组 param被推导为为**const char(&amp;)[13]**</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数实参</strong></p><p>在C++中不⽌是数组会退化为指针，函数类型也会退化为⼀个函数指针，因此函数规则和数组类似</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">someFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//someFunc是⼀个函数，类型是void(int,double)</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传值</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//传引⽤</span><span class="token function">f1</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//param被推导为指向函数的指针，类型是void(*)(int, double)</span><span class="token function">f2</span><span class="token punctuation">(</span>someFunc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//param被推导为指向函数的引⽤，类型为void(&amp;)(int, bouel)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>在模板类型推导时，有引用的实参会被视为无引用，他们的引用会被忽略（包括右值引用），使用忽略后的值推导T</li><li>对于通用引用的推导，左值实参会被特殊对待</li><li>对于传值类型推导，<code>const</code>和&#x2F;或<code>volatile</code>实参会被认为是non-<code>const</code>的和non-<code>volatile</code>的</li><li>在模板类型推导时，数组名或者函数名实参会退化为指针，除非它们被用于初始化引用</li></ul></blockquote><h2 id="2-理解auto类型推导"><a href="#2-理解auto类型推导" class="headerlink" title="2. 理解auto类型推导"></a>2. 理解<code>auto</code>类型推导</h2><p><strong>auto</strong>是建⽴在模板类型推导的基础上的，<strong>auto和模板类型推导唯一不同之处在于花括号初始化的推导。</strong></p><p>auto推导其实就是使用模板类型来进行推导，当一个变量使用<code>auto</code>进行声明时，<code>auto</code>扮演了模板中<code>T</code>的角色，变量的类型说明符扮演了<code>ParamType</code>的角色。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>ParmaType param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span> <span class="token comment">//类型说明符是auto</span><span class="token keyword">const</span> <span class="token keyword">auto</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">//类型说明符是const auto</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span> rx<span class="token operator">=</span>cx<span class="token punctuation">;</span><span class="token comment">//类型说明符是const auto&amp;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token comment">//理想化的模板⽤来推导x的类型</span><span class="token keyword">void</span> <span class="token function">func_for_x</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func_for_x</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token comment">//理想化的模板⽤来推导cx 的类型</span><span class="token keyword">void</span> <span class="token function">func_for_cx</span><span class="token punctuation">(</span><span class="token keyword">const</span> T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func_for_cx</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token comment">//理想化的模板⽤来推导rx的类型</span><span class="token keyword">void</span> <span class="token function">func_for_rx</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func_for_rx</span><span class="token punctuation">(</span>rx<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>auto推导结果和模板类型推导结果规则相同，只有在花括号初始化时推导不同。</p><p>当使⽤auto的变量使⽤花括号的语法进⾏初始化的时候，会推导出<strong>std::initializer_list</strong>的实例化，但是对于模板类型推导这样就⾏不通</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> x3<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">27</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//推导为std::initializer_list&lt;int></span><span class="token keyword">auto</span> x4<span class="token punctuation">&#123;</span><span class="token number">27</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//推导为std::initializer_list&lt;int></span><span class="token keyword">auto</span> x<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//x的类型是std::initializer_list&lt;int></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//错误！不能推导出T</span><span class="token comment">//然而如果指定T是std::initializer而留下未知T,模板类型推导就能正常⼯作：</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">></span> initList<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++14中<code>auto</code>用于函数返回值和lambda时，实际上使用模板类型推导的那一套规则在工作，而不是<code>auto</code>类型推导，如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">createInitList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>         <span class="token comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span><span class="token punctuation">&#125;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span><span class="token keyword">auto</span> resetV <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>v<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> newValue<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> v <span class="token operator">=</span> newValue<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token comment">//C++14</span><span class="token function">resetV</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//错误！不能推导&#123; 1, 2, 3 &#125;的类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结：</strong></p><ul><li><code>auto</code>类型推导通常和模板类型推导相同，但是<code>auto</code>类型推导假定花括号初始化代表<code>std::initializer_list</code>，而模板类型推导不这样做</li><li>在C++14中<code>auto</code>允许出现在函数返回值或者<em>lambda</em>函数形参中，但是它的工作机制是模板类型推导那一套方案，而不是<code>auto</code>类型推导</li></ul></blockquote><h2 id="3-理解decltype"><a href="#3-理解decltype" class="headerlink" title="3. 理解decltype"></a>3. 理解<code>decltype</code></h2><p>提供名字或者表达式，decltype能推导出其类型</p><p>decltype最主要用于声明函数模板，而这个函数返回类型依赖于形参类型，即使用尾置返回类型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Container</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Index</span><span class="token operator">></span>    <span class="token comment">//可以工作，</span><span class="token keyword">auto</span> <span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span>       <span class="token comment">//但是需要改良</span>    <span class="token operator">-></span><span class="token keyword">decltype</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lambda表达式能忽略尾置返回类型，只留下auto。<strong>但是当返回值是一个int&amp;类型时，模板类型推导会去除引用部分，最后推导出int类型</strong>，这会导致当赋值时出现意料外错误。</p><ul><li><p>解决办法：使用decltype(auto)，<code>auto</code>说明符表示这个类型将会被推导，<code>decltype</code>说明<code>decltype</code>的规则将会被用到这个推导过程中</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Container</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Index</span><span class="token operator">></span>    <span class="token comment">//C++14版本，</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span>                                  <span class="token comment">//可以工作，</span><span class="token function">authAndAccess</span><span class="token punctuation">(</span>Container<span class="token operator">&amp;</span> c<span class="token punctuation">,</span> Index i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>           <span class="token comment">//但是还需要</span><span class="token comment">//传左值正常，但传右值可能会出现意料外的结果，解决方法是使用通用引用+完美转发</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果想对初始化表达式使用<code>decltype</code>推导的规则，也可以使用decltype(auto)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> myWidget2 <span class="token operator">=</span> cw<span class="token punctuation">;</span>          <span class="token comment">//decltype类型推导，会推导出引用类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>将<code>decltype</code>应用于变量名会产生该变量名的声明类型。</p><p>然而，<strong>对于比单纯的变量名更复杂的左值表达式，<code>decltype</code>可以确保报告的类型始终是左值引用</strong>。C++11定义了表达式<code>(x)</code>也是一个左值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>b<span class="token punctuation">;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//推导为int</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>b<span class="token operator">=</span>x<span class="token punctuation">)</span>   <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//推导为int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li><code>decltype</code>总是不加修改的产生变量或者表达式的类型。</li><li>对于<code>T</code>类型的不是单纯的变量名的左值表达式，<code>decltype</code>总是产出<code>T</code>的引用即<code>T&amp;</code>。</li><li>C++14支持<code>decltype(auto)</code>，就像<code>auto</code>一样，推导出类型，但是它使用<code>decltype</code>的规则进行推导。</li></ul></blockquote><h2 id="4-学会查看类型推导结果"><a href="#4-学会查看类型推导结果" class="headerlink" title="4. 学会查看类型推导结果"></a>4. 学会查看类型推导结果</h2><p>三种方法：</p><ul><li>IDE编辑器：代码编写时使用IDE查看</li><li>编译器诊断：使用编译器出错时提供的错误消息</li><li>运行时输出：打印typeid(x).name()信息，但是其不一定返回有意义的信息，且不一定准确（因为<code>std::type_info::name</code>规范批准像传值形参一样来对待这些类型，因此可能丢失自身的引用属性或const属性）</li></ul><blockquote><p><strong>总结</strong></p><ul><li>类型推断可以从IDE看出，从编译器报错看出，从Boost TypeIndex库的使用看出</li><li>这些工具可能既不准确也无帮助，所以理解C++类型推导规则才是最重要的</li></ul></blockquote><h1 id="CHAPTER2-auto"><a href="#CHAPTER2-auto" class="headerlink" title="CHAPTER2 auto"></a><strong>CHAPTER2 auto</strong></h1><p>介绍auto的使用及坑</p><h2 id="5-优先考虑auto而⾮显式类型声明"><a href="#5-优先考虑auto而⾮显式类型声明" class="headerlink" title="5. 优先考虑auto而⾮显式类型声明"></a>5. 优先考虑auto而⾮显式类型声明</h2><p>auto会强制初始化，避免出现意料之外的初始值。auto能在修改代码后自动重构代码，且避免一些平台兼容导致的问题。</p><p>定义lambda函数变量时，<code>std::function</code>方法比<code>auto</code>方法要更耗空间且调用更慢，还可能有<em>out-of-memory</em>异常。（更耗空间是因为如果std::function声明的对象空间不足以存储闭包，则需要重新申请堆内存来存储）</p><p>遍历<code>std::unordered_map</code>时，其key是const，如果遍历方法如下则会导致每个元素生成一个非const的临时对象，然后将p绑定在临时对象上，从而出现意料之外的结果。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> p <span class="token operator">:</span> m<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li><code>auto</code>变量必须初始化，它可以避免一些移植性和效率性的问题，也使得重构更方便</li><li><code>auto</code>类型的变量可能会踩到一些陷阱。</li></ul></blockquote><h2 id="6-auto推导若非己愿，使用显式类型初始化惯用法"><a href="#6-auto推导若非己愿，使用显式类型初始化惯用法" class="headerlink" title="6. auto推导若非己愿，使用显式类型初始化惯用法"></a>6. <code>auto</code>推导若非己愿，使用显式类型初始化惯用法</h2><p>一些类的取值返回结果并未原始结果，而是代理类，其内部实现未知从而导致出现错误。如vector<bool>，其如果是临时对象时，可能会存在访问时已被释放的问题（其细节可以详见原书）。</p><p>auto有时会推导为代理类的类型，可以使用<strong>显式类型初始器惯用法</strong>强制指定推导类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> highPriority <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">features</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>不可见的代理类可能会使<code>auto</code>从表达式中推导出“错误的”类型</li><li>显式类型初始器惯用法强制<code>auto</code>推导出你想要的结果</li></ul></blockquote><h1 id="CHAPTER3-Moving-to-Modern-C"><a href="#CHAPTER3-Moving-to-Modern-C" class="headerlink" title="CHAPTER3 Moving to Modern C++"></a><strong>CHAPTER3 Moving to Modern C++</strong></h1><h2 id="7-区别使用-和-创建对象"><a href="#7-区别使用-和-创建对象" class="headerlink" title="7. 区别使用()和{}创建对象"></a>7. 区别使用<code>()</code>和<code>&#123;&#125;</code>创建对象</h2><p>C++11基于花括号来统一初始化。</p><p>花括号初始化能被用于：</p><ul><li>初始化容器元素，</li><li>为非静态数据成员指定默认初始值（也能用小括号初始化）</li><li>不可拷贝的对象（例如<code>std::atomic</code>）初始化（也能用小括号初始化）</li></ul><p><strong>注意</strong></p><ul><li><p>花括号表达式有一个异常的特性，它不允许内置类型间隐式的变窄转换（变化为更高类型允许）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span><span class="token keyword">int</span> sum1<span class="token punctuation">&#123;</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>          <span class="token comment">//错误！double的和可能不能表示为int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>花括号表达式能很好创建一个使用默认构造函数构造的对象</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget <span class="token function">w2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//最令人头疼的解析！声明一个函数w2，返回Widget</span>Widget w3<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                    <span class="token comment">//调用没有参数的构造函数构造对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p><strong>缺陷</strong></p><ul><li><p>使用花括号初始化时会优先调用声明有<code>std::initializer_list</code>形参的（移动）构造函数（即使直观上其他构造函数更适合），编译器热衷于把花括号初始化与使<code>std::initializer_list</code>构造函数匹配（如果花括号里面是空集则不会优先，除非里面再加一个花括号）</p></li><li><p>容器定义时使用花括号和小括号意义完全不同</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//使用非std::initializer_list构造函数</span>                                <span class="token comment">//创建一个包含10个元素的std::vector，所有的元素的值都是20</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v2<span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//使用std::initializer_list构造函数</span>                                <span class="token comment">//创建包含两个元素的std::vector，元素的值为10和20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p><strong>总结</strong></p><ul><li>括号初始化是最广泛使用的初始化语法，它防止变窄转换，并且对于C++最令人头疼的解析有天生的免疫性</li><li>在构造函数重载决议中，括号初始化尽最大可能与<code>std::initializer_list</code>参数匹配，即便其他构造函数看起来是更好的选择</li><li>对于数值类型的<code>std::vector</code>来说使用花括号初始化和小括号初始化会造成巨大的不同</li><li>在模板类选择使用小括号初始化或使用花括号初始化创建对象是一个挑战。</li></ul></blockquote><h2 id="8-优先考虑nullptr而非0和NULL"><a href="#8-优先考虑nullptr而非0和NULL" class="headerlink" title="8. 优先考虑nullptr而非0和NULL"></a>8. 优先考虑<code>nullptr</code>而非<code>0</code>和<code>NULL</code></h2><p>字面量0和NULL是int型，而非指针</p><p>当函数重载时，如果传递NULL，会优先与int型形参匹配</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//三个f的重载函数</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//调用f(int)而不是f(void*)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//一般来说调用f(int)，绝对不会调用f(void*)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>nullptr</code>的优点是它不是整型，是<strong>所有</strong>类型的指针，其真正类型是<code>std::nullptr_t</code>，<code>std::nullptr_t</code>可以隐式转换为指向任何内置类型的指针</p><p>使用nullptr而非NULL可以避免使用模板时将NULL指针推导为int型。</p><blockquote><p><strong>总结</strong></p><ul><li>优先考虑<code>nullptr</code>而非<code>0</code>和<code>NULL</code></li><li>避免重载指针和整型</li></ul></blockquote><h2 id="9-优先考虑别名声明而非typedefs"><a href="#9-优先考虑别名声明而非typedefs" class="headerlink" title="9. 优先考虑别名声明而非typedefs"></a>9. 优先考虑别名声明而非<code>typedef</code>s</h2><p>当声明一个函数指针时别名声明using更容易理解：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//typedef</span><span class="token keyword">using</span> FP <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//别名声明</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>using相比typedef最大一个特点是可以被模板化</strong>，而typedef定义模板别名只能嵌套进模板化的struct（其如果用来定义对象时又使用了模板形参，则定义对象时需要加typename）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                            <span class="token comment">//MyAllocList&lt;T>是</span><span class="token keyword">using</span> MyAllocList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">;</span>   <span class="token comment">//std::list&lt;T, MyAlloc&lt;T>>的同义词</span>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span> lw<span class="token punctuation">;</span>                         <span class="token comment">//用户代码</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                            <span class="token comment">//MyAllocList&lt;T>是</span><span class="token keyword">struct</span> <span class="token class-name">MyAllocList</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">//std::list&lt;T, MyAlloc&lt;T>></span>    <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">>></span> type<span class="token punctuation">;</span>      <span class="token comment">//的同义词  </span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>MyAllocList<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token double-colon punctuation">::</span>type lw<span class="token punctuation">;</span>                   <span class="token comment">//用户代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li><code>typedef</code>不支持模板化，但是别名声明支持。</li><li>别名模板避免了使用“<code>::type</code>”后缀，而且在模板中使用<code>typedef</code>还需要在前面加上<code>typename</code></li><li>C++14提供了C++11所有<em>type traits</em>转换的别名声明版本</li></ul></blockquote><h2 id="10-优先考虑限域enum而非未限域enum"><a href="#10-优先考虑限域enum而非未限域enum" class="headerlink" title="10. 优先考虑限域enum而非未限域enum"></a>10. 优先考虑限域<code>enum</code>而非未限域<code>enum</code></h2><p>未限域<code>enum</code>，枚举名的名字属于包含这个<code>enum</code>的作用域，这意味着作用域内不能含有相同名字的其他东西</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Color</span> <span class="token punctuation">&#123;</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">//black, white, red在Color所在的作用域</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>限域<code>enum</code>，枚举名的名字属于<code>enum</code>作用域</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color</span> <span class="token punctuation">&#123;</span> black<span class="token punctuation">,</span> white<span class="token punctuation">,</span> red <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//black, white, red//限制在Color域内</span><span class="token comment">//默认情况下，限域枚举的底层类型是int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>限域<code>enum</code>优点：</p><ul><li><p>减少命名空间污染</p></li><li><p>在作用域中，枚举名是强类型。未限域<code>enum</code>中的枚举名会隐式转换为整型</p></li><li><p>可以被前置声明，而非限域不行（除非指定底层类型，但编译器实现时需要知道所有枚举值从而选择一个最小的底层类型）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Color</span><span class="token operator">:</span> std<span class="token double-colon punctuation">::</span><span class="token keyword">uint8_t</span><span class="token punctuation">;</span>   <span class="token comment">//非限域enum前向声明 底层类型为std::uint8_t</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>未限域<code>enum</code>由于可隐式转换为整形，因此可有以下用法，限域要实现以下用法只能增加一个模板函数来转换，较为麻烦。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">UserInfoFields</span> <span class="token punctuation">&#123;</span> uiName<span class="token punctuation">,</span> uiEmail<span class="token punctuation">,</span> uiReputation <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>UserInfo uInfo<span class="token punctuation">;</span>                         <span class="token comment">//有三个字段</span><span class="token keyword">auto</span> val <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>uiEmail<span class="token operator">></span></span></span><span class="token punctuation">(</span>uInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//想获取用户email字段的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>C++98的<code>enum</code>即非限域<code>enum</code>。</li><li>限域<code>enum</code>的枚举名仅在<code>enum</code>内可见。要转换为其它类型只能使用<em>static_cast</em>。</li><li>非限域&#x2F;限域<code>enum</code>都支持底层类型说明语法，限域<code>enum</code>底层类型默认是<code>int</code>。非限域<code>enum</code>没有默认底层类型。</li><li>限域<code>enum</code>总是可以前置声明。非限域<code>enum</code>仅当指定它们的底层类型时才能前置。</li></ul></blockquote><h2 id="11-优先考虑使用deleted函数而非使用未定义的私有声明"><a href="#11-优先考虑使用deleted函数而非使用未定义的私有声明" class="headerlink" title="11. 优先考虑使用deleted函数而非使用未定义的私有声明"></a>11. 优先考虑使用deleted函数而非使用未定义的私有声明</h2><p>在C++98中防止调用函数的方法是将它们声明为私有（<code>private</code>）成员函数并且不定义，C++11中用“<code>= delete</code>”可将标记为<strong>deleted函数</strong></p><p><strong>deleted优点</strong></p><ul><li><p><em>deleted</em>函数不能以任何方式被调用，即使你在成员函数或者友元函数里面调用<em>deleted</em>函数也不能通过编译（声明为私有且不定义方法只有在链接时才被诊断出来）</p></li><li><p><em>deleted</em>函数应被声明为<code>public</code>而不是<code>private</code>（否则，编译器只会给出该函数是<code>private</code>的错误）</p></li><li><p><strong>任何</strong>函数（包括普通函数、模板示例函数）都可以标记为<em>deleted</em></p></li><li><p>禁止一些模板的实例化（在类中，无法使用private禁止函数模板实例化，因为模板特例化必须位于一个命名空间作用域，而不是类作用域）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token generic-function"><span class="token function">processPointer</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>比起声明函数为<code>private</code>但不定义，使用<em>deleted</em>函数更好</li><li>任何函数都能被删除（be deleted），包括非成员函数和模板实例（译注：实例化的函数）</li></ul></blockquote></li></ul><h2 id="12-使用override声明重载函数"><a href="#12-使用override声明重载函数" class="headerlink" title="12. 使用override声明重载函数"></a>12. 使用override声明重载函数</h2><p>要想重写一个函数，必须满足下列要求：</p><ul><li><p>基类函数必须是<code>virtual</code></p></li><li><p>基类和派生类函数名必须完全一样（除非是析构函数)</p></li><li><p>基类和派生类函数形参类型必须完全一样</p></li><li><p>基类和派生类函数常量性<code>const</code>ness必须完全一样</p></li><li><p>基类和派生类函数的返回值和异常说明（<em>exception specifications</em>）必须兼容</p></li><li><p>函数的引用限定符（<em>reference qualifiers</em>）必须完全一样。（c++11添加，它可以限定成员函数只能用于左值或者右值）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span>    <span class="token comment">//只有*this为左值的时候才能被调用</span>    <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//只有*this为右值的时候才能被调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>重写要求过于多，因此需要使用override来显性让编译器检查是否是重写函数。</p><blockquote><p><strong>总结</strong></p><ul><li>为重写函数加上<code>override</code></li><li>成员函数引用限定让我们可以区别对待左值对象和右值对象（即<code>*this</code>)</li></ul></blockquote><h2 id="13-优先考虑const-iterator而非iterator"><a href="#13-优先考虑const-iterator而非iterator" class="headerlink" title="13. 优先考虑const_iterator而非iterator"></a>13. 优先考虑<code>const_iterator</code>而非<code>iterator</code></h2><p> <code>const_iterator</code>等价于指向常量的指针，指向不能被修改的值。</p><p>C++98使用 <code>const_iterator</code>存在诸多不便，但C++11使用 <code>const_iterator</code>变得容器使用，例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> it <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">find</span><span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> values<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1983</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用cbegin和cend</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>C++11唯一支持不足在于不支持非成员函数<code>cbegin</code>，<code>cend</code>，<code>rbegin</code>，<code>rend</code>等，只提供<code>begin</code>、<code>end</code>（C++14中都已提供）。但可以通过以下方式自己支持：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">></span><span class="token keyword">auto</span> <span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span><span class="token operator">-></span><span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//解释见下</span><span class="token punctuation">&#125;</span><span class="token comment">//对const容器调用非成员函数begin（由C++11提供）将产出const_iterator，</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>优先考虑<code>const_iterator</code>而非<code>iterator</code></li><li>在最大程度通用的代码中，优先考虑非成员函数版本的<code>begin</code>，<code>end</code>，<code>rbegin</code>等，而非同名成员函数</li></ul></blockquote><h2 id="14-如果函数不抛出异常请使用noexcept"><a href="#14-如果函数不抛出异常请使用noexcept" class="headerlink" title="14. 如果函数不抛出异常请使用noexcept"></a>14. 如果函数不抛出异常请使用<code>noexcept</code></h2><blockquote><p>有些细节还是没咋看懂（原理、移动构造），后面再看</p></blockquote><p>在C++11中，<code>noexcept</code>保证函数不会抛出任何异常。</p><p>加入<code>noexcept</code>后编译器能更好的优化代码，在一个<code>noexcept</code>函数中，当异常可能传播到函数外时，优化器不需要保证运行时栈处于可展开状态</p><p>默认情况下，内存释放函数和析构函数——不管是用户定义的还是编译器生成的——都是默认<code>noexcept</code>。</p><blockquote><p><strong>总结</strong></p><ul><li><code>noexcept</code>是函数接口的一部分，这意味着调用者可能会依赖它</li><li><code>noexcept</code>函数较之于non-<code>noexcept</code>函数更容易优化</li><li><code>noexcept</code>对于移动语义，<code>swap</code>，内存释放函数和析构函数非常有用</li><li>大多数函数是异常中立的（译注：可能抛也可能不抛异常）而不是<code>noexcept</code></li></ul></blockquote><h2 id="15-尽可能的使用constexpr"><a href="#15-尽可能的使用constexpr" class="headerlink" title="15. 尽可能的使用constexpr"></a>15. 尽可能的使用<code>constexpr</code></h2><blockquote><p>const有两重语义：变量只读，修饰常量</p><p>变量只读：定义函数时，形参前有const修饰，此时表示此形参只读</p><p>修饰常量：定义常量</p></blockquote><p>当<code>constexpr</code>用于对象上面</p><ul><li>它本质上就是<code>const</code>的加强形式。声明为<code>constexpr</code>的变量，编译器会确保它们是编译期可知的（const不保证编译期可知）</li><li>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，定义的是一个常量指针（int* const ptr），是顶层const</li></ul><p>当<code>constexpr</code>用于函数时</p><ul><li><p>不表明函数返回一个<code>const</code>值，<strong>如果实参是编译期常量，这些函数将产出编译期常量；如果实参是运行时才能知道的值，它们就将产出运行时值</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token keyword">int</span> base<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//constexpr函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>C++11中，<code>constexpr</code>函数的代码不超过一行语句：一个<code>return</code>（可使用<code>:? </code>运算符和递归），在C++14中，<code>constexpr</code>函数不再限制一行语句。</p></li><li><p><code>constexpr</code>函数限制为只能获取和返回<strong>字面值类型</strong>，在C++11中，除了<code>void</code>外的所有内置类型，以及一些用户定义类型都可以是字面值类型，因为构造函数和其他成员函数可能是<code>constexpr</code></p><ul><li>当构造函数可被声明为<code>constexpr</code>，如果传入的参数在编译期可知，其数据成员也能在编译器可知，此时这样定义的<code>constexpr</code>类变量会在编译期就构造完成。</li><li>当成员函数被声明为<code>constexpr</code>，则调用此函数的代码也能被编译期构造完成。在C++11中， 成员函数以下情况不能被声明为<code>constexpr</code>，在C++14中无此限制。<ul><li>成员函数中修改操作的对象的状态</li><li>成员函数有<code>void</code>返回类型</li></ul></li></ul></li></ul><blockquote><p>算数类型、引用和指针都属于<strong>字面值类型</strong>。但他们的初始值受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是储存于某个固定地址中的对象。</p></blockquote><blockquote><p><strong>总结</strong></p><ul><li><code>constexpr</code>对象是<code>const</code>，它被在编译期可知的值初始化</li><li>当传递编译期可知的值时，<code>constexpr</code>函数可以产出编译期可知的结果</li><li><code>constexpr</code>对象和函数可以使用的范围比non-<code>constexpr</code>对象和函数要大</li><li><code>constexpr</code>是对象和函数接口的一部分</li></ul></blockquote><h2 id="16-让const成员函数线程安全"><a href="#16-让const成员函数线程安全" class="headerlink" title="16. 让const成员函数线程安全"></a>16. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/3.MovingToModernCpp/item16.md">让const成员函数线程安全</a></h2><p><code>const</code>成员函数应支持并发执行，确保<code>const</code>成员函数是线程安全的，但是mutable定义的变量在const成员函数中仍能被修改，从而导致线程不安全。</p><p>当const成员函数中需要修改mutable变量时，需保证互斥访问：</p><ul><li>对于需要同步的是单个的变量或者内存位置，使用<code>std::atomic</code>就足够</li><li>对两个以上的变量或内存位置作为一个单元来操作的话，就应该使用互斥量</li></ul><h2 id="17-理解特殊成员函数函数的生成"><a href="#17-理解特殊成员函数函数的生成" class="headerlink" title="17. 理解特殊成员函数函数的生成"></a>17. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/3.MovingToModernCpp/item17.md">理解特殊成员函数函数的生成</a></h2><p><strong>特殊成员函数</strong>是指C++自己生成的函数。</p><p><strong>C++98</strong></p><ul><li><p>有四个特殊成员函数：默认构造函数，析构函数，拷贝构造函数，拷贝赋值运算符，这些函数仅在需要的时候才生成</p></li><li><p>默认构造函数仅在类完全没有构造函数的时候才生成，生成的特殊成员函数是隐式public且<code>inline</code>。它们是非虚的，除非相关函数是在派生类中的析构函数，派生类继承了有虚析构函数的基类。</p></li></ul><p><strong>C++11</strong></p><ul><li><p>新增两个特殊成员函数：移动构造函数和移动赋值运算符</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//移动构造函数</span>Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//移动赋值运算符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>使用移动构造或者移动赋值时，如果支持移动就会逐成员移动类成员和基类成员，如果不支持移动就执行拷贝操作</li></ul></li><li><p>两个拷贝操作是独立的：声明一个不会限制编译器生成另一个；两个移动操作不是相互独立的。如果你声明了其中一个，编译器就不再生成另一个（如果逐成员移动构造有些问题，那么逐成员移动赋值同样也可能有问题）</p></li><li><p>如果一个类显式声明了拷贝操作，编译器就不会生成移动操作</p></li><li><p>如果一个类显式声明了移动操作，编译器就不会生成拷贝操作</p></li><li><p>C++11仅当下面条件成立时才会生成移动操作（当需要时）：</p><ul><li>类中没有拷贝操作</li><li>类中没有移动操作</li><li>类中没有用户定义的析构（有自定义析构就说明资源需要自己管理，自动生成移动操作可能出错）</li></ul></li><li><p>用户声明的析构函数会抑制编译器生成移动操作，所以如果该类需要具有移动性，就为移动操作加上<code>= default</code>。声明移动会抑制拷贝生成，所以如果拷贝性也需要支持，再为拷贝操作加上<code>= default</code></p></li></ul><p>Rule of Three规则：如果声明了拷贝构造函数，拷贝赋值运算符，或者析构函数三者之一，应该也声明其余两个</p><p>C++11对于特殊成员函数处理的规则如下：</p><ul><li><strong>默认构造函数</strong>：和C++98规则相同。仅当类不存在用户声明的构造函数时才自动生成。</li><li><strong>析构函数</strong>：基本上和C++98相同；稍微不同的是现在析构默认<code>noexcept</code>（参见<a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/3.MovingToModernCpp/item14.md">Item14</a>）。和C++98一样，仅当基类析构为虚函数时该类析构才为虚函数。</li><li><strong>拷贝构造函数</strong>：和C++98运行时行为一样：逐成员拷贝non-static数据。仅当类没有用户定义的拷贝构造时才生成。如果类声明了移动操作它就是<em>delete</em>的。当用户声明了拷贝赋值或者析构，该函数自动生成已被废弃。</li><li><strong>拷贝赋值运算符</strong>：和C++98运行时行为一样：逐成员拷贝赋值non-static数据。仅当类没有用户定义的拷贝赋值时才生成。如果类声明了移动操作它就是<em>delete</em>的。当用户声明了拷贝构造或者析构，该函数自动生成已被废弃。</li><li><strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>：都对非static数据执行逐成员移动。仅当类没有用户定义的拷贝操作，移动操作或析构时才自动生成。</li></ul><p>成员函数<strong>模版</strong>不会阻止编译器生成特殊成员函数</p><blockquote><p><strong>总结</strong></p><ul><li>特殊成员函数是编译器可能自动生成的函数：默认构造函数，析构函数，拷贝操作，移动操作。</li><li>移动操作仅当类没有显式声明移动操作，拷贝操作，析构函数时才自动生成。</li><li>拷贝构造函数仅当类没有显式声明拷贝构造函数时才自动生成，并且如果用户声明了移动操作，拷贝构造就是<em>delete</em>。拷贝赋值运算符仅当类没有显式声明拷贝赋值运算符时才自动生成，并且如果用户声明了移动操作，拷贝赋值运算符就是<em>delete</em>。当用户声明了析构函数，拷贝操作的自动生成已被废弃。</li><li>成员函数模板不抑制特殊成员函数的生成。</li></ul></blockquote><h1 id="CHAPTER4-Smart-Pointers"><a href="#CHAPTER4-Smart-Pointers" class="headerlink" title="CHAPTER4 Smart Pointers"></a><strong>CHAPTER4 Smart Pointers</strong></h1><p>原始指针缺点：</p><ol><li>它的声明不能指示所指到底是单个对象还是数组。</li><li>它的声明没有告诉你用完后是否应该销毁它，即指针是否拥有所指之物。</li><li>如果你决定你应该销毁指针所指对象，没人告诉你该用<code>delete</code>还是其他析构机制（比如将指针传给专门的销毁函数）。</li><li>如果你发现该用<code>delete</code>。 原因1说了可能不知道该用单个对象形式（“<code>delete</code>”）还是数组形式（“<code>delete[]</code>”）。如果用错了结果是未定义的。</li><li>假设你确定了指针所指，知道销毁机制，也很难确定你在所有执行路径上都执行了<strong>恰为一次</strong>销毁操作（包括异常产生后的路径）。少一条路径就会产生资源泄漏，销毁多次还会导致未定义行为。</li><li>一般来说没有办法告诉你指针是否变成了悬空指针（dangling pointers），即内存中不再存在指针所指之物。在对象销毁后指针仍指向它们就会产生悬空指针。</li></ol><p>C++11中存在四种智能指针：<code>std::auto_ptr</code>，<code>std::unique_ptr</code>，<code>std::shared_ptr</code>，<code> std::weak_ptr</code></p><h2 id="18-对于独占资源使用std-unique-ptr"><a href="#18-对于独占资源使用std-unique-ptr" class="headerlink" title="18. 对于独占资源使用std::unique_ptr"></a>18. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/4.SmartPointers/item18.md">对于独占资源使用std::unique_ptr</a></h2><p>默认情况下，<code>std::unique_ptr</code>大小等同于原始指针，且大多数操作执行的指令完全相同</p><p>一个non-null <code>std::unique_ptr</code>始终拥有其指向的内容。移动一个<code>std::unique_ptr</code>将所有权从源指针转移到目的指针（源指针被设为null）。拷贝一个<code>std::unique_ptr</code>是不允许的。</p><p>默认情况下，销毁将通过<code>delete</code>进行，但是在构造过程中，<code>std::unique_ptr</code>对象可以被设置为使用自定义删除器：当资源需要销毁时可调用的任意函数（或者函数对象，包括<em>lambda</em>表达式），参数就是智能指针管理的内存的地址。</p><p>当自定义删除器时，<code>std::unique_ptr</code>的内存消耗可能会变大：</p><ul><li>函数指针形式的删除器，通常会使<code>std::unique_ptr</code>的从一个字（<em>word</em>）大小增加到两个</li><li>对于函数对象形式的删除器来说，变化的大小取决于函数对象中存储的状态多少<ul><li>无状态函数（stateless function）对象（比如不捕获变量的<em>lambda</em>表达式）对大小没有影响，这意味当自定义删除器可以实现为函数或者<em>lambda</em>时，尽量使用<em>lambda</em></li></ul></li></ul><p><code>std::unique_ptr</code>有两种形式，一种用于单个对象（<code>std::unique_ptr&lt;T&gt;</code>），一种用于数组（<code>std::unique_ptr&lt;T[]&gt;</code>）。指向哪种形式都没有歧义，<code>std::unique_ptr</code>的API设计会自动匹配你的用法。</p><p>数组的<code>std::unique_ptr</code>相比vector等容器的唯一有用情况是使用类似C的API返回一个指向堆数组的原始指针，而你想接管这个数组的所有权。</p><blockquote><p><strong>总结</strong></p><ul><li><code>std::unique_ptr</code>是轻量级、快速的、只可移动（<em>move-only</em>）的管理专有所有权语义资源的智能指针</li><li>默认情况，资源销毁通过<code>delete</code>实现，但是支持自定义删除器。有状态的删除器和函数指针会增加<code>std::unique_ptr</code>对象的大小</li><li>将<code>std::unique_ptr</code>转化为<code>std::shared_ptr</code>非常简单</li></ul></blockquote><h2 id="19-对于共享资源使用std-shared-ptr"><a href="#19-对于共享资源使用std-shared-ptr" class="headerlink" title="19. 对于共享资源使用std::shared_ptr"></a>19. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/4.SmartPointers/item19.md">对于共享资源使用std::shared_ptr</a></h2><p><code>std::shared_ptr</code>通过引用计数（<em>reference count</em>）来确保它是否是最后一个指向某种资源的指针，引用计数关联资源并跟踪有多少<code>std::shared_ptr</code>指向该资源</p><p><code>std::shared_ptr</code>构造函数递增引用计数值（注意是通常，移动构造就不会增加），析构函数递减值。如果<code>std::shared_ptr</code>在计数值递减后发现引用计数值为零，没有其他<code>std::shared_ptr</code>指向该资源，它就会销毁资源。</p><p>引用计数暗示着性能问题：</p><ul><li><strong><code>std::shared_ptr</code>大小是原始指针的两倍</strong>，因为它内部包含一个指向资源的原始指针，还包含一个指向资源的控制块的原始指针（控制块中包含引用计数值）。</li><li><strong>引用计数的内存必须动态分配</strong>。<code>std::make_shared</code>创建<code>std::shared_ptr</code>可以避免引用计数的动态分配，但是还存在一些<code>std::make_shared</code>不能使用的场景</li><li><strong>递增递减引用计数必须是原子性的</strong>，原子操作通常比非原子操作要慢</li></ul><p><code>std::shared_ptr</code>使用<code>delete</code>作为资源的默认销毁机制，也支持自定义的删除器。对于<code>std::unique_ptr</code>来说，删除器类型是智能指针类型的一部分。对于<code>std::shared_ptr</code>则不是：</p><ul><li>导致自带不同的删除器的两个<code>std::shared_ptr</code>，可以放到同一个类型的容器中，且能互相赋值。<code>std::unique_ptr</code>不行，因为删除器是其类型一部分。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>loggingDel<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">upw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 删除器类型是指针类型的一部分</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span>loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 删除器类型不是指针类型的一部分</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>std::shared_ptr</code>指定自定义删除器不会改变对象的大小，总是只有两个指针大小。</p><ul><li>有一个指向控制块的指针，控制块中包含：引用计数值、自定义删除器的拷贝、分配器的拷贝、次级引用计数<em>weak count</em>等（使用继承实现，里面还有一个虚函数用来确保指向的对象被正确销毁）</li><li>控制块的创建会遵循下面几条规则：<ul><li><code>std::make_shared</code>总是创建一个控制块</li><li>当从独占指针（<code>std::unique_ptr</code>或者<code>std::auto_ptr</code>）上构造出<code>std::shared_ptr</code>时会创建控制块</li><li>当从原始指针上构造出<code>std::shared_ptr</code>时会创建控制块</li></ul></li></ul><p>禁止从同一个原始指针中构造超过一个<code>std::shared_ptr</code>，会导致多个控制块存在，为避免此类情况：</p><ul><li>使用<code>std::make_shared</code>构造</li><li>使用new出来的结果构造</li></ul><p>使用<code>std::shared_ptr</code>管理类对象时，避免传递出this指针，如果需要从对象中得到shared指针，可将类继承<code>std::enable_shared_from_this</code>，其定义了一个成员函数，成员函数会创建指向当前对象的<code>std::shared_ptr</code>却不创建多余控制块。</p><p><code>std::shared_ptr</code>不适用于处理数组，因为没提供<code>operator[]</code>，且转换为原始指针会存在安全问题。可使用vector替代。</p><blockquote><p><strong>总结</strong></p><ul><li>较之于<code>std::unique_ptr</code>，<code>std::shared_ptr</code>对象通常大两倍，控制块会产生开销，需要原子性的引用计数修改操作。</li><li>默认资源销毁是通过<code>delete</code>，但是也支持自定义删除器。删除器的类型是什么对于<code>std::shared_ptr</code>的类型没有影响。</li><li>避免从原始指针变量上创建<code>std::shared_ptr</code>。</li></ul></blockquote><h2 id="20-当std-shared-ptr可能悬空时使用std-weak-ptr"><a href="#20-当std-shared-ptr可能悬空时使用std-weak-ptr" class="headerlink" title="20. 当std::shared_ptr可能悬空时使用std::weak_ptr"></a>20. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/4.SmartPointers/item20.md">当std::shared_ptr可能悬空时使用std::weak_ptr</a></h2><p><code>std::weak_ptr</code>是一种类似<code>std::shared_ptr</code>但不影响对象引用计数的指针，通常从<code>std::shared_ptr</code>上创建（不会影响所指对象的引用计数），其主要用于解决shared指针可能指向已经销毁的对象问题。</p><p>使用expired函数+解引用组合会存在竟态问题，但可以通过从<code>std::weak_ptr</code>上创建<code>std::shared_ptr</code>指针是否成功来判断所指对象是否已过期，有两种方法：</p><ol><li><p>使用lock函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw1 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//如果wpw过期，spw1就为空</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>以<code>std::weak_ptr</code>为实参构造<code>std::shared_ptr</code>，这种情况中，如果<code>std::weak_ptr</code>过期，会抛出一个异常：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw3</span><span class="token punctuation">(</span>wpw<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//如果wpw过期，抛出std::bad_weak_ptr异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p><code>std::weak_ptr</code>可以解决指针循环持有问题，假如有三个对象<code>A</code>、<code>B</code>、<code>C</code>，每个对象中都有一个指针指向资源，<code>A</code>和<code>C</code>指针指向<code>B</code>，因此持有<code>std::shared_ptr</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230208212020138.png"></p><p>假定从B指向A的指针也很有用。应该使用哪种指针，有三种选择：</p><ul><li><strong>原始指针</strong>。如果<code>A</code>被销毁，但是<code>C</code>继续指向<code>B</code>，<code>B</code>就会有一个指向<code>A</code>的悬空指针。而且<code>B</code>不知道指针已经悬空，所以<code>B</code>可能会继续访问，就会导致未定义行为。</li><li>**<code>std::shared_ptr</code>**。<code>A</code>和<code>B</code>都互相持有对方的<code>std::shared_ptr</code>，导致的<code>std::shared_ptr</code>环状结构（<code>A</code>指向<code>B</code>，<code>B</code>指向<code>A</code>）阻止<code>A</code>和<code>B</code>的销毁。甚至<code>A</code>和<code>B</code>无法从其他数据结构访问了（比如，<code>C</code>不再指向<code>B</code>），每个的引用计数都还是1。这种情况会导致<code>A</code>和<code>B</code>都被泄漏。</li><li>**<code>std::weak_ptr</code>**。避免了上述两个问题。如果<code>A</code>被销毁，<code>B</code>指向它的指针悬空，但是<code>B</code>可以检测到这件事。尽管<code>A</code>和<code>B</code>互相指向对方，<code>B</code>的指针不会影响<code>A</code>的引用计数，因此在没有<code>std::shared_ptr</code>指向<code>A</code>时不会导致<code>A</code>无法被销毁。</li></ul><p>在严格分层的数据结构比如树中，子节点只被父节点持有。当父节点被销毁时，子节点就被销毁。从父到子的链接关系可以使用<code>std::unique_ptr</code>很好的表征。从子到父的反向连接可以使用原始指针安全实现，因为子节点的生命周期肯定短于父节点</p><p><code>std::weak_ptr</code>与<code>std::shared_ptr</code>的大小是相同的，使用相同的控制块，构造、析构、赋值操作涉及引用计数的原子操作。</p><blockquote><p><strong>总结</strong></p><ul><li>用<code>std::weak_ptr</code>替代可能会悬空的<code>std::shared_ptr</code>。</li><li><code>std::weak_ptr</code>的潜在使用场景包括：缓存、观察者列表、打破<code>std::shared_ptr</code>环状结构。</li></ul></blockquote><h2 id="21-优先考虑使用std-make-unique和std-make-shared，而非直接使用new"><a href="#21-优先考虑使用std-make-unique和std-make-shared，而非直接使用new" class="headerlink" title="21. 优先考虑使用std::make_unique和std::make_shared，而非直接使用new"></a>21. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/4.SmartPointers/item21.md">优先考虑使用std::make_unique和std::make_shared，而非直接使用new</a></h2><p><code>std::make_shared</code>是C++11标准的一部分，但很可惜的是，<code>std::make_unique</code>不是。它从C++14开始加入标准库，自己实现如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_unique</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Ts<span class="token operator">></span></span></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为何使用<code>make</code>函数更好的原因：</p><ul><li>无需重复写两次类型，避免重复代码</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">upw1</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//使用make函数 还能如此初始化？</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">upw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//不使用make函数</span><span class="token keyword">auto</span> <span class="token function">spw1</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//使用make函数</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//不使用make函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>避免函数调用时发生异常导致资源泄露</p><ul><li><p>假设调用一个函数如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">//潜在的资源泄漏！</span>              <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在函数调用前，会有“<code>new Widget</code>”、<code>std::shared_ptr&lt;Widget&gt;</code>构造、<code>computePriority</code>三个步骤需要执行，但是编译器执行顺序不一定，如果先执行“<code>new Widget</code>”，然后执行<code>computePriority</code>时发生异常则会导致shared指针不会构造，从而造成资源泄露</p></li></ul></li><li><p><code>std::make_shared</code>效率更高，使用原始下面代码时，会申请两次内存：new申请一次+控制块再申请一次。而使用<code>make_shared</code>只会进行一次内存分配。</p></li></ul><p><code>make</code>函数限制：</p><ul><li>不允许指定自定义删除器，而有些指针构造需要自定义删除器</li><li>在<code>make</code>函数初始化时，完美转发使用小括号，而不是花括号。如果想用花括号初始化指向的对象，你必须直接使用<code>new</code>。</li><li><code>shared_ptr</code>独有的限制（上述两个限制是<code>unique_ptr</code>使用make的限制）：<ul><li>重载了new和delete运算符的类不适合使用make函数</li><li>因为控制块和对象被放在同一块分配的内存块中，直到控制块的内存也被销毁，对象占用的内存才被释放。而控制块中不仅包括引用计数，还包括次引用计数(weak count)，只要存在weak_ptr引用控制块，则对象内存就不会被释放。</li></ul></li></ul><blockquote><p><strong>总结</strong></p><ul><li>和直接使用<code>new</code>相比，<code>make</code>函数消除了代码重复，提高了异常安全性。对于<code>std::make_shared</code>和<code>std::allocate_shared</code>，生成的代码更小更快。</li><li>不适合使用<code>make</code>函数的情况包括需要指定自定义删除器和希望用花括号初始化。</li><li>对于<code>std::shared_ptr</code>s，其他不建议使用<code>make</code>函数的情况包括(1)有自定义内存管理的类；(2)特别关注内存的系统，非常大的对象，以及<code>std::weak_ptr</code>s比对应的<code>std::shared_ptr</code>s活得更久。</li></ul></blockquote><h2 id="22-当使用Pimpl惯用法，请在实现文件中定义特殊成员函数"><a href="#22-当使用Pimpl惯用法，请在实现文件中定义特殊成员函数" class="headerlink" title="22. 当使用Pimpl惯用法，请在实现文件中定义特殊成员函数"></a>22. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/4.SmartPointers/item22.md">当使用Pimpl惯用法，请在实现文件中定义特殊成员函数</a></h2><p><strong>Pimpl</strong>（<em>pointer to implementation</em>）：将类数据成员替换成一个指向包含具体实现的类（或结构体）的指针，并将放在主类（primary class）的数据成员们移动到实现类（implementation class）去，而这些数据成员的访问将通过指针间接访问</p><p>假设有一个类使用Pimpl惯用法，但<strong>使用的是一个unique_ptr指针</strong>，类定义和类实现如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>                      <span class="token comment">//在“widget.h”中</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> <span class="token class-name">Impl</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span>    <span class="token comment">//使用智能指针而不是原始指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//实现文件cpp</span><span class="token keyword">struct</span> <span class="token class-name">Widget</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">Impl</span></span> <span class="token punctuation">&#123;</span>               <span class="token comment">//跟之前一样</span>    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span>    Gadget g1<span class="token punctuation">,</span>g2<span class="token punctuation">,</span>g3<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment">//根据条款21，通过std::make_unique</span><span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Impl<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">//来创建std::unique_ptr</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上的代码能编译，但是最普通的<code>Widget</code>用法却会导致编译出错：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span>                           <span class="token comment">//错误！</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是因为对象<code>w</code>被析构时，编译器会自动生成一个析构函数，在这个析构函数里，编译器会插入一些代码来调用类<code>Widget</code>的数据成员<code>pImpl</code>的析构函数。<code>pImpl</code>的默认删除器会使用<code>delete</code>来销毁内置于<code>std::unique_ptr</code>的原始指针，然而在使用<code>delete</code>之前通常会使用<code>static_assert</code>来确保原始指针指向的类型不是一个未完成类型。</p><ul><li>解决此问题关键在于让编译器在看到析构函数前先看到Impl定义即可，只需要在头文件中先声明析构函数，在实现文件中先定义Impl然后定义析构即可（可使用default)。</li><li>使用编译器默认生成的移动操作同样会出现上述问题：<ul><li>移动赋值操作符，在重新赋值之前，需要先销毁指针<code>pImpl</code>指向的对象； </li><li>移动构造函数的问题是编译器自动生成的代码里，包含有抛出异常的事件，在这个事件里会生成销毁<code>pImpl</code>的代码。</li><li>然而，销毁<code>pImpl</code>需要<code>Impl</code>是一个完成类型。</li><li>解决方法仍一样，先声明后定义，只是不能使用default来定义函数，需要自己定义。因为：<ul><li>对包含有只可移动（<em>move-only</em>）类型，如<code>std::unique_ptr</code>的类，编译器不会生成复制操作</li><li>即使编译器帮我们生成了，生成的复制操作也只会复制<code>std::unique_ptr</code>（浅拷贝），而实际上我们需要复制指针所指向的对象（深拷贝）。</li></ul></li></ul></li></ul><p><strong>注意，声明shared指针不存在上述问题</strong>，因为 对<code>std::unique_ptr</code>而言，删除器的类型是这个智能指针的一部分，而对<code>std::shared_ptr</code>而言，删除器的类型不是该智能指针的一部分。</p><blockquote><p><strong>总结</strong></p><ul><li>Pimpl惯用法通过减少在类实现和类使用者之间的编译依赖来减少编译时间。</li><li>对于<code>std::unique_ptr</code>类型的<code>pImpl</code>指针，需要在头文件的类里声明特殊的成员函数，然后在实现文件里先实现Impl定义然后实现他们。即使是编译器自动生成的代码可以工作，也要这么做。</li><li>以上的建议只适用于<code>std::unique_ptr</code>，不适用于<code>std::shared_ptr</code>。</li></ul></blockquote><h1 id="CHAPTER5-RValue-References-Move-Semantics-and-Perfect-Forwarding"><a href="#CHAPTER5-RValue-References-Move-Semantics-and-Perfect-Forwarding" class="headerlink" title="CHAPTER5 RValue References, Move Semantics and Perfect Forwarding"></a>CHAPTER5 RValue References, Move Semantics and Perfect Forwarding</h1><ul><li><strong>移动语义</strong>使编译器有可能用廉价的移动操作来代替昂贵的拷贝操作。</li><li><strong>完美转发</strong>使接收任意数量实参的函数模板成为可能，它可以将实参转发到其他的函数，使目标函数接收到的实参与被传递给转发函数的实参保持一致。</li><li><strong>右值引用</strong>是连接这两个截然不同的概念的胶合剂。它是使移动语义和完美转发变得可能的基础语言机制。</li></ul><h2 id="23-理解std-move和std-forward"><a href="#23-理解std-move和std-forward" class="headerlink" title="23. 理解std::move和std::forward"></a>23. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item23.md">理解std::move和std::forward</a></h2><p><code>std::move</code>不移动（move）任何东西，<code>std::forward</code>也不转发（forward）任何东西。在运行时，它们不做任何事情，不产生任何可执行代码。</p><p><code>std::move</code>和<code>std::forward</code>仅仅是执行转换（cast）的函数（事实上是函数模板）。<code>std::move</code>无条件的将它的实参转换为右值，而<code>std::forward</code>只在特定情况满足时下进行转换。</p><p><code>std::move</code>的实现只是做了一个类型转换，注意返回类型是先去除引用再添加右值引用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                            <span class="token comment">//在std命名空间</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span><span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">using</span> ReturnType <span class="token operator">=</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>                             <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>ReturnType<span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>std::move</code>注意</strong></p><ul><li>不要将希望能移动的对象声明为<code>const</code>。对<code>const</code>对象的移动请求会悄无声息的被转化为拷贝操作</li><li><code>std::move</code>不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动，能确保的是得到一个右值</li></ul><p><code>std::forward</code>和<code>std::move</code>很相似，不同之处在于<code>std::move</code>总是<strong>无条件</strong>的将它的实参为右值不同，<code>std::forward</code>只对绑定了右值的引用进行到右值转换</p><blockquote><p><strong>总结</strong></p><ul><li><code>std::move</code>执行右值的无条件的转换，但它不移动任何东西。</li><li><code>std::forward</code>只有当它的参数被绑定到一个右值时，才将参数转换为右值。</li><li><code>std::move</code>和<code>std::forward</code>在运行期什么也不做，编译期就已经完成了转换。</li></ul></blockquote><h2 id="24-区别通用引用和右值引用"><a href="#24-区别通用引用和右值引用" class="headerlink" title="24. 区别通用引用和右值引用"></a>24. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item24.md">区别通用引用和右值引用</a></h2><p>“<code>T&amp;&amp;</code>”有两种不同的意思：</p><ul><li>右值引用，只绑定到右值上。</li><li>通用引用，可以绑定到几乎任何东西。</li></ul><p>观察是否存在类型推导来区分是否为通用引用，一般有以下两种通用引用类型：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">//param是一个通用引用</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> var2 <span class="token operator">=</span> var1<span class="token punctuation">;</span>                 <span class="token comment">//var2是一个通用引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li><p>通用引用的格式必须为“<code>T&amp;&amp;</code>”（T可以是其他名字），无论是加const还是其他格式皆非通用引用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//param是一个右值引用！！</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//param是一个右值引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>模板内的函数即使有“<code>T&amp;&amp;</code>”形参，但也不一定是通用引用，因为其类型可能在模板推导时就被推导出来了，只有在函数调用时进行推导的“<code>T&amp;&amp;</code>”形参才是通用引用</p></li></ul><blockquote><p><strong>总结</strong></p><ul><li>如果一个函数模板形参的类型为<code>T&amp;&amp;</code>，并且<code>T</code>需要被推导得知，或者如果一个对象被声明为<code>auto&amp;&amp;</code>，这个形参或者对象就是一个通用引用。</li><li>如果类型声明的形式不是标准的<code>type&amp;&amp;</code>，或者如果类型推导没有发生，那么<code>type&amp;&amp;</code>代表一个右值引用。</li><li>通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用。</li></ul></blockquote><h2 id="25-对于右值引用使用std-move，对于通用引用使用std-forward"><a href="#25-对于右值引用使用std-move，对于通用引用使用std-forward" class="headerlink" title="25. 对于右值引用使用std::move，对于通用引用使用std::forward"></a>25. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item25.md">对于右值引用使用std::move，对于通用引用使用std::forward</a></h2><p>如果函数的形参是右值引用，当把右值引用转发给其他函数时，右值引用应该被<strong>无条件转换</strong>为右值（通过<code>std::move</code>），因为它们<strong>总是</strong>绑定到右值</p><p>如果函数的形参是通用引用，当转发通用引用时，通用引用应该<strong>有条件地转换</strong>为右值（通过<code>std::forward</code>），因为它们只是<strong>有时</strong>绑定到右值。</p><ul><li>如果此时转发使用move，则调用函数可能导致实参变成未定义。如果将模板函数改为重载两个函数，虽然能运行，但效率很低，且当参数变多时，需要重载的函数个数呈指数级上升。</li></ul><p>如果在<strong>按值</strong>返回的函数中，返回值绑定到右值引用或者通用引用上（必须这条件，否则RVO优化效率更高），需要对返回的引用使用<code>std::move</code>或者<code>std::forward</code>。</p><p>RVO（<em>return value optimization</em>）优化条件：</p><ul><li>局部对象与函数返回值的类型相同</li><li>局部对象就是要返回的东西</li><li>当函数不同控制路径返回不同局部变量时，不进行RVO优化，很难让编译器实现RVO</li></ul><blockquote><p><strong>总结</strong></p><ul><li>最后一次使用形参时，在右值引用上使用<code>std::move</code>，在通用引用上使用<code>std::forward</code>。</li><li>对按值返回的函数要返回的右值引用和通用引用，执行相同的操作。</li><li>如果局部对象可以被返回值优化消除，就绝不使用<code>std::move</code>或者<code>std::forward</code>。</li></ul></blockquote><h2 id="26-避免重载通用引用"><a href="#26-避免重载通用引用" class="headerlink" title="26. 避免重载通用引用"></a>26. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item26.md">避免重载通用引用</a></h2><p>把重载和通用引用组合在一块是糟糕主意的原因：</p><ul><li><p>使用通用引用的函数在C++中是最贪婪的函数，它们几乎可以精确匹配任何类型的实参</p></li><li><p>通用引用的实现会匹配比开发者预期要多得多的实参类型，而精确匹配优先于类型提升的匹配，所以被调用的是通用引用的重载。</p></li></ul><p>重载规则规定当模板实例化函数和非模板函数（或者称为“正常”函数）匹配优先级相当时，优先使用“正常”函数</p><p>注意：</p><ul><li>使用通用引用的模板构造函数可能会导致拷贝构造函数等即使被声明也不会调用，因为模板构造函数会生成更匹配的构造函数。</li><li>当继承纳入考虑范围时，使用通用引用的模板构造函数与编译器生成的拷贝、移动操作之间的交互会更加复杂</li></ul><blockquote><p><strong>总结</strong></p><ul><li>对通用引用形参的函数进行重载，通用引用函数的调用机会几乎总会比你期望的多得多。</li><li>完美转发构造函数是糟糕的实现，因为对于non-<code>const</code>左值，它们比拷贝构造函数而更匹配，而且会劫持派生类对于基类的拷贝和移动构造函数的调用。</li></ul></blockquote><h2 id="27-熟悉重载通用引用的替代品"><a href="#27-熟悉重载通用引用的替代品" class="headerlink" title="27. 熟悉重载通用引用的替代品"></a>27. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item27.md">熟悉重载通用引用的替代品</a></h2><p>通用引用重载的替代方法：</p><ul><li><strong>放弃重载</strong>。通过更改函数名来放弃重载，但这种方法不能用在构造函数上。</li><li>**传递const T&amp;**。将传递通用引用替换为传递lvalue-refrence-to-<code>const</code>，缺点是效率不高。</li><li><strong>传值</strong>。将按传引用形参替换为按值传递，即在你知道要拷贝时就按值传递，这是违反直觉的。</li><li><strong>使用tag dispatch</strong>。通用引用通常提供了最优匹配，但是如果形参列表中除了通用引用还包含其他<strong>非</strong>通用引用形参，则非通用引用形参的较差匹配会使有一个通用引用的重载版本不被运行（其实将相当于在形参中增加一个标签）。</li><li><strong>约束使用通用引用的模板</strong>。使用<code>std::enable_if</code>可以使得仅在<code>std::enable_if</code>指定的条件满足时模板才启用。</li></ul><blockquote><p><strong>总结</strong></p><ul><li>通用引用和重载的组合替代方案包括使用不同的函数名，通过lvalue-reference-to-<code>const</code>传递形参，按值传递形参，使用<em>tag dispatch</em>。</li><li>通过<code>std::enable_if</code>约束模板，允许组合通用引用和重载使用，但它也控制了编译器在哪种条件下才使用通用引用重载。</li><li>通用引用参数通常具有高效率的优势，但是可用性就值得斟酌。</li></ul></blockquote><h2 id="28-理解引用折叠"><a href="#28-理解引用折叠" class="headerlink" title="28. 理解引用折叠"></a>28. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item28.md">理解引用折叠</a></h2><p><strong>引用折叠</strong></p><ul><li>如果一个上下文中允许引用的引用存在（比如，模板的实例化），引用根据规则<strong>折叠</strong>为单个引用</li><li><strong>如果任一引用为左值引用，则结果为左值引用。否则（即，如果引用都是右值引用），结果为右值引用</strong>。</li></ul><p>std::forward实现也利用了引用折叠原理：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>                                <span class="token comment">//在std命名空间</span>T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>有四种情况会发生引用折叠：</p><ul><li>模板实例化</li><li><code>auto</code>的类型生成</li><li><code>typedef</code>和别名声明的产生和使用中</li><li><code>decltype</code>推导时</li></ul><p>通用引用不是一种新的引用，它实际上是满足以下两个条件下的右值引用：</p><ul><li><strong>类型推导区分左值和右值</strong>。<code>T</code>类型的左值被推导为<code>T&amp;</code>类型，<code>T</code>类型的右值被推导为<code>T</code>。</li><li><strong>发生引用折叠</strong>。</li></ul><blockquote><p><strong>总结</strong></p><ul><li>引用折叠发生在四种情况下：模板实例化，<code>auto</code>类型推导，<code>typedef</code>与别名声明的创建和使用，<code>decltype</code>。</li><li>当编译器在引用折叠环境中生成了引用的引用时，结果就是单个引用。有左值引用折叠结果就是左值引用，否则就是右值引用。</li><li>通用引用就是在特定上下文的右值引用，上下文是通过类型推导区分左值还是右值，并且发生引用折叠的那些地方。</li></ul></blockquote><h2 id="29-认识移动操作的缺点"><a href="#29-认识移动操作的缺点" class="headerlink" title="29. 认识移动操作的缺点"></a>29. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item29.md">认识移动操作的缺点</a></h2><p>存储具体数据在堆内存的容器使用移动操作会更快，如vector。使用array的移动操作时，需要存储的类移动比复制更快，才会使得array的移动比复制快。</p><p><code>std::string</code>提供了常数时间的移动操作和线性时间的复制操作，但移动不一定比复制快。许多字符串的实现采用了小字符串优化（<em>small string optimization</em>，SSO）。“小”字符串（比如长度小于15个字符的）存储在了<code>std::string</code>的缓冲区中，并没有存储在堆内存，移动这种存储的字符串并不必复制操作更快。</p><blockquote><p>SSO的动机是大量证据表明，短字符串是大量应用使用的习惯。使用内存缓冲区存储而不分配堆内存空间，是为了更好的效率。然而这种内存管理的效率导致移动的效率并不必复制操作高。</p></blockquote><p>标准库中的某些容器操作提供了强大的异常安全保证（item14），导致即使类提供了更具效率的移动操作，而且即使移动操作更合适（比如源对象是右值），编译器仍可能被迫使用复制操作，因为移动操作没有声明<code>noexcept</code>。</p><p>以下几种情况，C++11的移动语义并无优势：</p><ul><li><strong>没有移动操作</strong>：要移动的对象没有提供移动操作，所以移动的写法也会变成复制操作。</li><li><strong>移动不会更快</strong>：要移动的对象提供的移动操作并不比复制速度更快。</li><li><strong>移动不可用</strong>：进行移动的上下文要求移动操作不会抛出异常，但是该操作没有被声明为<code>noexcept</code>。</li><li><strong>源对象是左值</strong>：除了极少数的情况外（如<a href="https://kgithub.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item25.md">Item25</a>），只有右值可以作为移动操作的来源。</li></ul><blockquote><p><strong>总结</strong></p><ul><li>假定移动操作不存在，成本高，未被使用。</li><li>在已知的类型或者支持移动语义的代码中，就不需要上面的假设。</li></ul></blockquote><h2 id="30-熟悉完美转发失败的情况"><a href="#30-熟悉完美转发失败的情况" class="headerlink" title="30. 熟悉完美转发失败的情况"></a>30. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/5.RRefMovSemPerfForw/item30.md">熟悉完美转发失败的情况</a></h2><p><strong>完美转发</strong>意味着不仅转发对象，还转发特征：它们的类型，是左值还是右值，是<code>const</code>还是<code>volatile</code>。</p><p>当下面情况任何一个发生时，完美转发就会失败：</p><ul><li>编译器不能推导出完美转发模板的一个或者多个形参类型</li><li>编译器推导“错”了完美转发模板的一个或者多个形参类型，这里的错是指推导出的类型无法编译或推导出的类型与直接调用函数表现出不一样的行为</li></ul><p><strong>完美转发失败情形</strong>：</p><ul><li>花括号初始化器：其会被推导为<code>std::initializer_list</code>对象</li><li>0或者NULL作为空指针：会被推导为int型而不是指针类型</li><li>仅有声明的整型static const数据成员：因为编译器会直接用值替换其变量所在的地方，而不会存储在内存空间中，当取地址或推导类型时就会出错</li><li>重载函数的名称和模板名称：当函数被重载后，如果传递函数给完美转发模板则无法类型推导（因为不知道用哪个函数进行推导）。同理，函数模板作为传递参数时也无法被推导。</li><li>位域：完美转发模板形参是引用，而位域通常是non-<code>const</code>，C++中non-<code>const</code>引用不应该绑定到位域，因为位域可能指向int的3-5位，而C++最小指向单位是char（没有函数可以绑定引用到位域，也没有函数可以接受指向位域的指针，因此只能值传递）</li></ul><blockquote><p><strong>总结</strong></p><ul><li>当模板类型推导失败或者推导出错误类型，完美转发会失败。</li><li>导致完美转发失败的实参种类有花括号初始化，作为空指针的<code>0</code>或者<code>NULL</code>，仅有声明的整型<code>static const</code>数据成员，模板和重载函数的名字，位域。</li></ul></blockquote><h1 id="CHAPTER6-Lambda-Expressions"><a href="#CHAPTER6-Lambda-Expressions" class="headerlink" title="CHAPTER6 Lambda Expressions"></a><strong>CHAPTER6 Lambda Expressions</strong></h1><p><em>lambda</em>通常被用来创建闭包，该闭包仅用作函数的实参。闭包通常可以拷贝，所以可能有多个闭包对应于一个<em>lambda</em>。</p><p><strong>闭包</strong>（<em>enclosure</em>）是<em>lambda</em>创建的运行时对象。依赖捕获模式，闭包持有被捕获数据的副本或者引用。</p><p><strong>闭包类</strong>（<em>closure class</em>）是从中实例化闭包的类。每个<em>lambda</em>都会使编译器生成唯一的闭包类。<em>lambda</em>中的语句成为其闭包类的成员函数中的可执行指令。</p><h2 id="31-避免使用默认捕获模式"><a href="#31-避免使用默认捕获模式" class="headerlink" title="31. 避免使用默认捕获模式"></a>31. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/6.LambdaExpressions/item31.md">避免使用默认捕获模式</a></h2><p>C++11中有两种默认的捕获模式：</p><ul><li>按引用捕获：默认按引用捕获模式可能会带来悬空引用的问题<ul><li>显式列出<em>lambda</em>依赖的局部变量和形参，是更加符合软件工程规范的做法</li></ul></li><li>按值捕获：默认按值捕获模式可能会诱骗你让你以为能解决悬空引用的问题（实际上并没有），还会让你以为你的闭包是独立的（事实上也不是独立的）。<ul><li>如果按值捕获的是一个指针（如this指针），该指针拷贝到<em>lambda</em>对应的闭包里，并不能避免指针悬空问题</li><li>捕获只能应用于<em>lambda</em>被创建时所在作用域里的non-<code>static</code>局部变量（包括形参），不能捕获类的成员变量，因为真正捕获的是this，然后使用的this访问成员变量</li><li>一些静态成员在lambda中也能被使用，但其并未被捕获</li></ul></li></ul><blockquote><p><strong>总结</strong></p><ul><li>默认的按引用捕获可能会导致悬空引用。</li><li>默认的按值捕获对于悬空指针很敏感（尤其是<code>this</code>指针），并且它会误导人产生<em>lambda</em>是独立的想法。</li></ul></blockquote><h2 id="32-使用初始化捕获来移动对象到闭包中"><a href="#32-使用初始化捕获来移动对象到闭包中" class="headerlink" title="32. 使用初始化捕获来移动对象到闭包中"></a>32. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/6.LambdaExpressions/item32.md">使用初始化捕获来移动对象到闭包中</a></h2><p>C++11只能将对象复制到闭包中而不能移动到lambda闭包中，初始化捕获是C++14提供的一种新捕获机制，可以让你指定：</p><ol><li>从lambda生成的闭包类中的<strong>数据成员名称</strong>；</li><li>初始化该成员的<strong>表达式</strong>；</li></ol><p>初始化捕获示例如下，“<code>=</code>”的左侧是指定的闭包类中数据成员的名称，右侧则是初始化表达式。“<code>=</code>”左侧的作用域不同于右侧的作用域，“<code>=</code>”左侧的名称<code>pw</code>表示闭包类中的数据成员，而右侧的名称<code>pw</code>表示在<em>lambda</em>上方声明的对象</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment">//使用std::move(pw)初始化闭包数据成员</span>            <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> pw<span class="token operator">-></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span> pw<span class="token operator">-></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>移动捕获可以在C++11中这样模拟：</p><ol><li>将要捕获的对象移动到由<code>std::bind</code>产生的函数对象中；</li><li>将“被捕获的”对象的引用赋予给lambda。</li></ol><p>由于bind对象的生命周期与闭包对象的生命周期相同，因此可以将bind对象中的对象视为闭包中的对象。</p><p>模拟示例代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span>    std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>                              <span class="token comment">//C++11模拟初始化捕获</span>        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span> <span class="token comment">/*使用data*/</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>                         <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="33-对auto-amp-amp-形参使用decltype以std-forward它们"><a href="#33-对auto-amp-amp-形参使用decltype以std-forward它们" class="headerlink" title="33. 对auto&amp;&amp;形参使用decltype以std::forward它们"></a>33. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/6.LambdaExpressions/item33.md">对<code>auto&amp;&amp;</code>形参使用<code>decltype</code>以<code>std::forward</code>它们</a></h2><p><strong>泛型lambda</strong>的实现很简洁，即在闭包类中的<code>operator()</code>函数是一个函数模版</p><p>如果需要进行完美转发，则需要将lambda表达式形参定义为auto&amp;&amp;，但是这会导致std::forward的模板类型无法填写。解决方法是使用<code>decltype(x)</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="34-优先考虑lambda表达式而非std-bind"><a href="#34-优先考虑lambda表达式而非std-bind" class="headerlink" title="34. 优先考虑lambda表达式而非std::bind"></a>34. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/6.LambdaExpressions/item34.md">优先考虑lambda表达式而非std::bind</a></h2><p>优先<em>lambda</em>而不是<code>std::bind</code>的最重要原因是<em>lambda</em>更易读</p><p>使用std::bind时，如果传递给绑定函数的实参是一个函数，则此函数会在bind定义时就被计算，而非在绑定函数调用时计算。</p><ul><li>一个解决方法是将实参函数也使用bind函数绑定。</li><li>但是此方法面对函数重载时会编译失败，除非将函数名静态转换为函数指针，但编译器通常不会对函数指针进行内联。因此，使用<em>lambda</em>可能会比使用<code>std::bind</code>能生成更快的代码。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> setSoundB <span class="token operator">=</span>                            <span class="token comment">//“B”代表“bind”</span>    std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">,</span> steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>h<span class="token punctuation">,</span>     <span class="token comment">//不正确！见下</span>              _1<span class="token punctuation">,</span><span class="token number">30</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解决方法</span><span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">,</span>              std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">plus</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>steady_clock<span class="token double-colon punctuation">::</span>now<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span>              _1<span class="token punctuation">,</span><span class="token number">30</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::bind总是拷贝它的实参，但是可以使用引用来存储实参，这要通过应用<code>std::ref</code>到实参上实现。<code>auto compressRateB = std::bind(compress, std::ref(w), _1)</code>;</p><p>在C++14中，没有<code>std::bind</code>的合理用例。 但在C++11中，两个受约束的情况下证明使用<code>std::bind</code>是合理的：</p><ul><li><strong>移动捕获</strong>。C++11的<em>lambda</em>不提供移动捕获，但是可以通过结合<em>lambda</em>和<code>std::bind</code>来模拟。 </li><li><strong>多态函数对象</strong>。因为bind对象上的函数调用运算符使用完美转发，所以它可以接受任何类型的实参。当你要绑定带有模板化函数调用运算符的对象时，此功能很有用。</li></ul><blockquote><p><strong>总结</strong></p><ul><li>与使用<code>std::bind</code>相比，<em>lambda</em>更易读，更具表达力并且可能更高效。</li><li>只有在C++11中，<code>std::bind</code>可能对实现移动捕获或绑定带有模板化函数调用运算符的对象时会很有用。</li></ul></blockquote><h1 id="CHAPTER7-The-Concurrency-API"><a href="#CHAPTER7-The-Concurrency-API" class="headerlink" title="CHAPTER7 The Concurrency API"></a><strong>CHAPTER7 The Concurrency API</strong></h1><h2 id="35-优先考虑基于任务的编程而非基于线程的编程"><a href="#35-优先考虑基于任务的编程而非基于线程的编程" class="headerlink" title="35. 优先考虑基于任务的编程而非基于线程的编程"></a>35. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/7.TheConcurrencyAPI/Item35.md">优先考虑基于任务的编程而非基于线程的编程</a></h2><p>异步执行<code>doAsyncWork</code>函数，通常有两种方式：</p><ul><li><p>创建<code>std::thread</code>执行<code>doAsyncWork</code>，这是应用了<strong>基于线程</strong>（<em>thread-based</em>）的方式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>将<code>doAsyncWork</code>传递给<code>std::async</code>，一种<strong>基于任务</strong>（<em>task-based</em>）的策略（传递给<code>std::async</code>的函数对象被称为一个<strong>任务</strong>）：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//“fut”表示“future”</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>基于任务的方法通常比基于线程的方法更优，原因：</p><ul><li><code>std::async</code>返回的<em>future</em>提供了<code>get</code>函数（从而可以获取返回值）</li><li>如果<code>doAsycnWork</code>发生了异常，<code>get</code>函数就显得更为重要，因为<code>get</code>函数可以提供抛出异常的访问，而基于线程的方法，如果<code>doAsyncWork</code>抛出了异常，程序会直接终止</li><li>软件线程是有限的资源。如果开发者试图创建大于系统支持的线程数量，会抛出<code>std::system_error</code>异常。避免此异常的方法就是使用<code>std::async</code></li><li>当遇见资源超频（准备运行的软件线程大于硬件线程的数量的情况）时，由于std::async能自动决定是开启一个新线程还是将其插入等待运行结果的线程上，因此能有效减少线程切换消耗</li></ul><blockquote><p>基于线程与基于任务最根本的区别在于，基于任务的抽象层次更高。基于任务的方式使得开发者从线程管理的细节中解放出来，“<em>thread</em>”的三种含义：</p><ul><li><strong>硬件线程</strong>（hardware threads）是真实执行计算的线程。每个CPU核心提供一个或者多个硬件线程。</li><li><strong>软件线程</strong>（software threads）（也被称为系统线程）是操作系统管理的在硬件线程上执行的线程。通常存在比硬件线程更多数量的软件线程，因为当软件线程被阻塞的时候可以调度其他未阻塞的软件线程执行。</li><li><strong><code>std::thread</code></strong> 是C++执行过程的对象，并作为软件线程的句柄。有些<code>std::thread</code>对象代表“空”句柄，即没有对应软件线程，因为它们处在默认构造状态（即没有函数要执行）；有些被移动走（移动到的<code>std::thread</code>就作为这个软件线程的句柄）；有些被<code>join</code>（它们要运行的函数已经运行完）；有些被<code>detach</code>（它们和对应的软件线程之间的连接关系被打断）。</li></ul></blockquote><p>使用<code>std::thread</code>有优势的场景：</p><ul><li>需要访问非常基础的线程API为了提供对底层系统级线程API的访问，<code>std::thread</code>对象提供了<code>native_handle</code>的成员函数，而<code>std::future</code>（即<code>std::async</code>返回的东西）没有这种能力。</li><li>你需要且能够优化应用的线程使用。例如要开发一款已知执行概况的服务器软件，部署在有固定硬件特性的机器上，作为唯一的关键进程。</li><li>你需要实现C++并发API之外的线程技术，比如，C++实现中未支持的平台的线程池。</li></ul><blockquote><p><strong>总结</strong></p><ul><li><code>std::thread</code> API不能直接访问异步执行的结果，如果执行函数有异常抛出，代码会终止执行。</li><li>基于线程的编程方式需要手动的线程耗尽、资源超额、负责均衡、平台适配性管理。</li><li>通过带有默认启动策略的<code>std::async</code>进行基于任务的编程方式会解决大部分问题。</li></ul></blockquote><h2 id="36-如果有异步的必要请指定std-launch-async"><a href="#36-如果有异步的必要请指定std-launch-async" class="headerlink" title="36. 如果有异步的必要请指定std::launch::async"></a>36. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/7.TheConcurrencyAPI/item36.md">如果有异步的必要请指定std::launch::async</a></h2><p><code>std::async</code>有两种启动策略：</p><ul><li><code>std::launch::async</code>启动策略意味着<code>f</code>必须异步执行，即在不同的线程。</li><li><strong><code>std::launch::deferred</code>启动策略</strong>意味着<code>f</code>仅当在<code>std::async</code>返回的<em>future</em>上调用<code>get</code>或者<code>wait</code>时才执行，且调用方会被阻塞，直到被调用函数运行结束。</li></ul><p><code>std::async</code>默认启动策略是两个策略求或得到，因此默认策略允许<code>f</code>异步或者同步执行，也就导致无法预测函数f是否会并发执行，也无法预测函数f是否会执行（可能不被调用）。</p><ul><li>默认启动策略的调度灵活性导致使用<code>thread_local</code>变量比较麻烦，因为无法确认线程局部变量是新创建线程的还是调用方所在线程的</li><li>会影响到基于<code>wait</code>的循环使用超时机制，因为在一个延时的任务上调用<code>wait_for</code>或者<code>wait_until</code>会产生<code>std::launch::deferred</code>值</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async <span class="token operator">|</span>     <span class="token comment">//使用async或者deferred运行f</span>                       std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>deferred<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>只要满足以下条件，<code>std::async</code>的默认启动策略就可以使用：</p><ul><li>任务不需要和执行<code>get</code>或<code>wait</code>的线程并行执行。</li><li>读写哪个线程的<code>thread_local</code>变量没什么问题。</li><li>可以保证会在<code>std::async</code>返回的<em>future</em>上调用<code>get</code>或<code>wait</code>，或者该任务可能永远不会执行也可以接受。</li><li>使用<code>wait_for</code>或<code>wait_until</code>编码时考虑到了延迟状态。</li></ul><blockquote><p><strong>总结</strong></p><ul><li><code>std::async</code>的默认启动策略是异步和同步执行兼有的。</li><li>这个灵活性导致访问<code>thread_local</code>s的不确定性，隐含了任务可能不会被执行的意思，会影响调用基于超时的<code>wait</code>的程序逻辑。</li><li>如果异步执行任务非常关键，则指定<code>std::launch::async</code>。</li></ul></blockquote><h2 id="37-使std-thread在所有路径最后都不可结合"><a href="#37-使std-thread在所有路径最后都不可结合" class="headerlink" title="37. 使std::thread在所有路径最后都不可结合"></a>37. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/7.TheConcurrencyAPI/item37.md">使<code>std::thread</code>在所有路径最后都不可结合</a></h2><p>每个<code>std::thread</code>对象处于两个状态之一：</p><ul><li><strong>可结合的</strong>（<em>joinable</em>）：正在运行或者可能要运行或运行结束的异步执行线程</li><li><strong>不可结合的</strong>（<em>unjoinable</em>）：主要包括：<ul><li>默认构造的<code>std::thread</code>。没有函数执行，因此没有对应到底层执行线程上。</li><li>已经被移动走的<code>std::thread</code>对象。移动的结果就是一个<code>std::thread</code>原来对应的执行线程现在对应于另一个<code>std::thread</code>。</li><li>已经被<code>join</code>的<code>std::thread</code> 。在<code>join</code>之后，<code>std::thread</code>不再对应于已经运行完了的执行线程。</li><li>已经被<code>detach</code>的<code>std::thread</code> 。<code>detach</code>断开了<code>std::thread</code>对象与执行线程之间的连接。</li></ul></li></ul><p><strong><code>std::thread</code>的可结合性如此重要的原因之一</strong>：当可结合的线程的析构函数被调用，程序执行会终止</p><p>为了保证<code>std::thread</code>最后是不可结合的，可使用RALL来管理，即类似智能指针。实现代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ThreadRAII</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">DtorAction</span> <span class="token punctuation">&#123;</span> join<span class="token punctuation">,</span> detach <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// enum class的信息见条款10</span>  <span class="token function">ThreadRAII</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">,</span> DtorAction a<span class="token punctuation">)</span>  <span class="token comment">// 析构函数中对t实行a动作</span>      <span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token operator">~</span><span class="token function">ThreadRAII</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 可结合性测试见下</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>action <span class="token operator">==</span> DtorAction<span class="token double-colon punctuation">::</span>join<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 见下</span> <span class="token keyword">private</span><span class="token operator">:</span>  DtorAction action<span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>thread t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>在所有路径上保证<code>thread</code>最终是不可结合的。</li><li>析构时<code>join</code>会导致难以调试的表现异常问题。</li><li>析构时<code>detach</code>会导致难以调试的未定义行为。</li><li>声明类数据成员时，最后声明<code>std::thread</code>对象（因为线程构建完成就可能开始执行）。</li></ul></blockquote><h2 id="38-关注不同线程句柄析构行为"><a href="#38-关注不同线程句柄析构行为" class="headerlink" title="38. 关注不同线程句柄析构行为"></a>38. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/7.TheConcurrencyAPI/item38.md">关注不同线程句柄析构行为</a></h2><p>可结合的<code>std::thread</code>对应于执行的系统线程。未延迟（non-deferred）任务的<em>future</em>与系统线程有相似的关系。因此，可以将<code>std::thread</code>对象和<em>future</em>对象都视作系统线程的<strong>句柄</strong>（<em>handles</em>）</p><ul><li>可结合的<code>std::thread</code>析构会终止你的程序</li><li><em>future</em>的析构表现有时就像执行了隐式<code>join</code>，有时又像是隐式执行了<code>detach</code>，有时又没有执行这两个选择。它永远不会造成程序终止<ul><li>执行结果不能存储在调用者和被调用上，因此引入了一个共享状态存储结果。共享状态通常是基于堆的对象。<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230214110431271.png"></li><li>共享状态的存在非常重要，因为<em>future</em>的析构函数取决于与<em>future</em>关联的共享状态。特别地，<ul><li>引用了共享状态——使用<code>std::async</code>启动的未延迟任务建立的那个——的最后一个future的析构函数会阻塞住，直到任务完成。本质上，这种<em>future</em>的析构函数对执行异步任务的线程执行了隐式的<code>join</code>。</li><li>其他所有*future*的析构函数简单地销毁future对象。对于异步执行的任务，就像对底层的线程执行<code>detach</code>。对于延迟任务来说如果这是最后一个<em>future</em>，意味着这个延迟任务永远不会执行了。</li></ul></li><li>正常行为是<em>future</em>析构函数销毁<em>future</em>。不<code>join</code>也不<code>detach</code>，也不运行什么，只销毁<em>future</em>的数据成员。正常行为的例外情况仅在某个<code>future</code>同时满足下列所有情况下才会出现：<ul><li>它关联到由于调用<code>std::async</code>而创建出的共享状态。</li><li>任务的启动策略是<code>std::launch::async</code>，原因是运行时系统选择了该策略，或者在对<code>std::async</code>的调用中指定了该策略。</li><li>这个future是关联共享状态的最后一个future。对于<code>std::future</code>，情况总是如此，对于<code>std::shared_future</code>，如果还有其他的<code>std::shared_future</code>，与要被销毁的<em>future</em>引用相同的共享状态，则要被销毁的<em>future</em>遵循正常行为（即简单地销毁它的数据成员）。</li></ul></li></ul></li></ul><blockquote><p><strong>总结</strong></p><ul><li><em>future</em>的正常析构行为就是销毁<em>future</em>本身的数据成员。</li><li>引用了共享状态——使用<code>std::async</code>启动的未延迟任务建立的那个——的最后一个<em>future</em>的析构函数会阻塞住，直到任务完成。</li></ul></blockquote><h2 id="39-考虑对于单次事件通信使用void的future"><a href="#39-考虑对于单次事件通信使用void的future" class="headerlink" title="39. 考虑对于单次事件通信使用void的future"></a>39. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/7.TheConcurrencyAPI/item39.md">考虑对于单次事件通信使用void的future</a></h2><p>有时，一个任务（检测任务）通知另一个异步执行的任务（反应任务）发生了特定的事件很有用，这种情况下，线程间通信的最佳方案是什么？</p><p><strong>条件变量方案缺点</strong>：</p><ul><li>如果在反应任务<code>wait</code>之前检测任务通知了条件变量，反应任务会挂起。</li><li><code>wait</code>语句虚假唤醒。即在条件变量没有被通知时，也可能被唤醒。</li></ul><p><strong>原子类型flag方案缺点</strong>：</p><ul><li>会不断轮询，任务不会被阻塞</li></ul><p><strong>条件变量+flag方案缺点</strong>：</p><ul><li>通信机制不直接，不优雅</li></ul><p><strong>promise+futures方案</strong>：</p><ul><li>不需要互斥锁，无论在反应线程调用<code>wait</code>之前检测线程是否设置了<code>std::promise</code>都可以工作，并且不受虚假唤醒的影响。与基于条件变量的方法一样，反应任务在调用<code>wait</code>之后是真被阻塞住的，不会一直占用系统资源。</li><li>缺点：<ul><li>可能会产生基于堆的分配和释放开销</li><li><code>std::promise</code>只能设置一次。<code>std::promise</code>和<em>future</em>之间的通信是一次性的：不能重复使用</li></ul></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> p<span class="token punctuation">;</span>                   <span class="token comment">//通信信道的promise</span><span class="token comment">//检测任务</span>…                                       <span class="token comment">//检测某个事件</span>p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//通知反应任务</span><span class="token comment">//反应任务</span>…                                       <span class="token comment">//准备作出反应</span>p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">//等待对应于p的那个future</span>…                                       <span class="token comment">//对事件作出反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ul><li>对于简单的事件通信，基于条件变量的设计需要一个多余的互斥锁，对检测和反应任务的相对进度有约束，并且需要反应任务来验证事件是否已发生。</li><li>基于flag的设计避免的上一条的问题，但是是基于轮询，而不是阻塞。</li><li>条件变量和flag可以组合使用，但是产生的通信机制很不自然。</li><li>使用<code>std::promise</code>和<em>future</em>的方案避开了这些问题，但是这个方法使用了堆内存存储共享状态，同时有只能使用一次通信的限制。</li></ul></blockquote><h2 id="40-对于并发使用std-atomic，volatile用于特殊内存区"><a href="#40-对于并发使用std-atomic，volatile用于特殊内存区" class="headerlink" title="40. 对于并发使用std::atomic，volatile用于特殊内存区"></a>40. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/7.TheConcurrencyAPI/item40.md">对于并发使用std::atomic，volatile用于特殊内存区</a></h2><p><code>std::atomic</code>类型的最优的特性之一：一旦<code>std::atomic</code>对象被构建，所有成员函数，包括读-改-写（RMW）操作，从其他线程来看都是原子性的。</p><ul><li>一旦<code>std::atomic</code>对象被构建，在其上的操作表现得像操作是在互斥锁保护的关键区内，但是通常这些操作是使用特定的机器指令实现，这比锁的实现更高效。</li><li>编译器可能会对代码进行重排序，从而可能导致错误的结果，而<code>std::atomic</code>会限制这种重排序</li><li>使用了<code>std::atomic</code>，编译器仍可能对一些冗余操作进行优化（例如连续赋值两次）</li></ul><p><code>volatile</code>在多线程中实际上不保证任何事情，其主要用来告诉编译器现在处理的内存是不正常的（如处理外设内存）</p><ul><li>声明了<code>volatile</code>的变量，编译器不会对其进行优化重复读写（冗余访问和无用存储）的代码，</li></ul><p>因此：</p><ul><li><p><code>std::atomic</code>用在并发编程中，对访问特殊内存没用。</p></li><li><p><code>volatile</code>用于访问特殊内存，对并发编程没用。</p></li><li><p>因为<code>std::atomic</code>和<code>volatile</code>用于不同的目的，所以可以结合起来使用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">volatile</span> std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vai<span class="token punctuation">;</span>          <span class="token comment">//对vai的操作是原子性的，且不能被优化掉</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><blockquote><p><strong>总结</strong></p><ul><li><code>std::atomic</code>用于在不使用互斥锁情况下，来使变量被多个线程访问的情况。是用来编写并发程序的一个工具。</li><li><code>volatile</code>用在读取和写入不应被优化掉的内存上。是用来处理特殊内存的一个工具。</li></ul></blockquote><h1 id="CHAPTER8-Tweaks"><a href="#CHAPTER8-Tweaks" class="headerlink" title="CHAPTER8 Tweaks"></a><strong>CHAPTER8 Tweaks</strong></h1><h2 id="41-对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递"><a href="#41-对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递" class="headerlink" title="41. 对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递"></a>41. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/8.Tweaks/item41.md">对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递</a></h2><p>假设需要拷贝一个形参到私有容器，</p><ul><li><p>为了提高效率，应该设计以下两个函数，但会导致维护十分麻烦。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> newName<span class="token punctuation">)</span>    <span class="token comment">//接受左值；拷贝它</span>    <span class="token punctuation">&#123;</span> names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span>         <span class="token comment">//接受右值；移动它；std::move</span>    <span class="token punctuation">&#123;</span> names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>或使<code>addName</code>函数成为具有通用引用的函数模板，但是通用引用会导致实现必须放置在头文件、实例化等复杂性</p></li><li><p>一个可行的方式就是直接使用传值的方式，在C++11中，只有在左值实参情况下，<code>addName</code>被拷贝构造出来；对于右值，它会被移动构造（应该是编译器优化实现）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string newName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">//接受左值或右值；移动它</span>        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>考虑以上三种方法的开销：</p><ul><li><strong>重载</strong>：左值一次拷贝，右值一次移动。</li><li><strong>使用通用引用</strong>：左值一次拷贝，右值一次移动。</li><li><strong>按值传递</strong>：左值实参，一次拷贝一次移动，右值实参两次移动。对比按引用传递的方法，对于左值或者右值，均多出一次移动操作。</li></ul><p><strong>对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递</strong>。如此描述有以下原因：</p><ol><li>应该仅<strong>考虑</strong>使用传值方式。。按值传递方式只需要编写一个函数，避免了通用引用的种种问题</li><li>仅考虑对于可拷贝形参使用按值传递。如果不可拷贝，副本就必须通过移动构造函数创建，那就需要重载。</li><li>按值传递应该仅考虑那些<strong>移动开销小</strong>的形参。</li><li>你应该只对<strong>总是被拷贝</strong>的形参考虑按值传递。如果拷贝前有个判断语句，从而导致可能不拷贝，这会导致必然创建一个对象然后销毁，比基于引用的开销大。</li></ol><p>即使你编写的函数对可拷贝类型执行无条件的复制，且这个类型移动开销小，有时也可能不适合按值传递。</p><ul><li>使用通过赋值拷贝一个形参进行按值传递的函数的额外开销，取决于传递的类型，左值和右值的比例，这个类型是否需要动态分配内存</li></ul><blockquote><p><strong>总结</strong></p><ul><li>对于可拷贝，移动开销低，而且无条件被拷贝的形参，按值传递效率基本与按引用传递效率一致，而且易于实现，还生成更少的目标代码。</li><li>通过构造拷贝形参可能比通过赋值拷贝形参开销大的多。</li><li>按值传递会引起切片问题，所说不适合基类形参类型。</li></ul></blockquote><h2 id="42-考虑置入而非插入"><a href="#42-考虑置入而非插入" class="headerlink" title="42. 考虑置入而非插入"></a>42. <a href="https://github.com/CnTransGroup/EffectiveModernCppChinese/blob/master/src/8.Tweaks/item42.md">考虑置入而非插入</a></h2><p>考虑如下代码，push_back会发生以下操作：</p><ul><li>从”xyzzy”创建一个临时对象，然后传递给push_back的右值重载函数，然后此临时对象会被拷贝（移动）构造在vector内部创建一个新的对象，最后将临时对象销毁</li><li>上述操作多了一组不必要的构造和析构操作，造成了性能开销</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> vs<span class="token punctuation">;</span>        <span class="token comment">//std::string的容器</span>vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//添加字符串字面量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用emplace_back会直接在vector内部构造一个string，不会有临时变量生成和销毁。emplace_back是使用完美转发实现。可用于支持push_back的标准容器。</p><ul><li>插入函数接受<strong>对象</strong>去插入，而置入函数接受<strong>对象的构造函数接受的实参</strong>去插入。</li></ul><p>emplace并不一定比push快，<strong>emplace通常比push快的情况：</strong></p><ul><li>值是通过构造函数添加到容器，而不是直接赋值。此时使用emplace就无需生成临时变量。</li><li>传递的实参类型与容器的初始化类型不同。同样使用emplace就无需生成临时变量。</li><li>容器不拒绝重复项作为新值。置入实现通常会创建一个具有新值的对象，如果拒绝重复值插入则会导致这个对象的构造和析构被浪费。</li></ul><p><strong>注意</strong></p><ul><li>在对存储资源管理类对象的容器（比如<code>list&lt;shared_ptr&lt;Widget&gt;&gt;</code>）调用置入函数时，完美转发推迟了资源管理对象的创建，直到可以在容器的内存中构造它们为止，这给“异常导致资源泄漏”提供了可能。</li><li>置入函数使用直接初始化，这意味着可能使用<code>explicit</code>的构造函数。插入函数使用拷贝初始化，所以不能用<code>explicit</code>的构造函数。因此，置入函数可能执行插入函数拒绝的类型转换。</li></ul><blockquote><p><strong>总结</strong></p><ul><li>原则上，置入函数有时会比插入函数高效，并且不会更差。</li><li>实际上，当以下条件满足时，置入函数更快：（1）值被构造到容器中，而不是直接赋值；（2）传入的类型与容器的元素类型不一致；（3）容器不拒绝已经存在的重复值。</li><li>置入函数可能执行插入函数拒绝的类型转换。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>侯捷STL视频笔记</title>
      <link href="/2023/02/15/c++/%E4%BE%AF%E6%8D%B7STL%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/15/c++/%E4%BE%AF%E6%8D%B7STL%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>学习侯捷STL笔记，<a href="https://www.youtube.com/watch?v=Edcwv38c7d4&list=PLTcwR9j5y6W2Bf4S-qi0HBQlHXQVFoJrP">视频地址</a></p><hr><hr><h1 id="1-基础介绍"><a href="#1-基础介绍" class="headerlink" title="1. 基础介绍"></a>1. 基础介绍</h1><p>STL六大部件：</p><ul><li>容器 Containers</li><li>分配器 Allocator</li><li>算法 Algorithm</li><li>迭代器 Iterators</li><li>适配器 Adapters</li><li>仿函数 Functors</li></ul><p>容器存储数据，容器通过分配器来获得内存分配，算法通过迭代器来操作容器中的数据，仿函数可以为算法提供类函数似实体，适配器可对仿函数、容器等进行包装。</p><p><img src="C:\Users\MyPC\AppData\Roaming\Typora\typora-user-images\image-20221220190021504.png" alt="image-20221220190021504"></p><p>六大部件使用</p><p><img src="C:\Users\MyPC\AppData\Roaming\Typora\typora-user-images\image-20221220190856969.png" alt="image-20221220190856969"></p><h1 id="2-容器"><a href="#2-容器" class="headerlink" title="2. 容器"></a>2. 容器</h1><p>容器类型可以大致分为：</p><ul><li><p>序列式容器：</p><ul><li><p>array. 固定大小容器，容量不可增长</p></li><li><p>vector. 可自动增长容器</p></li><li><p>deque. 双向队列</p></li><li><p>List. 双向链表</p></li><li><p>Forward-List. 单向链表</p></li></ul></li><li><p>关联式容器：</p><ul><li><p>set&#x2F;multiset. 底层为红黑树，multiset值可以重复</p></li><li><p>map&#x2F;multimap. 底层为红黑树，multimap的key可以重复</p></li><li><p>unordered set&#x2F;multiset. 底层哈希表（常用拉链法）</p></li><li><p>unordered map&#x2F;multimap. 底层哈希表（常用拉链法）</p></li></ul></li></ul><h2 id="2-1-array"><a href="#2-1-array" class="headerlink" title="2.1 array"></a>2.1 array</h2><p><code>std::array</code> 是封装固定大小数组的容器。</p><p>此容器是一个聚合类型，其语义等同于保有一个 <a href="https://zh.cppreference.com/w/cpp/language/array">C 风格数组</a> T[N] 作为其唯一非静态数据成员的结构体。不同于 C 风格数组，它不会自动退化成 T* 。</p><p>array定义：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>    <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>    std<span class="token double-colon punctuation">::</span>size_t N<span class="token operator">></span> <span class="token keyword">struct</span> <span class="token class-name">array</span><span class="token punctuation">;</span><span class="token comment">// 用聚合初始化构造</span>    std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">></span> a1<span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// CWG 1270 重申前的 C++11 中要求双花括号</span>                                        <span class="token comment">// （ C++11 之后的版本和 C++14 起不要求）</span>    std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">></span> a2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// = 后决不要求双花括号</span>    std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">></span> a3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"b"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token comment">// 支持容器操作</span>    std<span class="token double-colon punctuation">::</span><span class="token function">sort</span><span class="token punctuation">(</span>a1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span><span class="token function">reverse_copy</span><span class="token punctuation">(</span>a2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">ostream_iterator</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>当其长度为零时 <code>array</code> （ <code>N == 0</code> ）有特殊情况。此时， array.begin() &#x3D;&#x3D; array.end() ，并拥有某个唯一值。在零长 <code>array</code> 上调用 front() 或 back() 是未定义的。</p></li><li><p>亦可将 <code>array</code> 当做拥有 <code>N</code> 个同类型元素的元组。</p></li><li><p>注意，在 <a href="https://zh.cppreference.com/w/cpp/container/array/swap">swap</a> 时，迭代器将继续指向同一 <code>array</code> 的元素，并将改变元素的值。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程和线程同步-C-Linux</title>
      <link href="/2023/02/15/c++/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5_C_Linux/"/>
      <url>/2023/02/15/c++/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5_C_Linux/</url>
      
        <content type="html"><![CDATA[<p><em>这是Linux下的多线程编程（基于C），而不是C++11多线程编程。参考爱编程的大丙的多线程和线程同步-C&#x2F;C++，<a href="https://www.bilibili.com/video/BV1sv41177e4?p=8&vd_source=7135ae3a4d6506056ac51c05382c2a25">bilibili视频地址</a>, <a href="https://subingwen.cn/linux/thread/#1-%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0">博客地址</a>。</em></p><hr><hr><h1 id="1-线程概述"><a href="#1-线程概述" class="headerlink" title="1. 线程概述"></a>1. 线程概述</h1><p>​线程是轻量级的进程，在 Linux 环境下线程的本质仍是进程。</p><p>​进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。</p><p>​<strong>线程和进程之间的区别</strong>：</p><ul><li><p>进程有自己独立的地址空间，多个线程共用同一个地址空间</p><ul><li>线程更加节省系统资源，效率不仅可以保持的，而且能够更高</li><li>在一个地址空间中多个线程独享：<em><strong>每个线程都有属于自己的栈区，寄存器 (内核中管理的)</strong></em></li><li>在一个地址空间中多个线程共享：代码段，堆区，全局数据区，打开的文件 (文件描述符表) 都是线程共享的</li></ul></li><li><p>线程是程序的最小执行单位，进程是操作系统中最小的资源分配单位</p></li><li><p>CPU 的调度和切换：线程的上下文切换比进程要快的多</p></li><li><p>线程更加廉价，启动速度更快，退出也快，对系统资源的冲击小。</p></li></ul><hr><hr><h1 id="2-多线程基础功能函数"><a href="#2-多线程基础功能函数" class="headerlink" title="2. 多线程基础功能函数"></a>2. 多线程基础功能函数</h1><h2 id="2-1-创建线程函数"><a href="#2-1-创建线程函数" class="headerlink" title="2.1 创建线程函数"></a>2.1 创建线程函数</h2><p>​每一个线程都有唯一的线程 ID，类型为 pthread_t，在Linux下也就是一个无符号长整形数，得到当前线程的线程 ID函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pthread_t <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 返回当前线程的线程ID</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​在一个进程中调用线程创建函数，就可得到一个子线程，注意，一个进程创建子线程后，进程就变为主线程+一个子线程，子线程创建函数如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span>pthread_t <span class="token operator">*</span>thread<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span>                   <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Compile and link with -pthread, 线程库的名字叫pthread, 全名: libpthread.so libptread.a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>参数</p><ul><li>thread: 传出参数，是无符号长整形数，线程创建成功，会将线程 ID 写入到这个指针指向的内存中</li><li>attr: 线程的属性，一般情况下使用默认属性即可，写 NULL</li><li>start_routine: 函数指针，创建出的子线程的处理动作，也就是该函数在子线程中执行。</li><li>arg: 作为实参传递到 start_routine 指针指向的函数内部（<strong>如需传递多个数据，可定义一个结构体</strong>）</li></ul></li><li><p>返回值：线程创建成功返回 0，创建失败返回对应的错误号</p></li></ul><p>​如果主线程退出了, 虚拟地址空间就被释放了, 子线程就一并被销毁了。但是如果某一个子线程退出了, 主线程仍在运行, 虚拟地址空间依旧存在。</p><h2 id="2-2-线程退出"><a href="#2-2-线程退出" class="headerlink" title="2.2 线程退出"></a>2.2 线程退出</h2><p>​只要调用线程退出函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。但是主线程退出结束后，子线程也会退出结束。线程退出函数如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token keyword">void</span> <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>参数：线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为 NULL（<strong>如需返回多个数据，可定义一个结构体</strong>）</li></ul><h2 id="2-3-线程回收"><a href="#2-3-线程回收" class="headerlink" title="2.3 线程回收"></a>2.3 线程回收</h2><p>​线程和进程一样，子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做 pthread_join()，这个函数是一个阻塞函数。</p><p>​如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</p><p>​<strong>线程回收函数</strong>如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token comment">// 这是一个阻塞函数, 子线程在运行这个函数就阻塞</span><span class="token comment">// 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()</span><span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>thread: 要被回收的子线程的线程 ID</p><ul><li>retval: 二级指针，指向一级指针的地址，是一个传出参数，这个地址中存储了 pthread_exit () 传递出的数据，如果不需要这个参数，可以指定为 NULL</li></ul></li><li><p>返回值：线程回收成功返回 0，回收失败返回错误号。</p></li></ul><p>​<strong>僵尸进程（僵尸线程）</strong>：主进程没有回收子进程的资源，导致子进程即使结束后还有一些资源未被释放，如进程号等</p><p>​<strong>回收子线程数据</strong>: 在子线程退出的时候可以使用 pthread_exit() 的参数将数据传出，在回收这个子线程的时候可以通过 phread_join() 的第二个参数来接收子线程传递出的数据。</p><p>​<strong>接受子线程数据方式</strong>：</p><pre><code>    -  （1）使用子线程栈：使用子线程栈区传递数据（*虽然每个线程都有属于自己的栈区空间，但是位于同一个地址空间的多个线程是可以相互访问对方的栈空间上的数据的*）    -  （2）使用全局变量    -  （3）使用主线程栈：使用主线程栈区传递数据</code></pre><h2 id="2-4-线程分离"><a href="#2-4-线程分离" class="headerlink" title="2.4 线程分离"></a>2.4 线程分离</h2><p>​在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用 pthread_join() 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。</p><p>​调用线程分离函数后，子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。</p><p>​线程分离之后在主线程中使用 pthread_join() 就回收不到子线程资源了。</p><p>​<strong>线程分离函数</strong>如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了</span><span class="token keyword">int</span> <span class="token function">pthread_detach</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-5-其他线程函数"><a href="#2-5-其他线程函数" class="headerlink" title="2.5 其他线程函数"></a>2.5 其他线程函数</h2><h3 id="2-5-1-线程取消"><a href="#2-5-1-线程取消" class="headerlink" title="2.5.1 线程取消"></a>2.5.1 线程取消</h3><p>​线程取消也就是杀死另外一个线程。</p><p>​杀死一个线程分为两步：</p><ul><li>（1）先调用函数pthread_cancel()杀死线程B，线程不是立即死亡</li><li>（2）当线程进行一次系统调用时（切换到内核态）时，线程才会死亡，否则一直存活</li></ul><p>​<strong>线程取消函数</strong>如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 参数是子线程的线程ID</span><span class="token keyword">int</span> <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回值：函数调用成功返回 0，调用失败返回非 0 错误号。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-5-2-线程-ID-比较"><a href="#2-5-2-线程-ID-比较" class="headerlink" title="2.5.2 线程 ID 比较"></a>2.5.2 线程 ID 比较</h3><p>​此函数也就是比较是否是一个线程</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_equal</span><span class="token punctuation">(</span>pthread_t t1<span class="token punctuation">,</span> pthread_t t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>参数：t1 和 t2 是要比较的线程的线程 ID</li><li>返回值：如果两个线程 ID 相等返回非 0 值，如果不相等返回 0</li></ul><hr><hr><h1 id="3-线程同步"><a href="#3-线程同步" class="headerlink" title="3. 线程同步"></a>3. 线程同步</h1><p>线程同步以我的理解就是对多个线程的临界资源进行线性化访问</p><p>常用的线程同步方式有四种：<strong>互斥锁、读写锁、条件变量、信号量</strong></p><p><strong>死锁</strong>：两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p><h2 id="3-1-互斥锁"><a href="#3-1-互斥锁" class="headerlink" title="3.1 互斥锁"></a>3.1 互斥锁</h2><p>Linux 中互斥锁的类型为 pthread_mutex_t，定义互斥锁方法如下，变量保存了锁的<strong>状态信息</strong>和打开其的线程</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pthread_mutex_t  mutex<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>初始化锁和销毁锁</strong>函数如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 初始化互斥锁</span><span class="token comment">// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的</span><span class="token keyword">int</span> <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">,</span>           <span class="token keyword">const</span> pthread_mutexattr_t <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 释放互斥锁资源            </span><span class="token keyword">int</span> <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>参数<ul><li>mutex: 互斥锁变量的地址</li><li>attr: 互斥锁的属性，一般使用默认属性即 NULL</li></ul></li></ul><p><strong>线程加锁函数</strong>如下，其工作流程是：先判断mutex是否被锁定，如果没有则加锁成功，否则，线程被阻塞，当锁被解除锁定后，阻塞线程则被唤醒。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 修改互斥锁的状态, 将其设定为锁定状态, 这个状态被写入到参数 mutex 中</span><span class="token keyword">int</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>线程解锁函数</strong>如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>互斥锁造成死锁场景</strong>：</p><ul><li>（1）加锁之后忘记解锁</li><li>（2）重复加锁，造成死锁</li><li>（3）在程序中有多个共享资源，因此有很多把锁，随意加锁，导致相互被阻塞</li></ul><p>使用互斥锁避免死锁方法：</p><ul><li>（1）避免多次锁定，多检查</li><li>（2）对共享资源访问完毕之后，一定要解锁</li></ul><h2 id="3-2-读写锁"><a href="#3-2-读写锁" class="headerlink" title="3.2 读写锁"></a>3.2 读写锁</h2><p>相比起互斥锁不区分读写权限，读写锁对读写权限进行了细分控制。读写锁的读操作是可以并行的，但写操作必须是串行的。</p><p>使用读写锁分别对两个临界区加了读锁和写锁，访问数据时，访问写锁临界区的线程继续运行，访问读锁临界区的线程阻塞，因为<strong>写锁比读锁的优先级高</strong>。</p><p>读写锁类型为pthread_rwlock_t，定义：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pthread_rwlock_t rwlock<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>读写锁初始化函数和销毁函数</strong>如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pthread_rwlock_t rwlock<span class="token punctuation">;</span><span class="token comment">// 初始化读写锁</span><span class="token keyword">int</span> <span class="token function">pthread_rwlock_init</span><span class="token punctuation">(</span>pthread_rwlock_t <span class="token operator">*</span>restrict rwlock<span class="token punctuation">,</span>           <span class="token keyword">const</span> pthread_rwlockattr_t <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 释放读写锁占用的系统资源</span><span class="token keyword">int</span> <span class="token function">pthread_rwlock_destroy</span><span class="token punctuation">(</span>pthread_rwlock_t <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//rwlock: 读写锁的地址，传出参数</span><span class="token comment">//attr: 读写锁属性，一般使用默认属性即NULL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>读写锁加读锁</strong>，其只有在已经被加写锁时才被阻塞</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_rwlock_rdlock</span><span class="token punctuation">(</span>pthread_rwlock_t <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>读写锁加写锁</strong>，和互斥锁类似</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_rwlock_wrlock</span><span class="token punctuation">(</span>pthread_rwlock_t <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>读写锁尝试加写锁</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 这个函数可以有效的避免死锁</span><span class="token comment">// 如果加写锁失败, 不会阻塞当前线程, 直接返回错误号</span><span class="token keyword">int</span> <span class="token function">pthread_rwlock_trywrlock</span><span class="token punctuation">(</span>pthread_rwlock_t <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>读写锁解锁，读锁和解锁都用此函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_rwlock_unlock</span><span class="token punctuation">(</span>pthread_rwlock_t <span class="token operator">*</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-3-条件变量"><a href="#3-3-条件变量" class="headerlink" title="3.3 条件变量"></a>3.3 条件变量</h2><p>条件变量以我的理解是不带资源计数，只记录阻塞线程信息，调用条件变量阻塞函数则直接阻塞线程，需要自己写是否阻塞判定语句。</p><p>条件变量能直接唤醒所有阻塞线程，当唤醒所有阻塞线程时，代码中应该判定是否满足需要条件，否则继续等待（通常用while来写）</p><p><strong>条件变量定义</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pthread_cond_t cond<span class="token punctuation">;</span><span class="token comment">//条件变量阻塞的线程的线程信息会被记录到变量中</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>条件变量初始化函数和销毁函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span>      <span class="token keyword">const</span> pthread_condattr_t <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//attr: 条件变量属性，一般使用默认属性，指定为 NULL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>线程阻塞函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数在阻塞线程的时候，需要一个互斥锁参数，<strong>这个互斥锁主要功能是保护条件变量</strong>进行线程同步。该函数会对这个互斥锁做以下几件事情：</p><ul><li>（1）在调用函数之前需要锁定互斥对象，然后再调用pthread_cond_wait。</li><li>（2）pthread_cond_wait所做的第一件事就是阻塞然后对互斥锁解锁，然后等到条件变量发生</li><li>（3） pthread_cond_wait()被唤醒时解除阻塞，并且尝试获取锁（不一定拿到锁）。因此，一般在使用的时候都是在一个循环里使用pthread_cond_wait()函数，因为它在返回的时候不一定能拿到锁（这里应该唤醒全部进程时需要使用循环。这可能会发生饿死情形，当然这取决于操作系统的调度策略，是否需要循环还需要验证，）。</li></ul><p>理解：在多线程中也需要对条件变量进行互斥访问，因此在使用函数前需要对互斥锁进行加锁，而在阻塞函数开始阻塞后，则立即将互斥锁释放掉。当满足条件变量时，会立即对互斥锁进行加锁，这是因为条件变量满足后，通常会有个临界区代码需要执行，为保证访问不混乱，则需要对这段代码开始加锁。</p><p>简单来说就是pthread_cond_wait函数里在包含一个解锁函数和加锁函数，如下代码中的2345，其中23是一个原子操作。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span> <span class="token function">lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">2</span> judge condition<span class="token punctuation">;</span><span class="token number">3</span> <span class="token function">unlock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">4</span> condition is met<span class="token punctuation">;</span><span class="token number">5</span> <span class="token function">trylock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">6</span> <span class="token function">unlock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>带时间的线程阻塞函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token punctuation">&#123;</span>time_t tv_sec<span class="token punctuation">;</span>      <span class="token comment">/* Seconds */</span><span class="token keyword">long</span>   tv_nsec<span class="token punctuation">;</span>     <span class="token comment">/* Nanoseconds [0 .. 999999999] */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了</span><span class="token keyword">int</span> <span class="token function">pthread_cond_timedwait</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span>           pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>restrict abstime<span class="token punctuation">)</span><span class="token punctuation">;</span>time_t mytim <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1970.1.1 0:0:0 到当前的总秒数</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> tmsp<span class="token punctuation">;</span>tmsp<span class="token punctuation">.</span>tv_nsec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>tmsp<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">// 线程阻塞100s</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>条件变量唤醒函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span><span class="token keyword">int</span> <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span><span class="token keyword">int</span> <span class="token function">pthread_cond_broadcast</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>条件变量和信号量区别</strong></p><ul><li>（1）使用条件变量可以一次唤醒所有等待者，而信号量不能</li><li>（2）信号量始终有一个值（状态），而条件变量是没有值的，没有地方记录发送信号的次数，也没有地方记录wait返回的次数</li><li>（3）信号量的意图在于进程间同步（也可以线程同步），条件变量意图在于线程间同步。</li><li>（4）互斥量是信号量的一种特例</li></ul><h2 id="3-4-信号量"><a href="#3-4-信号量" class="headerlink" title="3.4 信号量"></a>3.4 信号量</h2><p>这里信号量的信号量和操作系统中学的信号量概念相同，用于表示资源个数且附带阻塞唤醒</p><p>信号量不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用（存疑）</p><p>信号量时互斥量的扩展</p><p><strong>信号量声明</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span>sem_t sem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>信号量初始化和销毁</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 初始化信号量/信号灯</span><span class="token keyword">int</span> <span class="token function">sem_init</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 资源释放, 线程销毁之后调用这个函数即可         </span><span class="token keyword">int</span> <span class="token function">sem_destroy</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//sem：信号量变量地址</span><span class="token comment">//pshared  0：线程同步 非 0：进程同步</span><span class="token comment">//value：初始化当前信号量拥有的资源数（>=0），如果资源数为 0，线程就会被阻塞了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>wait函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span><span class="token keyword">int</span> <span class="token function">sem_trywait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>资源数大于0时，调用此函数，资源数-1，当资源数&lt;&#x3D;0时，则被阻塞</p><p><strong>trywait函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sem_trywait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理，和sem_trywait相比差别就是，资源数&lt;&#x3D;0时，线程不是被阻塞而是返回一个错误信号</p><p><strong>wait+time函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// abs_timeout: 阻塞的时间长度, 单位是s, 是从1970.1.1开始计算的,和前面计算时间类似</span><span class="token keyword">int</span> <span class="token function">sem_timedwait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>abs_timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>post函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 调用该函数给sem中的资源数+1</span><span class="token keyword">int</span> <span class="token function">sem_post</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当有线程被阻塞时，调用此函数后有一个阻塞线程会被唤醒</p><p><strong>查询资源个数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 查看信号量 sem 中的整形数的当前值, 这个值会被写入到sval指针对应的内存中</span><span class="token comment">// sval是一个传出参数</span><span class="token keyword">int</span> <span class="token function">sem_getvalue</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>sval<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程和线程同步-C++11</title>
      <link href="/2023/02/15/c++/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5_C++11/"/>
      <url>/2023/02/15/c++/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5_C++11/</url>
      
        <content type="html"><![CDATA[<p><em><strong>C++11多线程编程</strong>。参考爱编程的大丙的C++教程， <a href="https://subingwen.cn/cplusplus/">博客地址</a>。</em></p><hr><hr><h1 id="1-C-11线程类"><a href="#1-C-11线程类" class="headerlink" title="1. C++11线程类"></a>1. C++11线程类</h1><p>C++11提供了一个线程类：std::thread，使得并发编程更加方便</p><h2 id="1-1-常用操作函数"><a href="#1-1-常用操作函数" class="headerlink" title="1.1 常用操作函数"></a>1.1 常用操作函数</h2><p><strong>构造函数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//构造函数原型：</span><span class="token comment">// ①默认构造函，构造一个线程对象，在这个线程中不执行任何处理动作</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">// ②移动构造函数，将 other 的线程所有权转移给新的 thread 对象。之后 other 不再表示执行线程。</span><span class="token function">thread</span><span class="token punctuation">(</span> thread<span class="token operator">&amp;&amp;</span> other <span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">// ③创建线程对象，并在该线程中执行函数 f 中的业务逻辑，args 是要传递给函数 f 的参数</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Function</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args <span class="token operator">></span><span class="token keyword">explicit</span> <span class="token function">thread</span><span class="token punctuation">(</span> Function<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ④使用 =delete 显示删除拷贝构造，不允许线程对象之间的拷贝</span><span class="token function">thread</span><span class="token punctuation">(</span> <span class="token keyword">const</span> thread<span class="token operator">&amp;</span> <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//使用方法</span>thread <span class="token function">t</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token string">"i love you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>func1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>获取线程号</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span>id <span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">//此函数是由类对象调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>线程回收</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用此函数的线程会被阻塞，直到子线程执行完才会被唤醒</p><p><strong>线程分离</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此函数的作用是将主线程和子线程关系分离，子线程不再属于主线程，其由系统接管，且其返回值也不能再被主线程使用。</p><p>此函数不会阻塞线程。</p><p>**joinable()**：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">//返回值为 true：主线程和子线程之间有关联（连接）关系</span><span class="token comment">//返回值为 false：主线程和子线程之间没有关联（连接）关系</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>**operator&#x3D;**：</p><pre class="line-numbers language-c+" data-language="c+"><code class="language-c+">&#x2F;&#x2F; move (1)thread&amp; operator&#x3D; (thread&amp;&amp; other) noexcept;&#x2F;&#x2F; copy [deleted] (2)thread&amp; operator&#x3D; (const other&amp;) &#x3D; delete;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果 other 是一个右值，会进行资源所有权的转移</p><p>如果 other 不是右值，禁止拷贝，该函数被显示删除（&#x3D;delete），不可用</p><p><strong>获取核心数</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token keyword">int</span> num <span class="token operator">=</span> thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>call_once()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 定义于头文件 &lt;mutex></span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Callable</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args <span class="token operator">></span><span class="token keyword">void</span> <span class="token function">call_once</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>once_flag<span class="token operator">&amp;</span> flag<span class="token punctuation">,</span> Callable<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//flag：once_flag 类型的对象，用于保证只访问一次，要保证这个对象能够被多个线程同时访问到，可设为全局变量</span><span class="token comment">//f：回调函数，可以传递一个有名函数地址，也可以指定一个匿名函数</span><span class="token comment">//args：作为实参传递给回调函数</span><span class="token function">call_once</span><span class="token punctuation">(</span>g_flag<span class="token punctuation">,</span> do_once<span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"luffy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此函数用于保证某个函数在多线程中只被调用一次。在多个调用相同函数的线程中，在此线程中某个位置可能还会调用一个函数，call_once用于保证此函数只会被调用一次，不会被其他线程再调用。</p><h2 id="1-2-this-thread命名空间"><a href="#1-2-this-thread命名空间" class="headerlink" title="1.2 this_thread命名空间"></a>1.2 this_thread命名空间</h2><p>C++11还提供了一个关于线程的命名空间 std::this_thread，其含四个操作函数。</p><p><strong>get_id()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//得到当前线程的线程 ID</span>thread<span class="token double-colon punctuation">::</span>id <span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">//此函数无需在类上操作，直接使用</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"主线程: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>sleep_for()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Rep</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Period</span><span class="token operator">></span>  <span class="token keyword">void</span> <span class="token function">sleep_for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>Rep<span class="token punctuation">,</span>Period<span class="token operator">></span><span class="token operator">&amp;</span> rel_time<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>调用此函数，线程会进入阻塞状态，阻塞特定时间，其必须指定一个阻塞时间</p><p><strong>sleep_until()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//将进程阻塞到某个时间</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Duration</span><span class="token operator">></span>  <span class="token keyword">void</span> <span class="token function">sleep_until</span> <span class="token punctuation">(</span><span class="token keyword">const</span> chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>Clock<span class="token punctuation">,</span>Duration<span class="token operator">></span><span class="token operator">&amp;</span> abs_time<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>相比sleep_for，此函数是将线程阻塞到某个时间</p><p><strong>yield()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此函数是放弃当前线程的cpu使用权，将当前线程转为<strong>就绪态</strong>，当前线程仍然有可能在下一个时间片获得cpu使用权</p><hr><hr><h1 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2. 线程同步"></a>2. 线程同步</h1><p>C++11 中提供了三种同步方式：互斥锁、条件变量、原子变量atomic</p><h1 id="2-1-互斥锁"><a href="#2-1-互斥锁" class="headerlink" title="2.1 互斥锁"></a>2.1 互斥锁</h1><p>C++11中共有四种互斥锁：</p><ul><li>（1）std::mutex：独占的互斥锁，不能递归使用</li><li>（2）std::timed_mutex：带超时的独占互斥锁，不能递归使用</li><li>（3）std::recursive_mutex：递归互斥锁，不带超时功能</li><li>（4）std::recursive_timed_mutex：带超时的递归互斥锁</li></ul><h3 id="2-1-1-std-mutex"><a href="#2-1-1-std-mutex" class="headerlink" title="2.1.1 std::mutex"></a>2.1.1 std::mutex</h3><p><strong>互斥量定义</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span>mutex g_num_mutex<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>lock()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用于mutex对象加锁，并且只能有一个线程获得锁的所有权</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>try_lock()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">try_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//尝试给mutex对象加锁，加锁失败则返回false</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>unlock()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用于给mutex对象解锁，只有加锁的线程才能解锁成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-1-2-std-lock-guard"><a href="#2-1-2-std-lock-guard" class="headerlink" title="2.1.2 std::lock_guard"></a>2.1.2 std::lock_guard</h3><p>lock_guard 是 C++11 新增的一个模板类，使用这个类，可以简化互斥锁 lock() 和 unlock() 的写法，同时也更安全（离开作用域时自动释放锁）</p><p><strong>原型</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 类的定义，定义于头文件 &lt;mutex></span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Mutex</span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">lock_guard</span><span class="token punctuation">;</span><span class="token comment">// 常用构造函数</span><span class="token keyword">explicit</span> <span class="token function">lock_guard</span><span class="token punctuation">(</span> mutex_type<span class="token operator">&amp;</span> m <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lock_guard 在使用上面提供的这个构造函数构造对象时，会自动锁定互斥量，而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，避免忘记 unlock() 操作而导致线程死锁。lock_guard 使用了 RAII 技术，就是在类构造函数中分配资源，在析构函数中释放资源，保证资源出了作用域就释放。</p><h3 id="2-1-3-std-recursive-mutex"><a href="#2-1-3-std-recursive-mutex" class="headerlink" title="2.1.3 std::recursive_mutex"></a>2.1.3 std::recursive_mutex</h3><p>递归互斥锁 std::recursive_mutex 允许同一线程多次获得互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题</p><p><strong>定义</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">recursive_mutex m_mutex<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-C++打包依赖</title>
      <link href="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96/"/>
      <url>/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E6%89%93%E5%8C%85%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<p>参考 <a href="https://blog.csdn.net/lovelyaiq/article/details/119191665">Linux 下打包可执行程序所有依赖的so 库</a></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul><li><p>通过ldd 可以查询一个执行程序的依赖的所有so库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ldd 程序<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>拷贝ldd 的查询结果到指定目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ldd 程序 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;print $3&#125;'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token parameter variable">-i</span> <span class="token function">cp</span> <span class="token parameter variable">-L</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> ./lib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置环境变量，加载动态库时会去LD_LIBRARY_PATH下加载</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:<span class="token punctuation">(</span>./lib的绝对目录<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若需永久设置，则将此命令复制到bashrc中</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码剖析笔记</title>
      <link href="/2023/02/15/c++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2023/02/15/c++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>学习侯捷《STL源码剖析》笔记</p><hr><hr><h1 id="一、基础介绍"><a href="#一、基础介绍" class="headerlink" title="一、基础介绍"></a>一、基础介绍</h1><p>STL六大部件：</p><ul><li><strong>容器 Containers</strong>：各种数据结构，如vector、list、deque、set、map，用来存放数据。从实现来看，STL容器是一种 class template。</li><li><strong>分配器 Allocator</strong>：负责空间配置与管理，从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的 class template。</li><li><strong>算法 Algorithm</strong>：各种常用算法如 sort、search、copy、erase，从实现的角度来看，STL算法是一种 function template。</li><li><strong>迭代器 Iterators</strong>：扮演容器与算法之间的胶合剂，是所谓的“泛型指针”，共有五种类型，以及其它衍生变化，从实现的角度来看，迭代器是一种将：operators*、Operator-&gt;、Operator++、Operator– 等指针相关操作予以重载的class template。所有STL容器都附带有自己专属的迭代器——只有容器设计者才知道如何遍历自己的元素，原生指针（native pointer）也是一种迭代器。</li><li><strong>适配器 Adapters</strong>：一种用来修饰容器（containers）或仿函数（functors）或迭代器（iterators）接口的东西，例如：STL提供的 queue 和 stack，虽然看似容器，其实只能算是一种容器配接器，因为 它们的底部完全借助 deque，所有操作由底层的 deque 供应。改变 functor 接口者，称为 function adapter；改变 container 接口者，称为 container adapter；改变 iterator 接口者，称为 iterator adapter。配接器的实现技术很难一言蔽之，必须逐一分析。</li><li><strong>仿函数 Functors</strong>：行为类似函数，可作为算法的某种策略（policy），从实现的角度来看，仿函数是一种重载了 operator () 的 class 或 class template。一般函数指针可视为狭义的仿函数。</li></ul><p>容器存储数据，容器通过分配器来获得内存分配，算法通过迭代器来操作容器中的数据，仿函数可以为算法提供类函数似实体，适配器可对仿函数、容器等进行包装。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221220190021504.png"></p><p>六大部件使用</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221220190856969.png"></p><h1 id="二、空间配置器"><a href="#二、空间配置器" class="headerlink" title="二、空间配置器"></a>二、空间配置器</h1><blockquote><p>为什么不说allocator是内存配置器而说它是空间配置器呢？因为，空间不一定是内存，空间也可以是磁盘或其它辅助储存媒体。</p></blockquote><h2 id="2-1-空间配置器的标准接口"><a href="#2-1-空间配置器的标准接口" class="headerlink" title="2.1 空间配置器的标准接口"></a>2.1 空间配置器的标准接口</h2><p><strong>成员类型</strong></p><table><thead><tr><th>value_type</th><th>T</th></tr></thead><tbody><tr><td>pointer (C++17 中弃用)(C++20 中移除)</td><td>T*</td></tr><tr><td>const_pointer (C++17 中弃用)(C++20 中移除)</td><td>const T*</td></tr><tr><td>reference (C++17 中弃用)(C++20 中移除)</td><td>T&amp;</td></tr><tr><td>const_reference (C++17 中弃用)(C++20 中移除)</td><td>const T&amp;</td></tr><tr><td>size_type</td><td>std::size_t</td></tr><tr><td>difference_type</td><td>std::ptrdiff_t （<strong>是两个指针相减的结果类型，是一种有符号整数类型</strong>）</td></tr><tr><td>propagate_on_container_move_assignment(C++14)</td><td>std::true_type</td></tr><tr><td>rebind (C++17 中弃用)(C++20 中移除)</td><td>template&lt; class U &gt; struct rebind { typedef allocator other; };</td></tr><tr><td>is_always_equal(C++17)</td><td>std::true_type</td></tr></tbody></table><p><strong>成员函数</strong></p><table><thead><tr><th>(构造函数)</th><th>创建新的 allocator 实例(公开成员函数)</th></tr></thead><tbody><tr><td>(析构函数)</td><td>析构 allocator 实例(公开成员函数)</td></tr><tr><td>address(C++17 中弃用)(C++20 中移除)</td><td>获得对象的地址，即使重载了 operator&amp;(公开成员函数)</td></tr><tr><td>allocate</td><td>分配未初始化的存储(公开成员函数)</td></tr><tr><td>deallocate</td><td>解分配存储(公开成员函数)</td></tr><tr><td>max_size(C++17 中弃用)(C++20 中移除)</td><td>返回最大的受支持分配大小(公开成员函数)</td></tr><tr><td>construct(C++17 中弃用)(C++20 中移除)</td><td>在分配的存储构造对象(公开成员函数)</td></tr><tr><td>destroy</td><td>(C++17 中弃用)(C++20 中移除)析构在已分配存储中的对象(公开成员函数)</td></tr></tbody></table><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//以下各种 type 的设计原由，第三章详述。</span>allocator<span class="token double-colon punctuation">::</span>value_type allocator<span class="token double-colon punctuation">::</span>pointer allocator<span class="token double-colon punctuation">::</span>const_pointer allocator<span class="token double-colon punctuation">::</span>reference allocator<span class="token double-colon punctuation">::</span>const_reference allocator<span class="token double-colon punctuation">::</span>size_type allocator<span class="token double-colon punctuation">::</span>difference_type    allocator<span class="token double-colon punctuation">::</span>rebind 一个巢状的（nested）<span class="token keyword">class</span> <span class="token keyword">template</span>。<span class="token keyword">class</span> <span class="token class-name">rebind</span><span class="token operator">&lt;</span>U<span class="token operator">></span>拥有唯一成员other，那是一个 <span class="token keyword">typedef</span>，代表allocator<span class="token operator">&lt;</span>U<span class="token operator">></span>。allocator<span class="token double-colon punctuation">::</span><span class="token function">allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> constructor。allocator<span class="token double-colon punctuation">::</span><span class="token function">allocator</span><span class="token punctuation">(</span><span class="token keyword">const</span> allocator<span class="token operator">&amp;</span><span class="token punctuation">)</span> copy constructor。<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span>allocator<span class="token double-colon punctuation">::</span><span class="token function">allocator</span><span class="token punctuation">(</span><span class="token keyword">const</span> allocator<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span><span class="token punctuation">)</span> 泛化的copy constructor。<span class="token class-name">allocator</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> constructor。pointer allocator<span class="token double-colon punctuation">::</span><span class="token function">address</span><span class="token punctuation">(</span>reference x<span class="token punctuation">)</span> <span class="token keyword">const</span> 传回某个对象的地址。算式a<span class="token punctuation">.</span><span class="token function">address</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>等同于<span class="token operator">&amp;</span>x。const_pointer allocator<span class="token double-colon punctuation">::</span><span class="token function">address</span><span class="token punctuation">(</span>const_reference x<span class="token punctuation">)</span> <span class="token keyword">const</span> 传回某个<span class="token keyword">const</span>对象的地址。算式a<span class="token punctuation">.</span><span class="token function">address</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>等同于<span class="token operator">&amp;</span>x。pointer allocator<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>size_type n<span class="token punctuation">,</span> cosnt <span class="token keyword">void</span><span class="token operator">*</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> 配置空间，足以储存n个T对象。第二自变量是个提示。实作上可能会利用它来增进区域性（locality），或完全忽略之。<span class="token keyword">void</span> allocator<span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>pointer p<span class="token punctuation">,</span> size_type n<span class="token punctuation">)</span> 归还先前配置的空间。size_type allocator<span class="token double-colon punctuation">::</span><span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> 传回可成功配置的最大量。<span class="token keyword">void</span> allocator<span class="token double-colon punctuation">::</span><span class="token function">construct</span><span class="token punctuation">(</span>pointer p<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> 等同于<span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> p<span class="token punctuation">)</span> <span class="token function">T</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>。<span class="token keyword">void</span> allocator<span class="token double-colon punctuation">::</span><span class="token function">destroy</span><span class="token punctuation">(</span>pointer p<span class="token punctuation">)</span> 等同于p<span class="token operator">-></span><span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span>。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-SGI-空间配置器"><a href="#2-2-SGI-空间配置器" class="headerlink" title="2.2 SGI 空间配置器"></a>2.2 SGI 空间配置器</h2><p>SGI STL 的分配器与众不同，也与标准规范不同，其名称是 alloc 而非 allocator，而且不接受任何参数。具体来说，想在程序中明确使用 SGI 分配器，不能写<code>std::allocator&lt;int&gt;</code>，而要写成<code>std::alloc</code></p><h3 id="2-2-1-std-alloc"><a href="#2-2-1-std-alloc" class="headerlink" title="2.2.1 std::alloc"></a>2.2.1 std::alloc</h3><p>一般而言，我们所习惯的 C++ 内存配置动作和释放动作是这样：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> Foo<span class="token operator">*</span> pf <span class="token operator">=</span> <span class="token keyword">new</span> Foo<span class="token punctuation">;</span><span class="token comment">//配置内存，然后建构对象</span><span class="token keyword">delete</span> pf<span class="token punctuation">;</span> <span class="token comment">//将对象解构，然后释放内存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>new算式内含两阶段动作：</p><ul><li><p>(1)呼叫::operator new配置内存</p></li><li><p>(2) 呼叫Foo::Foo()建构对象内容</p></li></ul></li><li><p>delete算式也内含两阶段动作：</p><ul><li><p>(1)呼 叫Foo::~Foo()将对象解构</p></li><li><p>(2)呼叫::operator delete释放内存</p></li></ul></li></ul><p>为了精密分工，STL allocator决定将这两阶段动作区分开来：</p><ul><li>内存配置动作由alloc:allocate()负责</li><li>内存释放动作由alloc::deallocate()负责</li><li>对象建构动作由::construct()负责</li><li>对象解构动作由::destroy()负责</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103153350320.png"></p><h3 id="2-2-2-construct-和destroy"><a href="#2-2-2-construct-和destroy" class="headerlink" title="2.2.2 construct()和destroy()"></a>2.2.2 construct()和destroy()</h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103154204124.png"></p><p>construct()定义</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">></span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">construct</span><span class="token punctuation">(</span>T1<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">const</span> T2<span class="token operator">&amp;</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token function">T1</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//placement new;唤起 T1::T1(value); </span>    <span class="token comment">//placement new 是使用已有的内存空间进行初始化，这里是使用p指向的内存进行T1对象的初始化</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>destroy()定义</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//以下是 destroy()第一版ᴀ，接受一个指标。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span>T<span class="token operator">*</span> pointer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     pointer<span class="token operator">-></span><span class="token operator">~</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//唤起 dtor ~T() </span><span class="token punctuation">&#125;</span> <span class="token comment">//以下是 destroy()第二版ᴀ，接受两个迭代器。此函式设法找出元素的数值型别，</span><span class="token comment">//进而利用 __type_traits&lt;>求取最适当措施。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">></span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">__destroy</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> <span class="token function">value_type</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//判断元素的数值型别（value type）是否有trivial destructor </span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__destroy</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">__type_traits</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>has_trivial_destructor trivial_destructor<span class="token punctuation">;</span> <span class="token function">__destroy_aux</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> <span class="token function">trivial_destructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//如果元素的数值型别（value type）有non-trivial destructor…</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">></span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__destroy_aux</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span> __false_type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> first <span class="token operator">&lt;</span> last<span class="token punctuation">;</span> <span class="token operator">++</span>first<span class="token punctuation">)</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token operator">*</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//如果元素的数值型别（value type）有trivial destructor…</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">></span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__destroy_aux</span><span class="token punctuation">(</span>ForwardIterator<span class="token punctuation">,</span> ForwardIterator<span class="token punctuation">,</span> __true_type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//以下是 destroy()第二版ᴀ针对迭代器为 char*和 wchar_t*的特化版</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token keyword">wchar_t</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-3-空间的配置与释放"><a href="#2-2-3-空间的配置与释放" class="headerlink" title="2.2.3 空间的配置与释放"></a>2.2.3 空间的配置与释放</h3><p>设计思路如下：</p><ul><li>向 system heap要求空间</li><li>考虑多绪（multi-threads）状态</li><li>考虑内存不足时的应变措施</li><li>考虑过多「小型区块」可能造成的内存破碎（fragment）问题</li></ul><blockquote><p>C++的内存配置动作是::operator new() ， 内存释放动作是::operator delete()。这两个全域函式相当于 C 的 malloc()和 free() 函式。SGI 正是以malloc() 和free() 完成内存的配置与释放。</p></blockquote><p>考虑到小型区块可能造成的内存破碎问题，SGI设计了双层级配置器,第一级配置器直接使用<code>malloc()</code>和<code>free()</code>；第二级配置器则视情况采用不同的策略。当配置区块超过128byte时，视之为足够大，使用第一级配置器，当小于128byte时，视之为过小，采用复杂的memory pool整理方式。而不再求助于第一级适配器。使用哪一级适配器取决于<code>__USE_MALLOC</code>是否被定义。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103155652288.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103155711848.png"></p><h3 id="2-2-4-第一级配置器-malloc-alloc-template"><a href="#2-2-4-第一级配置器-malloc-alloc-template" class="headerlink" title="2.2.4 第一级配置器 __malloc_alloc_template"></a>2.2.4 第一级配置器 __malloc_alloc_template</h3><p>第一级配置器以malloc(), free(), realloc()等 C函式执行实际的内存配置、释放、重配置动作，并实作出类似 C++ new-handler的机制。它不能直接运用 C++ new-handler机制，因为并非使用::operatornew来配置记忆体。</p><blockquote><p>C++ new handler 机制是，你可以要求系统在内存配置需求无法被满足时，唤起一个你所指定的函式。换句话说一旦::operator new无法达成任务，在丢出<em>std::bad_alloc</em>异常状态之前，会先呼叫由客端指定的处理例程。</p></blockquote><p>注意，SGI 第一级配置器的allocate() 和realloc()都是在呼叫malloc() 和realloc()不成功后，改呼叫oom_malloc()和oom_realloc()。后两者都有内循环，不断呼叫「内存不足处理例程」，期望在某次呼叫之后，获得足够的内存而圆满达成任务。但如果「内存不足处理例程」并᳾被客端设定，oom_malloc()和oom_realloc() 便老实不客气地呼叫__THROW_BAD_ALLOC，丢出<em>bad_alloc</em>异常讯息，或利用exit(1)硬生生中止程序。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//一级适配器</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">__malloc_alloc_template</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment">//函数指针，所代表的函数将用来处理内存不足的情况</span>    <span class="token comment">//oom: out of memory</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">oom_malloc</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">oom_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>__malloc_alloc_oom_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">allocate</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//一级配置器必须使用malloc()</span>        <span class="token keyword">void</span> <span class="token operator">*</span>result<span class="token operator">=</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//当无法满足需求时，改用oom_malloc()</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">==</span>result<span class="token punctuation">)</span> result<span class="token operator">=</span><span class="token function">oom_malloc</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>size_t<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//第一级配置器直接使用free()</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//输入旧size和新size</span>    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>size_t<span class="token punctuation">,</span>size_t new_sz<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">void</span><span class="token operator">*</span> result<span class="token operator">=</span><span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>new_sz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">==</span>result<span class="token punctuation">)</span> result<span class="token operator">=</span><span class="token function">oom_realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>new_sz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">//指定自己的out-of-memory handler</span>        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token function">set_malloc_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//获取函数指针</span>        <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> old<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span>__malloc_alloc_oom_handler<span class="token punctuation">;</span>        __malloc_alloc_oom_handler<span class="token operator">=</span>f<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">(</span>old<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//下面是用户提供的malloc_alloc函数</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>__malloc_alloc_template<span class="token operator">&lt;</span>inst<span class="token operator">></span><span class="token double-colon punctuation">::</span>__malloc_alloc_oom_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token class-name">__malloc_alloc_template</span><span class="token operator">&lt;</span>inst<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">oom_malloc</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//获取内存分配句柄函数指针</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>result<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//指针指向分配函数</span>        my_malloc_handler<span class="token operator">=</span>__malloc_alloc_oom_handler<span class="token punctuation">;</span>        <span class="token comment">//分配失败抛出异常</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">==</span>my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>__THROW_BAD_ALLOC<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token comment">//调用处理例程，企图释放内存</span>        <span class="token punctuation">(</span><span class="token operator">*</span>my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//再次尝试分配内存</span>        result<span class="token operator">=</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//内存调用分配不成功时，进行二次调用</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token class-name">__malloc_alloc_template</span><span class="token operator">&lt;</span>inst<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">oom_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>size_t n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>result<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        my_malloc_handler<span class="token operator">=</span>__malloc_alloc_oom_handler<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">==</span>my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>__THROW_BAD_ALLOC<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token comment">//尝试调用处理例程</span>        <span class="token punctuation">(</span><span class="token operator">*</span>my_malloc_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//尝试分配内存</span>        result<span class="token operator">=</span><span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//注意,以下参数直接将inst指定为0</span><span class="token keyword">typedef</span> __malloc_alloc_template<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span> malloc_alloc<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-5-第二级配置器-default-alloc-template"><a href="#2-2-5-第二级配置器-default-alloc-template" class="headerlink" title="2.2.5 第二级配置器__default_alloc_template"></a>2.2.5 第二级配置器__default_alloc_template</h3><p>因为对于操作系统而言，需要块分配一定的内存来存储块的位置信息，因此当内存过小时，单独开辟块反而是得不偿失的。因此在此时，C++使用内存池机制来对数据进行管理。由配置器负责内存的管理和回收，通常SGI配置其会将小额区块的内存需求量上调至8的倍数(例如30B-32B),并唯独16个free-list,各自管理大小分别为8,16,24,32,40,48,56,64…128 bytes的小额区块。结构如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">union</span> obj<span class="token punctuation">&#123;</span>    <span class="token keyword">union</span> obj<span class="token operator">*</span> free_list_link<span class="token punctuation">;</span>    <span class="token keyword">char</span> client_data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于使用了union，节省了额外的指针内存消耗，free-list连接如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103164634110.png"></p><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span> __ALIGN <span class="token operator">=</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                           <span class="token comment">// 小型区块的上调边界</span><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span> __MAX_BYTES <span class="token operator">=</span> <span class="token number">128</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                     <span class="token comment">// 小型区块的上限</span><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span> __NFREELISTS <span class="token operator">=</span> __MAX_BYTES <span class="token operator">/</span> __ALIGN <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// free-lists个数</span><span class="token comment">// 以下是第二级配置器。</span><span class="token comment">// 注意，无「template 型别参数」，且第二参数完全没派上用场。</span><span class="token comment">// 第一参数用于多绪环境下。ᴀ书不讨论多绪环境。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> threads<span class="token punctuation">,</span> <span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">__default_alloc_template</span> <span class="token punctuation">&#123;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token comment">// ROUND_UP() 将 bytes上调至 8的倍数。</span>  <span class="token keyword">static</span> size_t <span class="token function">ROUND_UP</span><span class="token punctuation">(</span>size_t bytes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span> <span class="token operator">+</span> __ALIGN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>__ALIGN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token number">61</span> unionobj <span class="token punctuation">&#123;</span>  <span class="token comment">// free-lists 的节点构造</span>    <span class="token keyword">union</span> obj <span class="token operator">*</span>free_list_link<span class="token punctuation">;</span>    <span class="token keyword">char</span> client_data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* The client sees this. */</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token comment">// 16 个 free-lists</span>  <span class="token keyword">static</span> obj <span class="token operator">*</span>volatilefree_list<span class="token punctuation">[</span>__NFREELISTS<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 以下函式根据区块大小，决定使用第 n号 free-list。n 从 1 起算。</span>  <span class="token keyword">static</span> size_t <span class="token function">FREELIST_INDEX</span><span class="token punctuation">(</span>size_t bytes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span> <span class="token operator">+</span> __ALIGN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> __ALIGN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 传回一个大小为 n的对象，并可能加入大小为 n的其它区块到free list.</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">refill</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 配置一大块空间，可容纳 nobjs 个大小为 "size" 的区块。</span>  <span class="token comment">// 如果配置 nobjs个区块有所不便，nobjs可能会降低。</span>  <span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">chunk_alloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>nobjs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Chunk allocation state.</span>  <span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span>start_free<span class="token punctuation">;</span>  <span class="token comment">// 记忆池起始位置。只在 chunk_alloc()中变化</span>  <span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span>end_free<span class="token punctuation">;</span>  <span class="token comment">// 记忆池结束位置。只在 chunk_alloc()中变化</span>  <span class="token keyword">static</span> size_t heap_size<span class="token punctuation">;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">allocate</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 详述于后 */</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 详述于后 */</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> size_t old_sz<span class="token punctuation">,</span> size_t new_sz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 以下是 static data member 的定义与初值设定</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> threads<span class="token punctuation">,</span> <span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">char</span> <span class="token operator">*</span>__default_alloc_template<span class="token operator">&lt;</span>threads<span class="token punctuation">,</span> inst<span class="token operator">></span><span class="token double-colon punctuation">::</span>start_free <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> threads<span class="token punctuation">,</span> <span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">char</span> <span class="token operator">*</span>__default_alloc_template<span class="token operator">&lt;</span>threads<span class="token punctuation">,</span> inst<span class="token operator">></span><span class="token double-colon punctuation">::</span>end_free <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> threads<span class="token punctuation">,</span> <span class="token keyword">int</span> inst<span class="token operator">></span>size_t__default_alloc_template<span class="token operator">&lt;</span>threads<span class="token punctuation">,</span> inst<span class="token operator">></span><span class="token double-colon punctuation">::</span>heap_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> threads<span class="token punctuation">,</span> <span class="token keyword">int</span> inst<span class="token operator">></span>__default_alloc_template<span class="token operator">&lt;</span>threads<span class="token punctuation">,</span> inst<span class="token operator">></span><span class="token double-colon punctuation">::</span>obj <span class="token operator">*</span><span class="token keyword">volatile</span> __default_alloc_template<span class="token operator">&lt;</span>    threads<span class="token punctuation">,</span> inst<span class="token operator">></span><span class="token double-colon punctuation">::</span>free_list<span class="token punctuation">[</span>__NFREELISTS<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-6-空间配置函数-allocate"><a href="#2-2-6-空间配置函数-allocate" class="headerlink" title="2.2.6 空间配置函数 allocate()"></a>2.2.6 空间配置函数 allocate()</h3><p>__default_alloc_template拥有配置器的标准接口函数allocate()。此函数首先判断区块大小，大于128bytes就调用第一级配置器，小于128bytes就检查对应的free list。如果有可用区块就直接拿来用，没有就将区块的大小上调至8倍数边界，然后调用<code>refill()</code>准备为<code>free list</code>重新填充空间。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// n must be > 0</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">allocate</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  obj <span class="token operator">*</span><span class="token keyword">volatile</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">;</span>  obj <span class="token operator">*</span>result<span class="token punctuation">;</span>  <span class="token comment">// 大于 128 就呼叫第一级配置器</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>__MAX_BYTES<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>malloc_alloc<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 寻找 16 个 free lists 中适当的一个</span>  my_free_list <span class="token operator">=</span> free_list <span class="token operator">+</span> <span class="token function">FREELIST_INDEX</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  result <span class="token operator">=</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 没找到可用的 free list，准备重新填充 free list</span>    <span class="token number">63</span> <span class="token keyword">void</span> <span class="token operator">*</span>r <span class="token operator">=</span> <span class="token function">refill</span><span class="token punctuation">(</span><span class="token function">ROUND_UP</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> r<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 调整 free list</span>  <span class="token comment">// 下节详述</span>  <span class="token operator">*</span>my_free_list <span class="token operator">=</span> result<span class="token operator">-></span>free_list_link<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103170646960.png"></p><h3 id="2-2-7-空间释放函数deallocate"><a href="#2-2-7-空间释放函数deallocate" class="headerlink" title="2.2.7 空间释放函数deallocate()"></a>2.2.7 空间释放函数deallocate()</h3><p>判断区块大小，大于 128 bytes 就呼叫第一级配置器，小于 128 bytes 就找出对应的 <em>free list</em>，将区块回收。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// p 不可以是 0</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  obj <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span>obj <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>  obj <span class="token operator">*</span><span class="token keyword">volatile</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">;</span>  <span class="token comment">// 大于 128 就呼叫第一级配置器</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>__MAX_BYTES<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    malloc_alloc<span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 寻找对应的 free list</span>  my_free_list <span class="token operator">=</span> free_list <span class="token operator">+</span> <span class="token function">FREELIST_INDEX</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调整 free list，回收区块</span>  q<span class="token operator">-></span>free_list_link <span class="token operator">=</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">;</span>  <span class="token operator">*</span>my_free_list <span class="token operator">=</span> q<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103171300725.png"></p><h3 id="2-2-8-重新充填-free-lists"><a href="#2-2-8-重新充填-free-lists" class="headerlink" title="2.2.8 重新充填 free lists"></a>2.2.8 重新充填 <em>free list</em>s</h3><p>当内存池中没有可用区块的时候，就调用<code>refill()</code>准备为free-list重新分配空间。新的空间将取自内存池，缺省取得20个新节点(新区块)，但万一内存池空间不足，获得的节点数(区块数)可能小于20。</p><h3 id="2-2-9-内存池"><a href="#2-2-9-内存池" class="headerlink" title="2.2.9 内存池"></a>2.2.9 内存池</h3><p>使用chunk_alloc()从内存池中取出空间给free list使用。</p><p>以end_free - start_free 来判断内存池的水量。如果水量充足，就直接拨出 20 个区块传回给 <em>free list</em>。如果水量不足以提供 20 个区块，但还足够供应一个以上的区块，就拨出这不足20个区块的空间出去。如果内存池连一个区块空间都无法供应，此时便需利用malloc() 从 heap 中配置内存，为内存池注入活水源头以应付需求。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 假设 size 已经适当上调至 8的倍数。</span><span class="token comment">// 注意参数 nobjs是pass by reference。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> threads<span class="token punctuation">,</span> <span class="token keyword">int</span> inst<span class="token operator">></span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token class-name">__default_alloc_template</span><span class="token operator">&lt;</span>threads<span class="token punctuation">,</span> inst<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">chunk_alloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span>                                                           <span class="token keyword">int</span> <span class="token operator">&amp;</span>nobjs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>result<span class="token punctuation">;</span>  size_t total_bytes <span class="token operator">=</span> size <span class="token operator">*</span> nobjs<span class="token punctuation">;</span>  size_t bytes_left <span class="token operator">=</span> end_free <span class="token operator">-</span> start_free<span class="token punctuation">;</span>  <span class="token comment">// 记忆池剩余空间</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes_left <span class="token operator">>=</span> total_bytes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 记忆池剩余空间完全满足需求量。</span>    result <span class="token operator">=</span> start_free<span class="token punctuation">;</span>    start_free <span class="token operator">+=</span> total_bytes<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes_left <span class="token operator">>=</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token number">67</span>        <span class="token comment">// 记忆池剩余空间不能完全满足需求量，但足够供应一个（含）以上的区块。</span>        nobjs <span class="token operator">=</span> bytes_left <span class="token operator">/</span> size<span class="token punctuation">;</span>    total_bytes <span class="token operator">=</span> size <span class="token operator">*</span> nobjs<span class="token punctuation">;</span>    result <span class="token operator">=</span> start_free<span class="token punctuation">;</span>    start_free <span class="token operator">+=</span> total_bytes<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 记忆池剩余空间连一个区块的大小都无法提供。</span>    size_t bytes_to_get <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> total_bytes <span class="token operator">+</span> <span class="token function">ROUND_UP</span><span class="token punctuation">(</span>heap_size <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 以下试着让记忆池中的残余零头还有利用价值。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes_left <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 记忆池内还有一些零头，先配给适当的 free list。</span>      <span class="token comment">// 首先寻找适当的 free list。</span>      obj <span class="token operator">*</span><span class="token keyword">volatile</span> <span class="token operator">*</span>my_free_list <span class="token operator">=</span> free_list <span class="token operator">+</span> <span class="token function">FREELIST_INDEX</span><span class="token punctuation">(</span>bytes_left<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 调整 free list，将记忆池中的残余空间编入。</span>      <span class="token punctuation">(</span><span class="token punctuation">(</span>obj <span class="token operator">*</span><span class="token punctuation">)</span>start_free<span class="token punctuation">)</span><span class="token operator">-></span>free_list_link <span class="token operator">=</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">;</span>      <span class="token operator">*</span>my_free_list <span class="token operator">=</span> <span class="token punctuation">(</span>obj <span class="token operator">*</span><span class="token punctuation">)</span>start_free<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 配置 heap 空间，用来挹注记忆池。</span>    start_free <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>bytes_to_get<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> start_free<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// heap 空间不足，malloc() 失败。</span>      <span class="token keyword">int</span> i<span class="token punctuation">;</span>      obj <span class="token operator">*</span><span class="token keyword">volatile</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>      <span class="token comment">// 试着检视我们手上拥有的东西。这不会造成伤害。我们不打算尝试配置</span>      <span class="token comment">// 较小的区块，因为那在多行程（multi-process）机器上容易导致灾难</span>      <span class="token comment">// 以下搜寻适当的 free list，</span>      <span class="token comment">// 所谓适当是指「尚有᳾用区块，且区块够大」之 free</span>      <span class="token comment">// list。</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> size<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> __MAX_BYTES<span class="token punctuation">;</span> i <span class="token operator">+=</span> __ALIGN<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        my_free_list <span class="token operator">=</span> free_list <span class="token operator">+</span> <span class="token function">FREELIST_INDEX</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token operator">*</span>my_free_list<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// free list 内尚有᳾用区块。</span>          <span class="token comment">// 调整 free list以释出᳾用区块</span>          <span class="token operator">*</span>my_free_list <span class="token operator">=</span> p<span class="token operator">-></span>free_list_link<span class="token punctuation">;</span>          start_free <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>          end_free <span class="token operator">=</span> start_free <span class="token operator">+</span> i<span class="token punctuation">;</span>          <span class="token comment">// 递归呼叫自己，为了修正 nobjs。</span>          <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">chunk_alloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> nobjs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 注意，任何残余零头终将被编入适当的 free-list中备用。</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      end_free <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 如果出现意外（山穷水尽，到处都没内存可用了）</span>      <span class="token comment">// 呼叫第一级配置器，看看out-of-memory机制能否尽点力</span>      start_free <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>malloc_alloc<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>bytes_to_get<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 这会导致掷出异常（exception），或内存不足的情况获得改善。</span>    <span class="token punctuation">&#125;</span>    heap_size <span class="token operator">+=</span> bytes_to_get<span class="token punctuation">;</span>    end_free <span class="token operator">=</span> start_free <span class="token operator">+</span> bytes_to_get<span class="token punctuation">;</span>    <span class="token comment">// 递归呼叫自己，为了修正 nobjs。</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">chunk_alloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> nobjs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103194425350.png"></p><h2 id="2-3-内存基本处理工具"><a href="#2-3-内存基本处理工具" class="headerlink" title="2.3 内存基本处理工具"></a>2.3 内存基本处理工具</h2><p>STL中定义有5个全局函数，作用于未初始化空间之上。分别是<code>construct()</code>、<code>destroy()</code>、uninitailized_copy()、uninitailized_fill()、uninitialized_fill_n()，后三个分别对应于高层次函数copy()、fill()、fill_n()。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103200321466.png"></p><h3 id="2-3-1-uninitialized-copy"><a href="#2-3-1-uninitialized-copy" class="headerlink" title="2.3.1 uninitialized_copy"></a>2.3.1 uninitialized_copy</h3><p>uninitialized_copy() 能够将内存的配置与对象的建构行为分离开来。如果做为输出目的地的[result, result+(last-first))范围内的每一个迭 代 器 都 指 向未初 始 化 区 域 ， 则uninitialized_copy()会 使 用copy constructor，为身为输入来源之[first,last)范围内的每一个对象产生一份复制品，放进输出范围中。</p><p>具有 “<em>commit</em> or <em>rollback</em>“语意</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token operator">></span>ForwardIterator <span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span>                                   ForwardIterator result<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">__uninitialized_copy</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> result<span class="token punctuation">,</span><span class="token function">value_type</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//迭代器first指向输入端的起始位置</span><span class="token comment">//迭代器last指向输入端的结束位置（前闭后开区间）</span><span class="token comment">//迭代器result指向输出端（欲初始化空间）的起始处</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>uninitialized_copy首先萃取出迭代器 result 的 <em>value type</em>，然后判断该型别是否为 POD型别，如果是POD类型则调用STL的copy算法进行复制，否则使用construct逐个复制。</p><h3 id="2-3-2-uninitialized-fill"><a href="#2-3-2-uninitialized-fill" class="headerlink" title="2.3.2 uninitialized_fill"></a>2.3.2 uninitialized_fill</h3><p>uninitialized_fill() 也能够将内存配置与对象的建构行为分离开来。如果[first,last)范围内的每个迭代器都指向未初始化的内存，那么uninitialized_fill()会在该范围内产生x（上式第三参数）的复制品。</p><p>也具有 “<em>commit</em> or <em>rollback</em>“语意</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">uninitialized_fill</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> ForwardIterator last<span class="token punctuation">,</span>                        <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">__uninitialized_fill</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token function">value_type</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//迭代器first指向输出端（欲初始化空间）的起始处</span><span class="token comment">//迭代器last指向输出端（欲初始化空间）的结束处（前闭后开区间）</span><span class="token comment">//x表示初值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>uninitialized_fill首先萃取出迭代器 result 的 <em>value type</em>，然后判断该型别是否为 POD型别，如果是POD类型则调用STL的fill算法进行复制，否则使用construct逐个复制。</p><h3 id="2-3-3-uninitialized-fill-n"><a href="#2-3-3-uninitialized-fill-n" class="headerlink" title="2.3.3 uninitialized_fill_n"></a>2.3.3 uninitialized_fill_n</h3><p>uninitialized_fill_n()能够将内存配置与对象建构行为分离开来，会为指定范围内的所有元素设定相同的初值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Size</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>ForwardIterator <span class="token function">uninitialized_fill_n</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> Size n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">__uninitialized_fill_n</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> n<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token function">value_type</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//1.迭代器first指向欲初始化空间的起始处</span><span class="token comment">//2.n表示欲初始化空间的大小</span><span class="token comment">//3.x表示初值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>POD</strong>意指 <strong>Plain Old Data</strong>，也就是纯量型别（scalar types）或传统的 C struct型别。POD型别必然拥有 <em>trivial</em> ctor&#x2F;dtor&#x2F;copy&#x2F;assignment函式，因此，我们可以对POD型别采取最有效率的初值填写手法，而对non-POD 型别采取构造函数构造</p></blockquote><p>uninitialized_fill_n首先萃取出迭代器 first 的 value type（详见第三章），然后判断该型别是否为 POD型别，然后对是否未POD类型进行各自处理。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Size</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token operator">></span><span class="token keyword">inline</span> ForwardIterator <span class="token function">__uninitialized_fill_n</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> Size n<span class="token punctuation">,</span>                                              <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> T1<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 以下 __type_traits&lt;> 技法，详见 3.7 节</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">__type_traits</span><span class="token operator">&lt;</span>T1<span class="token operator">></span><span class="token double-colon punctuation">::</span>is_POD_typeis_POD<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">__uninitialized_fill_n_aux</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> n<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token function">is_POD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 如果 copy construction 等同于 assignment, 而且</span><span class="token comment">//  destructor 是 trivial，以下就有效。</span><span class="token comment">// 如果是 POD型别，执行流程就会转进到以下函式。这是藉由 function template</span><span class="token comment">// 的自变量推导机制而得。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Size</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">inline</span> ForwardIterator <span class="token function">__uninitialized_fill_n_aux</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> Size n<span class="token punctuation">,</span>                                                  <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> __true_type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">fill_n</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> n<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 交由高阶函式执行。见 6.4.2节。</span><span class="token punctuation">&#125;</span><span class="token comment">// 如果不是 POD 型别，执行流程就会转进到以下函式。这是藉由 function template</span><span class="token comment">// 的自变量推导机制而得。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwardIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Size</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>ForwardIterator <span class="token function">__uninitialized_fill_n_aux</span><span class="token punctuation">(</span>ForwardIterator first<span class="token punctuation">,</span> Size n<span class="token punctuation">,</span>                                           <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> __false_type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  ForwardIterator cur <span class="token operator">=</span> first<span class="token punctuation">;</span>  <span class="token comment">// 为求阅读顺畅，以下将原ᴀ该有的异常处理（exception handling）省略。</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>n<span class="token punctuation">,</span> <span class="token operator">++</span>cur<span class="token punctuation">)</span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token operator">*</span>cur<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、迭代器和traits"><a href="#三、迭代器和traits" class="headerlink" title="三、迭代器和traits"></a>三、迭代器和traits</h1><blockquote><p>STL 的中心思想在于，将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起</p></blockquote><h2 id="3-1-迭代器是一种-smart-pointer"><a href="#3-1-迭代器是一种-smart-pointer" class="headerlink" title="3.1 迭代器是一种 smart pointer"></a>3.1 迭代器是一种 smart pointer</h2><p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见也最重要的便是内容提领（<em>dereference</em>）和成员取用（member access），因此迭代器最重要的编程工作就是对 operator*和operator-&gt;进行重载。</p><p>一个简单迭代器如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Item</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">LisIter</span> <span class="token punctuation">&#123;</span>     Item<span class="token operator">*</span> ptr<span class="token punctuation">;</span>     <span class="token function">ListIter</span><span class="token punctuation">(</span>Item<span class="token operator">*</span> p<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">ptr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>     <span class="token comment">//关键操作</span>     Item<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>     Item<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> ptr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>     ListIter<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        ptr<span class="token operator">=</span>ptr<span class="token operator">-></span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>      ListIter <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        ListIter tmp<span class="token operator">=</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        retrun tmp<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> ListIter<span class="token operator">&amp;</span> i<span class="token punctuation">)</span> <span class="token keyword">const</span>     <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> ptr<span class="token operator">!=</span>i<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-迭代器相应型别"><a href="#3-2-迭代器相应型别" class="headerlink" title="3.2 迭代器相应型别"></a>3.2 迭代器相应型别</h2><blockquote><p>算法之中运用迭代器时，很可能会用到其相应型别，即便动用 RTTI 性质中的typeid()，获得的也只是型别名称，不能拿来做变量宣告之用。</p></blockquote><p>解决办法是：利用 function template 的自变量推导机制</p><p>例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">func_impl</span><span class="token punctuation">(</span>I iter<span class="token punctuation">,</span> T t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  T tmp<span class="token punctuation">;</span>  <span class="token comment">// 这里解决了问题。T就是迭代器所指之物的型别，ᴀ例为 int</span>  <span class="token comment">// ... 这里做原ᴀ func()应该做的全部工作</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>I iter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">func_impl</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> <span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// func 的工作全部移往 func_impl</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-Traits-编程技法"><a href="#3-3-Traits-编程技法" class="headerlink" title="3.3 Traits 编程技法"></a>3.3 Traits 编程技法</h2><blockquote><p>上述的自变量型别推导技巧虽然可用于 <em>value type</em>，却非全面可用：万一<em>value type</em>必须用于函式的传回值，就束手无策了，毕竟函式的「template 自变量推导机制」推而导之的只是自变量，无法推导函式的回返值型别。</p></blockquote><p>因此直接定义类型可以很好解决这个问题</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">MyIter</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span>  <span class="token comment">// 巢状型别宣告（nested type）</span>  T<span class="token operator">*</span> ptr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是并不是所有迭代器都是 class type，如原生指标就不是，无法对其定义类型（如int 不是类），使用偏特化来解决这个问题。</p><blockquote><p><strong>Partial Specialization（偏特化）</strong></p><p>如果 class template拥有一个以上的 template 参数，我们可以针对其中某个（或数个，但非全部）template参数进行特化工作。也就是为模板提供一个特别版本。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 这个泛化版ᴀ允许（接受）T为任何型别</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 这个特化版ᴀ仅适用于「T为原生指标」的情况</span><span class="token comment">// 「T为原生指标」便是「T 为任何型别」的一个更进一步的条件限制</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><strong>trait定义</strong></p><pre class="line-numbers language-none"><code class="language-none">template &lt;class I&gt;struct iterator_traits &#123;  &#x2F;&#x2F; traits 意为「特性」  typedef typename I::value_type value_type;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>traits意义在于，如果I定义有自己的value type,那么通过这个traits的作用，萃取出来的value_type就是I::value_type。trait这样设计在于可以拥有特例化版本，<strong>如为基本类型设计特化版本及为常量对象或指针设计非常量的版本</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103205014421.png"></p><p>最常用到的迭代器相应型别有五种：<em>value type</em>, <em>difference type</em>, <em>pointer</em>, <em>reference</em>,<em>iterator catagoly</em></p><ul><li><em>value type</em>，是指迭代器所指对象的型别</li><li><em>difference type</em> ，用来表示两个迭代器之间的距离，也因此，它可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。</li><li><em>reference type</em>，即所指对象的引用类型</li><li><em>pointer type</em>，即所指对象的指针类型</li><li><em>iterator_category</em>，主要用于大规模的迭代器，当迭代器是继承类型时，基类定义的指针无法知道到底是子类或父类，因此定义此类型进行说明，STL中针对子类或父类的迭代器具有不同优化</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">I</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">iterator_traits</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>iterator_category iterator_category<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>value_type value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>difference_type difference_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>pointer pointer<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">I</span><span class="token double-colon punctuation">::</span>reference reference<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>iterator_traits必须针对传入之型别为 pointer 及 pointer-to-const者，设计特化版本</p></blockquote><p>根据移动特性与施行操作，迭代器被分为5类：</p><ul><li>input iterator:这种迭代器所指的对象，不允许外界改变。只读(read only)</li><li>output Iterator:唯写(write only)</li><li>Forward Iterator:允许“写入型”算法(如replace())在此种迭代器所形成的区间上进行读写操作。</li><li>Bidirectional Iterator:可以双向移动。某些算法需要逆向走访某个迭代器区间(例如逆向拷贝某范围内的元素)，可以使用Bidirectional Iterators。</li><li>Random Access Iterator: 前四中迭代器都只提供一部分指针算术能力，第五种则涵盖所有指针和算术能力，包括p+n,p-n,p[n],p1-p2,p1小于p2。</li></ul><p>以 class 来定义迭代器的各种分类标签，不唯可以促成多载化机制的成功运作（使编译器得以正确执行多载程序，且透过继承，我们可以不必再写「单纯只做转呼叫」的函式）</p><h2 id="3-4-std-iterator-的保证"><a href="#3-4-std-iterator-的保证" class="headerlink" title="3.4 std::iterator 的保证"></a>3.4 std::iterator 的保证</h2><p>STL提供了一个iterator class 。每个新设计的迭代器都继承自它，可以保证STL所需之规范</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Category</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span> <span class="token operator">=</span> ptrdiff_t<span class="token punctuation">,</span>          <span class="token keyword">class</span> <span class="token class-name">Pointer</span> <span class="token operator">=</span> T<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Reference</span> <span class="token operator">=</span> T<span class="token operator">&amp;</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">iterator</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> Category iterator_category<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> Distance difference_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> Pointer pointer<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> Reference reference<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 使用</span>std<span class="token double-colon punctuation">::</span>iterator<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>forward_iterator_tag<span class="token punctuation">,</span> Item<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5-type-traits"><a href="#3-5-type-traits" class="headerlink" title="3.5  __type_traits"></a>3.5  __type_traits</h2><p>iterator_traits负责萃取迭代器的特性，__type_traits则负责萃取型别(type)的特性。它提供了一种机制，允许针对不同的型别属性，在编译时期完成函数派送决定。</p><blockquote><p>例如萃取此类型是否具备non-trivial defalt ctor ？是否具备 non-trivial copy ctor？是否具备 non-trivial assignment operator？是否具备 non-trivial dtor？</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">type</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">__type_traits</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> __true_type this_dummy_member_must_be_first<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __false_type has_trivial_default_constructor<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __false_type has_trivial_copy_constructor<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __false_type has_trivial_assignment_operator<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __false_type has_trivial_destructor<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __false_type is_POD_type<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SGI 把所有巢状型别都定义为false _type，然后然后（稍后可见）再针对每一个纯量型别（scalar types）设计适当的type_traits特化版</p><h1 id="四、序列式容器"><a href="#四、序列式容器" class="headerlink" title="四、序列式容器"></a>四、序列式容器</h1><blockquote><p>所谓序列式容器，其中的元素都可序（<em>ordered</em>），但᳾排序（<em>sorted</em>）。C++ 语言本身提供了一个序列式容器array，STL另外再提供vector,list,deque, stack,queue,priority-queue等等序列式容器。其中stack和queue由于只是将deque改头换面而成，技术上被归类为一种配接器（adapter），</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103211215851.png"></p><h2 id="4-1-vector"><a href="#4-1-vector" class="headerlink" title="4.1 vector"></a>4.1 vector</h2><blockquote><p>vector的数据安排以及操作方式，与array非常像似。两者的唯一差别在于空间的运用弹性。array是静态空间，一旦配置了就不能改变，而vector会自行扩充空间以容纳新元素。</p></blockquote><p><strong>vector迭代器</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> classAlloc <span class="token operator">=</span> alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> value_type<span class="token operator">*</span> iterator<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vector维护的是一个连续线性空间，所以不论其元素型别为何，原生指标都可以做为 vector的迭代器而满足所有必要条件，因此其迭代器都是元素类型的对应指针</p><p><strong>vector数据结构</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">&#123;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  <span class="token comment">// 目前使用的空间的头部</span>  iterator start<span class="token punctuation">;</span>  <span class="token comment">// 目前使用的空间的尾部</span>  iterator finish<span class="token punctuation">;</span>  <span class="token comment">// 目前可用空间的尾部</span>  iterator end_of_storage<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>以两个迭代器start和finish分别指向配置得来的连续空间中目前已经被使用的范围，并以迭代器end_of_storage指向整块连续空间(含备用空间)的尾端，</li><li>了方便扩充，vector实际配置的大小(capacity)可能比客户端需求更大一些，以备将来可能的扩充。</li><li>vector的容量永远大于或等于其大小。一旦容量等于大小，便是满载，下次再有新增元素，整个vector就要进行搬移。即capacity&gt;size永远成立</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230103215724632.png"></p><p><strong>vector 的建构与内存管理constructor、push_back</strong> </p><p>vector预设使用alloc做为空间配置器，并据此另外定义了一个data_allocator，为的是更方便以元素大小为配置单位</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> classAlloc <span class="token operator">=</span> alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">&#123;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  <span class="token comment">// simple_alloc&lt;> 见 2.2.4 节</span>  <span class="token keyword">typedef</span> simple_alloc<span class="token operator">&lt;</span>value_type<span class="token punctuation">,</span> Alloc<span class="token operator">></span> data_allocator<span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>constructor函数会先调用data_allocator::allocate(n)配置内存，然后调用uninitialized_fill_n填充元素，其会根据第一参数的型别特性，决定使用算法 fill_n()或反复呼叫 construct() 来完成任务</p><p>push_back代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>finish <span class="token operator">!=</span> end_of_storage<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 还有备用空间</span>    <span class="token function">construct</span><span class="token punctuation">(</span>finish<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">++</span>finish<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>    <span class="token function">insert_aux</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// vector member function，见以下列表</span><span class="token punctuation">&#125;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">vector</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">insert_aux</span><span class="token punctuation">(</span>iterator position<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>finish <span class="token operator">!=</span> end_of_storage<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 还有备用空间</span>    <span class="token comment">// 在备用空间起始处建构一个元素，并以 vector 最后一个元素值为其初值。</span>    <span class="token function">construct</span><span class="token punctuation">(</span>finish<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>finish <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调整水位。</span>    <span class="token operator">++</span>finish<span class="token punctuation">;</span>    T x_copy <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token function">copy_backward</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> finish <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> finish <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>position <span class="token operator">=</span> x_copy<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 已无备用空间</span>    <span class="token keyword">const</span> size_type old_size <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> size_typelen <span class="token operator">=</span> old_size <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">*</span> old_size <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 以上配置原则：如果原大小为 0，则配置 1（个元素大小）；</span>    <span class="token comment">// 如果原大小不为 0，则配置原大小的两倍，</span>    <span class="token comment">// 前半段用来放置原资料，后半段准备用来放置新资料。</span>    iterator new_start <span class="token operator">=</span> data_allocator<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 实际配置</span>    iterator new_finish <span class="token operator">=</span> new_start<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 将原 vector 的内容拷贝到新 vector。</span>      new_finish <span class="token operator">=</span> <span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> position<span class="token punctuation">,</span> new_start<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 为新元素设定初值 x</span>      <span class="token function">construct</span><span class="token punctuation">(</span>new_finish<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 调整水位</span>      <span class="token operator">++</span>new_finish<span class="token punctuation">;</span>      <span class="token comment">// 将原 vector 的备用空间中的内容也忠实拷贝过来（侯捷疑惑：啥用途？）</span>      new_finish <span class="token operator">=</span> <span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> finish<span class="token punctuation">,</span> new_finish<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// "commit or rollback" semantics.</span>      <span class="token function">destroy</span><span class="token punctuation">(</span>new_start<span class="token punctuation">,</span> new_finish<span class="token punctuation">)</span><span class="token punctuation">;</span>      data_allocator<span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>new_start<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">throw</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 解构并释放原 vector</span>    <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调整迭代器，指向新 vector</span>    start <span class="token operator">=</span> new_start<span class="token punctuation">;</span>    finish <span class="token operator">=</span> new_finish<span class="token punctuation">;</span>    end_of_storage <span class="token operator">=</span> new_start <span class="token operator">+</span> len<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，所谓动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后建构新元素，并释放原空间。</p><p>因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了</p></blockquote><p><strong>vector 的元素操作: pop_back, erase, clear, insert</strong> </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 将尾端元素拿掉，并调整大小。</span><span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token operator">--</span>finish<span class="token punctuation">;</span>  <span class="token function">destroy</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 将尾端标记往前移一格，表示将放弃尾端元素。</span><span class="token comment">//  destroy是全域函式，见第 2 章</span><span class="token comment">//  清除 [first,last) 中的所有元素</span>iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator first<span class="token punctuation">,</span> iterator last<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  iterator i <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>last<span class="token punctuation">,</span> finish<span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// copy 是全域函式，第 6 章</span>  <span class="token function">destroy</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> finish<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// destroy是全域函式，第 2 章</span>  finish <span class="token operator">=</span> finish <span class="token operator">-</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> first<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 清除某个位置上的元素</span>iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator position<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">copy</span><span class="token punctuation">(</span>position <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> finish<span class="token punctuation">,</span> position<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// copy 是全域函式，第 6 章</span>  <span class="token operator">--</span>finish<span class="token punctuation">;</span>  <span class="token function">destroy</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// destroy是全域函式，2.2.3 节</span>  <span class="token keyword">return</span> position<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// erase()就定义在上面</span><span class="token comment">//从 position 开始，安插 n个元素，元素初值为 x</span><span class="token comment">//函数里面分为了三种情况分别讨论，主要逻辑都是先将插入点以后的元素先拷贝到后面，然后再进行插入</span><span class="token keyword">void</span> <span class="token class-name">vector</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">insert</span><span class="token punctuation">(</span>iterator position<span class="token punctuation">,</span> size_type n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-list"><a href="#4-2-list" class="headerlink" title="4.2 list"></a>4.2 list</h2><blockquote><p>相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次安插或删除一个元素，就配置或释放一个元素空间。</p></blockquote><p><strong>list节点数据结构</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">__list_node</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token operator">*</span> void_pointer<span class="token punctuation">;</span>  void_pointer prev<span class="token punctuation">;</span>  <span class="token comment">// 型别为 void*。其实可设为 __list_node&lt;T>*</span>  void_pointer next<span class="token punctuation">;</span>  T data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>list 迭代器</strong></p><ul><li><p>由于STL list是一个双向串行，迭代器必须具备前移、后移的能力。所以list提供的是<em>Bidirectional Iterator</em>s。</p></li><li><p>list有一个重要性质：insert和splice都不会造成原有的list迭代器失效。</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ref</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ptr</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">__list_iterator</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> __list_node<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> link_type<span class="token punctuation">;</span>  link_type node<span class="token punctuation">;</span>  <span class="token comment">// 迭代器内部当然要有一个原生指标，指向 list 的节点</span>      <span class="token comment">// constructor</span>  <span class="token function">__list_iterator</span><span class="token punctuation">(</span>link_type x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token function">__list_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token function">__list_iterator</span><span class="token punctuation">(</span><span class="token keyword">const</span> iterator<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">node</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> node <span class="token operator">==</span> x<span class="token punctuation">.</span>node<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> node <span class="token operator">!=</span> x<span class="token punctuation">.</span>node<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 以下对迭代器取值（dereference），取的是节点的资料值。</span>  referenceoperator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 以下是迭代器的成员存取（member access）运算子的标准作法。</span>  pointeroperator<span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 对迭代器累加 1，就是前进一个节点</span>  self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    node <span class="token operator">=</span> <span class="token punctuation">(</span>link_type<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  self <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    self tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 对迭代器递减 1，就是后退一个节点</span>  self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span> node <span class="token operator">=</span> <span class="token punctuation">(</span>link_type<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  self <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> self tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span> <span class="token punctuation">&#123;</span>    <span class="token operator">--</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>list 数据结构</strong></p><p>SGI list不仅是一个双向串行，而且还是一个环状双向串行。所以它只需要一个指标，便可以完整表现整个串行</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> classAlloc <span class="token operator">=</span> alloc<span class="token operator">></span>  <span class="token comment">// 预设使用 alloc 为配置器</span><span class="token keyword">class</span> <span class="token class-name">list</span> <span class="token punctuation">&#123;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> __list_node<span class="token operator">&lt;</span>T<span class="token operator">></span> list_node<span class="token punctuation">;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> list_node<span class="token operator">*</span> link_type<span class="token punctuation">;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  link_type node<span class="token punctuation">;</span>  <span class="token comment">// 只要一个指标，便可表示整个环状双向串行</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230104194612566.png"></p><p><strong>list 构建与内存管理</strong></p><p>list为了方便空间配置器，额外定义了一个list_node_allocator，为的就是更方便地以节点大小为配置单位；</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">protected</span><span class="token operator">:</span><span class="token comment">// 配置一个节点并传回</span>link_type <span class="token function">get_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> list_node_allocator<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">// 释放一个节点</span><span class="token keyword">void</span> <span class="token function">put_node</span><span class="token punctuation">(</span>link_type p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> list_node_allocator<span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">// 产生(配置并构造)一个节点，带有元素值</span>link_type <span class="token function">create_node</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  link_type p <span class="token operator">=</span> <span class="token function">get_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 全局函数，构造/析构函数</span>  <span class="token function">construct</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>data<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 销毁一个节点</span><span class="token keyword">void</span> <span class="token function">destroy_node</span><span class="token punctuation">(</span>link_type p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 析构函数</span>  <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">put_node</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>list提供多个构造函数，default constructor允许我们不指定任何参数做出一个空的list出来。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230104194844419.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230104195030270.png"></p><p><strong>list 操作函数</strong></p><blockquote><p>提供push_front, push_back, erase, pop_front, pop_back,  clear, remove, unique, splice, merge, reverse, sort 等函数</p></blockquote><p>由于list是一个双向环状串行，只要我们把边际条件处理好，那么，在头部或尾部安插元素或移除元素，动作也几乎是一样的。移除（erase）某个迭代器所指元素，只是做一些指标搬移动作而已。</p><p>list这些操作很多都只是对指针进行操作，源代码太多了，见书上</p><p>list内部提供一个transfer操作；将某个连续范围的元素迁移到某个特定位置之前，迁移的元素可以是同一个list也可以是不同list</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// typedef list_node* link_type;</span><span class="token comment">// 将 [first,last) 内的所有元素搬移到 position 之前。</span><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>iterator position<span class="token punctuation">,</span> iterator first<span class="token punctuation">,</span> iterator last<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">!=</span> last<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">link_type</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>last<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> position<span class="token punctuation">.</span>node<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">link_type</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> last<span class="token punctuation">.</span>node<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">link_type</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>position<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> first<span class="token punctuation">.</span>node<span class="token punctuation">;</span>    link_type tmp <span class="token operator">=</span> <span class="token function">link_type</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>position<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>last<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230104195805857.png"></p><p>splice函数提供了诸多版本，但内部都是都是使用的transfer来进行操作</p><p>merge函数：将另一个list合并到当前list，前提是两个list都必须经过递增排序，内部实现也使用了transfer进行节点变换</p><p>sort函数：list 不能使用 STL 算法 sort()，必须使用自己的 sort() member function。因为 STL 算法 sort() 只接受 RamdonAccessIterator。</p><h2 id="4-3-deque"><a href="#4-3-deque" class="headerlink" title="4.3 deque"></a>4.3 deque</h2><p>deque则是一种双向开口的连续线性空间，可以在头尾两端分别做元素的安插和删除动作</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105205751267.png"></p><p>deque和vector的最大差异：</p><ul><li>于deque允许于常数时间内对起头端进行元素的安插或移除动作</li><li>deque没有所谓容量（capacity）观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来</li></ul><p>应尽可能选择使用vector而非deque。</p><p>对 deque进行的排序动作，为了最高效率，可将deque先完整复制到一个 vector 身上，将vector排序后（利用 STL sort算法），再复制回 deque。</p><p><strong>deque数据结构</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> classAlloc <span class="token operator">=</span> alloc<span class="token punctuation">,</span> size_t BufSiz <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">deque</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment">// Basic types</span>  <span class="token keyword">typedef</span> T value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> value_type<span class="token operator">*</span> pointer<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> size_t size_type<span class="token punctuation">;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment">// Iterators</span>  <span class="token keyword">typedef</span> __deque_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token punctuation">,</span> BufSiz<span class="token operator">></span> iterator<span class="token punctuation">;</span> <span class="token keyword">protected</span><span class="token operator">:</span>                      <span class="token keyword">typedef</span> pointer<span class="token operator">*</span> map_pointer<span class="token punctuation">;</span>  <span class="token comment">// 元素的指针的指针（pointer of pointer of T）</span> <span class="token keyword">protected</span><span class="token operator">:</span>         <span class="token comment">// Data members</span>  iterator start<span class="token punctuation">;</span>   <span class="token comment">// 表现第一个节点。</span>  iterator finish<span class="token punctuation">;</span>  <span class="token comment">// 表现最后一个节点。</span>  map_pointer map<span class="token punctuation">;</span>  <span class="token comment">// 指向 map，map 是块连续空间，</span>                    <span class="token comment">// 其每个元素都是个指针，指向一个节点（缓冲区）。</span>  size_type map_size<span class="token punctuation">;</span>  <span class="token comment">// map 内有多少指标。</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>deque 的中控器</strong></p><p>中控器即为数据结构中的map，其是指针的指针。</p><p>deque系由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的界面。</p><p>deque采用一块所谓的<em>map</em>（不是 STL 的map容器）做为主控。map*是一小块连续空间，其中每个元素（node）都是指针，指向另一段连续线性空间，称为缓冲区。缓冲区才是deque的储存空间主体。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105210422569.png"></p><p><strong>deque 的迭代器</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ref</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ptr</span><span class="token punctuation">,</span> size_t BufSiz<span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">__deque_iterator</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 保持与容器的联结</span>  T<span class="token operator">*</span> cur<span class="token punctuation">;</span>    <span class="token comment">// 此迭代器所指之缓冲区中的现行（current）元素</span>  T<span class="token operator">*</span> first<span class="token punctuation">;</span>  <span class="token comment">// 此迭代器所指之缓冲区的头</span>  T<span class="token operator">*</span> last<span class="token punctuation">;</span>   <span class="token comment">// 此迭代器所指之缓冲区的尾（含备用空间）</span>  map_pointer node<span class="token punctuation">;</span>  <span class="token comment">// 指向管控中心</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105211525843.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105211700125.png"></p><p>迭代器关键代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 更换缓冲区</span><span class="token keyword">void</span> <span class="token function">set_node</span><span class="token punctuation">(</span>map_pointer new_node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  node <span class="token operator">=</span> new_node<span class="token punctuation">;</span>  first <span class="token operator">=</span> <span class="token operator">*</span>new_node<span class="token punctuation">;</span>  last <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token function">difference_type</span><span class="token punctuation">(</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>difference_type <span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">const</span> self<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">difference_type</span><span class="token punctuation">(</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>node <span class="token operator">-</span> x<span class="token punctuation">.</span>node <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>cur <span class="token operator">-</span> first<span class="token punctuation">)</span> <span class="token operator">+</span>         <span class="token punctuation">(</span>x<span class="token punctuation">.</span>last <span class="token operator">-</span> x<span class="token punctuation">.</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token operator">++</span>cur<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> last<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 切换至下一个元素。</span>    <span class="token comment">// 如果已达所在缓冲区的尾端，</span>    <span class="token function">set_node</span><span class="token punctuation">(</span>node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 就切换至下一节点（亦即缓冲区）</span>    cur <span class="token operator">=</span> first<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 的第一个元素。</span>self <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 后置式，标准写法</span>  self tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span>difference_type n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  difference_type offset <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token punctuation">(</span>cur <span class="token operator">-</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> offset <span class="token operator">&lt;</span> <span class="token function">difference_type</span><span class="token punctuation">(</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 标的位置在同一缓冲区内</span>    cur <span class="token operator">+=</span> n<span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 标的位置不在同一缓冲区内</span>    difference_type node_offset <span class="token operator">=</span>        offset <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> offset <span class="token operator">/</span> <span class="token function">difference_type</span><span class="token punctuation">(</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token operator">:</span> <span class="token operator">-</span><span class="token function">difference_type</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-</span>offset <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 切换至正确的节点（亦即缓冲区）</span>    <span class="token function">set_node</span><span class="token punctuation">(</span>node <span class="token operator">+</span> node_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 切换至正确的元素</span>    cur <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token punctuation">(</span>offset <span class="token operator">-</span> node_offset <span class="token operator">*</span> <span class="token function">difference_type</span><span class="token punctuation">(</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>deque 构造与内存管理</strong></p><p>deque构造时，先申请map的空间和最少8个缓存区的空间，然后将start和finish指向map的中间段</p><p>其内存管理示例如下图</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>finish<span class="token punctuation">.</span>cur <span class="token operator">!=</span> finish<span class="token punctuation">.</span>last <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 最后缓冲区尚有一个以上的备用空间</span>    <span class="token function">construct</span><span class="token punctuation">(</span>finish<span class="token punctuation">.</span>cur<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 直接在备用空间上建构元素</span>    <span class="token operator">++</span>finish<span class="token punctuation">.</span>cur<span class="token punctuation">;</span>              <span class="token comment">// 调整最后缓冲区的使用状态</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>  <span class="token comment">// 最后缓冲区已无（或只剩一个）元素备用空间。</span>    <span class="token function">push_back_aux</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先向其添加3个元素：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105213342457.png"></p><p>再向尾部插入一个元素，若当前缓冲区只剩一个空间时，则先申请一个新的缓存区（申请前会判断map是否需要扩容），将需要添加的值置于最后一个空间处，然后将finsh指向新申请的缓冲区</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105214237534.png"></p><p>再向前端插入一个元素，由于此时第一缓冲区无空间，因此申请一个新的缓冲区（申请前会判断map是否需要扩容），然后将start指向新缓冲区，并将strart.cur指向末尾。此时插入一个元素</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230105214649662.png"></p><blockquote><p>什么时候需要将map更换空间？</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reserve_map_at_back</span><span class="token punctuation">(</span>size_type nodes_to_add <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>nodes_to_add <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> map_size <span class="token operator">-</span> <span class="token punctuation">(</span>finish<span class="token punctuation">.</span>node <span class="token operator">-</span> map<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 如果 map尾端的节点备用空间不足</span>    <span class="token comment">// 符合以上条件则必须重换一个 map（配置更大的，拷贝原来的，释放原来的）</span>    <span class="token function">reallocate_map</span><span class="token punctuation">(</span>nodes_to_add<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">reserve_map_at_front</span><span class="token punctuation">(</span>size_type nodes_to_add <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>nodes_to_add <span class="token operator">></span> start<span class="token punctuation">.</span>node <span class="token operator">-</span> map<span class="token punctuation">)</span>    <span class="token comment">// 如果 map前端的节点备用空间不足</span>    <span class="token comment">// 符合以上条件则必须重换一个 map（配置更大的，拷贝原来的，释放原来的）</span>    <span class="token function">reallocate_map</span><span class="token punctuation">(</span>nodes_to_add<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//reallocate_map主要是分配一段新的空间，然后将原map拷贝过去，并将start和finish更新</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><strong>deque的操作函数</strong></p><p>pop_back()函数，pop_front类似，都需要判断是否到需要删除当前缓冲区</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>finish<span class="token punctuation">.</span>cur <span class="token operator">!=</span> finish<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 最后缓冲区有一个（或更多）元素</span>    <span class="token operator">--</span>finish<span class="token punctuation">.</span>cur<span class="token punctuation">;</span>  <span class="token comment">// 调整指针，相当于排除了最后元素</span>  <span class="token punctuation">&#125;</span>  <span class="token function">destroy</span><span class="token punctuation">(</span>finish<span class="token punctuation">.</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将最后元素解构</span>  <span class="token keyword">else</span>      <span class="token comment">// 最后缓冲区没有任何元素</span>      <span class="token function">pop_back_aux</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 这里将进行缓冲区的释放工作</span><span class="token comment">// 只有当 finish.cur == finish.first 时才会被呼叫。</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token punctuation">,</span> size_t BufSize<span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">deque</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Alloc<span class="token punctuation">,</span> BufSize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">pop_back_aux</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">deallocate_node</span><span class="token punctuation">(</span>finish<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 释放最后一个缓冲区</span>  finish<span class="token punctuation">.</span><span class="token function">set_node</span><span class="token punctuation">(</span>finish<span class="token punctuation">.</span>node <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调整 finish 的状态，使指向</span>  finish<span class="token punctuation">.</span>cur <span class="token operator">=</span> finish<span class="token punctuation">.</span>last <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">destroy</span><span class="token punctuation">(</span>finish<span class="token punctuation">.</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>clear函数会保留一个缓冲区，而将其他缓冲区释放</p><p>erase()：用来清除某个元素或清楚一个范围的元素，为了效率其会比较移动首部还是尾部</p><p>insert()：用来插入元素，为了效率会判断是移动首部还是尾部</p><h2 id="4-4-stack"><a href="#4-4-stack" class="headerlink" title="4.4 stack"></a>4.4 stack</h2><blockquote><p>stack是一种先进后出（First In Last Out，FILO）的数据结构。</p><p>SGI STL以deque做为预设情况下的stack底部结构</p><p>由于stack系以底部容器完成其所有工作，而具有这种「修改某物接口，形成另一种风貌」之性质者，称为adapter（配接器）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106193937615.png"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//stack主要函数</span><span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token function">size_typesize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token function">referencetop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token function">const_referencetop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">// deque是两头可进出，stack是᳿端进，᳿端出（所以后进者先出）。</span><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> c<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>stack 没有迭代器</strong></p><p>stack不提供遍历功能，也不提供迭代器。</p><p><strong>list也可做为stack 的底层容器</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> istack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-5-queue"><a href="#4-5-queue" class="headerlink" title="4.5 queue"></a>4.5 queue</h2><blockquote><p>queue是一种先进先出（First In First Out，FIFO）的数据结构。</p><p>SGI STL 以deque做为预设情况下的queue底部结构</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106194006925.png"></p><p>queue函数主要是对deque的封装</p><p><strong>queue 没有迭代器</strong></p><p><strong>list也可做为queue 的底层容器</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> iqueue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-6-heap"><a href="#4-6-heap" class="headerlink" title="4.6 heap"></a>4.6 heap</h2><blockquote><p>heap并不归属于STL 容器组件，它是priority queue的底层</p><p>binary heap就是一种完全二叉树</p></blockquote><ul><li>max-heap: 每个节点键值都大于或者等于其子节点的键值</li><li>min-heap: 每个节点键值都小于或者等于其子节点的键值</li></ul><p><strong>完全二叉树可以用数组进行存储</strong></p><p>将0保留，使用arry的i表示某一个节点，那么左子节点就必须位于array的2i处，右子节点必须位于array的2i+1处。 </p><p><strong>push_heap 算法</strong></p><p>新元素安插在末尾处，然后不断和父节点比较，从而判断是否需要交换位置</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106194648317.png"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">void__push_heap</span><span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> Distance holeIndex<span class="token punctuation">,</span>                Distance topIndex<span class="token punctuation">,</span> T value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Distance parent <span class="token operator">=</span> <span class="token punctuation">(</span>holeIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 找出父节点</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>holeIndex <span class="token operator">></span> topIndex <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> parent<span class="token punctuation">)</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当尚᳾到达顶端，且父节点小于新值（于是不符合 heap</span>    <span class="token comment">// 的次序特性） 由于以上使用 operator&lt;，可知 STL heap 是一种</span>    <span class="token comment">// max-heap（大者为父）。</span>    <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> holeIndex<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 令洞值为父值</span>    holeIndex <span class="token operator">=</span> parent<span class="token punctuation">;</span>  <span class="token comment">// percolate up：调整洞号，向上提升至父节点。</span>    parent <span class="token operator">=</span> <span class="token punctuation">(</span>holeIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 新洞的父节点</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 持续至顶端，或满足 heap 的次序特性为止。</span>  <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> holeIndex<span class="token punctuation">)</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token comment">// 令洞值为新值，完成安插动作。</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>pop_heap 算法</strong></p><p>先将根节点与最末尾值交换，然后将新的根节点不断进行下沉，由于新根节点一定被放在叶子节点上，因此不断将其左右子节点较大值与其交换即可。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106195126838.png"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token function">void__adjust_heap</span><span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> Distance holeIndex<span class="token punctuation">,</span> Distance len<span class="token punctuation">,</span>                  T value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Distance topIndex <span class="token operator">=</span> holeIndex<span class="token punctuation">;</span>  Distance secondChild <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> holeIndex <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 洞节点之右子节点</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>secondChild <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 比较洞节点之左右两个子值，然后以 secondChild代表较大子节点。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> secondChild<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> <span class="token punctuation">(</span>secondChild <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> secondChild<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token comment">// Percolate down：令较大子值为洞值，再令洞号下移至较大子节点处。</span>    <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> holeIndex<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> secondChild<span class="token punctuation">)</span><span class="token punctuation">;</span>    holeIndex <span class="token operator">=</span> secondChild<span class="token punctuation">;</span>    <span class="token comment">// 找出新洞节点的右子节点</span>    secondChild <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span>secondChild <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>secondChild <span class="token operator">==</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 没有右子节点，只有左子节点</span>    <span class="token comment">// Percolate down：令左子值为洞值，再令洞号下移至左子节点处。</span>    <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> holeIndex<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> <span class="token punctuation">(</span>secondChild <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    holeIndex <span class="token operator">=</span> secondChild <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 将欲调整值填入目前的洞号内。注意，此时肯定满足次序特性。</span>  <span class="token comment">// 依侯捷之见，下面直接改为 *(first + holeIndex) = value; 应该可以。</span>  <span class="token function">__push_heap</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> holeIndex<span class="token punctuation">,</span> topIndex<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，pop_heap之后，最大元素只是被置放于底部容器的最尾端，尚未被取走</p><p><strong>sort_heap 算法</strong></p><p>每次pop_heap可获得 heap之中键值最大的元素，如果持续对整个 heap做pop_heap动作，每次将操作范围从后向前缩减一个元素（因为 pop_heap 会把键值最大的元素放在底部容器的最尾端），当整个程序执行完毕，便得到一个递增序列。</p><p><strong>make_heap 算法</strong></p><p>在需要形成堆的数组中，对前半部分中的每个值都进行下沉，便可形成最大堆或最小堆。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">__make_heap</span><span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token punctuation">,</span>                Distance<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// 如果长度为 0或 1，不必重新排列。</span>  Distance len <span class="token operator">=</span> last <span class="token operator">-</span> first<span class="token punctuation">;</span>  <span class="token comment">// 找出第一个需要重排的子树头部，以 parent 标示出。由于任何叶节点都不需执行</span>  <span class="token comment">// perlocate down，所以有以下计算。parent命名不佳，名为 holeIndex更好。</span>  Distance parent <span class="token operator">=</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 重排以 parent 为首的子树。len 是为了让 __adjust_heap()判断操作范围</span>    <span class="token function">__adjust_heap</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// 走完根节点，就结束。</span>    parent<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>heap 没有迭代器</strong></p><h2 id="4-7-priority-queue"><a href="#4-7-priority-queue" class="headerlink" title="4.7 priority_queue"></a>4.7 priority_queue</h2><blockquote><p>priority_queue是一个拥有权值观念的 queue，只允许在底端加入元素，并从顶端取出元素</p><p>预设情况下priority_queue利用一个max-heap 完成，后者是一个以 vector 为底层的 complete binary tree</p><p>priority_queue是适配器，而非容器</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106195927269.png"></p><p>关键代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Sequence</span> <span class="token operator">=</span> vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span>          <span class="token keyword">class</span> <span class="token class-name">Compare</span> <span class="token operator">=</span> less<span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Sequence</span><span class="token double-colon punctuation">::</span>value_type<span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">priority_queue</span> <span class="token punctuation">&#123;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  Sequence c<span class="token punctuation">;</span>    <span class="token comment">// 底层容器</span>  Compare comp<span class="token punctuation">;</span>  <span class="token comment">// 元素大小比较标准</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">priority_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">explicit</span> <span class="token function">priority_queue</span><span class="token punctuation">(</span><span class="token keyword">const</span> Compare<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">comp</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token comment">// 以下用到的 make_heap(), push_heap(), pop_heap()都是泛型算法</span>  <span class="token comment">// 注意，任一个建构式都立刻于底层容器内产生一个 implicit representation heap。</span>  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token operator">></span>  <span class="token function">priority_queue</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span> <span class="token keyword">const</span> Compare<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>      <span class="token operator">:</span> <span class="token function">c</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">comp</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">make_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token operator">></span>  <span class="token function">priority_queue</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">c</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">make_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token function">size_typesize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token function">const_referencetop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    __STL_TRY <span class="token punctuation">&#123;</span>      c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// push_heap是泛型算法，先利用底层容器的 push_back() 将新元素</span>      <span class="token function">push_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// push_heap是泛型算法，推入末端，再重排 heap</span>    <span class="token punctuation">&#125;</span>    <span class="token function">__STL_UNWIND</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    __STL_TRY <span class="token punctuation">&#123;</span>      <span class="token function">pop_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// pop_heap 是泛型算法，从 heap 内取出一个元素。它并不是真正将元素</span>      c<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 弹出，并重排 heap，然后再以底层容器的 pop_back() 取得被弹出的元素</span>    <span class="token punctuation">&#125;</span>    <span class="token function">__STL_UNWIND</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>priority_queue 没有迭代器</strong></p><h2 id="4-8-slist"><a href="#4-8-slist" class="headerlink" title="4.8 slist"></a>4.8 slist</h2><blockquote><p>slist是一个单向串行链表，并非STL规定</p><p>slist和list的主要差别在于，前者的迭代器属于单向的 <em>Forward Iterator</em>，后者的迭代器属于双向的<em>Bidirectional Iterator</em></p></blockquote><p>除了slist起始处附近的区域之外，在其它位置上采用insert 或erase 操作函式，都是不智之举</p><p>slist不提供 push_back()，只提供 push_front()</p><p><strong>slist 数据结构</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">slist</span> <span class="token punctuation">&#123;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">static</span> list_node<span class="token operator">*</span> <span class="token function">create_node</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    list_node<span class="token operator">*</span> node <span class="token operator">=</span> list_node_allocator<span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 配置空间</span>    __STL_TRY <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">construct</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>node<span class="token operator">-></span>data<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 建构元素</span>    <span class="token function">__STL_UNWIND</span><span class="token punctuation">(</span>list_node_allocator<span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">destroy_node</span><span class="token punctuation">(</span>list_node<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>node<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将元素解构</span>  <span class="token punctuation">&#125;</span>  list_node_allocator<span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 释还空间</span> <span class="token keyword">private</span><span class="token operator">:</span>  list_node_base head<span class="token punctuation">;</span>  <span class="token comment">// 头部。注意，它不是指标，是实物。</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">slist</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token operator">~</span><span class="token function">slist</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>slist node</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106200611744.png"></p><p><strong>slist 迭代器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230106200709076.png"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">__slist_iterator_base</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> size_t size_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> ptrdiff_t difference_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> forward_iterator _tagiterator_category<span class="token punctuation">;</span>  <span class="token comment">// 注意，单向</span>  __slist_node_base<span class="token operator">*</span> node<span class="token punctuation">;</span>                       <span class="token comment">// 指向节点基ᴀ结构</span>  <span class="token function">__slist_iterator_base</span><span class="token punctuation">(</span>__slist_node_base <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">incr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> node <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 前进一个节点</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> __slist_iterator_base<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> node <span class="token operator">==</span> x<span class="token punctuation">.</span>node<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> __slist_iterator_base<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> node <span class="token operator">!=</span> x<span class="token punctuation">.</span>node<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较两个slist迭代器是否等同时，其实是比较指向的node是否相同</p><p><strong>注意</strong>，调用slist的end()时，会创建一个新的值为0的node</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">typedef</span> __slist_iterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token operator">></span> iterator<span class="token punctuation">;</span><span class="token generic-function"><span class="token function">__slist_iterator</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//产生一个暂时对象，引发 ctor</span><span class="token function">__slist_iterator</span><span class="token punctuation">(</span>list_node<span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">__slist_iterator_base</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>struct__slist_iterator_base <span class="token punctuation">&#123;</span>  __slist_node_base<span class="token operator">*</span> node<span class="token punctuation">;</span>  <span class="token comment">// 指向节点基ᴀ结构</span>  <span class="token function">__slist_iterator_base</span><span class="token punctuation">(</span>__slist_node_base <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、关联式容器"><a href="#五、关联式容器" class="headerlink" title="五、关联式容器"></a>五、关联式容器</h1><p>当元素被插入到关联式容器中时，容器内部结构(可能是RB-tree或者hash-table)便依照其键值大小，以某种特定规则将这个元素放置于合适的位置，</p><p>关联式容器没有所谓头尾(只有最大元素和最小元素)，所以不会有所谓<code>push_back()</code>、<code>push_front()</code>等行为的操作。 </p><p> 一般而言关联式容器的内部结构是一个二叉平衡树，以便获得良好的搜寻效率。二叉平衡树有许多变形包括：AVL-tree、RB-tree、AA-tree；其中RB-tree被广泛应用于关联式容器。</p><h2 id="5-1-RB-tree"><a href="#5-1-RB-tree" class="headerlink" title="5.1 RB-tree"></a>5.1 RB-tree</h2><p>红黑树定义：</p><ul><li>（1）每个节点不是红色就是黑色(图中深色底纹代表黑色，浅色底纹代表红色，同下)。</li><li>（2）根节点为黑色</li><li>（3）如果节点为红，其子节点必须为黑色</li><li>（4）任一节点至NULL(树尾端)的任何路径，所含之黑节点数木必须相同</li></ul><p>由定义可以推导出：</p><ul><li>由规则4，新增节点必须为红</li><li>由规则3，新增节点的父节点必须为黑（如果为红，则子节点必须为黑，与新增几点为红矛盾）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108193422701.png"></p><h3 id="5-1-1-插入节点"><a href="#5-1-1-插入节点" class="headerlink" title="5.1.1 插入节点"></a>5.1.1 插入节点</h3><p>假设新增节点为X，其父节点为P，祖父节点为G，伯父节点为S，曾祖父节点为GG。有以下四种状况：</p><ul><li>状况1：s为黑色x为外侧插入，对此情况，先对P,G做一次单旋转，再更改P,G颜色，即可重新满足红黑树的规则3。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108193713609.png"></p><ul><li>状况2:S为黑且x为内侧插入，对此情况，我们必须先对P,X做一次单旋转并更改G,X颜色，再将结果对G做一次单旋转，级可再次满足红黑树规则3。（加第二次旋转是为了避免10的父节点是红色）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108193756597.png"></p><ul><li>状况3:S为红色且X为外侧插入，对此情况，先对P和G做一次单旋转，并改变X的颜色。此时如果GG为黑，一切搞定，如果GG为红，则是状况4</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108193919931.png"></p><ul><li>状况4:S为红且X为外侧插入。对此情况，先对P和G做一次单旋转，并改变X的颜色。此时如果GG亦为红，还得持续往上做，直到不再有父子连续为红的情况发生。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108194045969.png"></p><h3 id="5-1-2-一个由上而下的程序"><a href="#5-1-2-一个由上而下的程序" class="headerlink" title="5.1.2 一个由上而下的程序"></a>5.1.2 一个由上而下的程序</h3><p>假设新增节点为A,那么就沿着A的路径，只要看到某个节点X的两个子节点皆为红色，就把X该为红色，并把两个子节点改为黑色。然后在进行旋转变换。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108194413600.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108194539595.png"></p><h3 id="5-1-3-RB-tree节点设计"><a href="#5-1-3-RB-tree节点设计" class="headerlink" title="5.1.3 RB-tree节点设计"></a>5.1.3 RB-tree节点设计</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">bool</span> __rb_tree_color_type<span class="token punctuation">;</span><span class="token comment">//红色为0</span><span class="token keyword">const</span> __rb_tree_color_type __rb_tree_red<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">const</span> __rb_tree_color_type __rb_tree_black<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">__rb_tree_node_base</span><span class="token punctuation">&#123;</span>    <span class="token keyword">typedef</span> __rb_tree_color_type color_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> __rb_tree_node_base<span class="token operator">*</span> base_ptr<span class="token punctuation">;</span>    color_type color<span class="token punctuation">;</span><span class="token comment">//节点颜色，非红即黑</span>    base_ptr parent<span class="token punctuation">;</span>    <span class="token comment">//节点的父节点指针</span>    base_ptr left<span class="token punctuation">;</span>    <span class="token comment">//左节点指针</span>    base_ptr right<span class="token punctuation">;</span>    <span class="token comment">//右节点指针</span>    <span class="token keyword">static</span> base_ptr <span class="token function">minimum</span><span class="token punctuation">(</span>base_ptr x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">-></span>left<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>x<span class="token operator">=</span>x<span class="token operator">-></span>left<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> base_ptr <span class="token function">maximum</span><span class="token punctuation">(</span>base_ptr x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">-></span>right<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>x<span class="token operator">=</span>x<span class="token operator">-></span>right<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token operator">></span><span class="token keyword">struct</span>  <span class="token class-name">_rb_tree_node</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">__rb_tree_node_base</span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">typedef</span> __rb_tree_node<span class="token operator">&lt;</span>Value<span class="token operator">></span><span class="token operator">*</span> link_type<span class="token punctuation">;</span>    <span class="token comment">//节点值</span>    Value value_field<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-4-RB-tree迭代器"><a href="#5-1-4-RB-tree迭代器" class="headerlink" title="5.1.4 RB-tree迭代器"></a>5.1.4 RB-tree迭代器</h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108194922205.png"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">__rb_tree_base_iterator</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> __rb_tree_node_base<span class="token double-colon punctuation">::</span>base_ptr base_ptr<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> bidirectional_iterator_tag iterator_category<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> ptrdiff_t difference_type<span class="token punctuation">;</span>  <span class="token comment">// 用来与容器之间产生一个连接关系</span>  base_ptr node<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 存在右节点，就往右节点走</span>      node <span class="token operator">=</span> node<span class="token operator">-></span>right<span class="token punctuation">;</span>      <span class="token comment">// 然后一直往左子树，走到底</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        node <span class="token operator">=</span> node<span class="token operator">-></span>left<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">//状况2</span>      <span class="token comment">// 没有右子节点，先找出父节点</span>      base_ptr y <span class="token operator">=</span> node<span class="token operator">-></span>parent<span class="token punctuation">;</span>      <span class="token comment">// 如果现行节点本身就是个右子节点,就一直上朔，直到"不为右子节点"为止</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> y<span class="token operator">-></span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        node <span class="token operator">=</span> y<span class="token punctuation">;</span>        y <span class="token operator">=</span> y<span class="token operator">-></span>node<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 如果此时右子节点不等于次吃的父节点状况3，此时的父节点即为解答，否则此时的node为解答状况4</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right <span class="token operator">!=</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        node <span class="token operator">=</span> y<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 注意：以上判断"若此时的右子节点不等于次吃的父节点"，是为了应付一种特殊情况：</span>  <span class="token comment">// 我们欲寻找根节点的下一个节点，而恰巧根节点无左右子节点</span>  <span class="token comment">// 以上的特殊做法必须配合RB-tree根节点与特殊之header之间的特殊关系</span>  <span class="token keyword">void</span> <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果是红节点，且父节点的父节点等于自己,即node为head或者end节点的时候</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>color <span class="token operator">==</span> __rb_tree_red <span class="token operator">&amp;&amp;</span> node<span class="token operator">-></span>parent<span class="token operator">-></span>parent <span class="token operator">==</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      node <span class="token operator">=</span> node<span class="token operator">-></span>right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      base_ptr y <span class="token operator">=</span> node<span class="token operator">-></span>left<span class="token punctuation">;</span>      <span class="token comment">// 一直向右循环查找下去，直到没有右子节点</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>y<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        y <span class="token operator">=</span> y<span class="token operator">-></span>right<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      node <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// 即非根节点，亦无左子节点</span>      <span class="token comment">// 先找到符节点</span>      base_ptr y <span class="token operator">=</span> node<span class="token operator">-></span>parent<span class="token punctuation">;</span>      <span class="token comment">// 找寻父节点的左子节点直到node不是左子节点</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> y<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 这里主要是一直上朔</span>        node <span class="token operator">=</span> y<span class="token punctuation">;</span>        y <span class="token operator">=</span> y<span class="token operator">-></span>parent<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// RB-tree的正规迭代器  只是对base的一个封装，和link_type定义</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ref</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ptr</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">__rb_tree_iteraror</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">__rb_tree_base_iterator</span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">typedef</span> Value value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> Ref reference<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> Ptr pointer<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __rb_tree_iterator<span class="token operator">&lt;</span>Value<span class="token punctuation">,</span> Value<span class="token operator">&amp;</span><span class="token punctuation">,</span> Value<span class="token operator">*</span><span class="token operator">></span> iterator<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __rb_tree_iterator<span class="token operator">&lt;</span>Value<span class="token punctuation">,</span> <span class="token keyword">const</span> Value<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Value<span class="token operator">*</span><span class="token operator">></span> const_iterator<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __rb_tree_iterator<span class="token operator">&lt;</span>Value<span class="token punctuation">,</span> Ref<span class="token punctuation">,</span> Ptr<span class="token operator">></span> self<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> __rb_tree_node<span class="token operator">&lt;</span>Value<span class="token operator">></span><span class="token operator">*</span> link_type<span class="token punctuation">;</span><span class="token comment">//</span>  <span class="token function">__rb_tree_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token function">__rb_tree_iterator</span><span class="token punctuation">(</span>link_type x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> node <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token function">__rb_tree_iterator</span><span class="token punctuation">(</span><span class="token keyword">const</span> iterator<span class="token operator">&amp;</span> it<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> node <span class="token operator">=</span> it<span class="token punctuation">.</span>node<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  reference <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">link_type</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token operator">-></span>value_field<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__SGI_STL_NO_ARROW_OPERATOR pointer <span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> </span><span class="token punctuation">\</span>  <span class="token expression"><span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token expression">self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></span></span>  self <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    self tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108195719894.png"></p><h3 id="5-1-5-RB-tree数据结构"><a href="#5-1-5-RB-tree数据结构" class="headerlink" title="5.1.5 RB-tree数据结构"></a>5.1.5 RB-tree数据结构</h3><p>红黑树实现上有个技巧，使用一个header指向根节点，且header和root互为对方的父节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Key</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyOfValue</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token punctuation">,</span>          <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> alloc<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">rb_tree</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> __rb_tree_iterator<span class="token operator">&lt;</span>value_type<span class="token punctuation">,</span> reference<span class="token punctuation">,</span> pointer<span class="token operator">></span> iterator<span class="token punctuation">;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  size_type node_count<span class="token punctuation">;</span>  <span class="token comment">// 节点数目</span>  link_type header<span class="token punctuation">;</span>  Compare key_compare<span class="token punctuation">;</span>  <span class="token comment">// 节点的键值大小比较准则，应该会是一个function object;</span>  link_type<span class="token operator">&amp;</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>link_type<span class="token operator">&amp;</span><span class="token punctuation">)</span>header<span class="token operator">-></span>parent<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  link_type<span class="token operator">&amp;</span> <span class="token function">leftmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>link_type<span class="token operator">&amp;</span><span class="token punctuation">)</span>header<span class="token operator">-></span>left<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  link_type<span class="token operator">&amp;</span> <span class="token function">rightmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>link_type<span class="token operator">&amp;</span><span class="token punctuation">)</span>header<span class="token operator">-></span>right<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 相关的基本函数</span>  iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">leftmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> header<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> node_count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  size_type <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> node_count<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  size_type <span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">size_type</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-6-构造和内存管理"><a href="#5-1-6-构造和内存管理" class="headerlink" title="5.1.6 构造和内存管理"></a>5.1.6 构造和内存管理</h3><p>RB-tree的构造方式有两种，一种是拷贝构造，一种是空值构造。下面是其init()的关键函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 产生一个节点空间，令header指向它</span>    header <span class="token operator">=</span> <span class="token function">get_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 令header为红色，用来区分header和root</span>    <span class="token function">color</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span> <span class="token operator">=</span> __rb_tree_red<span class="token punctuation">;</span>    <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// header的左右子节点都为自己</span>    <span class="token function">leftmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> header<span class="token punctuation">;</span>    <span class="token function">rightmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> header<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  link_type <span class="token function">create_node</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    link_type tmp <span class="token operator">=</span> <span class="token function">get_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    __STL_TRY <span class="token punctuation">&#123;</span>      <span class="token comment">// 构造内容</span>      <span class="token function">construct</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmp<span class="token operator">-></span>value_field<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">__STL_UNWIND</span><span class="token punctuation">(</span><span class="token function">put_node</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">rb_tree</span><span class="token punctuation">(</span><span class="token keyword">const</span> Compare<span class="token operator">&amp;</span> comp <span class="token operator">=</span> <span class="token function">Compare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">node_count</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">key_compare</span><span class="token punctuation">(</span>comp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token operator">~</span><span class="token function">rb_tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_node</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230108204049321.png"></p><h3 id="5-1-7-操作函数"><a href="#5-1-7-操作函数" class="headerlink" title="5.1.7 操作函数"></a>5.1.7 操作函数</h3><p>RB-Tree提供两种插入：</p><ul><li>insert_unique()：如果已存在相同键值，则不进行插入</li><li>insert_equal()：插入的键值可以重复</li></ul><p><strong>insert_equal()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Key</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyOfValue</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">></span><span class="token keyword">typename</span> <span class="token class-name">rb_tree</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> KeyOfValue<span class="token punctuation">,</span> Compare<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator<span class="token class-name">rb_tree</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> KeyOfValue<span class="token punctuation">,</span> Compare<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">insert_equal</span><span class="token punctuation">(</span><span class="token keyword">const</span> Value<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  link_type y <span class="token operator">=</span> header<span class="token punctuation">;</span>  link_type x <span class="token operator">=</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从根节点开始向下寻找适当的传播节点，直到到根节点，注意这里y为x的parent节点</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    y <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment">// 遇大则左，遇小或者等于就右--v&lt;x向左，v>=x向右</span>    x <span class="token operator">=</span> <span class="token function">key_compare</span><span class="token punctuation">(</span><span class="token function">KeyOfValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">key</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">left</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">right</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// x为新值插入点，y为插入点之父节点，v为新值</span>  <span class="token keyword">return</span> <span class="token function">__insert</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>insert_unique()</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span>Class Key<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyOfValue</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">></span>pair<span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">rb_tree</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> KeyOfValue<span class="token punctuation">,</span> Compare<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span><span class="token class-name">rb_tree</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> KeyOfValue<span class="token punctuation">,</span> Compare<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">insert_unique</span><span class="token punctuation">(</span><span class="token keyword">const</span> Value<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  link_type y <span class="token operator">=</span> header<span class="token punctuation">;</span>  <span class="token comment">// 从根节点开始</span>  link_type x <span class="token operator">=</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 判断是否相同</span>  <span class="token keyword">bool</span> comp <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 一直遍历到根节点</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    y <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment">// v是否小于目前节点的键值</span>    comp <span class="token operator">=</span> <span class="token function">key_compare</span><span class="token punctuation">(</span><span class="token function">KeyOfValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">key</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 遇“大”向左，否则向右</span>    x <span class="token operator">=</span> comp <span class="token operator">?</span> <span class="token function">left</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">right</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 离开while循环之后，y即插入父节点</span>  <span class="token comment">// 令迭代器j指向插入点的父节点</span>  iterator j <span class="token operator">=</span> <span class="token function">iterator</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果在左边插入</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>comp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果插入节点为最左节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">__insert</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token operator">--</span>j<span class="token punctuation">;</span><span class="token comment">//为了判断比y小1的值是否和v相等，见下</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 如果小于新值，将插入右侧</span>  <span class="token comment">// 比较是否存在重复的值</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">key_compare</span><span class="token punctuation">(</span><span class="token function">key</span><span class="token punctuation">(</span>j<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">KeyOfValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">__insert</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>插入函数__insert()</strong></p><p>通过将父节点和插入值进行比较，从而判断插入点是左节点还是右节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 关键插入程序</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Key</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">KeyOfValue</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">></span><span class="token keyword">typename</span> <span class="token class-name">rb_tree</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> KeyOfValue<span class="token punctuation">,</span> Compare<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator<span class="token class-name">rb_tree</span><span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> KeyOfValue<span class="token punctuation">,</span> Compare<span class="token punctuation">,</span> Alloc<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">__insert</span><span class="token punctuation">(</span>base_ptr x_<span class="token punctuation">,</span>                                                          base_ptr y_<span class="token punctuation">,</span>                                                          <span class="token keyword">const</span> Value<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 将值隐式转换为节点指针，x插入位置，y插入父节点，v插入的值</span>  link_type x <span class="token operator">=</span> <span class="token punctuation">(</span>link_type<span class="token punctuation">)</span>x_<span class="token punctuation">;</span>  link_type y <span class="token operator">=</span> <span class="token punctuation">(</span>link_type<span class="token punctuation">)</span>y_<span class="token punctuation">;</span>  link_type z<span class="token punctuation">;</span>  <span class="token comment">// 判断是否为首节点</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> header <span class="token operator">||</span> x <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">key_compare</span><span class="token punctuation">(</span><span class="token function">KeyOfValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">key</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 产生一个新节点</span>    z <span class="token operator">=</span> <span class="token function">create_node</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">left</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> header<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>      <span class="token function">rightmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> <span class="token function">leftmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 如果y为最左节点</span>      <span class="token comment">// 让最左节点永远指向z</span>      <span class="token function">leftmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 不是head节点或者空节点</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 产生一个新节点</span>    z <span class="token operator">=</span> <span class="token function">create_node</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 令新节点作为插入节点的右兄弟节点</span>    <span class="token function">right</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token comment">// 更新最右指针位置</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> <span class="token function">rightmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">rightmost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 设置新节点的父节点,右子节点和左子节点</span>  <span class="token function">parent</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token function">left</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">right</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 调整和设置新节点的颜色</span>  <span class="token function">__rb_tree_rebalance</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> header<span class="token operator">-></span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">++</span>node_count<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>调整RB-tree</strong></p><p>先由上而下的解决父子都为红色的情况，然后进行旋转</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__rb_tree_rebalance</span><span class="token punctuation">(</span>__rb_tree_node_base<span class="token operator">*</span> x<span class="token punctuation">,</span>                                __rb_tree_node_base<span class="token operator">*</span><span class="token operator">&amp;</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 新节点毕为红</span>  x<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_red<span class="token punctuation">;</span>  <span class="token comment">// 假设父节点为红色,按照之前的4种情况进行判断然后调整</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> root <span class="token operator">&amp;&amp;</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">==</span> __rb_tree_red<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断父节点是否为左子节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>parent <span class="token operator">==</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// y指向右伯节点</span>      __rb_tree_node_base<span class="token operator">*</span> y <span class="token operator">=</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>right<span class="token punctuation">;</span>      <span class="token comment">// 如果y存在并且也为红色</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&amp;&amp;</span> y<span class="token operator">-></span>color <span class="token operator">==</span> __rb_tree_red<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 更改父节点为黑色</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span>        <span class="token comment">// 更改父节点为黑色</span>        y<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span>        <span class="token comment">// 更改祖父节点为红</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_red<span class="token punctuation">;</span>        <span class="token comment">// x重新指向祖节点,再次循环迭代更改</span>        x <span class="token operator">=</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token punctuation">;</span>        <span class="token comment">// 无伯父节点，或者伯父节点为黑</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果新节点为右子节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// x重新指向父节点</span>          x <span class="token operator">=</span> x<span class="token operator">-></span>parent<span class="token punctuation">;</span>          <span class="token comment">// 第一参数为左旋点进行左旋</span>          <span class="token function">__rb_tree_rotate_left</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 改变颜色</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_red<span class="token punctuation">;</span>        <span class="token comment">// 第一参数为右旋点</span>        <span class="token function">__rb_tree_rotate_right</span><span class="token punctuation">(</span>x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 父节点为祖父节点之右子节点</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// y为左伯父节点</span>      __rb_tree_node_base<span class="token operator">*</span> y <span class="token operator">=</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>left<span class="token punctuation">;</span>      <span class="token comment">// 左伯父节点存在且为红色</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&amp;&amp;</span> y<span class="token operator">-></span>color <span class="token operator">==</span> __rb_tree_red<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 更改父节点为黑</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span>        <span class="token comment">// 伯父节点为黑色</span>        y<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span>        <span class="token comment">// 更改祖父节点为红色</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_red<span class="token punctuation">;</span>        <span class="token comment">// 移动指针准备继续向上查</span>        x <span class="token operator">=</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token punctuation">;</span>        <span class="token comment">// 无伯父节点或伯父节点为黑</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果新节点为父节点之左子节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> x<span class="token operator">-></span>parent<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          x <span class="token operator">=</span> x<span class="token operator">-></span>parent<span class="token punctuation">;</span>          <span class="token comment">// 第一参数为右旋点</span>          <span class="token function">__rb_tree_rotate_right</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span>        x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_red<span class="token punctuation">;</span>        <span class="token comment">// 第一参数为左旋点</span>        <span class="token function">__rb_tree_rotate_left</span><span class="token punctuation">(</span>x<span class="token operator">-></span>parent<span class="token operator">-></span>parent<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// end while</span>  <span class="token comment">// root节点永远为黑</span>  root<span class="token operator">-></span>color <span class="token operator">=</span> __rb_tree_black<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>元素搜索</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109164149767.png"></p><p><strong>插入图例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109164245861.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109164304596.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109164319824.png"></p><h2 id="5-2-set"><a href="#5-2-set" class="headerlink" title="5.2 set"></a>5.2 set</h2><p>set中所有元素都会根据元素的键值自动被排序。set不允许两个元素拥有相同的值。</p><p>set与list拥有相同的某些性质：操作过程中，除了删除元素的迭代器外，其它迭代器不会失效。</p><p>set的compare默认情况下是使用<code>less&lt;Key&gt;</code>缺省情况下采用递增排序。</p><p>set采用红黑树来进行排序和数据存储。</p><p>set的iterator无法改变对应元素值，是一个const iterator</p><p><strong>数据结构</strong></p><p>函数基本上都是对红黑树的包装，注意iterator定义即可</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109171127400.png"></p><h2 id="5-3-map"><a href="#5-3-map" class="headerlink" title="5.3 map"></a>5.3 map</h2><p>map的特性是，所有元素都会根据元素的键值自动被排序。</p><p>map的所有元素都是pair，同时拥有实值(value)和键值(key)。pair的第一元素被视为键值，第二元素被视为实值。</p><p>map不允许两个元素拥有相同的键值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">pair</span><span class="token punctuation">&#123;</span>    <span class="token keyword">typedef</span> T1 first_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> T2 second_type<span class="token punctuation">;</span>    T1 first<span class="token punctuation">;</span>    T2 second<span class="token punctuation">;</span>    <span class="token function">pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token function">T1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">second</span><span class="token punctuation">(</span><span class="token function">T2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">pair</span><span class="token punctuation">(</span><span class="token keyword">const</span> T1<span class="token operator">&amp;</span> a<span class="token punctuation">,</span><span class="token keyword">const</span> T2<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">first</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">second</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109171431165.png"></p><p><strong>数据结构</strong></p><p>函数基本上都是对红黑树的包装</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Key</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Compare</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>less<span class="token operator">&lt;</span>_Key<span class="token operator">></span><span class="token punctuation">,</span>          <span class="token keyword">typename</span> <span class="token class-name">_Alloc</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">></span> <span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">map</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> _Key key_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Tp mapped_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">></span> value_type<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Compare key_compare<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> _Alloc allocator_type<span class="token punctuation">;</span>  <span class="token comment">// 用于比较大小</span>  <span class="token keyword">class</span> <span class="token class-name">value_compare</span>      <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">binary_function</span><span class="token operator">&lt;</span><span class="token class-name">value_type</span><span class="token punctuation">,</span> <span class="token class-name">value_type</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">map</span><span class="token operator">&lt;</span>_Key<span class="token punctuation">,</span> _Tp<span class="token punctuation">,</span> _Compare<span class="token punctuation">,</span> _Alloc<span class="token operator">></span><span class="token punctuation">;</span>   <span class="token keyword">protected</span><span class="token operator">:</span>    _Compare comp<span class="token punctuation">;</span>    <span class="token function">value_compare</span><span class="token punctuation">(</span>_Compare __c<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">comp</span><span class="token punctuation">(</span>__c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>   <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __x<span class="token punctuation">,</span> <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> __y<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token function">comp</span><span class="token punctuation">(</span>__x<span class="token punctuation">.</span>first<span class="token punctuation">,</span> __y<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">typedef</span> _Rb_tree<span class="token operator">&lt;</span>key_type<span class="token punctuation">,</span> value_type<span class="token punctuation">,</span> _Select1st<span class="token operator">&lt;</span>value_type<span class="token operator">></span><span class="token punctuation">,</span> key_compare<span class="token punctuation">,</span>                   _Pair_alloc_type<span class="token operator">></span>      _Rep_type<span class="token punctuation">;</span>  <span class="token comment">/// The actual tree structure.</span>  _Rep_type _M_t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用关联式容器时，应使用容器提供的find函数来搜寻元素，比STL的find函数更有效率，因为STL算法find只是循序搜索。</p><p>注意，insert函数的返回值</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109192955148.png"></p><p>[]符号的重写：先使用insert插入一个元素，返回一个pair，然后使用first取得iterator，再使用*获得一个map元素pair，取第二元素。由于返回值是引用，因此作为左值还是右值皆可。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230109193359053.png"></p><h2 id="5-4-multiset和multimap"><a href="#5-4-multiset和multimap" class="headerlink" title="5.4 multiset和multimap"></a>5.4 multiset和multimap</h2><p>multiset的特性以及用法和set完全相同，唯一的差别在于它允许键值重复。它的底层机制是使用RB-tree的insert_equal()而非insert_unique()；</p><p>multimap与map的用法完全相同，唯一的差别在于，它允许键值重复。它的底层机制是使用RB-tree的insert_equal()而非insert_unique()；</p><h2 id="5-5-hashtable"><a href="#5-5-hashtable" class="headerlink" title="5.5 hashtable"></a>5.5 hashtable</h2><h3 id="5-5-1-概述"><a href="#5-5-1-概述" class="headerlink" title="5.5.1 概述"></a>5.5.1 概述</h3><p>使用哈希函数不可避免会有碰撞情况发生，解决碰撞的三种方法：</p><ul><li>线性探测：当插入位置不可用时，则依次往后寻找空位。删除元素时不能直接删除，只能进行标记，等表格重新整理时删除。因为每个元素不仅表述自己，也关系到其他元素排列、</li><li>二次探测：若插入位置H不可用，则依次尝试H+1^2^、H+2^2^…. 此方法虽然计算平方较耗时，但可进行优化，整体上是得大于失。但缺可能造成次聚集问题，可使用复式散列（double hashing）解决。</li><li>拉链法：在表格每个元素中维护一个list，当碰撞时，在list末尾上进行插入。SGI STL采用此方法。</li></ul><h3 id="5-5-2-hashtable的桶子与节点"><a href="#5-5-2-hashtable的桶子与节点" class="headerlink" title="5.5.2 hashtable的桶子与节点"></a>5.5.2 hashtable的桶子与节点</h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110193310844.png"></p><p><strong>节点数据结构定义：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">__hastable_node</span><span class="token punctuation">&#123;</span>    __hashtable_node<span class="token operator">*</span> next<span class="token punctuation">;</span>    Value val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SGI中，bucket（桶子）维护的linked list未采用STL的list或slist，而是自行维护上述的node，而buckets聚合体则以vector完成。</p><p>bucket只维护指向第一个节点的指针。</p><h3 id="5-5-3-hashtable迭代器"><a href="#5-5-3-hashtable迭代器" class="headerlink" title="5.5.3 hashtable迭代器"></a>5.5.3 hashtable迭代器</h3><p>迭代器数据结构</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">__hashtable_iterator</span><span class="token punctuation">&#123;</span>node<span class="token operator">*</span> cur<span class="token punctuation">;</span><span class="token comment">// 指向节点</span>hashtable <span class="token operator">*</span>ht<span class="token punctuation">;</span><span class="token comment">//指向bucket，因为可能会跳到另一个bucket</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>hashtable的++操作可能会从当前bucket跳到另一个bucket，因此迭代器必须维持对整个vector的关系。</p><p>++操作：如果当前节点是list的尾端，则跳到下一个bucket</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110202103450.png"></p><p><strong>hashtable迭代器没有后退操作（ operator–() )</strong></p><h3 id="5-5-4-hashtable数据结构"><a href="#5-5-4-hashtable数据结构" class="headerlink" title="5.5.4 hashtable数据结构"></a>5.5.4 hashtable数据结构</h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110202321250.png"></p><p>模板说明：</p><ul><li>HashFcn：哈希函数类别</li><li>ExtractKey：从节点去除键值的方法，如identity类</li><li>EqualKey：判断键值是否相同的方法</li></ul><p>SGI以28个质数来设计表格大小，且已将其计算好，提供函数查询最接近某数并大于某数的质数</p><h3 id="5-5-5-hashtable构造和内存管理"><a href="#5-5-5-hashtable构造和内存管理" class="headerlink" title="5.5.5 hashtable构造和内存管理"></a>5.5.5 hashtable构造和内存管理</h3><p><strong>构造函数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110203028686.png"></p><p><strong>判断是否需要重建表格</strong></p><p>若现有元素个数大于vector大小，则需要重建</p><p>重建的方法其实就是将原来的bucket计算在新vector中的位置，然后将整个list插入过去</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110203147482.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110203203283.png"></p><p><strong>插入节点</strong></p><p>insert_unique插入键值不允许重复，注意新插入的节点会在bucket的第一个节点。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110203450355.png"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">HF</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Ex</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Eq</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">hashtable</span><span class="token operator">&lt;</span>V<span class="token punctuation">,</span> K<span class="token punctuation">,</span> HF<span class="token punctuation">,</span> Ex<span class="token punctuation">,</span> Eq<span class="token punctuation">,</span> A<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">insert_unique_noresize</span><span class="token punctuation">(</span>    <span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 决定obj的桶位置</span>  <span class="token keyword">const</span> size_type n <span class="token operator">=</span> <span class="token function">bkt_num</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// first指向bucket对应之串行头部</span>  node<span class="token operator">*</span> first <span class="token operator">=</span> buckets<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 如果位置已经被占用，即first!=0;循环遍历查找新位置</span>  <span class="token comment">//cur会结束的原因是：第一个插入节点的next会指向first，而此时first是0.</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>node<span class="token operator">*</span> cur <span class="token operator">=</span> first<span class="token punctuation">;</span> cur<span class="token punctuation">;</span> cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token function">get_key</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">get_key</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">iterator</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 离开以上循环，first指向bucket所值链表的头部节点</span>  <span class="token comment">// 产生新节点</span>  node<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token function">new_node</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  tmp<span class="token operator">-></span>next <span class="token operator">=</span> first<span class="token punctuation">;</span>  <span class="token comment">// 令节点成为链表的第一个节点</span>  buckets<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token comment">// 节点个数累加1</span>  <span class="token operator">++</span>num_elements<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">iterator</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>insert_equal允许重复，其逻辑和unique类似，只是如果找到相同键值则就在其前插入值，这就导致新插入值不一定在bucket的第一个节点</p><p><strong>判断元素插入处</strong></p><p>由于有些元素类别无法直接进行哈希运算，如字符串，需要取得其值才能计算（有些类需要指定如何获取键值）</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110205250550.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110205326459.png"></p><p><strong>复制和删除</strong></p><p>删除时需要对bucket中的每个节点进行内存释放</p><p>复制时先设置vector大小并置为null，然后对bucket中的每个节点进行复制</p><h3 id="5-5-6-hash-function"><a href="#5-5-6-hash-function" class="headerlink" title="5.5.6 hash function"></a>5.5.6 hash function</h3><p>SGI的hashtable无法处理char int long char*之外的元素类别，如string就会报错（unordered_set现在能处理string double等类别）</p><p>char int long 等整数类型的哈希函数是直接返回其原值</p><p>字符串哈希函数：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230110210424940.png"></p><h2 id="5-6-hash-set、hash-map、hash-multiset、hash-multimap"><a href="#5-6-hash-set、hash-map、hash-multiset、hash-multimap" class="headerlink" title="5.6 hash_set、hash_map、hash_multiset、hash_multimap"></a>5.6 hash_set、hash_map、hash_multiset、hash_multimap</h2><blockquote><p>现在c++都使用unordered开头，如unordered_set，hash_set这四种是SGI提供的</p></blockquote><p>这四种容器以hashtable为底层机制，其无自动排序能力（set会自动排序），其行为操作都是调用hashtable</p><p>hash_map是将元素类别设置pair&lt;const Key, T&gt;，然后提供取key仿函数即可转换为hashtable。</p><p>hash_set调用的hashtable的insert_unique()，而hash_multiset调用的hashtable的insert_equal()。</p><h1 id="六、算法"><a href="#六、算法" class="headerlink" title="六、算法"></a>六、算法</h1><p><strong>算法分类</strong></p><ul><li>质变算法：会改变操作对象之值；如copy、swap、replace、fill、remove、permutation、aprtition、random shuffling、sort等</li><li>非质变算法：不改变操作对象之值：find、search、count、for_each、equal、mismatch、max、min等</li></ul><p>质变算法一半提供两个版本：in-place–就地改变操作对象;copy–将操作对象的内容复制一份副本(通常以_copy结尾)，操作后返回。</p><p><strong>算法的泛型化</strong></p><p>关键在于把操作对象的型别抽象化，把操作对象的标识法和区间目标的移动行为抽象化，真个算法也就在一个抽象层面上工作了。</p><h2 id="6-1-数值算法"><a href="#6-1-数值算法" class="headerlink" title="6.1 数值算法"></a>6.1 数值算法</h2><p>SGI将其都实现于&lt;stl_numeric.h&gt;文件中。</p><h3 id="6-1-1accumulate"><a href="#6-1-1accumulate" class="headerlink" title="6.1.1accumulate"></a>6.1.1accumulate</h3><p>用来计算init和[first, last)内所有元素的总和</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230111194656990.png"></p><h3 id="6-1-2-adjacent-difference"><a href="#6-1-2-adjacent-difference" class="headerlink" title="6.1.2 adjacent_difference"></a>6.1.2 adjacent_difference</h3><p>用来计算[first, last)中相邻元素的差额，即记录没两个相邻值间的差值（后减前），另一版本可以传二元操作函数。</p><p>注意结果的第一个值是first，可以给result传first值，这也是代码中为啥使用tmp临时值的原因。</p><p>如果加法和减法是常规定义，则adjacent_difference和partial_sum是互逆操作。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230111195758986.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230111195808915.png"></p><h3 id="6-1-3-inner-product"><a href="#6-1-3-inner-product" class="headerlink" title="6.1.3 inner_product"></a>6.1.3 inner_product</h3><p>用于计算两组数据对应位置的内积之和，注意必须指定初值</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118195523934.png"></p><h3 id="6-1-4-partial-sum"><a href="#6-1-4-partial-sum" class="headerlink" title="6.1.4 partial_sum"></a>6.1.4 partial_sum</h3><p>用于计算局部总和，最后会使用一组数据记录对应位置之前的和</p><p>如果加法和减法是常规定义，那么partial_sum和adjacent_difference互为逆运算</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118195731956.png"></p><h3 id="6-1-5-power和itoa"><a href="#6-1-5-power和itoa" class="headerlink" title="6.1.5 power和itoa"></a>6.1.5 power和itoa</h3><p><strong>power</strong></p><p>非STL标准算法，用于计算某数的n幂次方。如果指定为乘法，则为乘幂次。</p><p>算法为了效率并非将原始数据乘以n次，而是将n不断除以2，看能除以多少次，然后将原数不断自身相乘多少次。</p><p><strong>itoa</strong></p><p>非STL标准算法，用于设定某个区间的内容</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118200609660.png"></p><h2 id="6-2-标准算法"><a href="#6-2-标准算法" class="headerlink" title="6.2 标准算法"></a>6.2 标准算法</h2><h3 id="6-2-1-equal、fill等"><a href="#6-2-1-equal、fill等" class="headerlink" title="6.2.1 equal、fill等"></a>6.2.1 equal、fill等</h3><p><strong>equal</strong></p><p>如果两个序列在[first, last]相等，则返回true。如果第二个序列元素较多，则多出来的元素不考虑。因此，需要先判断两个序列元素个数是否相等，才能判断其是否完全相等。</p><p><strong>fill</strong></p><p>将[first, last]内所有元素填充新值</p><p><strong>fill_n</strong></p><p>将[first, last]内的前n个元素填充新值，注意需要自己检查范围不可越界，或者使用inserter产生一个具有插入能力的迭代器。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118201348001.png"></p><p><strong>iter_swap</strong></p><p>将两个forwarditerators所指的对象对调。注意value_type返回的是一个T*指针。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118201551163.png"></p><p><strong>lexicographical_compare</strong></p><p>字典排列方式对两个序列，进行比较</p><ul><li>如果第一序列的元素较小，返回true,否则返回false</li><li>如果达到last1而尚未达到last2,返回true</li><li>如果达到last2而尚未达到last1,返回false</li><li>同时达到，返回false</li></ul><p><strong>max和min</strong></p><p>用于取较大值和较小值，都可以指定比较函数，注意比较的两个数类型必须相同。</p><p><strong>mismatch</strong></p><p>找出两个序列之间第一个不匹配点，需要保证第一序列不能比第二序列的元素个数少</p><p><strong>swap</strong></p><p>用于交换两个对象的内容</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118202110458.png"></p><h3 id="6-2-2-copy"><a href="#6-2-2-copy" class="headerlink" title="6.2.2 copy"></a>6.2.2 copy</h3><p>用于将输入区间内的元素复制到输出区间，copy更改的是迭代器所指对象，而非更改迭代器本身</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118202157052.png"></p><p>当复制结果的起点在原始区间内时，可能会发生错误，因为原始数据会被覆盖。copy会根据迭代器类型调用不同版本，可能会调用memmove函数来执行任务，其会将整个输入区间先复制。</p><p>vector的迭代器由于是原始指针，因此会调用memmove函数</p><h3 id="6-2-3-copy-backward"><a href="#6-2-3-copy-backward" class="headerlink" title="6.2.3 copy_backward"></a>6.2.3 copy_backward</h3><p>将[first, last]中的元素，以逆向复制到结果中，其实现和copy十分类似。</p><p>其所接受迭代器必须是bidirectionaliterators。</p><p>当复制结果的终点在原始果区间内时，可能会发生错误。</p><h2 id="6-3-set相关算法"><a href="#6-3-set相关算法" class="headerlink" title="6.3 set相关算法"></a>6.3 set相关算法</h2><p>STL提供了四种set(集合)相关的算法，分别是并集(union),交集(intersection)，差集(difference)、对称集(symmetic difference)</p><p>注意，当集合中存在重复元素时，其结果和直观定义所有不同</p><h3 id="6-3-1-set-union"><a href="#6-3-1-set-union" class="headerlink" title="6.3.1 set_union"></a>6.3.1 set_union</h3><p>用于计算两个集合S1和S2的并集，包含两个集合中的每一个元素，是一个稳定操作函数（元素相对顺序不变）。</p><p>若有重复元素，如果某个值在S1出现n次，在S2出现m次，每个结果中会出现max(m,n)次，其中n个来自S1，其余来自S2。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118210616021.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118210629080.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118210703803.png"></p><h3 id="6-3-2-set-intersection"><a href="#6-3-2-set-intersection" class="headerlink" title="6.3.2 set_intersection"></a>6.3.2 set_intersection</h3><p>求交集，不会改变元素相对顺序。</p><p>若有重复元素，如果某个值在S1出现n次，在S2出现m次，每个结果中会出现min(m,n)次，全部来自S1。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118210947226.png"></p><h3 id="6-3-3-set-difference"><a href="#6-3-3-set-difference" class="headerlink" title="6.3.3 set_difference"></a>6.3.3 set_difference</h3><p>用于求S1-S2，是一种稳定操作。</p><p>若有重复元素，如果某个值在S1出现n次，在S2出现m次，每个结果中会出现max(n-m)次，全部来自S1。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118211345411.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118211433357.png"></p><h3 id="6-3-4-set-symmetric-difference"><a href="#6-3-4-set-symmetric-difference" class="headerlink" title="6.3.4 set_symmetric_difference"></a>6.3.4 set_symmetric_difference</h3><p>用于求对称差集，即(S1-S2)U(S2-S1)，也是一种稳定操作。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118211639815.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118211655928.png"></p><h2 id="6-4-其他算法"><a href="#6-4-其他算法" class="headerlink" title="6.4 其他算法"></a>6.4 其他算法</h2><h3 id="6-4-1-单纯的数据处理"><a href="#6-4-1-单纯的数据处理" class="headerlink" title="6.4.1 单纯的数据处理"></a>6.4.1 单纯的数据处理</h3><h4 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a><strong>adjacent_find</strong></h4><p>找出第一个满足条件的相邻元素，有可指定操作函数版本。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118211953481.png"></p><h4 id="count和count-if"><a href="#count和count-if" class="headerlink" title="count和count_if"></a>count和count_if</h4><p>count将区间中所有元素与指定值比较，返回相等元素个数</p><p>count_if返回比较函数结果为true的元素个数</p><h4 id="find-find-if-find-end-find-first-of"><a href="#find-find-if-find-end-find-first-of" class="headerlink" title="find, find_if, find_end, find_first_of"></a>find, find_if, find_end, find_first_of</h4><p>find返回第一个相等的元素迭代器</p><p>find_if返回第一个令比较函数结果为true的元素迭代器</p><p>find_end在[first1, last1]中，查找[first2, last2]最后一次出现点，若不存在则返回last1。注意，不是查找子序列。</p><p>有两种实现：单向迭代器和双向迭代，以下是双向迭代器实现代码</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118212912369.png"></p><p>find_first_of在[first1, last1]中，以[first2, last2]中的元素为目标查找第一次出现点，若不存在则返回last1。注意，不是查找子序列，也不是增减元素得到的序列。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118213313726.png"></p><h4 id="for-each-transform"><a href="#for-each-transform" class="headerlink" title="for_each, transform"></a>for_each, transform</h4><p>for_each将仿函数f作用于区间中的每一个元素上。f不可以改变元素内容，因为输入迭代器是inputiterator。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118213504474.png"></p><p>transform将仿函数op作用于[first,last)中每个元素，并产生一个新序列。其result结果也可指向源端容器，另有版本可输入两个区间，操作函数操作两个元素。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118230231606.png"></p><h4 id="generate-generate-n"><a href="#generate-generate-n" class="headerlink" title="generate, generate_n"></a>generate, generate_n</h4><p>generate将运算结果填充到区间的所有元素上。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118213607242.png"></p><p>generate_n将运算结果填充到区间的前n个元素上。</p><h4 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h4><p>判断序列S2是否涵盖与序列S1（S2每个元素都出现于S1），两个序列必须是<strong>有序集合</strong>，元素可重复。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118221600461.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118221645407.png"></p><h4 id="max-element，min-element-merge"><a href="#max-element，min-element-merge" class="headerlink" title="max_element，min_element, merge"></a>max_element，min_element, merge</h4><p>max_element返回数值最大元素的迭代器</p><p>min_element返回数值最小元素的迭代器</p><p>merge将两个有序集合合并置于另一段空间</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118221912314.png"></p><h4 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h4><p>将区间中的元素重新排列，操作函数判定为true的放在区间前端，否则放在区间后段。不保证保留元素的原始相对位置，如果需要保留原始相对位置，应该使用stable_partition</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118223423379.png"></p><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>移除区间中与value相等的元素，其并未将相等元素真正删除，而是放于尾端。</p><p>array不适合使用remove和remove_if，因为其无法缩小尺寸导致被删除数据永远存在。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118223629835.png"></p><h4 id="remove-copy-remove-if-remove-copy-if"><a href="#remove-copy-remove-if-remove-copy-if" class="headerlink" title="remove_copy, remove_if, remove_copy_if"></a>remove_copy, remove_if, remove_copy_if</h4><p>remove_copy和remove相比只是将结果复制到一个新容器中，需保证新容器容量足够。</p><p>remove_if是指定一个判定函数，而不是数值。</p><p>remove_copy_if是上述两者结合</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118224023822.png"></p><h4 id="replace-replace-copy-replace-if-replace-copy-if"><a href="#replace-replace-copy-replace-if-replace-copy-if" class="headerlink" title="replace, replace_copy, replace_if, replace_copy_if"></a>replace, replace_copy, replace_if, replace_copy_if</h4><p>replace将区间所有old_value以new_value取代。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118224215390.png"></p><p>replace_copy唯一不同是即将结果输出到新容器中</p><p>replace_if可以设置判定函数</p><p>replace_copy_if是上述两者结合</p><h4 id="reverse-reverse-copy"><a href="#reverse-reverse-copy" class="headerlink" title="reverse, reverse_copy"></a>reverse, reverse_copy</h4><p>reverse将区间中的元素颠倒重排，由于迭代器类型不同，为不同迭代器设置了不同版本（只有随机迭代器才能比较大小）。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118224616548.png"></p><p>reverse_copy只是即将容器保存到新容器</p><h4 id="rotate-rotate-copy-swap-ranges"><a href="#rotate-rotate-copy-swap-ranges" class="headerlink" title="rotate, rotate_copy, swap_ranges"></a>rotate, rotate_copy, swap_ranges</h4><p>rotate将[first, middle)和[middle, last)内的元素互换。如有{1,2,3,4,5,6,7}，对3做旋转，则得到{3,4,5,6,7,1,2}。</p><p>swap_ranges()只能交换两个长度相同区间，而rotate区间长度可以不同，需保证第一区间长度大于等于第二区间长度</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118225150316.png"></p><p>rotate_copy同样也只是将结果保存到新容器中</p><h4 id="search-search-n"><a href="#search-search-n" class="headerlink" title="search, search_n"></a>search, search_n</h4><p>search在序列[first1,last1)中，查找序列[first2,last2)的首次出现点，若不存在则返回last1。</p><blockquote><p>注意这个函数是查找序列，而find_first_of不是找序列，是找存在任意一个元素即可</p></blockquote><p>search_n在序列[first1,last1)中，查找连续n个序列[first2,last2)的首次出现点</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118225654750.png"></p><h4 id="unique-unique-copy"><a href="#unique-unique-copy" class="headerlink" title="unique, unique_copy"></a>unique, unique_copy</h4><p>unique能够移除重复元素，其只会移除相邻重复元素。如果要移除所有重复元素，需要先排序。其是一个稳定算法。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230118230522565.png"></p><p>unique_copy也是将结果保存到新容器中</p><h3 id="6-4-2-lower-bound和upper-bound"><a href="#6-4-2-lower-bound和upper-bound" class="headerlink" title="6.4.2 lower_bound和upper_bound"></a>6.4.2 lower_bound和upper_bound</h3><p><strong>lower_bound</strong></p><ul><li><p>利用二分查找在<strong>已排序</strong>的序列中寻找元素value，返回的迭代器指向第一个不小于value的元素。</p></li><li><p>返回值是在不破坏排序状态下，可插入value的第一个位置。</p></li></ul><p><strong>upper_bound</strong></p><ul><li>同样要求序列必须已排序，返回可插入value的最后一个位置</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201170656919.png"></p><p>lower_bound代码实现：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201170727806.png"></p><h3 id="6-4-3-binary-search"><a href="#6-4-3-binary-search" class="headerlink" title="6.4.3 binary_search"></a>6.4.3 binary_search</h3><p>利用二分查找在<strong>已排序</strong>的序列中寻找元素value，若未找到则返回false</p><p>其实现是先使用lower_bound先找到第一value位置，然后判断是否是需要查找的目标</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201171256786.png"></p><h3 id="6-4-4-next-permutation和prev-permutation"><a href="#6-4-4-next-permutation和prev-permutation" class="headerlink" title="6.4.4 next_permutation和prev_permutation"></a>6.4.4 next_permutation和prev_permutation</h3><p><strong>next_permutation</strong>：取得[first,last)所标示的下一个排列组合，有就返回true,否则返回false</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201190857878.png"></p><p><strong>prev_permutation</strong>：取得[first,last)所标示的前一个排列组合</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201191008355.png"></p><h3 id="6-4-5-random-shuffle"><a href="#6-4-5-random-shuffle" class="headerlink" title="6.4.5 random_shuffle"></a>6.4.5 <strong>random_shuffle</strong></h3><p>将序列中的元素随机重排</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201191100622.png"></p><h3 id="6-4-6-paitial-sort"><a href="#6-4-6-paitial-sort" class="headerlink" title="6.4.6 paitial_sort"></a>6.4.6 paitial_sort</h3><p>对序列 [first, last) 的部分进行排序，使得middle-first个最小元素以递增顺序位于首部，其余元素无特定顺序位于尾部。</p><p>paitial_sort相比sort效率更高，只需挑出前N个最小元素进行排序</p><p><strong>实现</strong>：是将[first, middle) 作为一个最大堆，然后后面每个元素皆与第一个元素比较，最后再使用sort_heap()将[first, middle) 进行排序。</p><h3 id="6-4-7-sort"><a href="#6-4-7-sort" class="headerlink" title="6.4.7 sort"></a>6.4.7 sort</h3><p>接受两个RandomAccesslterators，然后将区间内的所有元素以渐增方式重新排列</p><p>vector和dequeue适合使用sort算法</p><p><strong>sort实现</strong>：当数据量较大时采用快速排序，当数据量较小时使用插入排序（SGI阈值是16）。通常都是先使用快速排序完成粗略的排序，此时段间有序，段内无序，然后使用插入排序完成段内排序。</p><p><strong>median-of-Three</strong>：为了避免排序元素不随机，整个序列的头、尾、中央三个元素的中值作为枢纽</p><p>快速排序的分割算法实现：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201192424865.png"></p><p><strong>introsort</strong></p><p>此算法是快速排序的改进，能有效避免算法恶化为O(N^2^)。</p><p>其通过先计算快速排序最大需要递归次数N，然后若当前递归次数达到N时，就使用堆排序进行排序，</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201192916195.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201192923452.png"></p><h3 id="6-4-8-equal-range"><a href="#6-4-8-equal-range" class="headerlink" title="6.4.8 equal_range"></a>6.4.8 equal_range</h3><p>是二分查找法的一个版本。试图在<strong>已排序</strong>的[first,last)中寻找value。它返回一对迭代器i和j,i是在不破坏次序的前提下，value可以插入的第一个位置，j则是最后一个。因此 [i, j) 内都是value。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201193159640.png"></p><p>其实现是先找到value位置，然后在value前部分使用lower_bound找到第一个value值，在value后半部分使用uupper_bound找到最后一个value。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201193430401.png"></p><h3 id="6-4-9-inplace-merge"><a href="#6-4-9-inplace-merge" class="headerlink" title="6.4.9 inplace_merge"></a>6.4.9 inplace_merge</h3><p>将两个连在一起且已排序的序列[first,middle) 和[middle, last) 合并成一个序列，合并结果有序。</p><p>其是一种稳定操作，不会改变相同元素次序。</p><blockquote><p>merge和inplace_merge区别？</p><p>merge：将两个有序但分离的区间合并</p><p>inplace_merge：将两个有序但不分离的区间合并</p></blockquote><p>注意，这个算法会使用额外的内存空间效率会高很多，但没有缓冲区也能运作。</p><p>当缓冲区空间充足时，将其中一个序列复制到缓冲区中，然后使用merge完成剩余工作。当缓冲区空间不足时，则将处理长度减半，看是否能容纳与缓冲区中。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201194411471.png"></p><h3 id="6-4-10-nth-element"><a href="#6-4-10-nth-element" class="headerlink" title="6.4.10 nth_element"></a>6.4.10 nth_element</h3><p>重新排列，使得迭代器nth所指的元素，与整个迭代队列完整排序之后，同一位置的元素同值。同时保证[nth,last)内没有任何一个元素小于[first,nth)；但对于[first,nth)和[nth,last)两个子区间内的元素次序则无任何保证。</p><p>简单来说就是将大于某值的元素置于尾部，小于的置于首部。其做法是不断进行递归，判断nth迭代器落在左子序列中还是右子序列中，然后再对那个序列进行分割。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201203330511.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201203943805.png"></p><h3 id="6-4-11-merge-sort"><a href="#6-4-11-merge-sort" class="headerlink" title="6.4.11 merge sort"></a>6.4.11 merge sort</h3><p>即归并排序，可利用inplace_merge实现。</p><p>其复杂度虽然为O(NlogN)，但由于需要额外空间和不断移动数据，因此效率比不上快速排序</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201204220642.png"></p><h1 id="七、仿函数"><a href="#七、仿函数" class="headerlink" title="七、仿函数"></a>七、仿函数</h1><p>仿函数是一个行为类似函数的对象，需要重载  ()  操作符</p><blockquote><p>有函数指针为啥还需要仿函数？</p><p>函数指针不能满足STL对抽象性的要求，且无法和STL其他组件搭配产生灵活变化</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230201205148990.png"></p><p>仿函数的分类：</p><ul><li>按操作数的个数：一元和二元仿函数</li><li>按功能划分：算术运算、关系运算、逻辑运算。</li></ul><h2 id="7-1-可配接-Adaptable-的关键"><a href="#7-1-可配接-Adaptable-的关键" class="headerlink" title="7.1 可配接(Adaptable)的关键"></a>7.1 可配接(Adaptable)的关键</h2><p>仿函数需要定义相应型别才能让配接器取出，从而获得仿函数的某些信息。</p><p>仿函数型别主要有函数参数类型和传回值型别。</p><p>STL定义了两个class，分别代表一元仿函数和二元仿函数（不支持三元仿函数），其中只有型别定义，无任何成员函数或变量。任何仿函数只需继承其一即可拥有配接能力。</p><p><strong>unary_function</strong></p><p>呈现一元函数的参数型别和返回类型</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202103705069.png"></p><p><strong>binary_function</strong></p><p>用来呈现二元函数的参数型别和返回值类型。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202103916695.png"></p><h2 id="7-2-算数类仿函数"><a href="#7-2-算数类仿函数" class="headerlink" title="7.2 算数类仿函数"></a>7.2 算数类仿函数</h2><p>STL提供一些算术类仿函数：</p><ul><li>加法：plus</li><li>减法：minus</li><li>乘法:multiplies</li><li>除法：divides</li><li>膜取(modulus):modulus</li><li>否定(negation):negate</li></ul><p><strong>证同元素（identity_element）</strong></p><p>数值A若与该元素做OP运算，会得到A自己。加法的同证元素为0，因为任何匀速加上0仍为自己。乘法的同证元素为1，因为任何元素乘以1任然为自己</p><h2 id="7-3-关系运算类仿函数"><a href="#7-3-关系运算类仿函数" class="headerlink" title="7.3 关系运算类仿函数"></a>7.3 关系运算类仿函数</h2><p>STL提供一些关系类仿函数：</p><ul><li>等于：equal_to</li><li>不等于：not_equal_to</li><li>大于: greater</li><li>大于或者等于：greater_equal</li><li>小于：less</li><li>小于或者等于:less_equal</li></ul><h2 id="7-4-逻辑运算类仿函数"><a href="#7-4-逻辑运算类仿函数" class="headerlink" title="7.4 逻辑运算类仿函数"></a>7.4 逻辑运算类仿函数</h2><p>其中And和Or为二元运算符，Not为一元运算符</p><ul><li>And: logical_and</li><li>Or: logical_or</li><li>Not: logical_not</li></ul><h2 id="7-5-证同-identity-、选择-select-、投射-project"><a href="#7-5-证同-identity-、选择-select-、投射-project" class="headerlink" title="7.5 证同(identity)、选择(select)、投射(project)"></a>7.5 证同(identity)、选择(select)、投射(project)</h2><p>皆非STL标准，这三个仿函数只是将参数原封不动传回，设计这三个仿函数是为了间接性（抽象）</p><p><strong>证同</strong></p><ul><li>任何数值通过此函数后，不会有任何改变，此式运用于用来指定RB-tree所需要的KeyOfValue op ，因为set元素的键值即实值，所以采用identity</li></ul> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">identity</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">unary_function</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span><span class="token class-name">T</span><span class="token operator">></span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">&#125;</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>选择</strong></p><ul><li>接受一个pair,传回第一元素。此式运用于用来指定RB-tree所需要的KeyOfValue op ，因为map系以pair元素的第一个元素为其键值，所以采用select1st。</li></ul><p><strong>投射</strong></p><ul><li>传回第一参数，忽略第二参数</li></ul><h1 id="八、配接器"><a href="#八、配接器" class="headerlink" title="八、配接器"></a>八、配接器</h1><p>配接器分类</p><ul><li><strong>function adapter</strong>: 改变仿函数(functors)接口</li><li><strong>container adapter</strong>: 改变容器(container)接口</li><li><strong>iterators adapter</strong>: 改变迭代器接口</li></ul><h2 id="8-1-container-adapters"><a href="#8-1-container-adapters" class="headerlink" title="8.1 container adapters"></a>8.1 container adapters</h2><p>stack和queue底层皆由deque构成，其都是封住了deque对外接口，只开放符合原则的几个函数。</p><h2 id="8-2-iterator-adapters"><a href="#8-2-iterator-adapters" class="headerlink" title="8.2 iterator adapters"></a>8.2 iterator adapters</h2><h3 id="8-2-1-insert-iterators"><a href="#8-2-1-insert-iterators" class="headerlink" title="8.2.1 insert iterators"></a>8.2.1 insert iterators</h3><ul><li><p>将一般迭代器的赋值转换为插入操作，主要有back_insert_iterator、front_insert_iterator、insert_iterator。</p></li><li><p>每一个insert iterator内部都维护一个容器，调用其operator&#x3D;操作符时实际是在调用底层容器的push_front()或Push_back()或insert()</p></li><li><p>上述三种配接器使用不直观，提供三个相应函数来操作<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202112047682.png"></p></li></ul><p>back_insert_iterator实现代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202144747631.png"></p><p>back_insert辅助函数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202144819846.png"></p><h3 id="8-2-2-reverse-iterators"><a href="#8-2-2-reverse-iterators" class="headerlink" title="8.2.2 reverse iterators"></a>8.2.2 reverse iterators</h3><p>将一般迭代器的移动方向逆转，如原来的++操作变成后退，–操作变成前进</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator ite<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>id<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reverse_iterator<span class="token operator">&lt;</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator<span class="token operator">></span> <span class="token function">rite</span><span class="token punctuation">(</span>ite<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>STL容器提供的rbegin()和rend()定义都类似如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202145353274.png"></p><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202145900054.png"></p><p>由于迭代器区间的“前闭后开”的习惯，当迭代器被逆向方向时，虽然实体位置(真正的地址)不变，但其逻辑位置(迭代器所代表的元素)改变了(必须如此改变)：因此正向和其逆向迭代器所取出的是不同的元素。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202145804973.png"></p><p>reverse iterator实现：</p><p><em>操作符重载是核心，*<em>对逆向迭代器取值，就是将“对应之正向迭代器”后退一格而后取值。</em></em></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202150412826.png"></p><h3 id="8-2-3-stream-iterators"><a href="#8-2-3-stream-iterators" class="headerlink" title="8.2.3 stream iterators"></a>8.2.3 stream iterators</h3><ul><li><p>可以将一个迭代器绑定到一个stream对象上。绑定到istream对象例如(std::cin)，就是istream_iterator拥有输入能力，同理输出对象上有输出能力。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202112612289.png"></p></li><li><p>istream iterator内部会维护一个istream member，对迭代器做的++操作都会调用istream member的输入操作。</p></li></ul><p>istream_iterator代码实现：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202151358555.png"></p><p>注意，只要定义一个istream iterator且绑定某个istream object，程序便会一直停留在read()上，等待输入。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202151633586.png"></p><h2 id="8-3-function-adapters"><a href="#8-3-function-adapters" class="headerlink" title="8.3 function adapters"></a>8.3 function adapters</h2><ul><li><p>所有期望获得配接能力的组件，本身都必须是可配接的。</p></li><li><p>STL提供的函数配接器也能用于一般函数和成员函数，但一般函数需经ptr_fun处理，成员函数需经mem_fun处理。</p></li><li><p><strong>函数配接器内部存在一个member object，只有真正调用某个函数配接器时，才会对其member object进行操作。</strong></p></li><li><p>常见配接器的辅助函数如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202113640598.png"></p></li></ul><p>示例：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202154222284.png"></p><h3 id="8-3-1-逻辑否定：not1和not2"><a href="#8-3-1-逻辑否定：not1和not2" class="headerlink" title="8.3.1 逻辑否定：not1和not2"></a>8.3.1 逻辑否定：not1和not2</h3><p>not1用于一元操作，not2用于二元操作</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202154754141.png"></p><h3 id="8-3-2-参数绑定：bind1st和bind2nd"><a href="#8-3-2-参数绑定：bind1st和bind2nd" class="headerlink" title="8.3.2 参数绑定：bind1st和bind2nd"></a>8.3.2 参数绑定：bind1st和bind2nd</h3><p>bind1st用于绑定第一个参数，bind2nd用于绑定第二个参数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202154912324.png"></p><h3 id="8-3-3-函数合成：compose1和compose2"><a href="#8-3-3-函数合成：compose1和compose2" class="headerlink" title="8.3.3 函数合成：compose1和compose2"></a>8.3.3 函数合成：compose1和compose2</h3><p>compose1接受两个参数，即调用 op1(op2)</p><p>compose2接受三个参数，即调用 op1(op2, op3)</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202155149637.png"></p><h3 id="8-3-4-用于函数指针：ptr-fun"><a href="#8-3-4-用于函数指针：ptr-fun" class="headerlink" title="8.3.4 用于函数指针：ptr_fun"></a>8.3.4 用于函数指针：ptr_fun</h3><p>这种配接器使得我们能够将一般函数当做仿函数使用，将一般函数当做仿函数传给STL算法。</p><p>其实质就是把一个函数指针包裹成一个函数对象使用。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202155501470.png"></p><h3 id="8-3-5-用于成员函数指针：mem-fun和mem-fun-ref"><a href="#8-3-5-用于成员函数指针：mem-fun和mem-fun-ref" class="headerlink" title="8.3.5 用于成员函数指针：mem_fun和mem_fun_ref"></a>8.3.5 用于成员函数指针：mem_fun和mem_fun_ref</h3><p>这种配接器使得我们能够将成员函数当做仿函数来进行使用，使得成员函数可以搭配各种泛型算法。</p><p>当一个容器中存储 X* 时，可以用virtual成员函数作为仿函数，从而由泛型算法完成多态调用（示例可见p489）。<strong>这是泛型和多态之间的重要接轨。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202155913739.png"></p><p>mem_fun代码实现：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202160345735.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202160416099.png"></p><p>mem_fun_ref代码实现：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202160448092.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230202160521723.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小林coding-操作系统-笔记</title>
      <link href="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>总结知识点，以便以后快速复习。</p><p><em>参考小林coding操作系统</em>, <a href="https://www.xiaolincoding.com/os/">地址</a></p><h1 id="一、硬件结构"><a href="#一、硬件结构" class="headerlink" title="一、硬件结构"></a>一、硬件结构</h1><h2 id="1-1-CPU-是如何执行程序的？"><a href="#1-1-CPU-是如何执行程序的？" class="headerlink" title="1.1 CPU 是如何执行程序的？"></a>1.1 CPU 是如何执行程序的？</h2><h2 id="1-2-磁盘比内存慢几万倍？"><a href="#1-2-磁盘比内存慢几万倍？" class="headerlink" title="1.2 磁盘比内存慢几万倍？"></a>1.2 磁盘比内存慢几万倍？</h2><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317105246779.png" style="zoom:67%;" /><hr><h3 id="存储器级别划分"><a href="#存储器级别划分" class="headerlink" title="存储器级别划分"></a><strong>存储器级别划分</strong></h3><ul><li><p>寄存器：寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写。寄存器的数量通常在几十到几百之间，每个寄存器可以用来存储一定的字节（byte）的数据</p></li><li><p>CPU Cache：用的是一种叫 SRAM（静态随机存储器） 的芯片，存储密度不高。只要有电，数据就可以保持存在。</p><ol><li>L1-Cache：每个 CPU 核心都有一块属于自己的 L1 高速缓存，访问速度通常只需要 <code>2~4</code> 个时钟周期，而大小在几十 KB 到几百 KB 不等。通常分成<strong>指令缓存</strong>和<strong>数据缓存</strong>（分开存放）。</li><li>L2-Cache：每个 CPU 核心都有，通常大小在几百 KB 到几 MB 不等，速度在 <code>10~20</code> 个时钟周期。</li><li>L3-Cahce：多个 CPU 核心共用，通常大小在几 MB 到几十 MB 不等，速度在 <code>20~60</code>个时钟周期</li></ol></li><li><p>内存：使用的是DRAM （动态随机存取存储器） 的芯片，内存速度大概在 <code>200~300</code> 个 时钟周期之间</p><blockquote><p>相比 SRAM，DRAM 的密度更高，功耗更低。</p><p>因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因</p></blockquote></li><li><p>SSD&#x2F;HDD 硬盘</p><ul><li>SSD结构和内存类似，断电后数据还是存在的，内存的读写速度比 SSD 大概快 <code>10~1000</code> 倍</li><li>机械硬盘（*, HDD*）是通过物理读写的方式来访问数据的，它的速度比内存慢 <code>10W</code> 倍左右。</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317105537831.png" style="zoom:50%;" /><blockquote><p>注意：</p><ul><li><p>CPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。</p></li><li><p>当 CPU 需要访问内存中某个数据的时候，会不断层级访问判断是否有该数据，如果没有则访问下一层级存储器</p></li><li><p>分级的目的是要构造<strong>缓存</strong>体系</p></li></ul></blockquote><h2 id="1-3-如何写出让-CPU-跑得更快的代码？"><a href="#1-3-如何写出让-CPU-跑得更快的代码？" class="headerlink" title="1.3 如何写出让 CPU 跑得更快的代码？"></a>1.3 如何写出让 CPU 跑得更快的代码？</h2><h3 id="CPU-Cache-的数据结构和读取过程"><a href="#CPU-Cache-的数据结构和读取过程" class="headerlink" title="CPU Cache 的数据结构和读取过程"></a><strong>CPU Cache 的数据结构和读取过程</strong></h3><ol><li>根据内存地址中索引信息，计算在 CPU Cache 中的索引，也就是找出对应的 CPU Cache Line 的地址；</li><li>找到对应 CPU Cache Line 后，判断 CPU Cache Line 中的有效位，确认 CPU Cache Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；</li><li>对比内存地址中组标记和 CPU Cache Line 中的组标记，确认 CPU Cache Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；</li><li>根据内存地址中偏移量信息，从 CPU Cache Line 的数据块中，读取对应的字。</li></ol><blockquote><p>上述过程是Cache直接映射计算方法，其使用的取模运算计算映射地址。</p><p>组标记是为了区分不同地址映射到相同位置，其实就是拿地址的前部分来判断。</p></blockquote><p><strong>注意，Cache每次读内存都是一块一块的读，也就是读取目标地址附近一个cache line大小的数据，可以利用此特性加快代码运行</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317114717676.png" style="zoom:80%;" /><hr><h3 id="如何写出让-CPU-跑得更快的代码？"><a href="#如何写出让-CPU-跑得更快的代码？" class="headerlink" title="如何写出让 CPU 跑得更快的代码？"></a><strong>如何写出让 CPU 跑得更快的代码？</strong></h3><ol><li><strong>提升数据缓存的命中率</strong><ul><li>按照内存布局顺序访问，将可以有效的利用 CPU Cache 带来的好处，这样我们代码的性能就会得到很大的提升</li><li>例如遍历二维数组的情况时，先遍历水平比先遍历竖直方向更快</li></ul></li><li><strong>提升指令缓存的命中率</strong><ul><li>对于 if 条件语句，会使用 CPU 的分支预测器预测跳转哪部分。如果分支预测可以预测到接下来要执行 的指令，就可以提前把这些指令放在指令缓存中，这样 CPU 可以直接从 Cache 读取到指令，于是执行速度就会很快。</li><li>例如先排序再用if判断比直接if判断分支预测更准确</li></ul></li><li><strong>提升多核 CPU 的缓存命中率</strong><ul><li>如果一个线程在不同核心来回切换，各个核心的缓存命中率就会受到影响，相反如果线程都在同一个核心上执行，那么其数据的 L1 和 L2 Cache 的缓存命中率可以得到有效提高，可以减少访问 内存的频率。</li><li>在 Linux 上提供了 <code>sched_setaffinity</code> 方法，来实现将线程绑定到某个 CPU 核心这一功能</li></ul></li></ol><h2 id="1-4-CPU-缓存一致性"><a href="#1-4-CPU-缓存一致性" class="headerlink" title="1.4 CPU 缓存一致性"></a>1.4 CPU 缓存一致性</h2><h3 id="CPU-Cache-的数据写入"><a href="#CPU-Cache-的数据写入" class="headerlink" title="CPU Cache 的数据写入"></a>CPU Cache 的数据写入</h3><p><strong>写直达</strong></p><p>保持内存与 Cache 一致性最简单的方式是，<strong>把数据同时写入内存和 Cache 中</strong>，这种方法称为<strong>写直达</strong></p><ul><li>写入前会先判断数据是否已经在 CPU Cache 里面了：<ul><li>如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面；</li><li>如果数据没有在 Cache 里面，就直接把数据更新到内存里面。</li></ul></li><li>缺点：每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响</li></ul><p><strong>写回</strong></p><p><strong>当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中</strong>，减少了数据写回内存的频率。</p><ul><li>如果当发生写操作时，数据已经在 CPU Cache 里的话，则把数据更新到 CPU Cache 里，同时标记 CPU Cache 里的这个 Cache Block 为脏的，代表这这个 Cache Block 的数据和内存是不一致的，这种情况是不用把数据写到内存里的；</li><li>如果当发生写操作时，数据所对应的 Cache Block 里存放的是「别的内存地址的数据」的话，就要检查这个 Cache Block 里的数据有没有被标记为脏的：<ul><li>如果是脏的话，我们就要把这个 Cache Block 里的数据<strong>写回到内存</strong>，然后再把当前要写入的数据从内存读入到 Cache Block 里，然后再把当前要写入的数据写入到 Cache Block，最后也把它标记为脏的；</li><li>如果不是脏的话，把当前要写入的数据先从内存读入到 Cache Block 里，接着将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的。</li></ul></li></ul><blockquote><p><strong>为什么缓存没命中时需要先从内存读取数据再写缓存？</strong></p><p>应该是为了配合下面的MESI协议保持多核之间的缓存一致性，MESI协议中一个cache从失效到独占状态都需要从内存读数据。</p><p>如果其他核心中存在已修改的数据，则需要写入到内存，然后当前核心从内存中读取。而如果其他核心无数据或数据为共享、独占状态，这样做的原因可能是为了统一操作。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317162141317.png" style="zoom:80%;" /><hr><h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>由于 L1&#x2F;L2 Cache 是多个核心各自独有的，那么会带来多核心的<strong>缓存一致性</strong></p><p>通常使用以下两点来同步两个不同核心里面的缓存数据：</p><ul><li>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播</strong><ul><li>当某个核心在 Cache 更新了数据，就需要同步到其他核心的 Cache 里</li></ul></li><li>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串行化</strong><ul><li>串行化是指其他核心要看到相同的数据变化顺序，否则即使有写传播也会造成混乱</li></ul></li></ul><p><strong>MESI 协议</strong></p><p>MESI 协议是写传播和事务串行化的实现，其通过总线来传播消息，每个核心都会监听总线上的广播事件。</p><p>可分为四种状态：</p><ul><li><em>Modified</em>，已修改：代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里</li><li><em>Exclusive</em>，独占：代表 Cache Block 里的数据和内存里面的数据是一致性的，但只存储在一个 CPU 核心的 Cache 里。<ul><li>如果要向独占的 Cache 写数据，就可以直接自由地写入，而不需要通知其他 CPU 核心</li><li>当核心读取了数据时，其会向其他核心发送通知，如果在其他核心是独占状态，则会将其改为共享状态。</li></ul></li><li><em>Shared</em>，共享：代表 Cache Block 里的数据和内存里面的数据是一致性的，但相同的数据在多个 CPU 核心的 Cache 里都有。<ul><li>要更新 Cache 里面的共享状态数据时，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。</li></ul></li><li><em>Invalidated</em>，已失效：表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据</li></ul><p>注意！这几个状态都是标记的一整个cache line。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317165044798.png" style="zoom:80%;" /><h2 id="1-5-CPU-是如何执行任务的？"><a href="#1-5-CPU-是如何执行任务的？" class="headerlink" title="1.5 CPU 是如何执行任务的？"></a>1.5 CPU 是如何执行任务的？</h2><h3 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h3><p>因为多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为<strong>伪共享</strong></p><ul><li>例如AB两个变量属于同一个cache line，A只会被1核心读写，B只会被2核心读写。如当1核心读取A时会将整个cache line读取，而其中又包括变量B，那么当改变变量A时，2核心的cache line也会通过MESI协议进行状态改变。同理2核心写B也会影响A。其实际并没有共享任何变量，从而造成性能影响。</li></ul><p><strong>避免伪共享的方法</strong></p><ul><li>在 Linux 内核中存在 <code>__cacheline_aligned_in_smp</code> 宏定义，是用于解决伪共享的问题。<ul><li>例如定义结构体时将其中的变量附上<code>__cacheline_aligned_in_smp</code>，就会使得变量分属于不同cache line，这其实是一种空间换时间的方法。</li></ul></li><li>Java 并发框架 Disruptor 使用「字节填充 + 继承」的方式，来避免伪共享的问题。</li></ul><hr><h3 id="CPU-如何选择线程的？"><a href="#CPU-如何选择线程的？" class="headerlink" title="CPU 如何选择线程的？"></a>CPU 如何选择线程的？</h3><blockquote><p>在 Linux 内核中，进程和线程都是用 <code>task_struct</code> 结构体表示的，区别在于线程的 task_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程</p></blockquote><p>在 Linux 系统中，根据任务的优先级以及响应要求，主要分为两种，其中优先级的数值越小，优先级越高：</p><ul><li>实时任务，对系统的响应时间要求很高，也就是要尽可能快的执行实时任务，优先级在 <code>0~99</code> 范围内的就算实时任务；</li><li>普通任务，响应时间没有很高的要求，优先级在 <code>100~139</code> 范围内都是普通任务级别</li></ul><p><strong>Linux 系统调度类</strong></p><ul><li>Deadline 和 Realtime 这两个调度类，都是应用于实时任务<ul><li><em>SCHED_DEADLINE</em>：距离当前时间点最近的 deadline 的任务会被优先调度；</li><li><em>SCHED_FIFO</em>：对于相同优先级的任务，按先来先服务的原则，但是优先级更高的任务，可以抢占低优先级的任务；</li><li><em>SCHED_RR</em>：对于相同优先级的任务，轮流着运行，每个任务都有一定的时间片，当用完时间片的任务会被放到队列尾部，以保证相同优先级任务的公平性，但是高优先级的任务依然可以抢占低优先级的任务；</li></ul></li><li>Fair 调度类是应用于普通任务，都是由 CFS 调度器管理的<ul><li><em>SCHED_NORMAL</em>：普通任务使用的调度策略；</li><li><em>SCHED_BATCH</em>：后台任务的调度策略，不和终端进行交互，因此在不影响其他需要交互的任务，可以适当降低它的优先级。</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317172758100.png" style="zoom:67%;" /><p><strong>完全公平调度</strong></p><ul><li>为每个任务安排一个虚拟运行时间 vruntime，如果一个任务在运行，其运行的越久，该任务的 vruntime 自然就会越大，而没有被运行的任务，vruntime 是不会变化的。<strong>在 CFS 算法调度的时候，会优先选择 vruntime 少的任务</strong></li><li>当考虑任务权重时，存在以下公式进行计算vruntime，NICE_0_LOAD 是一个常量<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317173136791.png" style="zoom:80%;" /></li></ul><p><strong>CPU 运行队列</strong></p><p>每个 CPU 都有自己的<strong>运行队列</strong>，用于描述在此 CPU 上所运行的所有进程，其队列包含三个运行队列：</p><ul><li>Deadline 运行队列 dl_rq</li><li>实时任务运行队列 rt_rq </li><li>CFS 运行队列 cfs_rq，其中 cfs_rq 是用红黑树来描述的，按 vruntime 大小来排序的，最左侧的叶子节点，就是下次会被调度的任务。</li></ul><p>调度类是有优先级的，优先级如下：Deadline &gt; Realtime &gt; Fair，会优先调度优先级高的调度类，因此<strong>实时任务总是会比普通任务优先被执行</strong></p><p><strong>调整优先级</strong></p><p>Linux默认情况下都是普通任务，普通任务的调度类是 Fair，由 CFS 调度器来进行管理。</p><p>可以调整任务的 <code>nice</code> 值，来间接影响任务优先级，其范围是 <code>-20～19</code>（nice值可以看成对任务优先级的修正，priority(new) &#x3D; priority(old) + nice）</p><h2 id="1-6-什么是软中断？"><a href="#1-6-什么是软中断？" class="headerlink" title="1.6 什么是软中断？"></a>1.6 什么是软中断？</h2><blockquote><p>中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。</p></blockquote><p>Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」。</p><ul><li>上半部用来快速处理中断，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。<ul><li>上半部直接处理硬件请求，也就是<strong>硬中断</strong>，主要是负责耗时短的工作，特点是快速执行</li></ul></li><li>下半部用来延迟处理上半部未完成的工作，一般以「内核线程」的方式运行。<ul><li>下半部是由内核触发，也就是<strong>软中断</strong>，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；</li><li>软中断不只是包括硬件设备中断处理程序的下半部，一些内核自定义事件也属于软中断，比如内核调度等</li><li>每一个 CPU 都对应一个软中断内核线程，名字通常为「ksoftirqd&#x2F;CPU 编号」</li></ul></li></ul><h2 id="1-7-为什么-0-1-0-2-不等于-0-3-？"><a href="#1-7-为什么-0-1-0-2-不等于-0-3-？" class="headerlink" title="1.7 为什么 0.1 + 0.2 不等于 0.3 ？"></a>1.7 为什么 0.1 + 0.2 不等于 0.3 ？</h2><h3 id="为什么负数要用补码表示？"><a href="#为什么负数要用补码表示？" class="headerlink" title="为什么负数要用补码表示？"></a>为什么负数要用补码表示？</h3><ul><li>正数存储：最高位是作为「符号标志位」，剩余的 31 位则表示二进制数据。正数的符号位是 <code>0</code>，负数的符号位是 <code>1</code>。</li><li>负数存储：最高位是作为「符号标志位」，剩余的以「补码」表示的，所谓的补码就是把正数的二进制全部取反再加 1</li></ul><p>负数之所以用补码的方式来表示，主要是为了统一和正数的加减法，使得不必根据是否为负数来调整操作。</p><hr><h3 id="十进制小数怎么转成二进制？"><a href="#十进制小数怎么转成二进制？" class="headerlink" title="十进制小数怎么转成二进制？"></a>十进制小数怎么转成二进制？</h3><p>十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317202013256.png" style="zoom:50%;" /><h3 id="计算机是怎么存小数的？"><a href="#计算机是怎么存小数的？" class="headerlink" title="计算机是怎么存小数的？"></a>计算机是怎么存小数的？</h3><p>计算机是以浮点数的形式存储小数的，包含三个部分：</p><ul><li>符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li><li>指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；</li><li>尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li></ul><p><strong>转换成二进制浮点数</strong></p><ul><li><p>先将数整体部分和小数部分都转换为二进制</p></li><li><p>然后把小数点，移动到第一个1后面，计算移动位数，小数点向左移为+，右移为减。然后小数点后的即为尾数。</p></li><li><p>指数位&#x3D;移动位数+偏移量，float 的话偏移量是 127。</p><blockquote><p>指数可能是正数，也可能是负数，为了减少不必要的麻烦，在实际存储指数的时候，需要把指数转换成<strong>无符号整数</strong>。</p><p>float 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 <code>-126 ~ +127</code>，于是为了把指数转换成无符号整数，就要加个<strong>偏移量</strong>，比如 float 的指数偏移量是 <code>127</code>，这样指数就不会出现负数了。</p></blockquote></li></ul><p> <strong>float 的二进制浮点数转换成十进制</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317202908467.png"></p><h3 id="0-1-0-2-x3D-x3D-0-3-吗？"><a href="#0-1-0-2-x3D-x3D-0-3-吗？" class="headerlink" title="0.1 + 0.2 &#x3D;&#x3D; 0.3 吗？"></a>0.1 + 0.2 &#x3D;&#x3D; 0.3 吗？</h3><p>0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。</p><h1 id="二、操作系统结构"><a href="#二、操作系统结构" class="headerlink" title="二、操作系统结构"></a>二、操作系统结构</h1><h2 id="2-1-Linux-内核-vs-Windows-内核"><a href="#2-1-Linux-内核-vs-Windows-内核" class="headerlink" title="2.1 Linux 内核 vs Windows 内核"></a>2.1 Linux 内核 vs Windows 内核</h2><p><strong>什么是内核？</strong></p><p>内核是应用连接硬件设备的桥梁，一般会提供 4 个基本能力：</p><ul><li>管理进程、线程，决定哪个进程、线程使用 CPU，也就是<strong>进程调度</strong>的能力；</li><li>管理内存，决定内存的分配和回收，也就是<strong>内存管理</strong>的能力；</li><li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是<strong>硬件通信</strong>能力；</li><li><strong>提供系统调用</strong>，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。</li></ul><p>多数操作系统，把内存分成了两个区域：</p><ul><li>内核空间，这个内存空间只有内核程序可以访问，即<strong>内核态</strong>执行；</li><li>用户空间，这个内存空间专门给应用程序使用，即<strong>用户态</strong>执行；</li></ul><p><strong>系统调用过程</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317204720389.png" style="zoom: 67%;" /><hr><h3 id="Linux-的设计"><a href="#Linux-的设计" class="headerlink" title="Linux 的设计"></a>Linux 的设计</h3><p>Linux 内核设计的理念主要有这几个点：</p><ul><li><em>MultiTask</em>，多任务：可以有多个任务同时执行，这里的「同时」可以是并发或并行</li><li><em>SMP</em>，对称多处理：每个 CPU 的地位是相等的，对资源的使用权限也是相同的，多个 CPU 共享同一个内存，每个 CPU 都可以访问完整的内存和硬件资源。</li><li><em>ELF</em>，可执行文件链接格式：是 Linux 操作系统中可执行文件的存储格式</li><li><em>Monolithic Kernel</em>，宏内核：宏内核的特征是系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。</li></ul><blockquote><p><strong>微内核</strong></p><ul><li><p>微内核架构的内核只保留最基本的能力，比如进程调度、虚拟机内存、中断等，把一些应用放到了用户空间，比如驱动程序、文件系统等。</p></li><li><p>这样服务与服务之间是隔离的，单个服务出现故障或者完全攻击，也不会导致整个操作系统挂掉，提高了操作系统的稳定性和可靠性。</p></li><li><p>缺点：由于驱动程序不在内核中，其会频繁调用底层能力，于是就需要频繁切换到内核态，带来性能损耗</p></li></ul><p><strong>混合内核</strong></p><ul><li>是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序；</li></ul></blockquote><hr><h3 id="Windows-设计"><a href="#Windows-设计" class="headerlink" title="Windows 设计"></a>Windows 设计</h3><p>Window 的内核设计则是采用了混合内核</p><p>Windows 的可执行文件格式叫 PE，称为<strong>可移植执行文件</strong>，扩展名通常是<code>.exe</code>、<code>.dll</code>、<code>.sys</code>等</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230317205424836.png" style="zoom:50%;" /><h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><h2 id="3-1-为什么要有虚拟内存？"><a href="#3-1-为什么要有虚拟内存？" class="headerlink" title="3.1 为什么要有虚拟内存？"></a>3.1 为什么要有虚拟内存？</h2><p>如果程序都直接操纵物理地址，那么不仅内存利用率低，且程序的迁移性也差。</p><p>操作系统为每个进程分配独立的一套「<strong>虚拟地址</strong>」，并提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</p><blockquote><p><strong>如何转换地址？</strong></p><p>虚拟地址通过 CPU 芯片中的内存管理单元（MMU），来转换变成物理地址</p></blockquote><hr><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段的形式把这些段分离出来。</p><p><strong>分段机制下，虚拟地址和物理地址是如何映射的？</strong></p><p>分段机制下的虚拟地址由两部分组成：</p><ul><li>段选择因子：保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。</li><li>段内偏移量：位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li></ul><p><strong>分段机制不足</strong></p><ul><li>内存碎片：由于每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以会出现外部<strong>内存碎片</strong>，其<strong>不存在内部碎片</strong>。可以使用<strong>内存交换</strong>解决外部内存碎片（将碎片合并）。</li><li>内存交换效率低：内存交换是将内存展示写入硬盘，但硬盘访问速度十分慢。如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</li></ul><hr><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间叫<strong>页</strong>。在 Linux 下，每一页的大小为 4KB。</p><p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，页表是存储在内存里的</p><p>当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p><p><strong>优缺点</strong></p><ul><li>采用了分页，页与页之间是紧密排列的，所以不会有外部碎片，但会有内部内存碎片。</li><li>当内存不足时，每次从硬盘读取写入的都只有几个页，内存交换的效率就相对比较高。</li><li>不再需要一次性都把程序加载到物理内存中，<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去</strong>。</li></ul><p><strong>分页机制下，虚拟地址和物理地址是如何映射的？</strong></p><p>虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。转换过程如下：</p><ul><li>把虚拟内存地址，切分成页号和偏移量；</li><li>根据页号，从页表里面，查询对应的物理页号；</li><li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li></ul><p><strong>多级页表</strong></p><p>一级页表会导致占用内存过大，解决办法即多级页表</p><ul><li>当前页表中存储下一级页表地址</li><li>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。从而达到节约内存作用。</li></ul><blockquote><p><strong>为什么不分级的页表就做不到这样节约内存呢？</strong></p><p>对于每个虚拟地址，查找页表时需要找到其对应（区间）位置，一级页表直接存储物理地址则就需要将所有地址进行存储，而多级页表存储的是一个页表位置，可以在下一页表中继续查找，而不会直接查找失败。</p></blockquote><p><strong>TLB</strong></p><p>多级页表需要多次地址转换，而程序是有局部性的，利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，因此加入了存储最常访问的页表项的 Cache，这个 Cache 就是 TLB。</p><p>CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表</p><hr><h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p>段页式内存管理实现的方式：</p><ul><li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</li><li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li></ul><p>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。</p><p><strong>地址转换过程</strong></p><ul><li>第一次访问段表，得到页表起始地址；</li><li>第二次访问页表，得到物理页号；</li><li>第三次将物理页号与页内位移组合，得到物理地址。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318105243087.png" style="zoom: 80%;" /><hr><h3 id="Linux-内存布局"><a href="#Linux-内存布局" class="headerlink" title="Linux 内存布局"></a>Linux 内存布局</h3><p><strong>Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制</strong>。</p><ul><li>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。</li><li>Linux 把所有段的基地址设为 <code>0</code>，因此包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），段只被用于访问控制和内存保护。</li><li>通俗讲，由于段基地址都设为0，那么所有段其实就共用了一个地址空间，而段只是作为内存访问控制保护用。</li></ul><p>虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318160056933.png" style="zoom: 67%;" /><p>虽然每个进程都各自有独立的虚拟内存，但是<strong>每个虚拟内存中的内核地址，其实关联的都是相同的物理内存</strong>。这样，进程切换到内核态后，就可以很方便地访问内核空间内存</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318160158361.png" style="zoom:67%;" /><p><strong>用户空间分布的情况</strong></p><ul><li>代码段，包括二进制可执行代码；</li><li>数据段，包括已初始化的静态常量和全局变量；</li><li>BSS 段，包括未初始化的静态变量和全局变量；</li><li>堆段，包括动态分配的内存，从低地址开始向上增长；</li><li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长；</li><li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>，可以自定义。</li></ul><p>在这 7 个内存段中，只有<strong>堆和文件映射段的内存是动态分配</strong>的</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318160256561.png" style="zoom:67%;" /><blockquote><p>上图中的内存布局可以看到，代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」。</p><p><strong>保留区作用</strong>：许多系统中比较小数值的地址不是一个合法地址，例如C中的NULL。设置保留区是防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞</p></blockquote><h2 id="3-2-malloc-是如何分配内存的？"><a href="#3-2-malloc-是如何分配内存的？" class="headerlink" title="3.2 malloc 是如何分配内存的？"></a>3.2 malloc 是如何分配内存的？</h2><p>malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存。</p><p>malloc 申请内存的时候，会有<strong>两种方式向操作系统申请堆内存</strong>：</p><ul><li><p>方式一：通过 brk() 系统调用从堆分配内存</p><ul><li><p>通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间</p></li><li><p>通过 brk() 方式申请的内存，free 释放内存的时候，并不一定会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用，这样就可以重复使用。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318173542731.png" style="zoom:67%;" /></li></ul></li><li><p>方式二：通过 mmap() 系统调用在文件映射区域分配内存；</p><ul><li><p>通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230318173508637.png" style="zoom: 67%;" /></li></ul></li></ul><p><strong>什么场景下 malloc() 会通过 brk() 分配内存？又是什么场景下通过 mmap() 分配内存？</strong></p><blockquote><p>malloc() 源码里默认定义了一个阈值：</p><ul><li>如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；</li><li>如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；</li></ul></blockquote><hr><h3 id="malloc-分配的是物理内存吗？"><a href="#malloc-分配的是物理内存吗？" class="headerlink" title="malloc() 分配的是物理内存吗？"></a>malloc() 分配的是物理内存吗？</h3><blockquote><p><strong>malloc() 分配的是虚拟内存</strong>。</p><ul><li><p>如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存。</p></li><li><p>只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。</p></li></ul></blockquote><hr><h3 id="malloc-1-会分配多大的虚拟内存？"><a href="#malloc-1-会分配多大的虚拟内存？" class="headerlink" title="malloc(1) 会分配多大的虚拟内存？"></a><strong>malloc(1) 会分配多大的虚拟内存？</strong></h3><blockquote><p>malloc() 在分配内存的时候，并不是按用户预期申请的字节数来分配内存空间大小，而是<strong>会预分配更大的空间作为内存池</strong>。</p></blockquote><hr><h3 id="free-释放内存，会归还给操作系统吗？"><a href="#free-释放内存，会归还给操作系统吗？" class="headerlink" title="free 释放内存，会归还给操作系统吗？"></a><strong>free 释放内存，会归还给操作系统吗？</strong></h3><blockquote><ul><li>malloc 通过 <strong>brk()</strong> 方式申请的内存，free 释放内存的时候，<strong>并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用</strong>；</li><li>malloc 通过 <strong>mmap()</strong> 方式申请的内存，free 释放内存的时候，<strong>会把内存归还给操作系统，内存得到真正的释放</strong>。</li></ul></blockquote><hr><h3 id="为什么不全部使用-mmap-来分配内存？"><a href="#为什么不全部使用-mmap-来分配内存？" class="headerlink" title="为什么不全部使用 mmap 来分配内存？"></a><strong>为什么不全部使用 mmap 来分配内存？</strong></h3><blockquote><ol><li>因为向操作系统申请内存，是要通过系统调用的，执行系统调用是要进入内核态的，然后在回到用户态，运行态的切换会耗费不少时间。如果都用 mmap 来分配内存，等于每次都要执行系统调用。</li><li>因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会<strong>触发缺页中断</strong>。</li></ol></blockquote><p>malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。</p><p>等下次在申请内存的时候，就直接从内存池取出对应的内存块就行，不仅减少了系统调用的次数，也减少了缺页中断的次数</p><hr><h3 id="既然-brk-那么牛逼，为什么不全部使用-brk-来分配？"><a href="#既然-brk-那么牛逼，为什么不全部使用-brk-来分配？" class="headerlink" title="既然 brk 那么牛逼，为什么不全部使用 brk 来分配？"></a><strong>既然 brk 那么牛逼，为什么不全部使用 brk 来分配？</strong></h3><blockquote><p>随着系统频繁地 malloc 和 free ，堆内将产生越来越多不可用的碎片</p></blockquote><hr><h3 id="free-函数只传入一个内存地址，为什么能知道要释放多大的内存？"><a href="#free-函数只传入一个内存地址，为什么能知道要释放多大的内存？" class="headerlink" title="free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？"></a><strong>free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？</strong></h3><blockquote><p>malloc 返回给用户态的内存起始地址比实际申请的地址会多16字节，这16个字节会存储内存块的头信息。</p><p>当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小</p></blockquote><h2 id="3-3-内存满了，会发生什么？"><a href="#3-3-内存满了，会发生什么？" class="headerlink" title="3.3 内存满了，会发生什么？"></a>3.3 内存满了，会发生什么？</h2><p><strong>虚拟内存作用</strong></p><ul><li>第一，虚拟内存可以使得进程对运行内存超过物理内存大小</li><li>第二，由于每个进程都有自己虚拟内存空间，这就解决了多进程之间地址冲突的问题。</li><li>第三，页表里的页表项还有一些读写权限、页是否存在等标记属性的比特，使得操作系统提供了更好的安全性。</li></ul><p><strong>申请物理内存的过程</strong></p><p>内核在给应用程序分配物理内存的时候，如果空闲物理内存不够，那么就会进行内存回收的工作，主要有两种方式：</p><ul><li>后台内存回收：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程异步的，不会阻塞进程的执行。</li><li>直接内存回收：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，会阻塞进程的执行。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/2f61b0822b3c4a359f99770231981b07.png" alt="img" style="zoom: 50%;" /><hr><h3 id="哪些内存可以被回收？"><a href="#哪些内存可以被回收？" class="headerlink" title="哪些内存可以被回收？"></a>哪些内存可以被回收？</h3><blockquote><p>主要有两类内存可以被回收：</p><ul><li><strong>文件页</strong>：内核缓存的磁盘数据和文件数据都叫作文件页。<strong>回收干净文件页的方式是直接释放内存，回收脏文件页的方式是先写回磁盘后再释放内存</strong>。</li><li><strong>匿名页</strong>：这部分内存没有实际载体，比如堆、栈数据等。<strong>通过 Linux 的 Swap 机制进行回收</strong>，把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存。</li></ul></blockquote><p>文件页和匿名页的回收都是基于 <strong>LRU 算法</strong>，也就是优先回收不常访问的内存，其维护 两个双向链表：</p><ul><li><strong>active_list</strong> 活跃内存页链表，存放最近被访问过（活跃）的内存页；</li><li><strong>inactive_list</strong> 不活跃内存页链表，存放很少被访问（非活跃）的内存页；</li></ul><hr><h3 id="回收内存带来的性能影响"><a href="#回收内存带来的性能影响" class="headerlink" title="回收内存带来的性能影响"></a>回收内存带来的性能影响</h3><blockquote><p>回收内存的操作基本都会发生磁盘 I&#x2F;O 的，如果回收内存的操作很频繁，意味着磁盘 I&#x2F;O 次数会很多，这个过程势必会影响系统的性能，整个系统给人的感觉就是很卡。</p></blockquote><hr><h3 id="调整文件页和匿名页的回收倾向"><a href="#调整文件页和匿名页的回收倾向" class="headerlink" title="调整文件页和匿名页的回收倾向"></a>调整文件页和匿名页的回收倾向</h3><p>Linux 提供了一个 <code>/proc/sys/vm/swappiness</code> 选项，用来调整文件页和匿名页的回收倾向</p><ul><li>数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；</li><li>数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</li></ul><hr><h3 id="如何保护一个进程不被-OOM-杀掉呢"><a href="#如何保护一个进程不被-OOM-杀掉呢" class="headerlink" title="如何保护一个进程不被 OOM 杀掉呢"></a>如何保护一个进程不被 OOM 杀掉呢</h3><blockquote><p> Linux 内核里有一个 <code>oom_badness()</code> 函数，它会把系统中可以被杀掉的进程扫描一遍，并对每个进程打分，得分最高的进程就会被首先杀掉。进程得分的结果受下面这两个方面影响：</p><ul><li>第一，进程已经使用的物理内存页面数。</li><li>第二，每个进程的 OOM 校准值 oom_score_adj。</li></ul><p>因此可以调整该进程的 oom_score_adj，降低该进程被 OOM 杀死的概率。</p><p>如果想某个进程无论如何都不能被杀掉，那你可以将 oom_score_adj 配置为 -1000。</p></blockquote><h2 id="3-4-在-4GB-物理内存的机器上，申请-8G-内存会怎么样？"><a href="#3-4-在-4GB-物理内存的机器上，申请-8G-内存会怎么样？" class="headerlink" title="3.4 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？"></a>3.4 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？</h2><p>在不同位数操作系统上：</p><ul><li><strong>32 位操作系统</strong>：因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。</li><li><strong>64 位操作系统</strong>：因为进程最大只能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：<ul><li>如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；</li><li>如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；</li></ul></li></ul><p>程序申请的虚拟内存，如果没有被使用，它是不会占用物理空间的，但保存虚拟内存等结果需要占用物理内存。物理内存不足可通过开启swap来缓解。</p><blockquote><p><strong>Swap 机制</strong></p><p>当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中。</p></blockquote><h2 id="3-5-如何避免预读失效和缓存污染的问题？"><a href="#3-5-如何避免预读失效和缓存污染的问题？" class="headerlink" title="3.5 如何避免预读失效和缓存污染的问题？"></a>3.5 如何避免预读失效和缓存污染的问题？</h2><p>传统的 LRU 算法存在这两个问题：</p><ul><li><strong>「预读失效」导致缓存命中率下降</strong>：预读数据没有用到导致缓存命中率低</li><li><strong>「缓存污染」导致缓存命中率下降</strong>：批量读数据时可能会把热点数据挤出缓存从而导致命中率低</li></ul><hr><h3 id="如何避免预读失效造成的影响？"><a href="#如何避免预读失效造成的影响？" class="headerlink" title="如何避免预读失效造成的影响？"></a>如何避免预读失效造成的影响？</h3><blockquote><p>要避免预读失效带来影响，最好就是<strong>让预读页停留在内存里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在内存里的时间尽可能长</strong>。</p><p><strong>解决办法</strong>：设置两个区域，真正读取页插入活跃区域，预读页插入非活跃区域，只有当预读页真正被读取时才将其插入活跃区域。。</p><ul><li>例如Linux中，实现了active list 和 inactive list两个LRU链表，真正读取页插入active list表头，预读页插入inactive list表头，只有预读页真正被访问后才会将其移动到active list表头。</li></ul></blockquote><hr><h3 id="怎么避免缓存污染造成的影响？"><a href="#怎么避免缓存污染造成的影响？" class="headerlink" title="怎么避免缓存污染造成的影响？"></a>怎么避免缓存污染造成的影响？</h3><blockquote><p><strong>提高进入到活跃 LRU 链表（或者 young 区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young 区域）里的热点数据不会被轻易替换掉</strong>。</p><ul><li><strong>Linux 操作系统</strong>：在内存页被访问<strong>第二次</strong>的时候，才将页从 inactive list 升级到 active list 里。</li><li><strong>MySQL Innodb</strong>：在内存页被访问<strong>第二次</strong>的时候，并不会马上将该页从 old 区域升级到 young 区域，还需要判断与第一次访问时间间隔是否超过1秒，如超过则提升。</li></ul></blockquote><h2 id="3-6-深入理解-Linux-虚拟内存管理"><a href="#3-6-深入理解-Linux-虚拟内存管理" class="headerlink" title="3.6 深入理解 Linux 虚拟内存管理"></a>3.6 深入理解 Linux 虚拟内存管理</h2><h2 id="3-7-深入理解-Linux-物理内存管理"><a href="#3-7-深入理解-Linux-物理内存管理" class="headerlink" title="3.7 深入理解 Linux 物理内存管理"></a>3.7 深入理解 Linux 物理内存管理</h2><h1 id="四、进程管理"><a href="#四、进程管理" class="headerlink" title="四、进程管理"></a>四、进程管理</h1><hr><h2 id="4-1-进程、线程基础知识"><a href="#4-1-进程、线程基础知识" class="headerlink" title="4.1 进程、线程基础知识"></a>4.1 进程、线程基础知识</h2><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul><li><p>运行状态（<em>Running</em>）：该时刻进程占用 CPU；</p></li><li><p>就绪状态（<em>Ready</em>）：可运行，由于其他进程处于运行状态而暂时停止运行；</p></li><li><p>阻塞状态（<em>Blocked</em>）：该进程正在等待某一事件发生（如等待输入&#x2F;输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；</p></li><li><p>创建状态（<em>new</em>）：进程正在被创建时的状态；</p></li><li><p>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态；</p></li></ul><blockquote><p>挂起状态：</p><ul><li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li><li>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；</li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230320170008285.png" style="zoom:67%;" /><hr><h3 id="进程的控制结构"><a href="#进程的控制结构" class="headerlink" title="进程的控制结构"></a>进程的控制结构</h3><p>在操作系统中，是用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程。<strong>PCB 是进程存在的唯一标识</strong></p><p><strong>PCB 具体包含信息</strong>：</p><ul><li><p><strong>进程描述信息：</strong></p><ul><li><p>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</p></li><li><p>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</p></li></ul></li><li><p><strong>进程控制和管理信息：</strong></p><ul><li><p>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</p></li><li><p>进程优先级：进程抢占 CPU 时的优先级；</p></li></ul></li><li><p><strong>资源分配清单：</strong></p><ul><li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I&#x2F;O 设备信息。</li></ul></li><li><p><strong>CPU 相关信息：</strong></p><ul><li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</li></ul></li></ul><p>PCB通过<strong>链表</strong>的方式进行组织，把具有<strong>相同状态的进程链在一起，组成各种队列</strong>，如就绪队列、阻塞队列。</p><hr><h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><p><strong>创建进程的过程</strong>：</p><ul><li>申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息，比如进程的唯一标识等；</li><li>为该进程分配运行时所必需的资源，比如内存资源；</li><li>将 PCB 插入到就绪队列，等待被调度运行；</li></ul><p><strong>进程可以有 3 种终止方式：正常结束、异常结束以及外界干预</strong>，终止进程的过程如下：</p><ul><li>查找需要终止的进程的 PCB；</li><li>如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；</li><li>如果其还有子进程，则应将该进程的子进程交给 1 号进程接管；</li><li>将该进程所拥有的全部资源都归还给操作系统；</li><li>将其从 PCB 所在队列中删除；</li></ul><p><strong>阻塞进程的过程</strong>：</p><ul><li>找到将要被阻塞进程标识号对应的 PCB；</li><li>如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；</li><li>将该 PCB 插入到阻塞队列中去；</li></ul><p><strong>唤醒进程的过程</strong>：</p><ul><li>在该事件的阻塞队列中找到相应进程的 PCB；</li><li>将其从阻塞队列中移出，并置其状态为就绪状态；</li><li>把该 PCB 插入到就绪队列中，等待调度程序调度；</li></ul><hr><h3 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h3><p><strong>CPU 上下文切换</strong>就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>CPU 上下文切换可分成：<strong>进程上下文切换、线程上下文切换和中断上下文切换</strong>。</p><p><strong>进程的上下文切换</strong>包含虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p><hr><h3 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h3><ul><li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；</li><li>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；</li></ul><hr><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主要有三种线程的实现方式：</p><ul><li><strong>用户线程</strong>：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；<ul><li>优点：可用于不支持线程技术的操作系统；线程切换无需用户态与内核态切换，所以速度特别快；</li><li>缺点：如果一个线程阻塞，那进程所包含的用户线程都阻塞；一个线程运行，同进程中的其他线程都不能运行；内核是按进程进行时间片分配，可能会导致执行慢。</li></ul></li><li><strong>内核线程</strong>：在内核中实现的线程，是由内核管理的线程；<ul><li>优点：不存在阻塞同进程其他线程问题；多线程的进程获得更多的 CPU 运行时间；</li><li>缺点：需要内核来维护线程的上下文信息；会切换到内核态，系统开销较大。</li></ul></li><li><strong>轻量级进程</strong>：在内核中来支持用户线程；<ul><li>轻量级进程与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息。</li></ul></li></ul><hr><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li><p><strong>先来先服务调度算法</strong>：非抢占式，对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p></li><li><p><strong>最短作业优先调度算法</strong>：优先选择运行时间最短的进程来运行；对长作业不利。</p></li><li><p><strong>高响应比优先</strong>：计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行。由于要求服务时间未知，所以是一种理想型算法。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230320204258422.png" style="zoom:50%;" /></li><li><p><strong>时间片轮转调度算法</strong>：每个进程被分配一个时间片，该进程在该时间段中运行。</p></li><li><p><strong>最高优先级调度算法</strong>：从就绪队列中选择最高优先级的进程运行。优先级可分为静态优先级和动态优先级，算法还可分为抢占式和非抢占式。</p></li><li><p><strong>多级反馈队列调度算法</strong>：是「时间片轮转算法」和「最高优先级算法」的综合和发展；</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短；</li><li>新的进程会被放入到第一级队列的末尾，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li></ul></li></ul><h2 id="4-2-进程间有哪些通信方式？"><a href="#4-2-进程间有哪些通信方式？" class="headerlink" title="4.2 进程间有哪些通信方式？"></a>4.2 进程间有哪些通信方式？</h2><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以<strong>进程之间要通信必须通过内核</strong>。</p><hr><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p><strong>管道传输数据是单向的</strong>，如果想相互通信，需要创建两个管道。</p><p><strong>匿名管道</strong>：没有名字标识，其是特殊文件只存在于内存，没有存在于文件系统中</p><ul><li><strong>通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</li></ul><p><strong>命名管道</strong>：也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p><ul><li><strong>可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</li></ul><p><strong>管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。管道传输的数据是无格式的流且大小受限。</p><p><strong>管道通信效率低，不适合进程间频繁地交换数据</strong>。</p><blockquote><p><strong>管道创建函数生成的两个描述符都在一个进程中，怎么起到进程间通信的作用？</strong></p><p>使用 fork 创建子进程，创建的子进程会复制父进程的文件描述符</p></blockquote><blockquote><p><strong>shell中使用管道</strong></p><p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p><p>所以在shell中要尽量少使用管道</p></blockquote><hr><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><strong>消息队列</strong>消息队列是保存在内核中的消息链表</p><ul><li>在发送数据时，会分成一个一个消息体，消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型</li><li>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在</li><li>缺点：<ul><li>通信不及时</li><li>消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限</li><li>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</li></ul></li></ul><hr><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p><strong>共享内存</strong>：是拿出一块虚拟地址空间来，映射到相同的物理内存中。因此无需多次拷贝，大大提高了进程间通信的速度。</p><ul><li>是最快的进程间通信方式，但多进程竞争同个共享资源会造成数据的错乱，需要使用信号量来控制。</li></ul><hr><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><strong>信号量</strong>是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li><strong>P 操作</strong>，信号量减去 1，相减后如果信号量 &lt; 0，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li><li><strong>V 操作</strong>，把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将阻塞进程唤醒；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p><strong>P V操作是必须成对出现的</strong></p><hr><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>以上进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，当有信号产生，有以下几种处理方式：</p><ul><li><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如 SIGTERM 信号就是终止进程。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p></li></ul><hr><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>若想<strong>跨网络与不同主机上的进程之间通信</strong>，就需要 Socket 通信，也可同主机上进程间通信。</p><p>根据创建 socket 类型的不同，可分为以下几种通信方式：</p><ul><li><strong>TCP 字节流通信</strong>： socket 类型是 AF_INET 和 SOCK_STREAM；</li><li><strong>UDP 数据报通信</strong>：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li><strong>本地进程间通信</strong>： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的。<ul><li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li><li>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</li></ul></li></ul><h2 id="4-3-多线程冲突了怎么办？"><a href="#4-3-多线程冲突了怎么办？" class="headerlink" title="4.3 多线程冲突了怎么办？"></a>4.3 多线程冲突了怎么办？</h2><p>由于多线程执行操作共享变量的这段代码可能会导致竞争状态，此段代码称为<strong>临界区</strong></p><p><strong>同步：</strong>就是并发进程&#x2F;线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程&#x2F;线程同步。</p><p>实现进程协作方法主要有两种：</p><ul><li><em>锁</em>：加锁、解锁操作；<ul><li><strong>自旋锁</strong>：获取不到锁时，线程就会一直 while 循环，不做任何事情<ul><li>通过 CPU 提供的 <code>CAS</code> 函数实现，在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换</li></ul></li><li><strong>无等待锁</strong>：当没获取到锁的时候，就把当前线程放入到锁的等待队列，然后执行调度程序</li></ul></li><li><em>信号量</em>：P、V 操作，其是原子操作；<ul><li>信号量不仅可以实现临界区的互斥访问控制，还可以线程间的事件同步。</li></ul></li></ul><h2 id="4-4-怎么避免死锁？"><a href="#4-4-怎么避免死锁？" class="headerlink" title="4.4 怎么避免死锁？"></a>4.4 怎么避免死锁？</h2><p>两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直相互等待，这就是<strong>死锁</strong>。</p><p><strong>死锁发生的必要条件</strong>：</p><ul><li>互斥条件：指多个线程不能同时使用同一个资源。</li><li>持有并等待条件：线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</li><li>不可剥夺条件：线程持有资源不能被其他线程剥夺获取</li><li>循环等待条件：两个线程获取资源的顺序构成了环形</li></ul><p>避免死锁问题就只需要破环其中一个条件，最常见的并且可行的就是<strong>使用资源有序分配法</strong></p><ul><li>即资源申请顺序一样，例如只能先申请A再申请B</li></ul><hr><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p><strong>思想</strong>：只要线程申请资源不超过拥有值，则尽可能满足其申请</p><ul><li>每一个新进程进入系统时，必须声明需要每种资源的最大数目，其数目不能超过系统所拥有的的资源总量。</li><li>当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程，若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态如果不会才将资源分配给它，否则让进程等待。</li></ul><h2 id="4-5-什么是悲观锁、乐观锁？"><a href="#4-5-什么是悲观锁、乐观锁？" class="headerlink" title="4.5 什么是悲观锁、乐观锁？"></a>4.5 什么是悲观锁、乐观锁？</h2><h3 id="互斥锁与自旋锁"><a href="#互斥锁与自旋锁" class="headerlink" title="互斥锁与自旋锁"></a><strong>互斥锁与自旋锁</strong></h3><ul><li>这两种锁是最底层的锁，其他高级锁都是基于此两种锁实现</li><li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li><li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li><li><strong>如果被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></li></ul><hr><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁，由「读锁」和「写锁」两部分构成，<strong>读写锁适用于能明确区分读操作和写操作的场景</strong>，工作原理：</p><ul><li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁</li><li>一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li></ul><p><strong>写锁是独占锁，而读锁是共享锁</strong></p><p>读写锁可以分为：</p><ul><li>「读优先锁」：当读锁被持有时，获取写锁的线程会被阻塞，且后续来的读线程仍然能获取读锁。知道所有读锁被释放，才能获取写锁成功。</li><li>「写优先锁」：当获取写锁时，持有读锁的线程会被阻塞，此时获取读锁的线程也会被阻塞</li></ul><p><strong>公平读写锁</strong>：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</p><hr><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p><strong>悲观锁</strong>：认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。</p><ul><li>互斥锁、自旋锁、读写锁，都是属于悲观锁。</li></ul><p><strong>乐观锁</strong>：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p><ul><li>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></li></ul><blockquote><p><strong>CAS 不是乐观锁吗，为什么基于 CAS 实现的自旋锁是悲观锁？</strong></p><p>CAS 是乐观锁没错，但是 CAS 和自旋锁不同之处，自旋锁基于 CAS 加了while 或者睡眠 CPU 的操作而产生自旋的效果，加锁失败会忙等待直到拿到锁，自旋锁是要需要事先拿到锁才能修改数据的，所以算悲观锁。</p></blockquote><h2 id="4-6-一个进程最多可以创建多少个线程？"><a href="#4-6-一个进程最多可以创建多少个线程？" class="headerlink" title="4.6 一个进程最多可以创建多少个线程？"></a>4.6 一个进程最多可以创建多少个线程？</h2><blockquote><ul><li>32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。</li><li>64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。</li></ul></blockquote><p>创建进程个数受两个方面影响：</p><ul><li><strong>进程的虚拟内存空间上限</strong>，因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多。</li><li><strong>系统参数限制</strong>，虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数。<ul><li><em><strong>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;threads-max</strong></em>，表示系统支持的最大线程数，默认值是 <code>14553</code>；</li><li><em><strong>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max</strong></em>，表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败，默认值是 <code>32768</code>；</li><li><em><strong>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;max_map_count</strong></em>，表示限制一个进程可以拥有的VMA(虚拟内存区域)的数量，具体什么意思我也没搞清楚，反正如果它的值很小，也会导致创建线程失败，默认值是 <code>65530</code>。</li></ul></li></ul><h2 id="4-7-线程崩溃了，进程也会崩溃吗"><a href="#4-7-线程崩溃了，进程也会崩溃吗" class="headerlink" title="4.7 线程崩溃了，进程也会崩溃吗"></a>4.7 线程崩溃了，进程也会崩溃吗</h2><p>一般来说如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃。因为某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程。</p><blockquote><p><strong>进程是如何崩溃的</strong>？</p><ul><li>调用 kill 系统调用向进程发送信号</li><li>操作系统根据情况执行相应的信号处理程序（函数），一般执行完信号处理程序逻辑后会让进程退出</li></ul></blockquote><p>虽然给进程发送了 kill 信号，但如果进程自己定义了信号处理函数或者无视信号，那么可能会毫无影响。</p><p><strong>为什么线程崩溃不会导致 JVM 进程崩溃？</strong></p><p>因为 JVM 自定义了自己的信号处理函数，拦截了 SIGSEGV 信号，针对这两者不让它们崩溃。</p><h1 id="五、调度算法"><a href="#五、调度算法" class="headerlink" title="五、调度算法"></a>五、调度算法</h1><h2 id="5-1-进程调度算法"><a href="#5-1-进程调度算法" class="headerlink" title="5.1 进程调度算法"></a>5.1 进程调度算法</h2><ul><li><p><strong>先来先服务调度算法</strong>：非抢占式，对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p></li><li><p><strong>最短作业优先调度算法</strong>：优先选择运行时间最短的进程来运行；对长作业不利。</p></li><li><p><strong>高响应比优先</strong>：计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行。由于要求服务时间未知，所以是一种理想型算法。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230320204258422.png" style="zoom:50%;" /></li><li><p><strong>时间片轮转调度算法</strong>：每个进程被分配一个时间片，该进程在该时间段中运行。</p></li><li><p><strong>最高优先级调度算法</strong>：从就绪队列中选择最高优先级的进程运行。优先级可分为静态优先级和动态优先级，算法还可分为抢占式和非抢占式。</p></li><li><p><strong>多级反馈队列调度算法</strong>：是「时间片轮转算法」和「最高优先级算法」的综合和发展；</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短；</li><li>新的进程会被放入到第一级队列的末尾，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li></ul></li></ul><h2 id="5-2-页面置换算法"><a href="#5-2-页面置换算法" class="headerlink" title="5.2 页面置换算法"></a>5.2 页面置换算法</h2><p>当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它<strong>与一般中断的主要区别</strong>在于：</p><ul><li>缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</li><li>缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。</li></ul><p>页表项通常有如下字段：</p><ul><li><em>状态位</em>：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问时参考。</li><li><em>访问字段</em>：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考。</li><li><em>修改位</em>：表示该页在调入内存后是否有被修改过</li><li><em>硬盘地址</em>：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321160617503.png"></p><p>常见的页面置换算法有如下几种：</p><ul><li><strong>最佳页面置换算法（<em>OPT</em>）</strong>：基本思路是置换在「未来」最长时间不访问的页面。<ul><li>实际系统中无法实现，因为程序访问页面时是动态的，无法预知每个页面在「下一次」访问前的等待时间。</li></ul></li><li><strong>先进先出置换算法（<em>FIFO</em>）</strong>：选择在内存驻留时间很长的页面进行中置换。</li><li><strong>最近最久未使用的置换算法（<em>LRU</em>）</strong>：发生缺页时，选择最长时间没有被访问的页面进行置换。<ul><li>该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用，近似最优置换算法。</li><li>代价很高。需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。且每次内存访问都需要更新链表，非常耗时。</li></ul></li><li><strong>时钟页面置换算法（<em>Lock</em>）</strong>：把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。当发生缺页中断时，算法首先检查表针指向的页面：<ul><li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li><li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li></ul></li><li><strong>最不常用置换算法（<em>LFU</em>）</strong>：当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰。<ul><li>缺点：查找哪个页面访问次数最小是非常耗时的，效率不高。且没有考虑访问时间。</li></ul></li></ul><h2 id="5-3-磁盘调度算法"><a href="#5-3-磁盘调度算法" class="headerlink" title="5.3 磁盘调度算法"></a>5.3 磁盘调度算法</h2><p>常见的磁盘调度算法有：</p><ul><li><strong>先来先服务算法</strong>：先到来的请求，先被服务。<ul><li>如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法在性能上就会显得很差，因为寻道时间过长。</li></ul></li><li><strong>最短寻道时间优先算法</strong>：优先选择从当前磁头位置所需寻道时间最短的请求<ul><li>可能产生了饥饿现象，因为磁头在一小块区域来回移动。</li></ul></li><li><strong>扫描算法</strong>：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，也叫做<strong>电梯算法</strong>；<ul><li>不会产生饥饿现象，但中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异</li></ul></li><li><strong>循环扫描算法</strong>：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头<ul><li>该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong>。</li></ul></li><li><strong>LOOK <strong>：针对扫描算法的优化。磁头在移动到「最远的请求」位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，</strong>反向移动的途中会响应请求</strong>。</li><li><strong>C-LOOK</strong> ：针对循环扫描算法的优化。磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong>。</li></ul><h1 id="六、文件系统"><a href="#六、文件系统" class="headerlink" title="六、文件系统"></a>六、文件系统</h1><h2 id="6-1-文件系统全家桶"><a href="#6-1-文件系统全家桶" class="headerlink" title="6.1 文件系统全家桶"></a>6.1 文件系统全家桶</h2><p>文件系统是操作系统中负责管理持久数据的子系统，基本数据单位是文件。</p><p>Linux 文件系统会为每个文件分配两个数据结构：</p><ul><li><strong>索引节点</strong>：<em>inode</em>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、<em>数据在磁盘的位置</em>等等。索引节点是文件的<strong>唯一</strong>标识，也同样都会被存储在硬盘中，所以<strong>索引节点同样占用磁盘空间</strong>。<ul><li>索引节点和文件的关系是多对一，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</li></ul></li><li><strong>目录项</strong>：<em>dentry</em>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构。<ul><li>与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>。</li></ul></li></ul><p><strong>目录也是文件</strong>，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><blockquote><p><strong>目录项和目录是一个东西吗？</strong></p><p>不是。目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。</p><ul><li>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存</li></ul><p><strong>文件数据是如何存储在磁盘的呢？</strong></p><p>磁盘读写的最小单位是<strong>扇区</strong>，文件系统把多个扇区组成了一个<strong>逻辑块</strong>，每次读写的最小单位就是逻辑块。</p></blockquote><p>磁盘进行格式化的时候，会被分成三个存储区域：</p><ul><li><em>超级块</em>，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。<ul><li>当文件系统挂载时进入内存；</li></ul></li><li><em>索引节点区</em>，用来存储索引节点；<ul><li>当文件被访问时进入内存；</li></ul></li><li><em>数据块区</em>，用来存储文件或目录数据；</li></ul><p>操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「<strong>文件描述符</strong>」，所以说文件描述符是打开文件的标识。操作系统在打开文件表中维护着打开文件的状态和信息：</p><ul><li>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；</li><li>文件打开计数器：该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；</li><li>文件磁盘位置：该信息保存在内存中，以免每个操作都从磁盘中读取；</li><li>访问权限：权限信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I&#x2F;O 请求；</li></ul><hr><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>操作系统希望<strong>对用户提供一个统一的接口</strong>，于是在用户层与文件系统层引入了中间层，被称为<strong>虚拟文件系统（VFS）。</strong></p><p>文件系统可分为三类：</p><ul><li><em><strong>磁盘的文件系统</strong></em>，它是直接把数据存储在磁盘中，比如 Ext 2&#x2F;3&#x2F;4、XFS 等都是这类文件系统。</li><li><em><strong>内存的文件系统</strong></em>，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 <code>/proc</code> 和 <code>/sys</code> 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。</li><li><em><strong>网络的文件系统</strong></em>，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。</li></ul><p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p><p><strong>文件系统的基本操作单位是数据块</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321163639861.png" style="zoom:33%;" /><hr><h3 id="文件的存储"><a href="#文件的存储" class="headerlink" title="文件的存储"></a>文件的存储</h3><p>文件有以下两种存储方式：</p><ul><li><p><strong>连续空间存放方式</strong>：文件存放在磁盘「连续的」物理空间中。inode里需要指定「起始块的位置」和「长度」。</p><ul><li>优点：读写效率很高</li><li>缺点：磁盘空间碎片问题；文件长度不易扩展；</li></ul></li><li><p><strong>非连续空间存放方式</strong></p><ul><li><p><strong>链表</strong></p><ul><li><strong>隐式链表</strong>：inode中要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置。<ul><li>缺点：无法直接访问数据块；稳定性较差，如果其中一个指针丢失，会导致文件数据丢失。</li></ul></li><li><strong>显式链接</strong>：把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，该表在<strong>整个磁盘仅设置一张</strong>，每个表项中存放链接指针，指向下一个数据块号。如win曾经的FAT。它的<strong>主要的缺点是不适用于大磁盘</strong>。</li></ul></li><li><p><strong>索引</strong>：为每个文件创建一个「索引数据块」，里面存放的是指向文件数据块的指针列表。另外，inode需要包含指向「索引数据块」的指针。</p><ul><li>优点：文件的创建、增大、缩小很方便；不会有碎片的问题；支持顺序读写和随机读写；</li><li>缺点：<strong>索引数据存放在磁盘块</strong>，会带来存储索引的开销</li></ul><blockquote><p><strong>链式索引</strong>：链表 + 索引。在索引数据块留出一个存放下一个索引数据块的指针，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。</p><p><strong>多级索引</strong>：通过一个索引块来存放多个索引数据块，一层套一层索引</p></blockquote></li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321170248979.png" style="zoom:80%;" /><hr><h3 id="Unix-文件的实现方式"><a href="#Unix-文件的实现方式" class="headerlink" title="Unix 文件的实现方式"></a>Unix 文件的实现方式</h3><p>根据文件的大小，存放的方式会有所变化：</p><ul><li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；</li><li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；</li><li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；</li><li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；</li></ul><p>因此，文件头（<em>Inode</em>）就需要包含 13 个指针：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321170712531.png" style="zoom:50%;" /><hr><h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><p>查找空闲块需要高效，有以下几种方法：</p><ul><li><strong>空闲表法</strong>：为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数。注意，这个方式是连续分配的。<ul><li>当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。</li><li>当用户撤销一个文件时，也需顺序扫描寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。</li><li>仅当有少量的空闲区时才有较好的效果</li></ul></li><li><strong>空闲链表法</strong>：每一个数据空闲块里有一个指针指向下一个数据空闲块。<ul><li>其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I&#x2F;O 操作，同时数据块的指针消耗了一定的存储空间。</li></ul></li><li><strong>位图法</strong>：利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。<ul><li>Linux 文件系统就采用了位图的方式来管理空闲空间，还用于 inode 空闲块的管理</li></ul></li></ul><hr><h3 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h3><p>一个块存放的位图能表示的存储大小是有限的，如只能128M。因此，在linux中使用了一个结构体<strong>块组</strong>来表示，然后大量块组就可以表示超大的文件，块组内容如下：</p><ul><li><em><strong>超级块</strong></em>，包含文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等。</li><li><em><strong>块组描述符</strong></em>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</li><li><em><strong>数据位图和 inode 位图</strong></em>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。</li><li><em><strong>inode 列表</strong></em>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</li><li><em><strong>数据块</strong></em>，包含文件的有用数据。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321212613348.png" style="zoom:67%;" /><blockquote><p>为什么每个块组中都有超级块和块组描述符表？</p><ul><li>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。</li><li>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。</li></ul></blockquote><hr><h3 id="目录的存储"><a href="#目录的存储" class="headerlink" title="目录的存储"></a>目录的存储</h3><p>普通文件的块里面保存的是文件数据，而<strong>目录文件的块里面保存的是目录里面一项一项的文件信息</strong>。</p><p>目录内容如下：</p><ul><li>第一项是「<code>.</code>」，表示当前目录，第二项是「<code>..</code>」，表示上一级目录</li><li>保存目录是使用<strong>哈希表</strong>，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希来匹配。<ul><li>种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321213002362.png" style="zoom: 67%;" /><hr><h3 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h3><p><strong>硬链接</strong></p><ul><li><strong>多个目录项中的「索引节点」指向一个文件</strong>，也就是指向同一个 inode</li><li>每个文件系统都有各自的 inode 数据结构和列表，所以<strong>硬链接是不可用于跨文件系统的</strong>。</li><li>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件</li></ul><p><strong>软链接</strong></p><ul><li>相当于重新创建一个文件，这个文件有<strong>独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件</li><li><strong>软链接是可以跨文件系统的</strong>，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</li></ul><hr><h3 id="文件-I-x2F-O"><a href="#文件-I-x2F-O" class="headerlink" title="文件 I&#x2F;O"></a>文件 I&#x2F;O</h3><p><strong>缓冲与非缓冲 I&#x2F;O</strong>：根据「是否利用标准库缓冲」，可以把文件 I&#x2F;O 分为缓冲 I&#x2F;O 和非缓冲，「缓冲」特指标准库内部实现的缓冲。</p><ul><li>缓冲 I&#x2F;O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。</li><li>非缓冲 I&#x2F;O，直接通过系统调用访问文件，不经过标准库缓存。</li></ul><p><strong>直接与非直接 I&#x2F;O</strong>： Linux 内核为了减少磁盘 I&#x2F;O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来只有当缓存满足某些条件的时候，才发起磁盘 I&#x2F;O 的请求。根据是「否利用操作系统的缓存」，可以把文件 I&#x2F;O 分为直接 I&#x2F;O 与非直接 I&#x2F;O：</p><ul><li><p>直接 I&#x2F;O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。</p><ul><li>如果你在使用文件操作类的系统调用函数时，指定了 <code>O_DIRECT</code> 标志，则表示使用直接 I&#x2F;O。如果没有设置过，默认使用的是非直接 I&#x2F;O。</li></ul></li><li><p>非直接 I&#x2F;O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。</p><blockquote><p>以下几种场景会触发内核缓存的数据写入磁盘：</p><ul><li>在调用 <code>write</code> 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；</li><li>用户主动调用 <code>sync</code>，内核缓存会刷到磁盘上；</li><li>当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；</li><li>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；</li></ul></blockquote></li></ul><p><strong>阻塞与非阻塞 I&#x2F;O VS 同步与异步 I&#x2F;O</strong>：这两类IO其实是内核数据准备和数据拷贝的不同区分。</p><ul><li><p>阻塞 I&#x2F;O：阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</p><ul><li>当用户程序执行 <code>read</code> ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，<code>read</code> 才会返回。</li></ul></li><li><p>非阻塞 I&#x2F;O：非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，<code>read</code> 调用才可以获取到结果</p><ul><li>注意，成功获取数据 的那次read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。</li></ul><blockquote><p>无论是阻塞 I&#x2F;O、非阻塞 I&#x2F;O，还是基于非阻塞 I&#x2F;O 的多路复用<strong>都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。</strong></p></blockquote></li><li><p>异步 I&#x2F;O ：「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待</p><blockquote><p>I&#x2F;O 是分为两个过程的：</p><ol><li>数据准备的过程</li><li>数据从内核空间拷贝到用户进程缓冲区的过程</li></ol><p>阻塞 I&#x2F;O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I&#x2F;O 和基于非阻塞 I&#x2F;O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I&#x2F;O。</p><p>异步 I&#x2F;O 则不同，「过程 1 」和「过程 2 」都不会阻塞。</p></blockquote></li></ul><h2 id="6-2-进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"><a href="#6-2-进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？" class="headerlink" title="6.2 进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"></a>6.2 进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？</h2><p>答案：不会丢失。</p><ul><li>因为进程在执行 write （使用缓冲 IO）系统调用的时候，实际上是将文件数据写到了内核的 page cache，它是文件系统中用于缓存文件数据的缓冲，所以即使进程崩溃了，文件数据还是保留在内核的 page cache</li><li>内核会找个合适的时机，将 page cache 中的数据持久化到磁盘。但是如果 page cache 里的文件数据，在持久化到磁盘化到磁盘之前，系统发生了崩溃，那这部分数据就会丢失了。</li><li>也可以在程序里调用 fsync 函数，在写文文件的时候，立刻将文件数据持久化到磁盘，这样就可以解决系统崩溃导致的文件数据丢失的问题。</li></ul><hr><h3 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h3><p>Page Cache 的本质是由 Linux 内核管理的内存区域。我们通过 mmap 以及 buffered I&#x2F;O 将文件读取到内存空间实际上都是读取到 Page Cache 中</p><p><strong>优势</strong></p><ul><li>加快数据访问</li><li>减少 I&#x2F;O 次数，提高系统磁盘 I&#x2F;O 吞吐量</li></ul><p><strong>劣势</strong></p><ul><li>需要占用额外物理内存空间，物理内存在比较紧俏的时候可能会导致频繁的 swap 操作，最终导致系统的磁盘 I&#x2F;O 负载的上升</li><li>对应用层并没有提供很好的管理 API，导致想优化 Page Cache 的使用策略很难进行</li><li>在某些应用场景下比 Direct I&#x2F;O 多一次磁盘读 I&#x2F;O 以及磁盘写 I&#x2F;O</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230321215335466.png"></p><blockquote><p><strong>page 与 Page Cache</strong></p><p>page 是内存管理分配的基本单位， Page Cache 由多个 page 构成。page 在操作系统中通常为 4KB 大小（32bits&#x2F;64bits），而 Page Cache 的大小则为 4KB 的整数倍。</p></blockquote><hr><h3 id="Page-Cache-与-buffer-cache"><a href="#Page-Cache-与-buffer-cache" class="headerlink" title="Page Cache 与 buffer cache"></a>Page Cache 与 buffer cache</h3><p>执行 free 命令，注意到会有两列名为 buffers 和 cached，也有一行名为 “-&#x2F;+ buffers&#x2F;cache”。</p><p><strong>Page Cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据。</strong></p><ul><li>页是逻辑上的概念，因此 Page Cache 是与文件系统同级的；</li><li>块是物理上的概念，因此 buffer cache 是与块设备驱动程序同级的。</li></ul><p>Page Cache 与 buffer cache 的<strong>共同目的都是加速数据 I&#x2F;O</strong>：</p><ul><li>写数据时首先写到缓存，将写入的页标记为 dirty，然后向外部存储 flush，也就是缓存写机制中的 write-back（另一种是 write-through，Linux 默认情况下不采用）；</li><li>读数据时首先读取缓存，如果未命中，再去外部存储读取，并且将读取来的数据也加入缓存。操作系统总是积极地将所有空闲内存都用作 Page Cache 和 buffer cache，当内存不够用时也会用 LRU 等算法淘汰缓存页。</li></ul><p><strong>在 2.4 版本内核之后，两块缓存近似融合在了一起：如果一个文件的页加载到了 Page Cache，那么同时 buffer cache 只需要维护块指向页的指针就可以了</strong></p><hr><h3 id="Page-Cache-与文件持久化的一致性-amp-可靠性"><a href="#Page-Cache-与文件持久化的一致性-amp-可靠性" class="headerlink" title="Page Cache 与文件持久化的一致性&amp;可靠性"></a>Page Cache 与文件持久化的一致性&amp;可靠性</h3><p>Linux 下以两种方式实现文件一致性：</p><ol><li><strong>Write Through（写穿）</strong>：向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性；<ul><li>以牺牲系统 I&#x2F;O 吞吐量作为代价，向上层应用确保一旦写入，数据就已经落盘，不会丢失</li></ul></li><li><strong>Write back（写回）</strong>：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的 Linux 一致性方案；<ul><li>在系统发生宕机的情况下无法确保数据已经落盘，因此存在数据丢失的问题。</li></ul></li></ol><p>上述两种方式最终都依赖于系统调用，主要分为如下三种系统调用：</p><table><thead><tr><th align="left">方法</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">fsync(intfd)</td><td align="left">fsync(fd)：将 fd 代表的文件的脏数据和脏元数据全部刷新至磁盘中。</td></tr><tr><td align="left">fdatasync(int fd)</td><td align="left">fdatasync(fd)：将 fd 代表的文件的脏数据刷新至磁盘，同时对必要的元数据刷新至磁盘中，这里所说的必要的概念是指：对接下来访问文件有关键作用的信息，如文件大小，而文件修改时间等不属于必要信息</td></tr><tr><td align="left">sync()</td><td align="left">sync()：则是对系统中所有的脏的文件数据元数据刷新至磁盘中</td></tr></tbody></table><ol><li>系统中存在一个管理线程和多个刷新线程（每个持久存储设备对应一个刷新线程）。<ul><li>管理线程监控设备上的脏页面情况，若设备一段时间内没有产生脏页面，就销毁设备上的刷新线程；若监测到设备上有脏页面需要回写且尚未为该设备创建刷新线程，那么创建刷新线程处理脏页面回写。</li><li>刷新线程的任务较为单调，只负责将设备中的脏页面回写至持久存储设备中。</li></ul></li><li>刷新线程刷新设备上脏页面大致设计如下：<ul><li>每个设备保存脏文件链表，保存的是该设备上存储的脏文件的 inode 节点。所谓的回写文件脏页面即回写该 inode 链表上的某些文件的脏页面；</li><li>系统中存在多个回写时机，第一是应用程序主动调用回写接口，第二管理线程周期性地唤醒设备上的回写线程进行回写，第三是某些应用程序&#x2F;内核任务发现内存不足时要回收部分缓存页面而事先进行脏页面回写</li></ul></li></ol><h1 id="七、设备管理"><a href="#七、设备管理" class="headerlink" title="七、设备管理"></a>七、设备管理</h1><h2 id="7-1-键盘敲入-A-字母时，操作系统期间发生了什么？"><a href="#7-1-键盘敲入-A-字母时，操作系统期间发生了什么？" class="headerlink" title="7.1 键盘敲入 A 字母时，操作系统期间发生了什么？"></a>7.1 键盘敲入 A 字母时，操作系统期间发生了什么？</h2><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p>为了屏蔽设备之间的差异，每个设备都有一个叫<strong>设备控制器</strong>，CPU 是通过设备控制器来和设备打交道的</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230322174034974.png" style="zoom:33%;" /><p>设备控制器里有芯片，也有寄存器用来与 CPU 进行通信，可分为三类：</p><ul><li><em><strong>数据寄存器</strong></em>，CPU 向 I&#x2F;O 设备写入需要传输的数据，比如要打印的内容是「Hello」，CPU 就要先发送一个 H 字符给到对应的 I&#x2F;O 设备。</li><li><em><strong>命令寄存器</strong></em>，CPU 发送一个命令，告诉 I&#x2F;O 设备，要进行输入&#x2F;输出操作，于是就会交给 I&#x2F;O 设备去工作，任务完成后，会把状态寄存器里面的状态标记为完成。</li><li><em><strong>状态寄存器</strong></em>，目的是告诉 CPU ，现在已经在工作或工作已经完成，如果已经在工作状态，CPU 再发送数据或者命令过来，都是没有用的，直到前面的工作已经完成，状态寄存标记成已完成，CPU 才能发送下一个字符和命令。</li></ul><p> 输入输出设备可分为两大类 ：</p><ul><li><em><strong>块设备</strong></em>，把数据存储在固定大小的块中，每个块有自己的地址，硬盘、USB 是常见的块设备。<ul><li>块设备通常传输的数据量会非常大，于是控制器设立了一个可读写的<strong>数据缓冲区</strong>。无论读写都是囤够了一部分，才会发给设备或拷贝到内存。</li></ul></li><li><em><strong>字符设备</strong></em>，以字符为单位发送或接收一个字符流，字符设备是不可寻址的，也没有任何寻道操作，鼠标是常见的字符设备。</li></ul><p>CPU 设备的控制寄存器和数据缓冲区通信方法：</p><ul><li><em><strong>端口 I&#x2F;O</strong></em>，每个控制寄存器被分配一个 I&#x2F;O 端口，可以通过特殊的汇编指令操作这些寄存器，比如 <code>in/out</code> 类似的指令。</li><li><em><strong>内存映射 I&#x2F;O</strong></em>，将所有控制寄存器映射到内存空间中，这样就可以像读写内存一样读写数据缓冲区。</li></ul><hr><h3 id="I-x2F-O-控制方式"><a href="#I-x2F-O-控制方式" class="headerlink" title="I&#x2F;O 控制方式"></a>I&#x2F;O 控制方式</h3><p><strong>轮询等待</strong>：CPU 一直检查寄存器的状态</p><p><strong>中断</strong>：当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU</p><p><strong>DMA</strong>：可以使得设备在 CPU 不参与的情况下，能够自行完成把设备 I&#x2F;O 数据放入到内存，工作方式如下：</p><ul><li>CPU 需对 DMA 控制器下发指令，告诉它想读取多少数据，读完的数据放在内存的某个地方就可以了；</li><li>接下来，DMA 控制器会向磁盘控制器发出指令，通知它从磁盘读数据到内存缓冲区中，接着磁盘控制器将缓冲区的数据传输到内存；</li><li>当磁盘控制器把数据传输到内存的操作完成后，磁盘控制器在总线上发出一个确认成功的信号到 DMA 控制器；</li><li>DMA 控制器收到信号后，DMA 控制器发中断通知 CPU 指令完成，CPU 就可以直接用内存里面现成的数据了；</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230322173920982.png" style="zoom:80%;" /><hr><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>每种设备的控制器的寄存器、缓冲区等使用模式都是不同的，所以为了屏蔽「设备控制器」的差异，引入了<strong>设备驱动程序</strong>。设备驱动程序会提供统一的接口给操作系统。</p><p>设备驱动程序里会响应控制器发来的中断请求，并根据这个中断的类型调用响应的<strong>中断处理程序</strong>进行处理。通常，设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数。</p><p><strong>中断处理程序的处理流程</strong>：</p><ol><li>在 I&#x2F;O 时，设备控制器如果已经准备好数据，则会通过中断控制器向 CPU 发送中断请求；</li><li>保护被中断进程的 CPU 上下文；</li><li>转入相应的设备中断处理函数；</li><li>进行中断处理；</li><li>恢复被中断进程的上下文；</li></ol><hr><h3 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h3><p>对于块设备，为了减少不同块设备的差异带来的影响，Linux 通过一个统一的<strong>通用块层</strong>，来管理不同的块设备。</p><p>通用块层是处于文件系统和磁盘驱动中间的一个块设备抽象层，它主要有两个功能：</p><ul><li>向上为文件系统和应用程序，提供访问块设备的标准接口，向下把各种不同的磁盘设备抽象为统一的块设备，并在内核层面，提供一个框架来管理这些设备的驱动程序；</li><li>通用块层还会给文件系统和应用程序发来的 I&#x2F;O 请求排队，接着会对队列重新排序、请求合并等方式，也就是 I&#x2F;O 调度，主要目的是为了提高磁盘读写的效率。</li></ul><p>Linux 内存支持 5 种 I&#x2F;O 调度算法，分别是：</p><ul><li><strong>没有调度算法</strong>：不做任何处理，通常用于虚拟机IO</li><li><strong>先入先出调度算法</strong></li><li><strong>完全公平调度算法</strong>：为每个进程维护了一个 I&#x2F;O 调度队列，并按照时间片来均匀分布每个进程的 I&#x2F;O 请求，常作为默认调度算法。</li><li><strong>优先级调度</strong>：优先级高的 I&#x2F;O 请求先发生， 它适用于运行大量进程的系统</li><li><strong>最终期限调度算法</strong>：分别为读、写请求创建了不同的 I&#x2F;O 队列，这样可以提高机械磁盘的吞吐量，并确保达到最终期限的请求被优先处理，适用于在 I&#x2F;O 压力比较大的场景，比如数据库等。</li></ul><hr><h3 id="存储系统-I-x2F-O-软件分层"><a href="#存储系统-I-x2F-O-软件分层" class="headerlink" title="存储系统 I&#x2F;O 软件分层"></a>存储系统 I&#x2F;O 软件分层</h3><p>Linux 存储系统的 I&#x2F;O 由上到下可以分为三个层次：</p><ul><li><strong>文件系统层</strong>，包括虚拟文件系统和其他文件系统的具体实现，它向上为应用程序统一提供了标准的文件访问接口，向下会通过通用块层来存储和管理磁盘数据。</li><li><strong>通用块层</strong>，包括块设备的 I&#x2F;O 队列和 I&#x2F;O 调度器，它会对文件系统的 I&#x2F;O 请求进行排队，再通过 I&#x2F;O 调度器，选择一个 I&#x2F;O 发给下一层的设备层。</li><li><strong>设备层</strong>，包括硬件设备、设备控制器和驱动程序，负责最终物理设备的 I&#x2F;O 操作。</li></ul><p>存储系统的 I&#x2F;O 是整个系统最慢的一个环节，所以 Linux 提供了不少缓存机制来提高 I&#x2F;O 的效率。</p><ul><li>为了提高文件访问的效率，会使用<strong>页缓存、索引节点缓存、目录项缓存</strong>等多种缓存机制，目的是为了减少对块设备的直接调用。</li><li>为了提高块设备的访问效率， 会使用<strong>缓冲区</strong>，来缓存块设备的数据</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230322175046656.png" style="zoom:50%;" /><hr><h3 id="键盘敲入字母时，期间发生了什么？"><a href="#键盘敲入字母时，期间发生了什么？" class="headerlink" title="键盘敲入字母时，期间发生了什么？"></a>键盘敲入字母时，期间发生了什么？</h3><ul><li>当用户输入了键盘字符，<strong>键盘控制器</strong>就会产生扫描码数据，并将其缓冲在键盘控制器的寄存器中，紧接着键盘控制器通过总线给 CPU 发送<strong>中断请求</strong>。</li><li>CPU 收到中断请求后，操作系统会<strong>保存被中断进程的 CPU 上下文</strong>，然后调用键盘的<strong>中断处理程序</strong>。</li><li>键盘的中断处理程序是在<strong>键盘驱动程序</strong>初始化时注册的，即从键盘控制器的寄存器的缓冲区读取扫描码，再根据扫描码找到用户在键盘输入的字符。如果输入的字符是显示字符，那就会把扫描码翻译成对应显示字符的 ASCII 码</li><li>把 ASCII 码放到「读缓冲区队列」，显示设备的驱动程序会定时从「读缓冲区队列」读取数据放到「写缓冲区队列」，最后把「写缓冲区队列」的数据写入到显示设备控制器的寄存器中的数据缓冲区</li><li>最后，恢复被中断进程的上下文</li></ul><h1 id="八、网络系统"><a href="#八、网络系统" class="headerlink" title="八、网络系统"></a>八、网络系统</h1><h2 id="8-1-什么是零拷贝？"><a href="#8-1-什么是零拷贝？" class="headerlink" title="8.1 什么是零拷贝？"></a>8.1 什么是零拷贝？</h2><h3 id="传统的文件传输有多糟糕？"><a href="#传统的文件传输有多糟糕？" class="headerlink" title="传统的文件传输有多糟糕？"></a>传统的文件传输有多糟糕？</h3><p>将磁盘上的文件读取出来，然后通过网络协议发送给客户端<strong>发生了 4 次用户态与内核态的上下文切换</strong>，<strong>发生了 4 次数据拷贝</strong>。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323153949122.png" style="zoom:67%;" /><hr><h3 id="如何优化文件传输的性能？"><a href="#如何优化文件传输的性能？" class="headerlink" title="如何优化文件传输的性能？"></a>如何优化文件传输的性能？</h3><p><strong>如何减少「用户态与内核态的上下文切换」的次数？</strong>  </p><p> 减少系统调用的次数</p><p><strong>如何减少「数据拷贝」的次数？</strong> </p><p>「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」这个过程是没有必要的。因为在用户空间我们并不会对数据「再加工」，因此<strong>用户的缓冲区是没有必要存在的</strong>。</p><hr><h3 id="如何实现零拷贝？"><a href="#如何实现零拷贝？" class="headerlink" title="如何实现零拷贝？"></a>如何实现零拷贝？</h3><p>零拷贝技术实现的方式通常有 2 种：</p><ul><li><p><strong>mmap + write</strong>：用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p><ul><li><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。而write函数直接从内核缓冲区将数据拷贝到socket缓冲区中。</li><li>可以减少一次数据拷贝的过程，但仍然需要 4 次上下文切换，因为系统调用还是 2 次</li></ul></li><li><p><strong>sendfile</strong>：这是一个专门发送文件的系统调用函数。</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">ssize_t</span> <span class="token function">sendfile</span><span class="token punctuation">(</span><span class="token keyword">int</span> out_fd<span class="token punctuation">,</span> <span class="token keyword">int</span> in_fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> <span class="token operator">*</span>offset<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用</li><li>该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝</li></ul><blockquote><p>如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术，那么可以将拷贝次数缩小为2此，从而实现<strong>零拷贝</strong>，其过程如下：</p><ul><li>通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，减少了一次数据拷贝；</li></ul></blockquote></li></ul><hr><h3 id="PageCache-有什么作用？"><a href="#PageCache-有什么作用？" class="headerlink" title="PageCache 有什么作用？"></a>PageCache 有什么作用？</h3><p>把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是<strong>磁盘高速缓存（*PageCache*）</strong>。</p><p><strong>PageCache 的优点</strong>主要是两个：</p><ul><li>缓存最近被访问的数据；</li><li>预读功能；</li></ul><p><strong>但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能</strong>，这是因为：</p><ul><li>PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；</li><li>PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；</li></ul><p><strong>所以大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术</strong></p><hr><h3 id="大文件传输用什么方式实现？"><a href="#大文件传输用什么方式实现？" class="headerlink" title="大文件传输用什么方式实现？"></a>大文件传输用什么方式实现？</h3><p><strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I&#x2F;O + 直接 I&#x2F;O」来替代零拷贝技术</strong>。</p><p>异步 I&#x2F;O 工作方式如下图，异步 I&#x2F;O 并没有涉及到 PageCache，所以使用异步 I&#x2F;O 就意味着要绕开 PageCache。对于磁盘，异步 I&#x2F;O 只支持直接 I&#x2F;O。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323160634929.png" style="zoom:67%;" /><blockquote><p>直接 I&#x2F;O 应用场景常见的两种：</p><ul><li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存</li><li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销</li></ul><p>由于直接 I&#x2F;O 绕过了 PageCache，就无法享受内核的这两点的优化：</p><ul><li>合并IO请求从而减少磁盘寻址操作</li><li>预读数据从而减少对磁盘的操作</li></ul></blockquote><p>传输文件的时候，要根据文件的大小来使用不同的方式：</p><ul><li>传输大文件的时候，使用「异步 I&#x2F;O + 直接 I&#x2F;O」；</li><li>传输小文件的时候，则使用「零拷贝技术」；</li></ul><h2 id="8-2-I-x2F-O-多路复用：select-x2F-poll-x2F-epoll"><a href="#8-2-I-x2F-O-多路复用：select-x2F-poll-x2F-epoll" class="headerlink" title="8.2 I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll"></a>8.2 I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll</h2><p><strong>文件描述符的作用是什么？</strong></p><blockquote><p>每一个进程都有一个数据结构 <code>task_struct</code>，该结构体里有一个指向「文件描述符数组」的成员指针。该数组里列出这个进程打开的所有文件的文件描述符。数组的下标是文件描述符，是一个整数，而数组的内容是一个指针，指向内核中所有打开的文件的列表，也就是说内核可以通过文件描述符找到对应打开的文件。</p></blockquote><p>每个文件都有一个 inode，Socket 文件的 inode 指向了内核中的 Socket 结构，在这个结构体里有两个队列，分别是<strong>发送队列</strong>和<strong>接收队列</strong>，这个两个队列里面保存的是一个个 <code>struct sk_buff</code>，用链表的组织形式串起来。</p><hr><h3 id="select-x2F-poll"><a href="#select-x2F-poll" class="headerlink" title="select&#x2F;poll"></a>select&#x2F;poll</h3><p>select 实现多路复用的方式：</p><ul><li>将已连接的 Socket 都放到一个<strong>文件描述符集合</strong></li><li>然后调用 select 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生</li><li>检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写</li><li>接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket</li></ul><p>缺点：</p><ul><li>需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里</li><li>发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中</li><li>所支持的文件描述符的个数是有限制的，但可以通过修改内核参数FD_SETSIZE 来解决</li></ul><p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p><p>poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong></p><hr><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><strong>使用</strong>:先用e poll_create 创建一个 epol l对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据</p><p>epoll 通过两个方面，很好解决了 select&#x2F;poll 的问题:</p><ul><li>epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，增删改一般时间复杂度是 <code>O(logn)</code>。 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</li><li>epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li></ul><p>epoll_wait返回数据时会将数据从内核拷贝到用户空间。</p><hr><h3 id="边缘触发和水平触发"><a href="#边缘触发和水平触发" class="headerlink" title="边缘触发和水平触发"></a>边缘触发和水平触发</h3><p>epoll 支持两种事件触发模式:</p><ul><li><strong>边缘触发</strong>：当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没一次读完数据。</li><li><strong>水平触发</strong>：当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong><ul><li>由于I&#x2F;O 事件发生时只会通知一次，因此需要<strong>循环</strong>从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里。所以，<strong>边缘触发模式一般和非阻塞 I&#x2F;O 搭配使用</strong>。</li></ul></li></ul><p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p><h2 id="8-3-高性能网络模式：Reactor-和-Proactor"><a href="#8-3-高性能网络模式：Reactor-和-Proactor" class="headerlink" title="8.3 高性能网络模式：Reactor 和 Proactor"></a>8.3 高性能网络模式：Reactor 和 Proactor</h2><h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p>Reactor 模式是<strong>非阻塞同步网络模式</strong>，主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：</p><ul><li>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；</li><li>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</li></ul><p>Reactor一般使用以下三种方案：</p><ul><li><p><strong>单 Reactor 单进程 &#x2F; 线程</strong></p><ul><li><p>Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发</p></li><li><p>如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；</p></li><li><p>如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；</p></li><li><p>缺点：</p><ul><li>无法充分利用 多核 CPU 的性能；</li><li>Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就造成响应的延迟；</li></ul></li><li><p>不适用计算机密集型的场景，只适用于业务处理非常快速的场景。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323175338913.png" style="zoom:67%;" /></li></ul></li><li><p><strong>单 Reactor 多进程 &#x2F; 线程</strong></p><ul><li>监听和事件分发和单Reactor单线程方案一样，不一样的步骤是：<ul><li>Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理；</li><li>子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client；</li></ul></li><li>因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323175718048.png" style="zoom:67%;" /></li><li><p><strong>多 Reactor 多进程 &#x2F; 线程</strong></p><ul><li>主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程；</li><li>子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。</li><li>如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。</li><li>Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li></ul></li></ul><hr><h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h3><p><strong>Proactor 是异步网络模式</strong></p><p>无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 <strong>Reactor 模式是基于「待完成」的 I&#x2F;O 事件，而 Proactor 模式则是基于「已完成」的 I&#x2F;O 事件</strong>。</p><blockquote><p>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」，而 Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</p><ul><li><strong>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件</strong>。在每次感知到有事件发生后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</li><li><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read&#x2F;write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230323180503685.png" style="zoom:80%;" /><p>Proactor 模式的工作流程：</p><ul><li>Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核；</li><li>Asynchronous Operation Processor 负责处理注册请求，并处理 I&#x2F;O 操作；</li><li>Asynchronous Operation Processor 完成 I&#x2F;O 操作后通知 Proactor；</li><li>Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理；</li><li>Handler 完成业务处理；</li></ul><blockquote><p>在 Linux 下的异步 I&#x2F;O 是不完善的， <code>aio</code> 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的</p><p> Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 <code>IOCP</code></p></blockquote><h1 id="8-4-什么是一致性哈希？"><a href="#8-4-什么是一致性哈希？" class="headerlink" title="8.4 什么是一致性哈希？"></a>8.4 什么是一致性哈希？</h1><blockquote><p>对于分布式系统，由于需要考虑负载均衡，因此需要将数据水平切分到不同节点上，访问数据的时候寻址存储该数据的节点。</p><p>哈希算法虽然能建立数据和节点的映射关系，但是每次在节点数量发生变化的时候，最坏情况下所有数据都需要迁移，这样太麻烦了，所以不适用节点数量变化的场景。</p></blockquote><p><strong>一致性哈希</strong>是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上（例如2^32大小的环），如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。</p><ul><li>对存储节点进行哈希计算，比如根据节点的 IP 地址进行哈希，将其映射到哈希环上；</li><li>当对数据进行存储或访问时，对数据进行哈希映射；</li></ul><p><strong>一致性哈希算法不能够均匀的分布节点</strong>，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。</p><p>解决办法：引入虚拟节点。不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，而真实节点包含多个虚拟节点。</p><ul><li>引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mit-6.824</title>
      <link href="/2023/02/15/%E9%A1%B9%E7%9B%AE/Mit-6.824/"/>
      <url>/2023/02/15/%E9%A1%B9%E7%9B%AE/Mit-6.824/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab1：MapReduce"><a href="#Lab1：MapReduce" class="headerlink" title="Lab1：MapReduce"></a>Lab1：MapReduce</h1><p>MapReduce框架：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230620115253482.png"></p><h2 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a><strong>任务描述</strong></h2><p>实现分布式MapReduce，一个coordinator，一个worker（启动多个），在这次实验都在一个机器上运行。worker通过rpc和coordinator交互。worker请求任务,进行运算,写出结果到文件。coordinator需要关心worker的任务是否完成，在超时情况下将任务重新分配给别的worker。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>系统的输入是一堆文件，每个文件对应一个 Map 任务。任务由 Worker 向 Coordinator 请求，由 Coordinator 向下分发。</li><li>在分发 Map 任务时，Coordinator 同时会传递 Reduce 的任务数量（NReduce）给 Worker。</li><li>每个 Map Worker 会生成 NReduce 个中间文件，将不同的 Key 哈希到不同文件里。文件命名为mr-n-m，其中n为文件序号，m为reduce序号</li><li>每个Reduce Worker x会读取所有mr-*-x文件，然后使用map函数对其处理，然后将其输出</li><li>使用临时文件方法来避免crash发生</li><li>使用互斥访问来避免并行执行时异常发生</li></ul><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>使用一个结构体来描述任务信息：</p><pre class="line-numbers language-none"><code class="language-none">type TaskInfo struct &#123;TaskType  string &#x2F;&#x2F;分为四种类型：Map、Reduce、Wait(等待所有Map执行完)、None(无任务，结束)FilePath  stringNReduce   intRidx      int &#x2F;&#x2F;reduce 任务idxFileN     int &#x2F;&#x2F;总文件数FileIdx   int &#x2F;&#x2F;当前任务文件序列号StartTime int64&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了简便，没有分开map任务信息和reduce信息。各字段说明如下：</p><ul><li>TaskType：分为Map、Reduce、Wait(等待所有Map或Reduce任务执行完)、None(无任务，结束)</li><li>FilePath：Map任务执行时的输入文件，Reduce任务忽略此字段</li><li>NReduce：Map将每个单词置于不同文件中，放置位置是使用单词的哈希函数除NReduce求得（这就使得将所有单词分离到不同Reduce任务中）。</li><li>Ridx：reduce 任务idx，即用于识别属于该reduce任务的文件</li><li>FileN：在Map任务重，每个输入文件都会输出NReduce个临时文件，因此在Reduce任务中需要知道所有文件数量才能读取完临时文件</li><li>FileIdx：当前任务文件序列号，用于Map任务时输出临时文件的文件名</li><li>StartTime：任务开始时间，主要用于判断当前任务是否已经超时，如果超时则使用重新分配此任务</li></ul><p>在实现的队列结构中，使用一个哈希表和mutex：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TaskQue <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>mQue  <span class="token keyword">map</span><span class="token punctuation">[</span>TaskInfo<span class="token punctuation">]</span><span class="token builtin">int</span>mutex sync<span class="token punctuation">.</span>Mutex<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>另外实现了pop、insert、getLen、empty、delete函数，主要是使用mutex来避免多线程访问时出现异常。</p><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a><em>Coordinator</em></h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Coordinator <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// Your definitions here.</span>mapDo       TaskQuemapDoing    TaskQuereduceDo    TaskQuereduceDoing TaskQuenReduce     <span class="token builtin">int</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>coordinator用于协调worker，其主要由四个队列组成：</p><ul><li>mapDo：需要执行map任务的队列</li><li>mapDoing：正在执行map任务的队列</li><li>reduceDo：需要执行reduce任务的队列</li><li>reduceDoing：正在执行reduce任务的队列</li></ul><p>主要实现了两个RPC函数：</p><ul><li><p>请求任务函数：GetTask，主要用于判断是分配Map、Reduce还是等待或结束程序，另外为了简便，还是此函数中判断了是否有超时任务，如果有则将其重新分配</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Coordinator<span class="token punctuation">)</span> <span class="token function">GetTask</span><span class="token punctuation">(</span>args <span class="token builtin">int</span><span class="token punctuation">,</span> reply <span class="token operator">*</span>TaskInfo<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span><span class="token comment">//map和reduce正在执行的任务超过10秒，则重新执行</span><span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span>mapDoing<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> key<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token keyword">range</span> c<span class="token punctuation">.</span>mapDoing<span class="token punctuation">.</span>mQue <span class="token punctuation">&#123;</span><span class="token keyword">if</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>key<span class="token punctuation">.</span>StartTime <span class="token operator">></span> <span class="token number">10</span> <span class="token punctuation">&#123;</span>tmp <span class="token operator">:=</span> c<span class="token punctuation">.</span>mapDoing<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>mapDo<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmp<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span>reduceDoing<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> key<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token keyword">range</span> c<span class="token punctuation">.</span>reduceDoing<span class="token punctuation">.</span>mQue <span class="token punctuation">&#123;</span><span class="token keyword">if</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>key<span class="token punctuation">.</span>StartTime <span class="token operator">></span> <span class="token number">10</span> <span class="token punctuation">&#123;</span>tmp <span class="token operator">:=</span> c<span class="token punctuation">.</span>reduceDoing<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>reduceDo<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmp<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span>mapDo<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>reply <span class="token operator">=</span> c<span class="token punctuation">.</span>mapDo<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>mapDoing<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span>mapDoing<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>reply <span class="token operator">=</span> TaskInfo<span class="token punctuation">&#123;</span><span class="token string">"Wait"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span>reduceDo<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>reply <span class="token operator">=</span> c<span class="token punctuation">.</span>reduceDo<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>reduceDoing<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> c<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>reply <span class="token operator">=</span> TaskInfo<span class="token punctuation">&#123;</span><span class="token string">"None"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>reply <span class="token operator">=</span> TaskInfo<span class="token punctuation">&#123;</span><span class="token string">"Wait"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>任务完成报告函数：FinReport，主要是判断完成的Map还是Reduce任务，并将其从相应的doing队列中移除</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Coordinator<span class="token punctuation">)</span> <span class="token function">FinReport</span><span class="token punctuation">(</span>args TaskInfo<span class="token punctuation">,</span> reply <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> args<span class="token punctuation">.</span>TaskType <span class="token operator">==</span> <span class="token string">"Map"</span> <span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>mapDoing<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> args<span class="token punctuation">.</span>TaskType <span class="token operator">==</span> <span class="token string">"Reduce"</span> <span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>reduceDoing<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><p>实现请求任务和报告任务完成函数的远程调用，根据请求任务的结果判断是执行Map任务还是Reduce任务或等待或结束进程。</p><p><strong>Map任务执行实现</strong>：根据taskinfo中的信息读取输入文件，使用mapf函数得到中间值，然后根据每个单词的不同哈希值将其存储到不同文件中（输出时使用时json进行编码）</p><ul><li>为了通过crash test，每个单词输出到临时文件，当所有单词输出完成后才将临时文件重命名。即使在重命名时程序崩溃，由于输出文件是使用的覆盖，因此也不会出现异常。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">doMap</span><span class="token punctuation">(</span>task <span class="token operator">*</span>TaskInfo<span class="token punctuation">,</span> mapf <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>KeyValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// fmt.Printf("Map id:%v, map time:%v\n", task.FileIdx, task.StartTime)</span>intermediate <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>KeyValue<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>filename <span class="token operator">:=</span> task<span class="token punctuation">.</span>FilePathfile<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"cannot open %v"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>content<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"cannot read %v"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>kva <span class="token operator">:=</span> <span class="token function">mapf</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span>intermediate <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>intermediate<span class="token punctuation">,</span> kva<span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">//生成临时文件，避免程序崩溃时导致错误发生</span>nReduce <span class="token operator">:=</span> task<span class="token punctuation">.</span>NReduceoutFiles <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>os<span class="token punctuation">.</span>File<span class="token punctuation">,</span> nReduce<span class="token punctuation">)</span>fileEncs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>json<span class="token punctuation">.</span>Encoder<span class="token punctuation">,</span> nReduce<span class="token punctuation">)</span><span class="token keyword">for</span> outIdx <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> outIdx <span class="token operator">&lt;</span> nReduce<span class="token punctuation">;</span> outIdx<span class="token operator">++</span> <span class="token punctuation">&#123;</span>outFiles<span class="token punctuation">[</span>outIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> ioutil<span class="token punctuation">.</span><span class="token function">TempFile</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"mr-tmp-*"</span><span class="token punctuation">)</span>fileEncs<span class="token punctuation">[</span>outIdx<span class="token punctuation">]</span> <span class="token operator">=</span> json<span class="token punctuation">.</span><span class="token function">NewEncoder</span><span class="token punctuation">(</span>outFiles<span class="token punctuation">[</span>outIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> kv <span class="token operator">:=</span> <span class="token keyword">range</span> intermediate <span class="token punctuation">&#123;</span>hashIdx <span class="token operator">:=</span> <span class="token function">ihash</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>Key<span class="token punctuation">)</span> <span class="token operator">%</span> nReduceenc <span class="token operator">:=</span> fileEncs<span class="token punctuation">[</span>hashIdx<span class="token punctuation">]</span>err <span class="token operator">:=</span> enc<span class="token punctuation">.</span><span class="token function">Encode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kv<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"kv encode failed! Error: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> outIdx<span class="token punctuation">,</span> file <span class="token operator">:=</span> <span class="token keyword">range</span> outFiles <span class="token punctuation">&#123;</span>newName <span class="token operator">:=</span> <span class="token string">"mr-"</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>FileIdx<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>outIdx<span class="token punctuation">)</span>oldName <span class="token operator">:=</span> filepath<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>os<span class="token punctuation">.</span><span class="token function">Rename</span><span class="token punctuation">(</span>oldName<span class="token punctuation">,</span> newName<span class="token punctuation">)</span>file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">CallFinReport</span><span class="token punctuation">(</span><span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Reduce任务执行实现</strong>：从所有属于该reduce任务的文件中读取数据，然后使用sort进行排序，再使用reducef函数输出。同理，为了通过crash test，使用临时文件进行输出。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">doReduce</span><span class="token punctuation">(</span>task <span class="token operator">*</span>TaskInfo<span class="token punctuation">,</span> reducef <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>intermediate <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>KeyValue<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> idx <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> idx <span class="token operator">&lt;</span> task<span class="token punctuation">.</span>FileN<span class="token punctuation">;</span> idx<span class="token operator">++</span> <span class="token punctuation">&#123;</span>fileName <span class="token operator">:=</span> <span class="token string">"mr-"</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>Ridx<span class="token punctuation">)</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"file:%v read failed!\n"</span><span class="token punctuation">,</span> fileName<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>dec <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">NewDecoder</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> kv KeyValue<span class="token keyword">if</span> err <span class="token operator">:=</span> dec<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kv<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>intermediate <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>intermediate<span class="token punctuation">,</span> kv<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>sort<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span><span class="token function">ByKey</span><span class="token punctuation">(</span>intermediate<span class="token punctuation">)</span><span class="token punctuation">)</span>outFile<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">TempFile</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"mr-tmp-out-*"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"create temp file failed!"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>i <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>intermediate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>j <span class="token operator">:=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token keyword">for</span> j <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>intermediate<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> intermediate<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>Key <span class="token operator">==</span> intermediate<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Key <span class="token punctuation">&#123;</span>j<span class="token operator">++</span><span class="token punctuation">&#125;</span>values <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> k <span class="token operator">:=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span> <span class="token punctuation">&#123;</span>values <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> intermediate<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>output <span class="token operator">:=</span> <span class="token function">reducef</span><span class="token punctuation">(</span>intermediate<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Key<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token comment">// this is the correct format for each line of Reduce output.</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>outFile<span class="token punctuation">,</span> <span class="token string">"%v %v\n"</span><span class="token punctuation">,</span> intermediate<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Key<span class="token punctuation">,</span> output<span class="token punctuation">)</span>i <span class="token operator">=</span> j<span class="token punctuation">&#125;</span>newName <span class="token operator">:=</span> <span class="token string">"mr-out-"</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>Ridx<span class="token punctuation">)</span>os<span class="token punctuation">.</span><span class="token function">Rename</span><span class="token punctuation">(</span>outFile<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> newName<span class="token punctuation">)</span>outFile<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">CallFinReport</span><span class="token punctuation">(</span><span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>early exit test不通过：</p><ul><li>此测试是为了测试在任务未完成情况下，是否有worker或master退出</li><li>在实现中，请求任务时会检测所有任务是否完成，如果为完成则wait，否则退出。</li></ul></blockquote><h1 id="Lab2：Raft"><a href="#Lab2：Raft" class="headerlink" title="Lab2：Raft"></a>Lab2：Raft</h1><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230426174946043.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230426174922607.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230428103956852.png"></p><p>bug</p><ul><li>当kv上层检测到需要发送Snapshot时，调用Snapshot函数，但此时raft底层从主raft收到安装镜像调用，将log进行修改，此时如果不进行log边界检查就会发生错误。</li><li>踩了一个坑，添加日志消息rpc的args中的entry需要进行深拷贝，否则可能因为log被修改从而导致args.entry发生改变。<ul><li>折腾了好久才发现这问题，其他rpc没进行深拷贝主要是因为其切片不会被改变，导致形成了思维定势。</li></ul></li></ul><h2 id="Label2A和Label2B"><a href="#Label2A和Label2B" class="headerlink" title="Label2A和Label2B"></a>Label2A和Label2B</h2><p>由于2A中的选举和2B中的日志复制有一部分相关，所以一起，但也可单独做2A，只是做2B的时候还需要修改2A代码</p><h3 id="任务描述-1"><a href="#任务描述-1" class="headerlink" title="任务描述"></a><strong>任务描述</strong></h3><p>实现分布式选举及分布式日志复制</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>raft结构体如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Raft <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>mu        sync<span class="token punctuation">.</span>Mutex          <span class="token comment">// Lock to protect shared access to this peer's state</span>peers     <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>labrpc<span class="token punctuation">.</span>ClientEnd <span class="token comment">// RPC end points of all peers</span>persister <span class="token operator">*</span>Persister          <span class="token comment">// Object to hold this peer's persisted state</span>me        <span class="token builtin">int</span>                 <span class="token comment">// this peer's index into peers[]</span>dead      <span class="token builtin">int32</span>               <span class="token comment">// set by Kill()</span>applyCh <span class="token operator">*</span><span class="token keyword">chan</span> ApplyMsg <span class="token comment">//通过此通道提交日志和snapshot</span><span class="token comment">//persistent state</span>currentTerm <span class="token builtin">int</span>     <span class="token comment">//当前term</span>votedFor    <span class="token builtin">int</span>     <span class="token comment">//当前投票给谁</span>log         <span class="token punctuation">[</span><span class="token punctuation">]</span>Entry <span class="token comment">//日志信息</span><span class="token comment">//Volatile state</span>state        <span class="token builtin">int</span>   <span class="token comment">//当前raft的状态：follower、candidate、leader之一</span>lastRecTime  <span class="token builtin">int64</span> <span class="token comment">//当前raft最后一次收到消息时间，毫秒时间戳</span>commitIndex  <span class="token builtin">int</span>   <span class="token comment">//当前日志待提交的序号</span>lastApplied  <span class="token builtin">int</span>   <span class="token comment">//已提交日志的序号</span>lastLogIndex <span class="token builtin">int</span>   <span class="token comment">//最后一个日志序号</span><span class="token comment">//Reinitialized after election</span>nextIndex  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment">//所有raft的下一个要发送日志的位置</span>matchIndex <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment">//和其他raft成功匹配的日志位置</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在结构体中添加了lastRecTime来记录最后一次收到消息时间，来实现超时选举。添加state来记录当时状态，lastLogIndex来记录最后一个日志位置。</p><p>创建raft时，commitIndex、lastApplied、lastLogIndex都初始化为1，votedFor&#x3D;-1，currentTerm&#x3D;0。为了lastApplied和commitIndex等使用方便，log初始化时添加了一个日志，使得不用每次访问log添加偏移。</p><p><strong>分布式选举</strong>：为每个raft创建一个定时器，当超过时间阈值进行选举，当收到日志消息或心跳时都会对lastRecTime进行更新</p><p><strong>日志复制</strong>：将心跳信息和发送日志合并为一个函数，心跳信息只是日志为空。通过检测日志是否匹配来更新nextIndex，从而更快完成日志复制。</p><p>主要有两个RPC方法，即：RequestVote（用于投票）和AppendEntries（用于接受心跳、添加日志等消息）</p><p>相应的，主要也是在三个函数中对这两个rpc方法进行调用：</p><ul><li>startElect（调用RequestVote进行选举）</li><li>syncAllEntries（调用AppendEntries用于添加同步日志）</li><li>sendAllHeartBeat（调用AppendEntries发送心跳）</li></ul><p>以下进行分别介绍这5个函数，其他方法如start等都较为简单</p><h4 id="RequestVote"><a href="#RequestVote" class="headerlink" title="RequestVote"></a>RequestVote</h4><p>request和reply结构体如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> RequestVoteArgs <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Term         <span class="token builtin">int</span> <span class="token comment">//rpc发起者的term</span>CandidateId  <span class="token builtin">int</span> <span class="token comment">//rpc发起者的序号</span>LastLogIndex <span class="token builtin">int</span> <span class="token comment">//rpc发起者的最后一个日志的序号</span>LastLogTerm  <span class="token builtin">int</span> <span class="token comment">//rpc发起者的最后一个日志的term</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> RequestVoteReply <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Term        <span class="token builtin">int</span> <span class="token comment">//被调用者的当前term</span>VoteGranted <span class="token builtin">bool</span> <span class="token comment">//被调用者是否同意投票给调用者</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此函数主要用于判断是否接受投票，其主要判断条件如下：</p><ul><li>如果请求方的term小于当前term，拒绝投票</li><li>在请求方的term不小于当前term的情况下，如果当前未投票，则比较日志谁最新。日志最新比较规则是最大term大者最新，若term相等，则日志长度越长者越新</li></ul><p>因此，此函数里面主要的实现逻辑就是上述条件。注意，如果args的term大于当前term，则必须更改当前raft的状态为follower并更新term，且将votedFor置为-1。</p><p>为了避免重复选举，每接收到一个vote都会对最后接受时间lastRecTime进行更新</p><h4 id="startElect"><a href="#startElect" class="headerlink" title="startElect"></a>startElect</h4><p>当每个raft最后一次收到消息时间超过阈值，则调用此函数进行新一轮选举。逻辑如下：</p><ul><li>首先将state置为candidate，votedFor设置自己，且将currentTerm+1</li><li>然后对除自己之外的raft发送投票请求<ul><li>当同意投票数量大于一半时（自己也算一票），则当前raft变为leader（注意，需要先判断此时currentTerm是否等于函数开始时的term，这是为了防止发起投票时，有其他raft发起新的投票）。由于超过半数就变为leader，为了防止多次变为leader，需当前状态为candidate才变为leader</li><li>如果收到拒绝投票，则判断reply的term是否大于当前term，若大于则更新当前term且将状态更改为follower</li></ul></li></ul><h4 id="AppendEntries"><a href="#AppendEntries" class="headerlink" title="AppendEntries"></a>AppendEntries</h4><p>request和reply结构体如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> RequestAppendArgs <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Term         <span class="token builtin">int</span>     <span class="token comment">//发起者当前term</span>LeaderId     <span class="token builtin">int</span>     <span class="token comment">//发起者id</span>PrevLogIndex <span class="token builtin">int</span>     <span class="token comment">//当前要添加日志的前一个日志位置</span>PrevLogTerm  <span class="token builtin">int</span>     <span class="token comment">//当前要添加日志的前一个日志的term</span>Entries      <span class="token punctuation">[</span><span class="token punctuation">]</span>Entry <span class="token comment">//要添加的日志</span>LeaderCommit <span class="token builtin">int</span>     <span class="token comment">//发起者的commit大小，主要用于接受者提交日志</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> RequestAppendReply <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Term       <span class="token builtin">int</span>    <span class="token comment">//接收方当前term</span>Success    <span class="token builtin">bool</span>   <span class="token comment">//是否成功添加日志</span>FailReason <span class="token builtin">string</span> <span class="token comment">//添加失败的原因，有点多余这参数，</span>UpdateNext <span class="token builtin">int</span>    <span class="token comment">//添加失败，即日志冲突时，需要将leader的nextIndex更新为UpdateNext</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此函数主要用于添加日志和接收心跳（心跳就是一个日志为空），其主要逻辑如下：</p><ul><li>如果args.term&lt;当前term，则拒绝添加日志，返回false</li><li>如果日志为空，则此消息时日志，对lastRecTime进行更新，且根据心跳消息中的LeaderCommit提交此raft的日志。</li><li>在上述两都不满足情况下，则说明此次请求是一个正常添加日志请求<ul><li>首先需要判断args.PrevLogIndex是否大于rf.lastLogIndex，大于则说明当前日志长度不够则返回false，且将reply.UpdateNext&#x3D;rf.lastLogIndex（注意，lastLogIndex可能为0，因此当其为0时需要将UpdateNext置为1，因为nextIndex最小为1）</li><li>args.PrevLogIndex小于等于rf.lastLogIndex，则需要判断rf.log[args.PrevLogIndex].Term 是否等于 args.PrevLogTerm，如果不等则说明日志不匹配，则返回false，且将UpdateNext更新为args.PrevLogIndex<ul><li>2C中如果只将UpdateNext更新为args.PrevLogIndex则会无法通过，需要优化。其优化规则是在当前日志中找到第一个日志term为rf.log[args.PrevLogIndex].Term的日志，这样就可以使得同一个term内的日志只退回一次。</li></ul></li><li>如果需添加日志的前一个日志不冲突，则比较需添加日志是否与当前日志冲突，若冲突则更改。不冲突，则添加。在添加日志后同样需要检查LeaderCommit，来更新当前的commit并提交日志。</li></ul></li></ul><h4 id="sendAllHeartBeat"><a href="#sendAllHeartBeat" class="headerlink" title="sendAllHeartBeat"></a>sendAllHeartBeat</h4><p>主要用于发送心跳信息，使用time.sleep每150ms发送一次，逻辑如下：</p><ul><li>每次发送前都需要判断当前状态是否为leader，如果不是则结束</li><li>向除自己外的raft发送心跳，LeaderCommit应该设置为min(rf.lastApplied, rf.matchIndex[idx])，如果reply.Term &gt; rf.currentTerm，则更新term并将状态置为follower。</li><li>注意，为了避免leader自己超时，每次发送心跳时也需要更新自己的lastRecTime</li></ul><blockquote><p>LeaderCommit没有按论文中的Fig2设置为commitIndex，这是为了避免日志还未同步完成就通过心跳消息发送了commit，此时日志可能还是错误的，就会导致错误日志被提交。当时这个折腾了老久。。。</p></blockquote><h4 id="syncAllEntries"><a href="#syncAllEntries" class="headerlink" title="syncAllEntries"></a>syncAllEntries</h4><p>此函数用于向其他raft同步日志，包括第一次成为leader时同步日志和有新日志时进行同步。逻辑如下：</p><ul><li>此函数为除自己为的raft都创建一个线程，线程一直运行，只有当term发生改变（又一次被选为leader）和不再为leader时才推出线程。</li><li>判断是否需要发送日志是通过比较lastLogIndex和rf.nextIndex[i]，如果lastLogIndex大于等于rf.nextIndex[i]则说明需要发送日志。<ul><li>如果reply为success，则需要将nextIndex更新为lastLogIndex + 1，matchIndex更新为lastLogIndex</li><li>如果reply失败：<ul><li>若由于第一次同步等原因日志不匹配导致失败，此时需要对nextIndex进行更新为UpdateNext</li><li>若由于此term小于被请求的term，则更改term、状态等并退出线程。</li></ul></li></ul></li><li>每次同步完日志后，需要遍历日志，找到序号最小且其被超过一半的raft提交的日志（即大于matchIndex超过一半），将commitIndex更新为此日志位置。<strong>注意</strong>，为了避免Fig8错误，若找到日志的term不等于当前term，则不更新commitIndex。<ul><li>还有一个更简单的方法，即通过找matchIndex的中位数，但尝试了下，有些测试有问题，还没解决。</li></ul></li><li>注意在此线程中没进入临界区都需要判断是否为leader或term是否发生变化。</li></ul><h2 id="Label2C"><a href="#Label2C" class="headerlink" title="Label2C"></a>Label2C</h2><p>主要实现persist函数和readPersist，其是对currentTerm、votedFor、log进行序列化保存和反序列化读取（把state也保存了。。）。根据example来写就行，注意readPersist中读取数据后，需要更新lastLogIndex值。</p><p>只会在创建raft时调用readPersist。按理说只要上述需要保存的三个变量发生变化就调用persist函数，但为了效率，只有当log和currentTerm发生变化时调用，即start函数、RequestVote和AppendEntries函数中调用</p><p>为了通过2C测试，需要对nextIndex更新做优化，否则可能无法通过。</p><h2 id="Label2D"><a href="#Label2D" class="headerlink" title="Label2D"></a>Label2D</h2><p>还有缺陷，将snapcommon中的iter减小后能通过lab2D，主要原因是发送同步消息时如果网络不通会很久才超时，有的要等5秒以上（网络其实早已经恢复，但还是很久才超时），从而导致每个iter处理时间很长（实验设计中同步消息是一个协程在做）</p><p>实现：</p><ul><li>此实验raft结构体添加了lastIncludedTerm和lastIncludedIndex，并需要将其持久化，且访问log需要带上lastIncludedIndex偏移。</li><li>修改persist函数，对snapshot也进行持久化。readPersist函数也需要读取snapshot。注意！提交ApplyMsg消息时不能持有锁，因为提交一定数量消息后会进行快照，此时调用Snapshot函数，而Snapshot函数中会申请锁，从而导致死锁。解决办法是创建一个协程来提交ApplyMsg消息。</li><li>实现Snapshot函数：此函数根据已经有的快照来修剪log，需同时修改lastIncludedTerm、lastIncludedIndex、commitIndex、lastApplied，且需要持久化。</li><li>实现InstallSnapshot函数：此函数对发送来得snapshot进行安装，安装成功后需要修改参数等，且需提交带snapshot的ApplyMsg</li><li>修改syncAllEntries函数：当nextIndex&lt;&#x3D;lastIncludedIndex时调用InstallSnapshot函数，需要对reply进行处理，如果term大于currentTerm则结束同步协程</li></ul><p>后续可做工作：</p><ul><li>发送日志消息时设置超时时间，如果超时则重发（已简单尝试，但会出错，考虑加上时间来排除重复请求）</li><li>合并发送日志函数和心跳函数。</li></ul><h1 id="Lab3：Kvraft"><a href="#Lab3：Kvraft" class="headerlink" title="Lab3：Kvraft"></a>Lab3：Kvraft</h1><p>整体逻辑：</p><ul><li>客户端不断轮询服务器知道请求成功</li><li>服务端使用一个线程来处理所有对数据的操作</li></ul><p>客户端：主要实现Get和PutAppend逻辑都差不多，都是先生成请求，不断向服务器发送请求知道请求成功，由于不知道leader，因此每次请求不成功就更改服务器id</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>ck <span class="token operator">*</span>Clerk<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>ck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ck<span class="token punctuation">.</span>requestId<span class="token operator">++</span>ck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>serverId <span class="token operator">:=</span> ck<span class="token punctuation">.</span>leaderIdargs <span class="token operator">:=</span> GetArgs<span class="token punctuation">&#123;</span>key<span class="token punctuation">,</span> ck<span class="token punctuation">.</span>me<span class="token punctuation">,</span> ck<span class="token punctuation">.</span>requestId<span class="token punctuation">&#125;</span><span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"ck[%v] send Get rpc..., args=%v"</span><span class="token punctuation">,</span> ck<span class="token punctuation">.</span>me<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>reply <span class="token operator">:=</span> GetReply<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>ok <span class="token operator">:=</span> ck<span class="token punctuation">.</span>servers<span class="token punctuation">[</span>serverId<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">"KVServer.Get"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>args<span class="token punctuation">,</span> <span class="token operator">&amp;</span>reply<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ok<span class="token punctuation">)</span> <span class="token operator">||</span> reply<span class="token punctuation">.</span>Err <span class="token operator">==</span> ErrWrongLeader <span class="token punctuation">&#123;</span>serverId <span class="token operator">=</span> <span class="token punctuation">(</span>serverId <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>ck<span class="token punctuation">.</span>servers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> reply<span class="token punctuation">.</span>Err <span class="token operator">==</span> ErrNoKey <span class="token punctuation">&#123;</span>ck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ck<span class="token punctuation">.</span>leaderId <span class="token operator">=</span> serverIdck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"ck[%v] get no key"</span><span class="token punctuation">,</span> ck<span class="token punctuation">.</span>me<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> reply<span class="token punctuation">.</span>Err <span class="token operator">==</span> OK <span class="token punctuation">&#123;</span>ck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ck<span class="token punctuation">.</span>leaderId <span class="token operator">=</span> serverIdck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"ck[%v] success get value=%v, args=%v"</span><span class="token punctuation">,</span> ck<span class="token punctuation">.</span>me<span class="token punctuation">,</span> reply<span class="token punctuation">.</span>Value<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token keyword">return</span> reply<span class="token punctuation">.</span>Value<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务端：主要实现对Get和PutAppend rpc的响应函数，及对raft底层提交的日志进行处理applyLoop。主要使用三个哈希表来记录状态：kvdb（记录数据库）、  clientLastReq（每个客户端记录的最后一个请求），applyWaitCh（记录每个请求对应的通道）。</p><ul><li>Get函数中，先使用start函数，根据返回值判断此kv是否为leader，如果是leader则需要创建一个通道用来等待服务处理完成的结果</li><li>applyLoop函数中，根据底层raft提交的日志消息不断处理，如果是snapshot日志则需要根据快照恢复状态，如果kv.maxraftstate-kv.rf.GetRaftStateSize()小于一定阈值则说明需要进行快照了。如果是普通操作，则先判断其操作ID是否重复，如果重复则不根据当前日志对数据库进行操作，否则进行操作并在哈希表中记录</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>KVServer<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>args <span class="token operator">*</span>GetArgs<span class="token punctuation">,</span> reply <span class="token operator">*</span>GetReply<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Your code here.</span><span class="token keyword">if</span> kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"kv[%v] is killed, return ErrWrongLeader"</span><span class="token punctuation">,</span> kv<span class="token punctuation">.</span>me<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>op <span class="token operator">:=</span> Op<span class="token punctuation">&#123;</span>GetOp<span class="token punctuation">,</span> args<span class="token punctuation">.</span>Key<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span>ClientId<span class="token punctuation">,</span> args<span class="token punctuation">.</span>RequestId<span class="token punctuation">&#125;</span>kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>index<span class="token punctuation">,</span> term<span class="token punctuation">,</span> isLeader <span class="token operator">:=</span> kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token keyword">if</span> term <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrNoKey<span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>isLeader <span class="token punctuation">&#123;</span>kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token comment">// DPrintf("kv[%v] is not a leader, return ErrWrongLeader", kv.me)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"kv[%v] start deal get, op=%v"</span><span class="token punctuation">,</span> kv<span class="token punctuation">.</span>me<span class="token punctuation">,</span> op<span class="token punctuation">)</span>curCh <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> applyRes<span class="token punctuation">)</span>command <span class="token operator">:=</span> commandEntry<span class="token punctuation">&#123;</span>op<span class="token punctuation">,</span> curCh<span class="token punctuation">&#125;</span>kv<span class="token punctuation">.</span>applyWaitCh<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> commandkv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token operator">!</span>kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> res <span class="token operator">:=</span> <span class="token operator">&lt;-</span>curCh<span class="token punctuation">:</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> res<span class="token punctuation">.</span>Errreply<span class="token punctuation">.</span>Value <span class="token operator">=</span> res<span class="token punctuation">.</span>Value<span class="token keyword">if</span> res<span class="token punctuation">.</span>Err <span class="token operator">==</span> OK <span class="token punctuation">&#123;</span><span class="token keyword">if</span> res<span class="token punctuation">.</span>Value <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>res<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrNoKey<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>DealTimeOut<span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token operator">&lt;-</span>curCh <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//需要接受处理结果，否则applyloop会死等</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"kv[%v] timeout, return ErrWrongLeader"</span><span class="token punctuation">,</span> kv<span class="token punctuation">.</span>me<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//当kv crash时</span><span class="token keyword">if</span> kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>KVServer<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>args <span class="token operator">*</span>GetArgs<span class="token punctuation">,</span> reply <span class="token operator">*</span>GetReply<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Your code here.</span><span class="token keyword">if</span> kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"kv[%v] is killed, return ErrWrongLeader"</span><span class="token punctuation">,</span> kv<span class="token punctuation">.</span>me<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>op <span class="token operator">:=</span> Op<span class="token punctuation">&#123;</span>GetOp<span class="token punctuation">,</span> args<span class="token punctuation">.</span>Key<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span>ClientId<span class="token punctuation">,</span> args<span class="token punctuation">.</span>RequestId<span class="token punctuation">&#125;</span>kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>index<span class="token punctuation">,</span> term<span class="token punctuation">,</span> isLeader <span class="token operator">:=</span> kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token keyword">if</span> term <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrNoKey<span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>isLeader <span class="token punctuation">&#123;</span>kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token comment">// DPrintf("kv[%v] is not a leader, return ErrWrongLeader", kv.me)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"kv[%v] start deal get, op=%v"</span><span class="token punctuation">,</span> kv<span class="token punctuation">.</span>me<span class="token punctuation">,</span> op<span class="token punctuation">)</span>curCh <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> applyRes<span class="token punctuation">)</span>command <span class="token operator">:=</span> commandEntry<span class="token punctuation">&#123;</span>op<span class="token punctuation">,</span> curCh<span class="token punctuation">&#125;</span>kv<span class="token punctuation">.</span>applyWaitCh<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> commandkv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token operator">!</span>kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> res <span class="token operator">:=</span> <span class="token operator">&lt;-</span>curCh<span class="token punctuation">:</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> res<span class="token punctuation">.</span>Errreply<span class="token punctuation">.</span>Value <span class="token operator">=</span> res<span class="token punctuation">.</span>Value<span class="token keyword">if</span> res<span class="token punctuation">.</span>Err <span class="token operator">==</span> OK <span class="token punctuation">&#123;</span><span class="token keyword">if</span> res<span class="token punctuation">.</span>Value <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>res<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrNoKey<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>DealTimeOut<span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token operator">&lt;-</span>curCh <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//需要接受处理结果，否则applyloop会死等</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token function">DPrintf</span><span class="token punctuation">(</span><span class="token string">"kv[%v] timeout, return ErrWrongLeader"</span><span class="token punctuation">,</span> kv<span class="token punctuation">.</span>me<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//当kv crash时</span><span class="token keyword">if</span> kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader<span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>遇到问题</p><ul><li>completion after heal (3A) 无法通过<ul><li>将请求响应等待超时时间设置的过大，导致没有超时返回ERRWrongLeader, 就不会重新发送请求将值设置为15，导致无法通过</li></ul></li></ul></blockquote><h1 id="Lab4：Sharded-KV-Service"><a href="#Lab4：Sharded-KV-Service" class="headerlink" title="Lab4：Sharded KV Service"></a>Lab4：Sharded KV Service</h1><h2 id="Label4A"><a href="#Label4A" class="headerlink" title="Label4A"></a>Label4A</h2><p>此实验需要实现一个高容错的配置管理中心，因此使用raft作为底层同步协议，使用多个服务器作为一个group，从而提供配置服务。</p><p>整体逻辑：</p><ul><li>每进行一次配置变动就形成新版本配置，且以前配置都需要在configs中进行保存</li><li>由于多个服务器需要进行同步，因此配置变动操作需要先提交给raft底层，然后根据raft apply的日志不断进行操作，因此需要有一个函数applyLoop不断循环处理raft提交的日志。</li><li>由于需要将操作提交到底层，因此需要一个结构体Op来描述各种操作及携带的数据，然后applyLoop根据日志中的Op进行相应处理。</li><li>在提交给raft后，需要等待操作完成，这里使用通道进行等待，没个操作对应一个通道，当applyLoop处理完一个操作就在对应通道发送信号。因此使用一个哈希表applyWaitCh来存储日志序号（每提交一个操作都会有唯一的日志序号）对应的通道。</li><li>当处理Join、Move、Leave操作后，需要对shard配置进行重新分配使得配置均衡。一个简单的算法就是不断找出当前分片数最多的服务器A和分片数最少得服务器B，然后将最后一个分片分配给分片数最少得服务器（注意这里不要用map存储，因为map取第一个值是随机的，从而导致多个服务器状态不同），知道分片最多服务器和分片最少服务器分片数量最多相差1。</li><li>和kvraft一样，为了过滤重复请求，使用一个哈希表 clientLastReq来记录每个客户端已被处理的最大请求和对应请求结果（用于get）</li><li>这里没有提供persister，因此无需进行snapshot处理</li></ul><p>各结构体如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ShardCtrler <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>mu      sync<span class="token punctuation">.</span>Mutexme      <span class="token builtin">int</span>rf      <span class="token operator">*</span>raft<span class="token punctuation">.</span>RaftapplyCh <span class="token keyword">chan</span> raft<span class="token punctuation">.</span>ApplyMsg<span class="token comment">// Your data here.</span>clientLastReq <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int64</span><span class="token punctuation">]</span>applyRes  <span class="token comment">//记录每个客户端已被处理的最大请求和对应请求结果，用于过滤重复请求</span>applyWaitCh   <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token keyword">chan</span> applyRes <span class="token comment">//存储日志序号（每提交一个操作都会有唯一的日志序号）对应的通道</span>lastApply <span class="token builtin">int</span> <span class="token comment">//最近被处理的日志序号，</span>configs   <span class="token punctuation">[</span><span class="token punctuation">]</span>Config <span class="token comment">// indexed by config num  存储当前所有配置</span>curConfId <span class="token builtin">int</span> <span class="token comment">//最后一个配置序号</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> applyRes <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Err   ErrreqId <span class="token builtin">int</span>Value Config<span class="token punctuation">&#125;</span><span class="token keyword">type</span> Op <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// Your data here.</span>Operation <span class="token builtin">string</span>ClientID  <span class="token builtin">int64</span>RequestId <span class="token builtin">int</span>Servers   <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token comment">//JoinOp</span>GIDs      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>            <span class="token comment">//LeaveOp</span>Shard     <span class="token builtin">int</span>              <span class="token comment">//MoveOp</span>GID       <span class="token builtin">int</span>              <span class="token comment">//MoveOp</span>Num       <span class="token builtin">int</span>              <span class="token comment">//QueryOp</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Label4B"><a href="#Label4B" class="headerlink" title="Label4B"></a>Label4B</h2><p>此部分需要实现一个分片kv服务，有多组group，每组group的多个服务器使用同一raft来同步数据，每组group存储不同分片，客户端通过哈希函数可确定需要访问哪个分片。由于配置会发生变化，因此还需要向其他group发送或接收分片数据。</p><p>主要逻辑：</p><ul><li>首先，和4a一样，客户端的各种操作需要向底层raft提交来进行操作，然后使用函数applyLoop不断循环处理raft提交的日志。</li><li>由于配置不断发生改变，因此使用一个线程detecConfLoop不断获取新配置。注意，只有在当前配置curConf和上一个配置preConf之间的数据已经同步完成才能获取新配置，且只获取比当前版本号大1的新配置。同步数据是否完成包含两个部分：<ul><li>发送数据是否完成：将不属于当前配置的切片发送给相应服务器，当未发送完成时需要向其他服务器发送，每当发送成功一个切片后需要向raft提交删除相应切片数据日志</li><li>接受数据是否完成：属于当前配置的切片是否已经接收完毕，每当接收一个切片数据就向raft提交更新切片数据日志。</li><li>注意，数据的更新和删除必须通过raft，才能使得整个group的状态一致。</li></ul></li><li></li></ul><p>bug1</p><ul><li>restart错误，未成功安装底层提交的镜像，因为判断是否安装的条件写反了</li><li>append重复提交应当成功处理</li><li>同一更新配置命令可能会提交两次（即使通道一直等待处理结果，也可能因为机器重启导致提交相同的配置两次）。当两次配置都被应用，导致value值被清空。解决方法：重复检测，如果新配置不比当前配置大则不配置。</li><li>底层raft有点问题，重新启动时需要提交一条空日志后raft才会向上层提交日志</li><li>记录客户端请求id时需要记录请求结果，当检测到重复请求时，返回上次请求结果，特别是GET请求。</li><li>需要特别处理shard配置为0时，此时将服务端设置为自己向自己发送消息。</li><li>发送更新shard消息时，由于网络不稳定，有时一直无法得到结果（call不通，不返回false，也没有reply）。解决方法：每次都随机在GRoup挑选一个进行发送，使得不会因为一个机器网络问题而一直不对后面机器进行尝试。</li><li>因为网络问题，shard数据已经发送成功，但返回结果时出现问题，且接收端应用了新配置，导致后面不断发送shard分片数据时，返回错误结果。解决方法：条件判定出错了，应该先判断是否为旧分片数据（使用confignum判断），然后再判断当前配置是否允许接受改分片</li><li>服务器重启后，日志还未重放完，此时发送shard数据从而导致数据缺失（一些操作已经返回操作成功结果，导致客户端不会在新服务器请求）。解决方法：设置一个是否重放完成标志，并在创建服务器后插入一条特殊日志，当应用到特殊日志时，就将标志设为true，在检测配置循环中，每次都判断标志。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式存储 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mprpc-分布式通信网络框架</title>
      <link href="/2023/02/15/%E9%A1%B9%E7%9B%AE/mprpc-%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/02/15/%E9%A1%B9%E7%9B%AE/mprpc-%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p><em>根据施磊<strong>C++实现分布式网络通信框架</strong>项目所写</em>, <a href="">视频地址</a></p><hr><hr><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><h2 id="1-1-技术栈"><a href="#1-1-技术栈" class="headerlink" title="1.1 技术栈"></a>1.1 技术栈</h2><ul><li>集群和分布式概念以及原理</li><li>RPC远程过程调用原理以及实现</li><li>Protobuf数据序列化和反序列化协议</li><li>ZooKeeper分布式一致性协调服务应用以及编程</li><li>muduo网络库编程</li><li>conf配置文件读取</li><li>异步日志</li><li>CMake构建项目集成编译环境</li><li>github管理项目</li></ul><h2 id="1-2-单机服务器、集群和分布式"><a href="#1-2-单机服务器、集群和分布式" class="headerlink" title="1.2 单机服务器、集群和分布式"></a>1.2 单机服务器、集群和分布式</h2><p><strong>单机服务器</strong></p><p>缺点：</p><ul><li>受限于硬件资源，聊天服务器所能承受的用户并发量有限</li><li>任意模块的修改，都会整个项目代码重新编译部署</li><li>系统中，有的任务是CPU密集型，有的则是IO密集型，造成各模块对硬件资源的需求不一样</li></ul><p><strong>集群</strong></p><p>每一台服务器独立运行一个工程的所有模块。</p><ul><li>优点：并发量提升</li><li>缺点：代码还需重新编译且需要多次部署，有的模块如后台管理不需要高并发不需要多次部署</li></ul><p><strong>分布式</strong></p><p>一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工</p><p>作共同提供服务，每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节</p><p>点模块集群部署。</p><h2 id="1-3-RPC通信原理"><a href="#1-3-RPC通信原理" class="headerlink" title="1.3 RPC通信原理"></a>1.3 RPC通信原理</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221113162552596.png"></p><ul><li><p>黄色部分：设计rpc方法参数的打包和解析，也就是数据的序列化和反序列化，使用Protobuf。</p></li><li><p>绿色部分：网络部分，包括寻找rpc服务主机，发起rpc调用请求和响应rpc调用结果，使用muduo网络库和zookeeper服务配置中心（专门做服务发现）。</p></li></ul><p>mprpc框架主要包含以上两个部分的内容</p><h2 id="1-4-Protobuf"><a href="#1-4-Protobuf" class="headerlink" title="1.4 Protobuf"></a>1.4 Protobuf</h2><p><code>protobuf</code> (protocol buffer) 是谷歌内部的混合语言数据标准。通过将结构化的数据进行序列化(串行化)，用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p><h3 id="1-4-1-message"><a href="#1-4-1-message" class="headerlink" title="1.4.1 message"></a>1.4.1 message</h3><blockquote><p><code>protobuf</code>中定义一个消息类型是通过关键字<code>message</code>字段指定的，这个关键字类似于C++&#x2F;Java中的class关键字。使用protobuf编译器将<code>proto</code>编译成C++代码之后，每个<code>message</code>都会生成一个名字与之对应的C++类，该类公开继承自<code>google::protobuf::Message</code>。</p></blockquote><p>声明protobuf版本</p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span><span class="token operator">=</span><span class="token string">"proto3"</span><span class="token punctuation">;</span><span class="token comment">//protobuf版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>声明定义message或service所在包（c++中对应为namespace）</p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">package</span> fixbug<span class="token punctuation">;</span><span class="token comment">//声明代码所在包（namespace）</span><span class="token keyword">package</span> a<span class="token punctuation">.</span>fixbug<span class="token punctuation">;</span><span class="token comment">//二级</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>message实例</strong></p><p>message有三种成员类型：数据、列表、映射表</p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">message</span> <span class="token class-name">ResultCode</span><span class="token punctuation">&#123;</span>    <span class="token builtin">int32</span> errcode<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token builtin">bytes</span> errmsg<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//登录消息类型</span><span class="token keyword">message</span> <span class="token class-name">LoginRequest</span><span class="token punctuation">&#123;</span>    <span class="token builtin">bytes</span> name<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//1:消息类型字段</span>    <span class="token builtin">bytes</span> pwd<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">// map&lt;int32,string> test=3; //映射表</span><span class="token punctuation">&#125;</span><span class="token comment">//登录相应消息类型</span><span class="token keyword">message</span> <span class="token class-name">LoginResponse</span><span class="token punctuation">&#123;</span>    <span class="token positional-class-name class-name">ResultCode</span> result<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//1为标识号</span>    <span class="token builtin">bool</span> success<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//定义User类型</span><span class="token keyword">message</span> <span class="token class-name">User</span><span class="token punctuation">&#123;</span>    <span class="token builtin">bytes</span> name<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token builtin">uint32</span> age<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">enum</span> <span class="token class-name">Sex</span><span class="token punctuation">&#123;</span><span class="token comment">//枚举</span>        MAN<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        WOMAN<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token positional-class-name class-name">Sex</span> sex<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">message</span> <span class="token class-name">GetFriendListsResponse</span><span class="token punctuation">&#123;</span>    <span class="token positional-class-name class-name">ResultCode</span> result<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">repeated</span> <span class="token positional-class-name class-name">User</span> friend_list<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//列表类型</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>message字段规则</strong></p><ul><li><code>required</code>:消息体中必填字段，不设置会导致编解码异常。</li><li><code>optional</code>: 消息体中可选字段，可通过default关键字设置默认值。</li><li><code>repeated</code>: 消息体中可重复字段，重复的值的顺序会被保留。其中，proto3默认使用packed方式存储，这样编码方式比较节省内存。</li></ul><blockquote><p>在proto3版本中，字段规则上移除了required，并把optional字段改名为singular。所有没有指定字段规则的字段默认为optional，</p></blockquote><p><strong>标识号</strong></p><p>在消息体的定义中，每个字段都必须要有一个唯一的标识号，标识号是[0,2^29-1]范围内的一个整数</p><p><strong>数据定义</strong></p><p>许多标准的简单数据类型都可以用作<code>message</code>字段类型，包括<code>bool</code>,<code>int32</code>,<code>float</code>,<code>double</code>和<code>string</code>。还可以使用其他<code>message</code>类型作为字段类型在消息体中添加更多结构，如上面的ResultCode。</p><p><strong>函数方法</strong></p><p>用<code>message</code>关键字声明的的消息体，允许你检查、操作、读、或写整个消息，包括解析二进制字符串，以及序列化二进制字符串。除此之外，也定义了下列方法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LoginResponse<span class="token operator">:</span>缺省的构造函数。<span class="token operator">~</span><span class="token function">LoginResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>缺省的析构函数。<span class="token function">LoginResponse</span><span class="token punctuation">(</span><span class="token keyword">const</span> LoginResponse<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">:</span>拷贝构造函数。LoginResponse<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> LoginResponse<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">:</span>赋值 <span class="token punctuation">(</span>Assignment ）操作符。<span class="token keyword">const</span> UnknownFieldSet<span class="token operator">&amp;</span> <span class="token function">unknown_fields</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token operator">:</span>返回当解析信息时遇到的未知字段的集合。UnknownFieldSet<span class="token operator">*</span> <span class="token function">mutable_unknown_fields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>返回当前解析信息时遇到的未知字段的集合的一个mutale指针。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>message实例</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> LoginRequest req<span class="token punctuation">;</span> req<span class="token punctuation">.</span><span class="token function">set_name</span><span class="token punctuation">(</span><span class="token string">"wang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> req<span class="token punctuation">.</span><span class="token function">set_pwd</span><span class="token punctuation">(</span><span class="token string">"123434"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对象序列化</span> std<span class="token double-colon punctuation">::</span>string send_str<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">SerializeToString</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>send_str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> send_str <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// send_str反序列化</span> LoginRequest reqB<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>reqB<span class="token punctuation">.</span><span class="token function">ParseFromString</span><span class="token punctuation">(</span>send_str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> reqB<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> reqB<span class="token punctuation">.</span><span class="token function">pwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">//GetFriendListsResponse 定义列表成员示例</span> GetFriendListsResponse rsp<span class="token punctuation">;</span> ResultCode <span class="token operator">*</span>rc <span class="token operator">=</span> rsp<span class="token punctuation">.</span><span class="token function">mutable_result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> rc<span class="token operator">-></span><span class="token function">set_errcode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> User <span class="token operator">*</span>user1 <span class="token operator">=</span> rsp<span class="token punctuation">.</span><span class="token function">add_friend_list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> user1<span class="token operator">-></span><span class="token function">set_name</span><span class="token punctuation">(</span><span class="token string">"zhang san"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> user1<span class="token operator">-></span><span class="token function">set_age</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> user1<span class="token operator">-></span><span class="token function">set_sex</span><span class="token punctuation">(</span>User<span class="token double-colon punctuation">::</span>MAN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置枚举</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> rsp<span class="token punctuation">.</span><span class="token function">friend_list_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>protobuf编译</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ main.cc test.pb.cc <span class="token parameter variable">-o</span> t <span class="token parameter variable">-std</span><span class="token operator">=</span>c++11 <span class="token parameter variable">-L</span> /usr/local/lib <span class="token parameter variable">-lprotobuf</span> <span class="token parameter variable">-pthread</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-4-2-service"><a href="#1-4-2-service" class="headerlink" title="1.4.2 service"></a>1.4.2 service</h3><p>message定义了消息类型，service则定义了方法</p><p>protobuf默认不生成service类，需使用如下option开启：</p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">option</span> cc_generic_services<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>service实例</strong></p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">service</span> <span class="token class-name">UserServiceRpc</span><span class="token punctuation">&#123;</span>    <span class="token keyword">rpc</span> <span class="token function">Login</span><span class="token punctuation">(</span><span class="token class-name">LoginRequest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">LoginResponse</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">rpc</span> <span class="token function">GetFriendLists</span><span class="token punctuation">(</span><span class="token class-name">GetFriendListsQuest</span><span class="token punctuation">)</span> <span class="token keyword">returns</span><span class="token punctuation">(</span><span class="token class-name">GetFriendListsResponse</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>定义的UserServiceRpc默认会生成两个类：UserServiceRpc和UserServiceRpc_Stub</p><p><strong>UserServiceRpc</strong></p><p>是被调用类，其继承自protobuf的service基类</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UserServiceRpc</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span><span class="token class-name">Service</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">protected</span><span class="token operator">:</span>  <span class="token comment">// This class should be treated as an abstract interface.</span>  <span class="token keyword">inline</span> <span class="token function">UserServiceRpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">UserServiceRpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">typedef</span> UserServiceRpc_Stub Stub<span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>ServiceDescriptor<span class="token operator">*</span> <span class="token function">descriptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Login</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                       <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>LoginRequest<span class="token operator">*</span> request<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>LoginResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">GetFriendLists</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                       <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>GetFriendListsQuest<span class="token operator">*</span> request<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>GetFriendListsResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// implements Service ----------------------------------------------</span>  <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>ServiceDescriptor<span class="token operator">*</span> <span class="token function">GetDescriptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>UserServiceRpc_Stub</strong></p><p>UserServiceRpc_Stub是调用类，其继承自UserServiceRpc类，通过使用此类来调用方法，</p><p>注意，其没有默认的初始化构造函数，需通过RpcChannel指针来初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UserServiceRpc_Stub</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">UserServiceRpc</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">UserServiceRpc_Stub</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcChannel<span class="token operator">*</span> channel<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">UserServiceRpc_Stub</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcChannel<span class="token operator">*</span> channel<span class="token punctuation">,</span>                   <span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>Service<span class="token double-colon punctuation">::</span>ChannelOwnership ownership<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">~</span><span class="token function">UserServiceRpc_Stub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">Login</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                       <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>LoginRequest<span class="token operator">*</span> request<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>LoginResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">GetFriendLists</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                       <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>GetFriendListsQuest<span class="token operator">*</span> request<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>GetFriendListsResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                       <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcChannel<span class="token operator">*</span> channel_<span class="token punctuation">;</span>  <span class="token keyword">bool</span> owns_channel_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意看Login和GetFriendLists方法实现如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">UserServiceRpc_Stub</span><span class="token double-colon punctuation">::</span><span class="token function">Login</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                              <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>LoginRequest<span class="token operator">*</span> request<span class="token punctuation">,</span>                              <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>LoginResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                              <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  channel_<span class="token operator">-></span><span class="token function">CallMethod</span><span class="token punctuation">(</span><span class="token function">descriptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">method</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       controller<span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token class-name">UserServiceRpc_Stub</span><span class="token double-colon punctuation">::</span><span class="token function">GetFriendLists</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                              <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>GetFriendListsQuest<span class="token operator">*</span> request<span class="token punctuation">,</span>                              <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>GetFriendListsResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                              <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  channel_<span class="token operator">-></span><span class="token function">CallMethod</span><span class="token punctuation">(</span><span class="token function">descriptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">method</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       controller<span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个方法都是通过调用channel的CallMethod来调用，因此需要使用一个MyRpcChannel类继承RpcChannel类，实现其CallMethod方法来完成序列号、调用等操作。</p><h1 id="2-mprpc实现"><a href="#2-mprpc实现" class="headerlink" title="2. mprpc实现"></a>2. mprpc实现</h1><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221113162552596.png"></p><p>如上图，黄色部分的序列化和反序列化都是通过调用protobuf来完成，而mprpc框架主要使用muduo来接受请求调用然后调用相应函数，最后返回结果。</p><p>Caller的功能由RpcChannel类来实现，而Callee的功能由RpcProvidre类来实现。</p><h2 id="2-1-RpcProvidre类"><a href="#2-1-RpcProvidre类" class="headerlink" title="2.1 RpcProvidre类"></a>2.1 RpcProvidre类</h2><p>RpcProvider类需要实现接受请求，然后将其解析得到需要调用的方法和参数，然后调用相应方法和参数，最后将调用结果序列化发送给调用方。</p><p><strong>私有成员</strong></p><p>将OnMessage绑定到muduo库，当有消息到来时，所有反序列化、调用函数等操作都在OnMessage函数中进行</p><p>最后将调用结果发送到调用方是在SendRpcResponse方法中进行</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//组合eventloop</span>muduo<span class="token double-colon punctuation">::</span>EventLoop m_eventLoop<span class="token punctuation">;</span><span class="token comment">// service服务类型信息</span><span class="token keyword">struct</span> <span class="token class-name">ServiceInfo</span> <span class="token punctuation">&#123;</span>  google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Service <span class="token operator">*</span>m_service<span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">const</span> google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>MethodDescriptor <span class="token operator">*</span><span class="token operator">></span>      m_methodMap<span class="token punctuation">;</span>  <span class="token comment">//保存服务方法</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//存储服务对象和其服务方法的所有信息</span>std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> ServiceInfo<span class="token operator">></span> m_serviceMap<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">OnConnection</span><span class="token punctuation">(</span><span class="token keyword">const</span> muduo<span class="token double-colon punctuation">::</span>TcpConnectionPtr <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">OnMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> muduo<span class="token double-colon punctuation">::</span>TcpConnectionPtr <span class="token operator">&amp;</span><span class="token punctuation">,</span> muduo<span class="token double-colon punctuation">::</span>Buffer <span class="token operator">*</span><span class="token punctuation">,</span>               muduo<span class="token double-colon punctuation">::</span>Timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// closure回调操作，用于序列号rpc的响应和网络发送</span><span class="token keyword">void</span> <span class="token function">SendRpcResponse</span><span class="token punctuation">(</span><span class="token keyword">const</span> muduo<span class="token double-colon punctuation">::</span>TcpConnectionPtr <span class="token operator">&amp;</span><span class="token punctuation">,</span>                     google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Message <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>公有成员</strong></p><p>用户通过NotiFyService发布方法，然后调用Run函数即可</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//发布Rpc方法的函数 主要是通过遍历将service中的函数指针和函数名都保存起来，方便调用</span><span class="token keyword">void</span> <span class="token function">NotiFyService</span><span class="token punctuation">(</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Service <span class="token operator">*</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//启动rpc服务节点，开始提供rpc远程网络调用服务：绑定消息函数，启动server监听</span><span class="token keyword">void</span> <span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键函数</strong></p><p>OnMessage（当请求到来，如何进行处理）：</p><ul><li>通过请求头大小及请求参数大小等解析出请求service_name和method_name及请求参数，然后根据服务名和方法名在存储服务及对应方法的map中找到对应的类指针，然后就通过该指针调用相应方法。</li><li>注意看以下代码，调用方法是使用service的CallMethod方法进行（每个service都会实现一个CallMethod方法，传入对应方法就可以调用），而CallMethod最后一个参数是回调函数，当CallMethod执行完后会回调done-run()方法。在这里使用SendRpcResponse定义了一个closure类用于回调。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//获取service对象</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Service <span class="token operator">*</span>service <span class="token operator">=</span> it<span class="token operator">-></span>second<span class="token punctuation">.</span>m_service<span class="token punctuation">;</span><span class="token comment">//获取method方法</span><span class="token keyword">const</span> google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>MethodDescriptor <span class="token operator">*</span>method <span class="token operator">=</span> mit<span class="token operator">-></span>second<span class="token punctuation">;</span><span class="token comment">//生成rpc方法调用的请求request和响应response参数</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Message <span class="token operator">*</span>request <span class="token operator">=</span>    service<span class="token operator">-></span><span class="token function">GetRequestPrototype</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>request<span class="token operator">-></span><span class="token function">ParseFromString</span><span class="token punctuation">(</span>args_str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"request parse error! content:%s"</span><span class="token punctuation">,</span> args_str<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Message <span class="token operator">*</span>response <span class="token operator">=</span>    service<span class="token operator">-></span><span class="token function">GetResponsePrototype</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// method方法绑定一个closure的回调函数</span><span class="token comment">//相当于使用SendRpcResponse函数重写了closure类中的Run方法,在用户自己写得服务中最后会执行done->run(),最终会执行SendRpcResponse方法</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure <span class="token operator">*</span>done <span class="token operator">=</span>    google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">NewCallback</span><span class="token generic class-name"><span class="token operator">&lt;</span>RpcProvider<span class="token punctuation">,</span>                                  <span class="token keyword">const</span> muduo<span class="token double-colon punctuation">::</span>TcpConnectionPtr <span class="token operator">&amp;</span><span class="token punctuation">,</span>                                  google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Message <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>        <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>RpcProvider<span class="token double-colon punctuation">::</span>SendRpcResponse<span class="token punctuation">,</span> conn<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用rpc方法</span>service<span class="token operator">-></span><span class="token function">CallMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-MprpcChannel类"><a href="#2-2-MprpcChannel类" class="headerlink" title="2.2 MprpcChannel类"></a>2.2 MprpcChannel类</h2><p>在使用中，用户都是通过调用protobuf提供的<em>ServiceRpc_Stub</em>类来调用函数的，而<em>ServiceRpc_Stub</em>初始化需要一个<em>RpcChannel</em>，当调用<em>ServiceRpc_Stub</em>的函数时最后都会转到调用<em>RpcChannel</em>的CallMethod方法，因此需要将<em>MprpcChannel</em>类继承rpcchannel类，实现其虚有方法CallMethod即可。</p><p>例如，自定义的一个方法，使用stub调用时其底层是使用CallMethod进行调用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">FriendServiceRpc_Stub</span><span class="token double-colon punctuation">::</span><span class="token function">getFriendList</span><span class="token punctuation">(</span><span class="token double-colon punctuation">::</span>PROTOBUF_NAMESPACE_ID<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                              <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>getFriendListRequest<span class="token operator">*</span> request<span class="token punctuation">,</span>                              <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>getFriendListResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                              <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  channel_<span class="token operator">-></span><span class="token function">CallMethod</span><span class="token punctuation">(</span><span class="token function">descriptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">method</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       controller<span class="token punctuation">,</span> request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> done<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MprpcChannel类只有一个成员：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//所有通过stub代理对象调用的rpc方法，都到这里做rpc方法调用数据的序列化和网络发送</span><span class="token keyword">void</span> <span class="token function">CallMethod</span><span class="token punctuation">(</span><span class="token keyword">const</span> google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>MethodDescriptor<span class="token operator">*</span> method<span class="token punctuation">,</span>                google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                <span class="token keyword">const</span> google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Message<span class="token operator">*</span> request<span class="token punctuation">,</span>                google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Message<span class="token operator">*</span> response<span class="token punctuation">,</span>                google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在CallMethod方法中，主要是将要调用的方法名和参数进行序列化然后发送到远程，然后等待其返回结果，最后将返回结果反序列化即可。</p><h2 id="2-3-mprpccontroller类"><a href="#2-3-mprpccontroller类" class="headerlink" title="2.3 mprpccontroller类"></a>2.3 mprpccontroller类</h2><p>此类主要是用来控制rpc调用过程中出现的错误信息，如设置错误，获取错误信息。</p><h2 id="2-4-Mprpc框架使用"><a href="#2-4-Mprpc框架使用" class="headerlink" title="2.4 Mprpc框架使用"></a>2.4 Mprpc框架使用</h2><p>先使用protobuf定义好远程调用service、方法和参数，比如定义提供<em>FriendServiceRpc</em>，其中包括GetFriendList方法</p><p><strong>callee</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">FriendService</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> fixbug<span class="token double-colon punctuation">::</span><span class="token class-name">FriendServiceRpc</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> <span class="token function">GetFriendList</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> userid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">getFriendList</span><span class="token punctuation">(</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>RpcController<span class="token operator">*</span> controller<span class="token punctuation">,</span>                     <span class="token keyword">const</span> <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>getFriendListRequest<span class="token operator">*</span> request<span class="token punctuation">,</span>                     <span class="token double-colon punctuation">::</span>fixbug<span class="token double-colon punctuation">::</span>getFriendListResponse<span class="token operator">*</span> response<span class="token punctuation">,</span>                     <span class="token double-colon punctuation">::</span>google<span class="token double-colon punctuation">::</span>protobuf<span class="token double-colon punctuation">::</span>Closure<span class="token operator">*</span> done<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于提供服务者，定义<em>FriendService</em>类继承<em>FriendServiceRpc</em>类，实现其虚有方法getFriendList，为使逻辑清晰，注意在此getFriendList方法中只是将设计的远程调用参数转为本地调用需要的参数，然后调用业务逻辑，最后将返回的参数打包成远程接口参数，并没有在此函数中执行真正的业务逻辑。</p><p>最后，用户只需要将此业务注册发布即可</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"first log message test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"%s:%s:%d"</span><span class="token punctuation">,</span><span class="token constant">__FILE__</span><span class="token punctuation">,</span>__FUNCTION__<span class="token punctuation">,</span><span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//框架初始化</span>  <span class="token class-name">MprpcApplication</span><span class="token double-colon punctuation">::</span><span class="token function">Init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>  RpcProvider provider<span class="token punctuation">;</span>  provider<span class="token punctuation">.</span><span class="token function">NotiFyService</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">FriendService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  provider<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>caller</strong></p><p>调用方都是通过protobu生成的service_stub去调用，只需要在定义service_stub变量时使用mprpcchannel初始化，然后定义请求参数和接受参数变量，再调用stub的方法即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//需要先调用框架的初始化函数</span>  <span class="token class-name">MprpcApplication</span><span class="token double-colon punctuation">::</span><span class="token function">Init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//调用远程发布的rpc方法Login</span>  fixbug<span class="token double-colon punctuation">::</span>FriendServiceRpc_Stub <span class="token function">stub</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">MprpcChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//相当于调用RpcChannel->RpcChannel::callMethod</span>  <span class="token comment">// stub.Login();</span>  fixbug<span class="token double-colon punctuation">::</span>getFriendListRequest request<span class="token punctuation">;</span>  request<span class="token punctuation">.</span><span class="token function">set_id</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  fixbug<span class="token double-colon punctuation">::</span>getFriendListResponse response<span class="token punctuation">;</span>  MprpcController controller<span class="token punctuation">;</span>  stub<span class="token punctuation">.</span><span class="token function">getFriendList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>controller<span class="token punctuation">,</span> <span class="token operator">&amp;</span>request<span class="token punctuation">,</span> <span class="token operator">&amp;</span>response<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>controller<span class="token punctuation">.</span><span class="token function">Failed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> controller<span class="token punctuation">.</span><span class="token function">ErrorText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">errcode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"rpc login response: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> name <span class="token operator">:</span> response<span class="token punctuation">.</span><span class="token function">friends</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> name<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"rpc login response error:%s"</span><span class="token punctuation">,</span>               response<span class="token punctuation">.</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">errmsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>179. 最大数</title>
      <link href="/2023/02/15/leetcode/other/leetcode-179-%E6%9C%80%E5%A4%A7%E6%95%B0-middle/"/>
      <url>/2023/02/15/leetcode/other/leetcode-179-%E6%9C%80%E5%A4%A7%E6%95%B0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a href="https://leetcode.cn/problems/largest-number/">179. 最大数</a></h1><p>FIrst：开始折腾比较规则，后来想到为啥不直接拼好再比较。。。</p><hr><p><strong>方法1</strong>：<strong>排序</strong></p><p>将所有值进行比较排序，每两个值比较时看谁拼接起来大（也可以使用数字算加和）</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(int a,int b)&#123;        string sa&#x3D;to_string(a);        string sb&#x3D;to_string(b);        string ka&#x3D;sa+sb;        string kb&#x3D;sb+sa;        return ka&gt;kb;    &#125;    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end(),compare);        if(nums[0]&#x3D;&#x3D;0) return &quot;0&quot;;        string ans;        for(auto a:nums)&#123;            ans+&#x3D;to_string(a);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小林coding-计算机网络-笔记</title>
      <link href="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B0%8F%E6%9E%97coding-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>总结知识点，以便以后快速复习。</p><p><em>参考小林coding网络图解</em>, <a href="https://www.xiaolincoding.com/network">地址</a></p><h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="1-1-TCP-x2F-IP-网络模型有哪几层？"><a href="#1-1-TCP-x2F-IP-网络模型有哪几层？" class="headerlink" title="1.1 TCP&#x2F;IP 网络模型有哪几层？"></a>1.1 TCP&#x2F;IP 网络模型有哪几层？</h2><p><strong>应用层</strong></p><ul><li>应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的</li><li>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态</li></ul><p><strong>传输层</strong>：</p><ul><li><p>为应用层提供网络支持</p></li><li><p>TCP 的全称叫传输控制协议，大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p><blockquote><p><strong>IP层有分块，为什么TCP还要分块？</strong></p><p>应用需要传输的数据可能会非常大，当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。</p><p>如果TCP不进行分块，则在IP层可能会分块，当一个分块丢失，则需要重传整个数据，造成效率很低。</p></blockquote></li><li><p>UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。</p></li><li><p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。</p></li></ul><p><strong>网络层</strong></p><ul><li><p>实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，这就是网络层要干的事。</p></li><li><p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p></li><li><p>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</p></li></ul><p><strong>网络接口层</strong></p><ul><li>网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备</li><li>网络接口层通常负责直接相连的节点之间的传输</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316210322498.png"></p><p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p><h2 id="1-2-键入网址到网页显示，期间发生了什么？"><a href="#1-2-键入网址到网页显示，期间发生了什么？" class="headerlink" title="1.2 键入网址到网页显示，期间发生了什么？"></a>1.2 键入网址到网页显示，期间发生了什么？</h2><ol><li><p>解析 URL：使用DNS解析域名</p><ul><li>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/6.jpg"></li></ul></li><li><p>使用操作系统中的协议栈来发送HTTP数据</p><ul><li><p>先三次握手建立连接</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316211136080.png"></p></li></ul></li></ol><h2 id="1-3-Linux-系统是如何收发网络包的？"><a href="#1-3-Linux-系统是如何收发网络包的？" class="headerlink" title="1.3 Linux 系统是如何收发网络包的？"></a>1.3 Linux 系统是如何收发网络包的？</h2><p><strong>Linux 网络协议栈</strong></p><ul><li>应用程序需要通过系统调用，来跟 Socket 层进行数据交互；</li><li>Socket 层的下面就是传输层、网络层和网络接口层；</li><li>最下面的一层，则是网卡驱动程序和硬件网卡设备；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316211406095.png"></p><p><strong>Linux 接收网络包的流程</strong></p><ul><li>当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区</li><li>触发一个中断告诉操作系统有数据到达，后面操作系统会发起一个软中断用于处理数据。内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。<ul><li>为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 NAPI 机制（<em>NAPI 机制</em>：不采用中断的方式读取数据，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据）</li></ul></li><li>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</li><li>在网络接口层，检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，接着再去掉帧头和帧尾，然后交给网络层</li><li>到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。</li><li>传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」(TCP) 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。</li><li>应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316211518689.png"></p><p><strong>Linux 发送网络包的流程</strong></p><ol><li>应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 sk_buff 内存，<strong>将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区</strong>。</li><li>网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理</li><li>如果使用的是 TCP 传输协议发送数据，那么<strong>先拷贝一个新的 sk_buff 副本</strong>，然后对 sk_buff 填充 TCP 头。<ul><li>拷贝副本原因：因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉，而 TCP 协议是支持丢失重传的。</li></ul></li><li>在网络层里会选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。然后交给网络接口层处理。</li><li>网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中。</li><li>这些工作准备好后，会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</li><li>当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放 sk_buff 内存和清理 RingBuffer 内存。</li><li>最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 sk_buff 。</li></ol><blockquote><p>为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，通过调整 sk_buff 中 <code>data</code> 的指针：</p><ul><li>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。</li><li>当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。</li></ul></blockquote><blockquote><p><strong>发送网络数据的时候，涉及几次内存拷贝操作？</strong></p><ul><li>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</li><li>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</li><li>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff</li></ul></blockquote><h1 id="二、HTTP篇"><a href="#二、HTTP篇" class="headerlink" title="二、HTTP篇"></a>二、HTTP篇</h1><h2 id="2-1-HTTP-常见面试题"><a href="#2-1-HTTP-常见面试题" class="headerlink" title="2.1 HTTP 常见面试题"></a>2.1 HTTP 常见面试题</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230316213651972.png"></p><h3 id="HTTP-是什么？"><a href="#HTTP-是什么？" class="headerlink" title="HTTP 是什么？"></a>HTTP 是什么？</h3><p>HTTP 的名字「超文本协议传输」，它可以拆成三个部分：</p><ul><li>超文本：超越普通文字，包括文字、图片、视频等</li><li>传输：确立在两点之间传输数据的约定和规范</li><li>协议：确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式（行为约定和规范）</li></ul><p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><hr><h3 id="HTTP-常见的状态码有哪些？"><a href="#HTTP-常见的状态码有哪些？" class="headerlink" title="HTTP 常见的状态码有哪些？"></a>HTTP 常见的状态码有哪些？</h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329155907563.png"></p><hr><h3 id="HTTP-常见字段有哪些？"><a href="#HTTP-常见字段有哪些？" class="headerlink" title="HTTP 常见字段有哪些？"></a>HTTP 常见字段有哪些？</h3><ul><li><strong><em>Host</em> 字段</strong>：使用此字段可以在相同ip+端口部署不同服务</li><li><em><strong>Content-Length 字段</strong></em>：数据长度（为了解决粘包问题）</li><li><em><strong>Connection 字段</strong></em>：最常用于客户端要求服务器使用「HTTP 长连接」机制（http1.1默认开启keep alibe，1.0则是关闭）</li><li><em><strong>Content-Type 字段</strong></em>：数据格式</li><li><em><strong>Content-Encoding 字段</strong></em>：数据压缩方法</li></ul><hr><h3 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h3><ul><li>GET 的语义是从服务器获取指定的资源，GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII</li><li>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理，POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据</li></ul><hr><h3 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h3><blockquote><p>「安全」是指请求方法不会「破坏」服务器上的资源；「幂等」是指多次执行相同的操作，结果都是「相同」的。</p></blockquote><ul><li>GET 方法就是安全且幂等的，因为它是「只读」操作（所以可以对get请求的数据做缓存）</li><li>POST方法是不安全且不幂等的，因为它会修改服务器上的资源（所以一般不会缓存post请求）</li></ul><p>上述是RFC规范，但如果不遵循规范可能会导致get并非安全且幂等</p><blockquote><p><strong>GET 请求可以带 body 吗？</strong></p><p>RFC 规范并没有规定 GET 请求不能带 body，任何请求都可以带 body 的 。</p><p>URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的</p></blockquote><hr><h3 id="HTTP-缓存有哪些实现方式？"><a href="#HTTP-缓存有哪些实现方式？" class="headerlink" title="HTTP 缓存有哪些实现方式？"></a>HTTP 缓存有哪些实现方式？</h3><p>两种实现方式：</p><ul><li><p><strong>强制缓存</strong>：只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p><ul><li>HTTP头部有两个字段用于表示缓存有效时间：<code>Cache-Control</code>，相对时间；<code>Expires</code>，绝对时间；</li><li>Cache-Control 的优先级高于 Expires </li><li>具体实现流程如下：<ul><li>当第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul></li></ul></li><li><p><strong>协商缓存</strong>：与服务端协商之后，通过协商结果来判断是否使用本地缓存。协商缓存可以基于两种头部来实现：</p><ul><li>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现<ul><li><code>Last-Modified</code> ：标示这个响应资源的最后修改时间</li><li><code>If-Modified-Since</code>：当资源过期，其具有Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后与被请求资源的最后修改时间进行对比，如果资源被改过，则返回最新资源，HTTP 200 OK；如果资源无新修改，响应 HTTP 304 走缓存。</li></ul></li><li>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段<ul><li><code>Etag</code>：唯一标识响应资源；</li><li><code>If-None-Match</code>：当资源过期时，其具有有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul></li><li>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</li></ul><blockquote><p>请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，<strong>这时 Etag 的优先级更高</strong>。服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。这样做是因为：</p><ul><li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致认为这文件被改动了</li><li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的</li><li>有些服务器不能精确获取文件的最后修改时间</li></ul></blockquote></li></ul><p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329164950051.png" style="zoom:67%;" /><hr><h3 id="HTTP的优点有哪些？"><a href="#HTTP的优点有哪些？" class="headerlink" title="HTTP的优点有哪些？"></a>HTTP的优点有哪些？</h3><ul><li><em>简单</em>：基本的报文格式就是 <code>header + body</code>，头部信息是 <code>key-value</code> 形式，易于理解</li><li><em>灵活和易于扩展</em>：HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等都允许开发人员自定义和扩充，且下层可以随意变化。</li><li><em>应用广泛和跨平台</em></li></ul><hr><h3 id="HTTP的缺点有哪些？"><a href="#HTTP的缺点有哪些？" class="headerlink" title="HTTP的缺点有哪些？"></a>HTTP的缺点有哪些？</h3><ul><li><em>无状态双刃剑</em>：<ul><li>好处：不需要额外的资源来记录状态信息，能减轻服务器的负担</li><li>坏处：完成有关联性的操作时会非常麻烦</li></ul></li><li><em>明文传输双刃剑</em>：对调试工作十分方便，但信息容易被窃取。</li><li><em>不安全</em>：通信使用明文（不加密），内容可能会被窃听；不验证通信方的身份，因此有可能遭遇伪装；无法证明报文的完整性，所以有可能已遭篡改。</li></ul><hr><h3 id="HTTP-x2F-1-1-相比-HTTP-x2F-1-0-提高了什么性能？"><a href="#HTTP-x2F-1-1-相比-HTTP-x2F-1-0-提高了什么性能？" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h3><ul><li><em><strong>长连接</strong></em>：http1.1默认使用长连接，减少了 TCP 连接的重复建立和断开所造成的额外开销。</li><li><em><strong>管道网络传输</strong></em>：即发送完第一个请求后可以马上发送下一个请求，而无序等待第一个请求完成。<ul><li>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。所以只<strong>解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong></li></ul></li></ul><hr><h3 id="HTTP-x2F-2-做了什么优化？"><a href="#HTTP-x2F-2-做了什么优化？" class="headerlink" title="HTTP&#x2F;2 做了什么优化？"></a>HTTP&#x2F;2 做了什么优化？</h3><p>HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p><ul><li><strong>重复头部压缩：</strong>如果多个请求的头部是一样的，那么会消除重复的部分。采用<code>HPACK</code> 算法，在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后只发送索引号，从而减少数据。<code>HPACK</code> 算法由以下三个部分组成：<ul><li>静态表编码：HTTP&#x2F;2 为高频出现在头部的字符串和字段建立了一张静态表，它不会变化，共61组（序号所在字节第一位用于表示其是否在静态表存在）</li><li>动态表编码：对于不在静态表中的字段就需要构建动态表，每次发送一个字段后，客户端和服务端都会更新动态表，以后按动态表的序号发送即可（服务器一般会限制动态表大小）</li><li>哈夫曼编码：HTTP&#x2F;2 根据出现频率将 ASCII 码编码为了 Huffman 编码表，是固定不变的。（在头部字段后面的下一个字节的第一位表示是否使用哈夫曼编码，后7为表示value长度）</li></ul></li><li><strong>二进制格式：</strong>头信息和数据体都采用二进制格式。</li><li><strong>并发传输：</strong>初步解决http1.1中的服务端队头阻塞问题，使用了stream，多个 Stream 复用在一条 TCP 连接。<ul><li>1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 是一个请求或响应</li><li>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应。</li><li>不同 Stream 的帧是可以乱序发送的，而同一 Stream 内部的帧必须是严格有序的</li></ul></li><li><strong>服务器主动推送资源：</strong>服务端不再是被动地响应，可以主动向客户端发送消息。<ul><li>客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</li></ul></li></ul><blockquote><p><strong>HTTP2缺陷</strong></p><p>HTTP2是基于TCP协议的，而TCP协议必须保证收到的报文是完整且连续的。如果接受窗口的一部分数据没有收到，那么即使其后面数据收到也只有等待前面数据收到后，内核才能拿到数据。因此并未真正解决队头阻塞问题。</p></blockquote><hr><h3 id="HTTP-x2F-3-做了哪些优化？"><a href="#HTTP-x2F-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h3><p> HTTP&#x2F;3 把 下层的 TCP 协议改成了 基于UDP的QUIC协议，其特点如下：</p><ul><li><p><em><strong>无队头阻塞</strong></em>：QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，且有一套机制保证传输可靠性。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。</p></li><li><p><em><strong>更快的连接建立</strong></em>：HTTP&#x2F;3 的 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商。</p><ul><li><p>且在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329203350684.png" style="zoom:50%;" /></li></ul></li><li><p><em><strong>连接迁移</strong></em>：TCP协议是基于四元组确认一条连接，当设备网络发生变化后需要重新建立连接。QUIC协议通过连接ID来标记通信的两个端点，当网络变化后通过连接ID、TLS密钥等就可以复用原连接，从而达到连接迁移功能。</p></li></ul><p>HTTP3相比HTTP2变化：</p><ul><li>HTTP&#x2F;3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream</li><li>HTTP&#x2F;3使用QPACK算法压缩，主要将静态表扩大到91项，且利用了QUIC中的两个单向流来同步双方的动态表。</li></ul><hr><h3 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h3><ul><li>HTTP 是明文传输，存在安全风险。HTTPS 在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 在 TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><hr><h3 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？"></a>HTTPS 解决了 HTTP 的哪些问题？</h3><p>解决了窃听问题、篡改问题、网站冒充问题，使用下面方法进行解决的：</p><ul><li><strong>混合加密的方式实现信息的机密性，解决了窃听的风险。</strong><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。这是因为：<ul><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题，但速度慢。</li></ul></li></ul></li><li><strong>摘要算法的方式来实现完整性，解决了篡改的风险。</strong><ul><li>对内容计算出一个「指纹」，然后同内容一起传输给对方。对方收到后先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</li><li>指纹是通过哈希函数计算出的一个哈希值，但并不能保证「内容 + 哈希值」不会被中间人替换。<strong>解决办法</strong>是使用私钥对内容的哈希值进行加密，接收方对其解密并验证哈希是否相同。</li></ul></li><li><strong>将服务器公钥放入到数字证书中，解决了冒充的风险。</strong><ul><li>通过数字证书的方式保证服务器公钥的身份</li></ul></li></ul><blockquote><p><strong>非对称加密有两种用途</strong>：</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul></blockquote><hr><h3 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h3><ol><li><p><em><strong>ClientHello</strong></em>：客户端向服务器发起加密通信请求，主要发送以下信息：支持的 TLS 协议版本、生产的随机数、支持的密码套件列表。</p></li><li><p><em><strong>SeverHello</strong></em>：服务器收到客户端请求后，向客户端发出响应，回应的内容主要如下：确认 TLS 协议版本；服务器生产的随机数；确认的密码套件列表；服务器的数字证书</p></li><li><p><em><strong>客户端回应</strong></em>：先根据CA公钥确认服务器的数字证书的真实性。如果没有问题，客户端会从数字证书中取出公钥，使用它加密报文，向服务器发送如下信息：</p><ul><li>一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</li><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li></ul><blockquote><p><strong>服务器和客户端有了这三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p></blockquote></li><li><p><em><strong>服务器的最后回应</strong></em>：服务器收到客户端的第三个随机数之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发送最后的信息：</p><ul><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</li></ul></li></ol><blockquote><p>SSL&#x2F;TLS 1.2 需要 4 握手，需要 2 个 RTT 的时延。</p><p>而SSL&#x2F;TLS 1.3 优化了过程，只需要 1 个 RTT 往返时延，也就是只需要 3 次握手，细节见后文。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329193344364.png"></p><p><strong>数字证书签发和验证流程：</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329194543425.png"></strong></p><blockquote><p><strong>多层证书验证过程</strong></p><ul><li>根据收到的证书找到其签发机构，如果签发机构不是根证书，则继续找直到达到根证书。</li><li>如果此根证书已经预载于系统重，则使用根证书的公钥去验证下一级的证书，不断进行验证从而完成所有证书信任。</li></ul><p><strong>为什么要搞这么多层级证书？</strong></p><p>为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题</p></blockquote><hr><h3 id="HTTPS-的应用数据是如何保证完整性的？"><a href="#HTTPS-的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS 的应用数据是如何保证完整性的？"></a>HTTPS 的应用数据是如何保证完整性的？</h3><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议就是 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据；</li><li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li></ul><p>记录协议过程如下：</p><ol><li>消息被分割成多个较短片段，对每个片段分别进行压缩</li><li>再压缩片段后面加上消息认证码（MAC值）。为防止重放攻击，计算消息认证码时还加上了片段的编码。</li><li>使用对称密码对每个片段进行加密，加上报文头从而组成最终报文数据</li></ol><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329200337847.png" style="zoom:50%;" /><hr><h3 id="HTTPS-一定安全可靠吗？"><a href="#HTTPS-一定安全可靠吗？" class="headerlink" title="HTTPS 一定安全可靠吗？"></a>HTTPS 一定安全可靠吗？</h3><p>受到中间人攻击（伪基站）时，https安全吗？</p><p>安全，即使有伪基站进行中间攻击，但客户端会验证其公钥是否与域名对应（CA机构可验证），如果不对应则拒绝后续执行，而伪基站自己生成的公钥和所要访问的域名肯定是不对应的。</p><p>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</p><blockquote><p><strong>为什么抓包工具能截取 HTTPS 数据？</strong></p><p>对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:</p><ol><li>作为客户端与真实服务端建立连接，这一步不会有问题，因为服务端不会校验客户端的身份；</li><li>作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；中间人要拿到私钥只能通过如下方式：<ul><li>去网站服务端拿到私钥；</li><li>去CA处拿域名签发私钥；</li><li>自己签发证书，切要被浏览器信任；</li></ul></li></ol><p>因此，使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这也是能被截取数据的关键所在</p><p><strong>如何避免被中间人抓取数据？</strong></p><ul><li>不要点击任何证书非法的网站</li><li>通过 HTTPS 双向认证，即服务器也验证客户端身份：将包含客户端公钥的证书发给服务器，服务器进行验证</li></ul></blockquote><h2 id="2-2-HTTP-x2F-1-1-优化"><a href="#2-2-HTTP-x2F-1-1-优化" class="headerlink" title="2.2 HTTP&#x2F;1.1 优化"></a>2.2 HTTP&#x2F;1.1 优化</h2><ul><li><strong>避免发送HTTP请求</strong>：使用HTTP的强制缓存和协商缓存技术，即收到请求后将其缓存到本地，下次请求时如果缓存没过期则直接使用缓存数据，如果过期则请求时带上数据的摘要，由服务端判断是否继续使用原缓存。</li><li><strong>减少 HTTP 请求次数</strong><ul><li><strong><em>减少重定向请求次数</em>：</strong>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数</li><li><strong><em>合并请求</em>：</strong>将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输</li><li><strong><em>延迟发送请求</em>：</strong>按需访问资源，只访问当前用户看得到&#x2F;用得到的资源，才接下来的资源</li></ul></li><li><strong>减少 HTTP 响应的数据大小</strong>：对数据进行压缩，例如对关键数据进行无损压缩，对图片音频等进行有损压缩</li></ul><h2 id="2-3-HTTPS-RSA-握手解析"><a href="#2-3-HTTPS-RSA-握手解析" class="headerlink" title="2.3 HTTPS RSA 握手解析"></a>2.3 HTTPS RSA 握手解析</h2><p>TLS 的握手过程，如下图：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329205705346.png" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329212203781.png"></p><ul><li><strong>第一次握手</strong>：发一个「Client Hello」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random），这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</li><li><strong>第二次握手</strong>：返回「Server Hello」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件<ul><li>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成随机数（Server Random）</li><li>服务端为了证明自己的身份，会发送「Server Certificate」给客户端，这个消息里含有数字证书</li></ul></li><li><strong>第三次握手</strong>：在收到服务端发送的第二次握手信息后，会先验证证书可靠性，如果不可靠则终止。客户端就会生成一个新的随机数 (pre-master)，用服务器的 RSA 公钥加密该随机数，通过「Client Key Exchange」消息传给服务端。<ul><li>生成完「会话密钥」后，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息</li><li>再发一个「Encrypted Handshake Message（Finishd）」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」</li></ul></li><li><strong>第四次握手</strong>：发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</li></ul><blockquote><p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。因为随机数使用公钥加密的，如果私钥泄露，以前的报文都会被泄露。</p></blockquote><h2 id="2-4-HTTPS-ECDHE-握手解析"><a href="#2-4-HTTPS-ECDHE-握手解析" class="headerlink" title="2.4 HTTPS ECDHE 握手解析"></a>2.4 HTTPS ECDHE 握手解析</h2><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230329212936210.png" style="zoom:50%;" /><h2 id="2-5-HTTPS-如何优化？"><a href="#2-5-HTTPS-如何优化？" class="headerlink" title="2.5 HTTPS 如何优化？"></a>2.5 HTTPS 如何优化？</h2><p>产生性能消耗的两个环节：</p><ul><li>第一个环节， TLS 协议握手过程；</li><li>第二个环节，握手后的对称加密报文传输。</li></ul><p><strong>硬件优化</strong>：应该选择可以支持 AES-NI 特性的 CPU，因为这种CPU 在指令级别优化了 AES 算法，加速了数据的加解密传输过程</p><p><strong>软件优化</strong>：</p><ul><li><p><strong>协议优化</strong></p><ul><li>密钥交换算法应该选择 ECDHE 算法，而不用 RSA 算法，因为 ECDHE 算法具备前向安全性，而且客户端可以在第三次握手之后，就发送加密应用数据，节省了 1 RTT。ECDHE算法尽量选择 x25519 曲线。</li><li>将 TLS1.2 升级 TLS1.3，因为 TLS1.3 的握手过程只需要 1 RTT，而且安全性更强。</li></ul></li><li><p><strong>证书优化</strong></p><ul><li>服务器应该选用 ECDSA 证书，而非 RSA 证书，因为在相同安全级别下，ECC 的密钥长度比 RSA 短很多</li><li>服务器应该开启 OCSP Stapling 功能，由服务器预先获得 OCSP 的响应，并把响应结果缓存起来，这样 TLS 握手的时候就不用再访问 CA 服务器，减少了网络通信的开销，提高了证书验证的效率；（OCSP：向 CA 发送查询请求，让 CA 返回证书的有效状态）</li></ul></li><li><p><strong>会话复用：</strong>对于重连 HTTPS 时，可以使用Session ID 和 Session Ticket等回话重用技术，从而快速恢复对话。</p><ul><li>Session ID：<ul><li>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识。</li><li>当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态。</li></ul></li><li>Session Ticket：<ul><li>客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。</li><li>客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，就可以恢复会话了，开始加密通信。</li></ul></li><li>Pre-shared Key：和ticket类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端</li></ul></li></ul><blockquote><p><strong>TLS1.3减少1RTT的方法</strong>：</p><ul><li>客户端在 Client Hello 消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥</li><li>服务端收到后选择其中一中曲线计算公钥，返回时带上公钥，从而双方皆有能生成会话密钥。</li></ul></blockquote><h2 id="2-6-既然有-HTTP-协议，为什么还要有-RPC？"><a href="#2-6-既然有-HTTP-协议，为什么还要有-RPC？" class="headerlink" title="2.6 既然有 HTTP 协议，为什么还要有 RPC？"></a>2.6 既然有 HTTP 协议，为什么还要有 RPC？</h2><p>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义消息边界。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</p><p>HTTP 和 RPC 区别</p><ul><li><strong>服务发现</strong><ul><li>在 HTTP 中，知道服务的域名，就可以通过 DNS 服务去解析得到 IP 地址，默认 80 端口。</li><li>在 RPC 中，一般会有专门的中间服务去保存服务名和IP信息，比如 Consul 或者 Etcd。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。</li></ul></li><li><strong>底层连接形式</strong><ul><li>HTTP&#x2F;1.1 默认在建立底层 TCP 连接之后会一直保持这个连接</li><li>RPC 协议也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用</li></ul></li><li><strong>传输的内容</strong><ul><li>HTTP&#x2F;1.1使用 Json 来序列化结构体数据</li><li>RPC一般采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></li></ul></li></ul><blockquote><p>HTTP&#x2F;2 在1.1的基础上做了很多改进，所以性能可能比很多 RPC 协议还要好，甚至连 gRPC 底层都直接用的 HTTP&#x2F;2。</p></blockquote><h2 id="2-7-既然有-HTTP-协议，为什么还要有-WebSocket？"><a href="#2-7-既然有-HTTP-协议，为什么还要有-WebSocket？" class="headerlink" title="2.7 既然有 HTTP 协议，为什么还要有 WebSocket？"></a>2.7 既然有 HTTP 协议，为什么还要有 WebSocket？</h2><p><strong>服务器主动发消息给客户端该怎么实现？</strong></p><ul><li><strong>使用 HTTP 不断轮询</strong>：代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息<ul><li>缺点：消耗带宽和服务器性能；由于存在轮询间隔，因此会感到明显的卡顿</li></ul></li><li><strong>长轮询</strong>：HTTP 请求将超时设置的很大，比如 30 秒，在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。<ul><li>缺点：适用于简单场景，如果有大量数据需要推送则不适合。</li></ul></li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>HTTP1.1是一种半双工协议，服务器不能主动向客户端发送消息，因此WebSocket应运而生。</p><p>为了兼容HTTP场景和WebSocket场景，浏览器在 TCP 三次握手建立连接之后，都统一使用 HTTP 协议先进行一次通信：</p><ul><li>如果此时是普通的 HTTP 请求，那后续双方就还是老样子继续用普通 HTTP 协议进行交互，这点没啥疑问。</li><li>如果这时候是想建立 WebSocket 连接，就会在 HTTP 请求里带上一些特殊的header 头，表示想升级成 WebSocket 协议</li></ul><p>WebSocket握手过程：</p><ul><li><p>第一次握手：在建立http连接后，在http请求里面加上升级协议字段，并生成一个随机的base64码，发送给服务器</p><pre class="line-numbers language-none"><code class="language-none">Connection: UpgradeUpgrade: WebSocketSec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg&#x3D;&#x3D;\r\n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>第二次握手：如果服务器支持升级WebSocket协议，根据客户端生成的 base64 码，用某个公开的算法变成另一段字符串，放在 HTTP 响应的 Sec-WebSocket-Accept 头里，同时带上101状态码，发回给浏览器。</p></li><li><p>浏览器也用同样的公开算法将base64码转成另一段字符串，如果这段字符串跟服务器传回来的字符串一致，那就可以使用 webscoket 的数据格式进行通信。</p></li></ul><blockquote><p>注意！WebSocket是利用HTTP协议来完成的握手过程，握手完成后就不再使用http协议</p></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230330173008117.png" style="zoom:50%;" /><h1 id="三、TCP篇"><a href="#三、TCP篇" class="headerlink" title="三、TCP篇"></a>三、TCP篇</h1><h2 id="3-1-TCP-三次握手与四次挥手面试题"><a href="#3-1-TCP-三次握手与四次挥手面试题" class="headerlink" title="3.1 TCP 三次握手与四次挥手面试题"></a>3.1 TCP 三次握手与四次挥手面试题</h2><h3 id="TCP-头格式有哪些？"><a href="#TCP-头格式有哪些？" class="headerlink" title="TCP 头格式有哪些？"></a>TCP 头格式有哪些？</h3><ul><li><p><strong>序列号</strong>：在建立连接时生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」（不包含首部大小）的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p><p><strong>控制位：</strong></p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示不会再有数据发送，希望断开连接。</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230330191311058.png" style="zoom:50%;" /><hr><h3 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a>什么是 TCP ？</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议：</p><ul><li><p><strong>面向连接</strong>：一定是「一对一」连接，不像 UDP 协议可以一个主机同时向多个主机发送消息，一对多是无法做到的；</p></li><li><p><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p></li><li><p><strong>字节流</strong>：通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。</p><ul><li>TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul></li></ul><blockquote><p><strong>什么是TCP连接？</strong></p><p>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合（Socket、序列号和窗口大小）称为连接。</p><p><strong>为什么 TCP 是面向字节流的协议？</strong></p><p>当用户消息通过 TCP 协议传输时，消息可能会被操作系统分组成多个的 TCP 报文，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。至于什么时候真正被发送，取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件。</p><p><strong>如何解决粘包</strong></p><ul><li>固定长度的消息；</li><li>特殊字符作为边界；</li><li>自定义消息结构。</li></ul></blockquote><hr><h3 id="如何唯一确定一个-TCP-连接呢？"><a href="#如何唯一确定一个-TCP-连接呢？" class="headerlink" title="如何唯一确定一个 TCP 连接呢？"></a>如何唯一确定一个 TCP 连接呢？</h3><p>TCP 四元组可以唯一的确定一个连接，四元组包括：源地址、源端口、目的地址、目的端口</p><ul><li>源地址和目的地址是在 IP 头部中，源端口和目的端口是在 TCP 头部中</li></ul><blockquote><p>有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</p><p>由于本地ip和端口固定，理论最大链接数&#x3D;客户端IP数*客户端端口数&#x3D;2^32 x 2^16。但实际会受文件描述符限制、内存限制</p></blockquote><hr><h3 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h3><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。UPD非常简单，头部只有 <code>8</code> 个字节：</p><ul><li>目标和源端口：告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度： UDP 首部的长度跟数据的长度之和。</li><li>校验和：为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230330192533307.png" style="zoom:33%;" /><p><strong>TCP 和 UDP 区别：</strong></p><ul><li><p><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但可以基于 UDP 传输协议实现一个可靠的传输协议</li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul></li></ul><p><strong>TCP 和 UDP 应用场景：</strong></p><ul><li>TCP 常用于：FTP文件传输、HTTP等</li><li>UDP常用于：包总量较少的通信DNS；视频、音频等多媒体通信；广播通信</li></ul><blockquote><p><strong>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</strong></p><ul><li>原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的</li></ul><p><strong>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong></p><ul><li>TCP计算负载数据长度方法：IP总长度-IP首部长度-TCP首部长度，因此TCP无需包长度字段也能计算出包长度</li><li>UDP也可利用上述方法求，有包长度字段的原因可能是以前UDP不一定基于IP</li></ul></blockquote><hr><h3 id="半连接队列、全连接队列是什么"><a href="#半连接队列、全连接队列是什么" class="headerlink" title="半连接队列、全连接队列是什么"></a>半连接队列、全连接队列是什么</h3><p>执行<code>listen方法</code>后，内核会为每一个处于<code>LISTEN</code>状态的<code>socket</code> 分配两个队列：</p><ul><li><p><strong>半连接队列（SYN队列）</strong>，服务端收到<strong>第一次握手</strong>后，会将<code>sock</code>加入到这个队列中，队列内的<code>sock</code>都处于<code>SYN_RECV</code> 状态。</p><ul><li><p>半连接队列是个哈希表；当收到第三次握手时，如果半连接队列是个链表，就需要依次遍历才能拿到想要的连接，算法复杂度就是O(n)。</p></li><li><p>通过以下命令可以查看当前半连接数量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> <span class="token parameter variable">-nt</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> <span class="token string">'127.0.0.1:8080'</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> <span class="token string">'SYN_RECV'</span> <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p><strong>全连接队列（ACCEPT队列）</strong>，在服务端收到<strong>第三次握手</strong>后，会将半连接队列的<code>sock</code>取出，放到全连接队列中。队列里的<code>sock</code>都处于 <code>ESTABLISHED</code>状态。这里面的连接，就<strong>等着服务端执行accept()后被取出了。</strong></p><ul><li>全连接队列是个链表</li><li>通过ss -lnt命令，可以看到全连接队列的大小，其中Send-Q是指全连接队列的最大值，Recv-Q是指当前的全连接队列的使用值</li></ul></li></ul><hr><h3 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h3><p><strong>可以</strong></p><p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序（相同协议）。</p><p>主机收到数据包后，根据 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p><hr><h3 id="TCP-三次握手过程是怎样的？"><a href="#TCP-三次握手过程是怎样的？" class="headerlink" title="TCP 三次握手过程是怎样的？"></a>TCP 三次握手过程是怎样的？</h3><ul><li>客户端会随机初始化序号，将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，之后客户端处于 <code>SYN-SENT</code> 状态。此阶段不能携带应用数据。</li><li>服务端收到 <code>SYN</code> 报文后，也随机初始化自己的序号，将此序号填入 TCP 首部的「序号」字段中，其次把 「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，之后服务端处于 <code>SYN-RCVD</code> 状态。此阶段不能携带应用数据。</li><li>客户端收到服务端报文后，向服务端回应最后一个应答报文，首应答报文  <code>ACK</code> 标志位置为 <code>1</code> ，「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，<strong>这次报文可以携带客户到服务端的数据</strong>，之后客户端处于 <code>ESTABLISHED</code> 状态。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230330202343022.png" style="zoom:50%;" /><blockquote><p>如何在 Linux 系统中查看 TCP 状态？在 Linux 可以通过 <code>netstat -napt</code> 命令查看</p></blockquote><hr><h3 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h3><ul><li><p><strong>三次握手才可以阻止重复历史连接的初始化（主要原因）</strong></p><ul><li><p>当旧SYN报文比新SYN报文先抵达时，服务器能会对其响应，但客户端收到后会发现并非预期报文，会回RST报文，服务器会关闭连接（二次连接也可以回RST报文，但无法避免丢失情况）。</p><blockquote><p>为什么 TCP 两次握手为什么无法阻止历史连接呢？</p><p>像上述情况，在收到旧报文并做出响应后，服务端就会建立连接，导致服务端资源浪费</p></blockquote></li></ul></li><li><p><strong>三次握手才可以同步双方的初始序列号</strong></p><ul><li>三次握手才能确保对方正确收到了自己报文，才能同步序列号</li></ul></li><li><p><strong>三次握手才可以避免资源浪费</strong></p><ul><li>如果只有「两次握手」，当客户端发生的 SYN 报文在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以服务端每收到一个 SYN 就只能先主动建立一个连接。导致建立多个冗余的无效链接，造成不必要的资源浪费。</li></ul></li></ul><blockquote><p><strong>如果客户端发送的第三次握手丢失，而又发送了数据，那数据会不会丢失？</strong></p><p>不会，即使服务端还是在 syn_received 状态，也是可以收数据的，而数据包中有ack和确认号，这个确认号和第三次握手的确认号一样。</p></blockquote><p>小结：不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><hr><h3 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h3><p>主要原因：</p><ul><li><p><strong>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</strong></p><ul><li><p>如果有报文被阻塞了，而服务器此时宕机重启，之前连接就断掉了，而与客户端又建立了一个新连接。如果被阻塞的报文此时到达，其序号很大可能就在服务端接受端口中，会被正常接受，从而导致数据错乱。</p></li><li><p>初始化序列化不同并不能完全阻止历史报文问题，还需要用时间戳来判断历史报文。如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包。</p><blockquote><p>解决时间戳回绕：</p><ul><li>增加时间戳的大小，由32 bit扩大到64bit：但会导致协议兼容问题</li><li>将一个与时钟频率无关的值作为时间戳，时钟频率可以增加但时间戳的增速不变</li></ul></blockquote></li></ul></li><li><p><strong>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</strong></p></li></ul><blockquote><p><strong>初始序列号 ISN 是如何随机产生的？</strong></p><p>ISN &#x3D; M + F</p><ul><li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li><li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。</li></ul></blockquote><hr><h3 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h3><p>当超过 <code>MTU</code> 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层</p><p>但是<strong>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文，也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发整个 TCP 报文。</p><blockquote><p>为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，即SYN报文中会有MSS值</p></blockquote><hr><h3 id="三次握手丢失分析"><a href="#三次握手丢失分析" class="headerlink" title="三次握手丢失分析"></a>三次握手丢失分析</h3><ul><li><p><strong>第一次握手丢失了，会发生什么？</strong></p><ul><li>当发送第一个报文后，进入到 <code>SYN_SENT</code> 状态。如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</li><li>不同系统重传时间不同，Linux系统重传次数默认为5，且每次超时等待时间翻倍。</li></ul></li><li><p><strong>第二次握手丢失了，会发生什么？</strong></p><ul><li><p>当服务端收到客户端的第一次握手后，会进入 <code>SYN_RCVD</code> 状态。当第二次握手丢失了，客户端和服务端都会重传：</p><ul><li><p>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code>内核参数决定；</p></li><li><p>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</p></li></ul></li></ul></li><li><p><strong>第三次握手丢失了，会发生什么</strong></p><ul><li>当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</li></ul></li></ul><hr><h3 id="什么是-SYN-攻击？如何避免-SYN-攻击"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击"></a>什么是 SYN 攻击？如何避免 SYN 攻击</h3><blockquote><p>内核中建立连接过程：</p><ul><li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li><li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li><li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出连接对象。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331112943795.png" style="zoom:50%;" /></blockquote><p><strong>SYN 攻击</strong>：把 TCP 半连接队列打满，这样当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接。</p><p>避免 SYN 攻击方式，可以有以下四种方法：</p><ul><li><p><strong>调大 netdev_max_backlog：</strong>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。调大 netdev_max_backlog值能增加该队列大小。</p></li><li><p><strong>增大 TCP 半连接队列：</strong>增大 TCP 半连接队列，要同时增大下面这三个参数：</p><ul><li>增大 net.ipv4.tcp_max_syn_backlog（主要参数，如果超过tcp_max_syn_backlog值则直接丢弃）</li><li>增大 listen() 函数中的 backlog（这个是全连接参数，但半连接丢弃逻辑里面会判断全连接是否满，如果满了则丢弃）</li><li>增大 net.core.somaxconn（全连接队列大小也受此参数影响）</li></ul></li><li><p><strong>开启 tcp_syncookies：</strong>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</p><ul><li><p>当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 <code>cookie</code> 值；</p></li><li><p>将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端（服务器不保存cookie）；</p></li><li><p>服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的cookie。如果合法，将该连接对象放入到「 Accept 队列」。</p></li><li><p>最后应用程序通过调用 <code>accpet()</code> 接口，从「 Accept 队列」取出的连接。</p><blockquote><p>注意！不会有一个cookies队列，它是通过通信双方的IP地址端口、时间戳、MSS等信息进行实时计算的，保存在TCP报头的seq里。当服务端收到客户端发来的第三次握手包时，会通过seq还原出通信双方的IP地址端口、时间戳、MSS，验证通过则建立连接。</p></blockquote></li></ul></li><li><p><strong>减少 SYN+ACK 重传次数：</strong>减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开</p></li></ul><blockquote><p><strong>如何增大 TCP 全连接队列？</strong></p><ul><li>TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，backlog 在listen时设定</li></ul><p><strong>cookies方案为什么不直接取代半连接队列？</strong></p><ul><li>因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。</li><li>编码解码cookies，都是比较耗CPU的，可能会出现cookies攻击，使得cpu耗费大量资源</li></ul></blockquote><hr><h3 id="TCP-四次挥手过程是怎样的？"><a href="#TCP-四次挥手过程是怎样的？" class="headerlink" title="TCP 四次挥手过程是怎样的？"></a>TCP 四次挥手过程是怎样的？</h3><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，之后进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。<ul><li>在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，这个 EOF 会被<strong>放在已排队等候的其他已接收的数据之后</strong>。当read读取到EOF后，如果有数据待发送则发送完数据才调用关闭连接函数，否则直接调用关闭连接函数。</li></ul></li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li></ul><blockquote><p><strong>主动关闭连接的，才有 TIME_WAIT 状态</strong></p></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331113717875.png" style="zoom:50%;" /><hr><h3 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h3><p>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，<strong>但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序</strong>：</p><ul><li>如果应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；</li><li>如果应用程序没有数据要发送的话，可以直接调用关闭连接的函数，</li></ul><hr><h3 id="四次挥手丢失分析"><a href="#四次挥手丢失分析" class="headerlink" title="四次挥手丢失分析"></a>四次挥手丢失分析</h3><ul><li><p><strong>第一次挥手丢失了，会发生什么？</strong></p><ul><li>客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文。当重传次数超过限制，那么等待一段时间后就直接进入close状态</li></ul></li><li><p><strong>第二次挥手丢失了，会发生什么？</strong></p><ul><li>客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</li></ul><blockquote><p>如果收到第二次挥手，客户端就会处于 <code>FIN_WAIT2</code> 状态，在这个状态需要等服务端发送第三次挥手：</p><ul><li>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以<code>FIN_WAIT2</code> 状态不可以持续太久，默认 60 秒。</li><li>如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭。如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 <code>FIN_WAIT2</code> 状态</li></ul></blockquote></li><li><p><strong>第三次挥手丢失了，会发生什么？</strong></p><ul><li>服务端就会重发 FIN 报文，直到达到最大重传次数</li></ul></li><li><p><strong>第四次挥手丢失了，会发生什么？</strong></p><ul><li>服务端就会重发 FIN 报文，直到达到最大重传次数</li></ul></li></ul><hr><h3 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h3><blockquote><p><code>MSL</code> 是指报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p><strong>MSL 与 TTL 的区别</strong>： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡</p></blockquote><p>如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p><blockquote><p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p></blockquote><hr><h3 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h3><p>主要是两个原因：</p><ul><li><strong>防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong><ul><li>由于序列号是会循环使用的，如果没有timewait状态，那么新建立的连接可能就会接受到历史连接的数据。</li><li>而timewait&#x3D;2msl 足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。（也可以利用时间戳过滤历史数据）</li></ul></li><li><strong>保证「被动关闭连接」的一方，能被正确的关闭</strong><ul><li>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</li><li>假设没有 TIME_WAIT 状态，在发完最后一次 ACK 报文就进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传FIN 报文，而客户端已经进入到关闭状态了，就会回 RST 报文。服务端收到这个 RST 会将其解释为一个错误。</li></ul></li></ul><hr><h3 id="TIME-WAIT-过多有什么危害"><a href="#TIME-WAIT-过多有什么危害" class="headerlink" title="TIME_WAIT 过多有什么危害"></a>TIME_WAIT 过多有什么危害</h3><ul><li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li><li>第二是占用端口资源，端口资源也是有限的。</li></ul><p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong></p><ul><li>如果占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接，但可以对不同IP或端口发起连接</li></ul><p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong></p><ul><li>并不会导致端口资源受限，因为服务端只监听一个端口，而客户端IP和端口是不同的。但会占用系统资源。</li></ul><hr><h3 id="如何优化-TIME-WAIT？"><a href="#如何优化-TIME-WAIT？" class="headerlink" title="如何优化 TIME_WAIT？"></a>如何优化 TIME_WAIT？</h3><ul><li><strong>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项</strong><ul><li>打开reuse参数后，可以将处于 TIME_WAIT 的 socket 为新的连接所用</li><li>tcp_tw_reuse 功能只能用于连接发起方，因为在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</li><li>开始reuse参数则必须打开timestamps，主要是根据时间戳来过滤历史数据。</li></ul></li><li><strong>net.ipv4.tcp_max_tw_buckets</strong><ul><li>系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</li></ul></li><li><strong>程序中使用 SO_LINGER ，应用强制使用 RST 关闭</strong><ul><li>对so_linger的<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</li></ul></li></ul><blockquote><p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p></blockquote><hr><h3 id="服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>服务器出现大量 TIME_WAIT 状态的原因有哪些？</h3><ul><li><strong>第一个场景：HTTP 没有使用长连接</strong><ul><li>在大多数 Web 服务的实现中，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</li></ul></li><li><strong>第二个场景：HTTP 长连接超时</strong><ul><li>一般在Web服务实现中，如果长连接超过60秒为传输数据，就会关闭连接，从而服务器上出现timewait状态</li></ul></li><li><strong>第三个场景：HTTP 长连接的请求数量达到上限</strong><ul><li>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</li></ul></li></ul><hr><h3 id="服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h3><p><strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p><p>可能原因如下：</p><ul><li>没有将服务端监听 socket 注册到 epoll，服务端无法获取新链接，也就不能对 socket 调用 close 函数。（第二次挥手的ACK是内核处理发送的）</li><li>有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数</li><li>通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端无法调用 close 函数</li><li>当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为死锁、代码bug等原因。</li></ul><hr><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP存在一个保活机制，需要创建socket时使用SO_KEEPALIVE参数，原理如下：</p><ul><li>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会每隔一个时间间隔，发送一个探测报文，如果连续几个探测报文都没有得到响应，则认为TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</li></ul><p>如果开启了 TCP 保活，会有以下几种情况：</p><ol><li><strong>对端程序是正常工作的</strong>。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。</li><li><strong>对端主机宕机并重启</strong>。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被重置。</li><li><strong>对端主机宕机或报文不可达</strong>。当连续几次探测报文没有响应则会报告该连接已死亡</li></ol><blockquote><p><strong>心跳机制</strong></p><p>TCP保活的检测时间过长，可以在应用层实现一个心跳机制。</p></blockquote><hr><h3 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h3><p>TCP 的连接信息是由内核维护的，当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与</p><hr><h3 id="listen-时候参数-backlog-的意义？"><a href="#listen-时候参数-backlog-的意义？" class="headerlink" title="listen 时候参数 backlog 的意义？"></a>listen 时候参数 backlog 的意义？</h3><p>在早期是指半连接队列，在linux2.2后指全连接队列长度。</p><p>但是 全连接队列长度 &#x3D; min(backlog, somaxconn)，somaxconn是内核一个参数</p><hr><h3 id="accept-发生在三次握手的哪一步？"><a href="#accept-发生在三次握手的哪一步？" class="headerlink" title="accept 发生在三次握手的哪一步？"></a>accept 发生在三次握手的哪一步？</h3><p><strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331162105259.png" style="zoom:50%;" /><hr><h3 id="没有-accept，能建立-TCP-连接吗？"><a href="#没有-accept，能建立-TCP-连接吗？" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h3><p><strong>可以</strong></p><p>accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。</p><hr><h3 id="没有-listen，能建立-TCP-连接吗？"><a href="#没有-listen，能建立-TCP-连接吗？" class="headerlink" title="没有 listen，能建立 TCP 连接吗？"></a>没有 listen，能建立 TCP 连接吗？</h3><p><strong>可以</strong></p><p>客户端是可以自己连自己的形成连接（<strong>TCP自连接</strong>），也可以两个客户端同时向对方发出请求建立连接（<strong>TCP同时打开</strong>），这两个情况都有个共同点，就是<strong>没有服务端参与，也就是没有 listen，就能 TCP 建立连接。</strong></p><h2 id="3-2-TCP-重传、滑动窗口、流量控制、拥塞控制"><a href="#3-2-TCP-重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="3.2 TCP 重传、滑动窗口、流量控制、拥塞控制"></a>3.2 TCP 重传、滑动窗口、流量控制、拥塞控制</h2><h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><ul><li><strong>超时重传</strong><ul><li>TCP 会在以下两种情况发生超时重传：数据包丢失；确认应答丢失；</li><li>超时时间是以RTO表示，其若过大会很久才回重传，若过小则重发次数显增，其应略大于报文往返RTT值。</li><li>Linux中，RTO计算方式考虑两个方面：<ol><li>TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，这个值是不断变化的</li><li>还要采样 RTT 的波动范围，避免如果 RTT 有一个大的波动的话，很难被发现</li></ol></li><li>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。</li></ul></li><li><strong>快速重传</strong><ul><li>当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</li><li><strong>需要解决重传的时候，是重传一个，还是重传所有的问题，为此设计了SACK。</strong>。例如，当发送了Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，所以发送方并不知道该重传哪些报文。</li></ul></li><li><strong>SACK方法</strong><ul><li><code>SACK</code>（ Selective Acknowledgment）， 选择性确认。在 TCP 头部「选项」字段里加一个 SACK ，可以将已收到的数据的信息发送给「发送方」，就可以只重传丢失的数据</li></ul></li><li><strong>Duplicate  SACK</strong><ul><li>又称 D-SACK，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。就是当ACK值大于SACK值时，就会认为SACK数据被重复接受。</li><li>例如传送了两个数据包，而「接收方」发给「发送方」的两个 ACK 确认应答都丢失，接收方发送了一个SACK告诉发送方第一个数据包被接受了，而此时ACK确认两个包都被接受，所以这个 SACK 就代表着 <code>D-SACK</code>。接受方就知道数据没丢，只是ACK丢了。</li><li>好处：<ul><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ul></li></ul></li></ul><hr><h3 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h3><p>由于等待每个请求返回再发送新请求会导致效率很低，因此引入了滑动窗口概念。只要在滑动窗口中的数据都可以直接发送。窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。</p><ul><li>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</li></ul><p><strong>窗口大小由哪一方决定？</strong></p><ul><li>通常窗口的大小是由接收方的窗口大小来决定的（还由拥塞窗口大小决定，取最小值）。</li><li>TCP 头有一个 <code>Window</code>字段，表示窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</li></ul><p><strong>程序是如何表示发送方的四个部分的呢？</strong></p><ul><li><code>SND.WND</code>：表示发送窗口的大小</li><li><code>SND.UNA</code>（<em>Send Unacknoleged</em>）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li><li><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</li><li>指向 #4 的第一个字节是个相对指针，它需要 <code>SND.UNA</code> 指针加上 <code>SND.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331191516242.png" style="zoom:67%;" /><p><strong>接收方的滑动窗口</strong></p><ul><li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li><li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li><li>指向 #4 的第一个字节是个相对指针，它需要 <code>RCV.NXT</code> 指针加上 <code>RCV.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331191722409.png" style="zoom:67%;" /><p><strong>接收窗口和发送窗口的大小是相等的吗？</strong></p><ul><li>并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。因为告诉发送方窗口大小是需要时延的。</li></ul><p><strong>窗口关闭问题</strong></p><ul><li>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</li><li><strong>窗口关闭导致的死锁问题</strong>：如果发送方现在是窗口关闭状态，如果接受方发送的一个新的窗口非0的报文丢失，那么发送方会一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，从而造成死锁。<ul><li>解决办法：TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</li></ul></li></ul><p><strong>糊涂窗口综合症</strong></p><ul><li>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。</li><li>由于头部存在，发送几个字节的数据利用率很低，解决办法：<ul><li>让接收方不通告小窗口给发送方：即小于一定空间，通告窗口为0</li><li>让发送方避免发送小数据：等到窗口大于一定阈值或收到之前发送数据的 <code>ack</code> 回包（Nagle 算法）</li></ul></li></ul><hr><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><blockquote><p>流量控制是避免「发送方」的数据填满「接收方」的缓存；拥塞控制是避免「发送方」的数据填满整个网络</p></blockquote><p>拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化。只要发生了超时重传，就会认为网络出现了拥塞。</p><ul><li><strong>慢启动</strong><ul><li>当发送方每收到一个数据的 ACK，拥塞窗口 cwnd 的大小就会加 1（加经过确认的数据大小）。</li><li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li></ul></li><li><strong>拥塞避免</strong><ul><li>每当收到一个数据的 ACK 时，cwnd 增加 1&#x2F;cwnd（线性增长）。</li></ul></li><li><strong>拥塞发生</strong>：当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：<ul><li>超时重传：<code>ssthresh</code> 设为 <code>cwnd/2</code>；cwnd<code>重置为</code>1（初始值）；</li><li>快速重传：cwnd &#x3D; cwnd&#x2F;2；<code>ssthresh = cwnd</code>;并进入快速恢复算法。</li></ul></li><li><strong>快速恢复</strong>：快速重传和快速恢复算法一般同时使用，因为还能收到 3 个重复 ACK 说明网络也不那么糟糕。算法如下：<ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值（是+3前的那个值），原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230331194227959.png" style="zoom:80%;" /><h2 id="3-3-如何优化-TCP"><a href="#3-3-如何优化-TCP" class="headerlink" title="3.3 如何优化 TCP?"></a>3.3 如何优化 TCP?</h2><h3 id="TCP-三次握手的性能提升"><a href="#TCP-三次握手的性能提升" class="headerlink" title="TCP 三次握手的性能提升"></a><strong>TCP 三次握手的性能提升</strong></h3><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401154456625.png" style="zoom:50%;" /><ul><li><p><strong>客户端优化</strong></p><ul><li><strong>SYN_SENT 状态的优化</strong>：客户端在发送SYN报文后会等待服务器的报文，如果一直没等到则会重传SYN报文。因此可以根据网络的稳定性和目标服务器的繁忙程度修改 SYN 的重传次数，调整客户端的三次握手时间上限</li></ul></li><li><p><strong>服务端优化</strong></p><ul><li><strong>SYN_RCV 状态的优化</strong>：服务端在发送第二次握手后，如果一直没有回应则会重传报文。因此也可以根据网络情况设置重传次数和重传时间。</li><li><strong>调整SYN半连接队列长度</strong>：通过 <code>tcp_max_syn_backlog、somaxconn、backlog</code> 参数来调整 SYN 半连接队列的大小。</li><li><strong>调整accpet全连接队列长度</strong>：通过 listen 函数的 <code>backlog</code> 参数和 <code>somaxconn</code> 系统参数提高队列大小</li><li><strong>开启tcp_syncookies</strong>：如果遭受 SYN 攻击，应把 <code>tcp_syncookies</code> 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接成功建立。</li></ul></li><li><p><strong>绕过三次握手</strong></p><ul><li><strong>TCP Fast Open</strong>：<ul><li>第一次三次握手建立连接时，服务器生成cookie交给客户端缓存起来。</li><li>当第二次想再次建立连接时，客户端发送的SYN报文中包含请求数据和Cookie，服务器会对cookie进行验证，如果有效则对请求数据进行处理，并返回SYN+ACK报文和请求响应报文。</li><li>cookie 的值是存放到 TCP option 字段</li></ul></li></ul></li></ul><blockquote><p><strong>accept 队列已满，只能丢弃连接吗？</strong></p><ul><li>丢弃连接只是 Linux 的默认行为，还可以选择向客户端发送 RST 复位报文，告诉客户端连接已经建立失败。需要将 tcp_abort_on_overflow 参数设置为 1。</li></ul></blockquote><hr><h3 id="TCP-四次挥手的性能提升"><a href="#TCP-四次挥手的性能提升" class="headerlink" title="TCP 四次挥手的性能提升"></a><strong>TCP 四次挥手的性能提升</strong></h3><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401154407005.png" style="zoom:50%;" /><ul><li><strong>主动关闭方的优化</strong><ul><li>FIN_WAIT1 状态的优化：发送第一次挥手后，如果未收到ack报文会重传，因此可以优化重传次数</li><li>FIN_WAIT2 状态的优化：根据关闭方式不同，优化方式不同：<ul><li>close函数关闭：这是一个孤儿连接，如果tcp_fin_timeout时间内没收到FIN报文，就直接关闭。可使用tcp_max_orphans参数来限制最大孤儿连接数量。</li><li>shutdown函数关闭：此函数关闭会一直等待FIN报文，其不受tcp_max_orphans参数限制。</li></ul></li><li>TIME_WAIT 状态的优化：<ul><li>Linux 提供了 tcp_max_tw_buckets 参数，当 TIME_WAIT 的连接数量超过该参数时，新关闭的连接就不再经历 TIME_WAIT 而直接关闭；当连接过多时，可以适当调大<code>tcp_max_tw_buckets</code> 参数，减少不同连接间数据错乱的概率。</li><li>打开 tcp_tw_reuse 参数复用处于 TIME_WAIT 状态的连接（只能用于连接发起方，因为是在调用 connect() 时起作用的）</li><li>设置so_linger，如果其<code>l_onoff</code> 为非 0， 且 <code>l_linger</code> 值为 0，那么调用 close 后，会立该发送一个 RST 标志给对端，也就跳过了 TIME_WAIT 状态，直接关闭（只推荐客户端使用）。</li></ul></li></ul></li><li><strong>被动关闭方的优化</strong><ul><li>被动关闭的连接方应对非常简单，它在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。</li><li>当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，会在 <code>tcp_orphan_retries</code> 参数的控制下重发 FIN 报文</li></ul></li></ul><blockquote><p><strong>如果连接双方同时关闭连接，会怎么样？</strong></p><ul><li>两方发送 FIN 报文时，都认为自己是主动方，所以都进入了 FIN_WAIT1 状态</li><li>双方在等待 ACK 报文的过程中，都等来了 FIN 报文。这是一种新情况，所以连接会进入一种叫做 CLOSING 的新状态，它替代了 FIN_WAIT2 状态。</li><li>双方内核回复 ACK 确认对方发送通道的关闭后，进入 TIME_WAIT 状态，等待 2MSL 的时间后，连接自动关闭。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401153825397.png" style="zoom:33%;" /></blockquote><hr><h3 id="TCP-数据传输的性能提升"><a href="#TCP-数据传输的性能提升" class="headerlink" title="TCP 数据传输的性能提升"></a><strong>TCP 数据传输的性能提升</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401154704168.png"></p><ul><li><strong>扩大滑动窗口大小</strong>：通过设置 <code>tcp_window_scaling</code> 提升滑动窗口的上限（需要考虑带宽时延积进行设置）</li><li><strong>调整发送缓冲区</strong>：通过 tcp_wmem 参数配置缓冲区大小。发送缓冲区是自行调节的，当发送方发送的数据被确认后，并且没有新的数据要发送，就会把发送缓冲区的内存释放掉。</li><li><strong>调整接受缓冲区</strong>：通过设置tcp_rmem 参数配置接收缓冲区大小。需要配置 tcp_moderate_rcvbuf 为 1 来开启自动调节功能。</li><li><strong>调节 TCP 内存范围</strong>：通过 tcp_mem 配置不自动调节范围、自动调节范围、不分配新内存范围。</li><li><strong>根据实际场景</strong><ul><li>在高并发服务器中，为了兼顾网速与大量的并发连接，我们应当保证缓冲区的动态调整的最大值达到带宽时延积，而最小值保持默认的 4K 不变即可。而对于内存紧张的服务而言，调低默认值是提高并发的有效手段。</li><li>如果是网络 IO 型服务器，调大 tcp_mem 的上限可以让 TCP 连接使用更多的系统内存，这有利于提升并发能力。千万不要在 socket 上直接设置 SO_SNDBUF 或者 SO_RCVBUF，这样会关闭缓冲区的动态调整功能。</li></ul></li></ul><h2 id="3-4-SYN-报文什么时候情况下会被丢弃？"><a href="#3-4-SYN-报文什么时候情况下会被丢弃？" class="headerlink" title="3.4 SYN 报文什么时候情况下会被丢弃？"></a>3.4 SYN 报文什么时候情况下会被丢弃？</h2><p>两种场景：</p><ul><li><strong>开启 tcp_tw_recycle 参数，并且在 NAT 环境下，造成 SYN 报文被丢弃</strong><ul><li>Linux提供了两个参数来快速回收处于 TIME_WAIT 状态的连接，一个是net.ipv4.tcp_tw_reuse，一个是net.ipv4.tcp_tw_recycle。都需要打开时间戳才能生效。</li><li>如果同时开启了recycle 和 timestamps 选项，则会开启一种称之为「 per-host 的 PAWS 机制」<ul><li>PAWS 机制是防止 TCP 包中的序列号发生绕回。PAWS 要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</li><li>per-host 是对「对端 IP 做 PAWS 检查」，而非对「IP + 端口」四元组做 PAWS 检查</li></ul></li><li>当客户端是在NAT网关中，其对外IP是相同的。当使用recycle时，如果A客户端已经连接，然后服务器主动关闭并且快速回收 TIME-WAIT 状态的连接后，此时B客户端也建立连接，如果客户端 B 的 timestamp 比 客户端 A 的 timestamp 小，那么由于服务端的 per-host 的 PAWS 机制的作用，服务端就会丢弃客户端主机 B 发来的 SYN 包。</li></ul></li><li><strong>TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃</strong><ul><li>当TCP 半连接队列满了，后面来的 syn 包都会被丢弃。但如果开启了syncookies 功能，即使半连接队列满了，也不会丢弃syn 包。</li><li>当TCP全连接队列满了，后续的连接就会被丢弃，这样就会出现服务端请求数量上不去的现象（有点不对题，全连接满影响的是第三次ACK报文，于SYN报文丢弃无关）</li></ul></li></ul><h2 id="3-5-已建立连接的TCP，收到SYN会发生什么？"><a href="#3-5-已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="3.5 已建立连接的TCP，收到SYN会发生什么？"></a>3.5 已建立连接的TCP，收到SYN会发生什么？</h2><blockquote><p>一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，一直处于 Established 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理？</p></blockquote><p>TCP是由四元组确定，因此需要看客户端的源端口是否发生变化：</p><ul><li><strong>客户端的 SYN 报文里的端口号与历史连接不相同</strong></li><li>此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。</li><li>而旧连接中，如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</li><li><strong>客户端的 SYN 报文里的端口号与历史连接相同</strong><ul><li>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</li><li>客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</li></ul></li></ul><hr><h3 id="如何关闭一个-TCP-连接？"><a href="#如何关闭一个-TCP-连接？" class="headerlink" title="如何关闭一个 TCP 连接？"></a>如何关闭一个 TCP 连接？</h3><p>最简单办法是杀掉进程，但如果服务端杀掉进程会导致其他连接都会被关闭，无法继续提供访问服务。</p><p><strong>解决办法</strong>：伪造一个四元组相同的 RST 报文，但必须拿到连接的序列号否则RST报文会被拒绝。</p><p><strong>如何拿到序列号？</strong></p><ul><li>处于 Established 状态的服务端，收到四元组相同的 SYN 报文后，会回复一个 Challenge ACK，这个 ACK 报文里的「确认号」，正好是服务端下一次想要接收的序列号。</li></ul><p><strong>killcx原理</strong>：主动像服务端发送 SYN 包获取 SEQ&#x2F;ACK 号，然后利用 SEQ&#x2F;ACK 号伪造两个 RST 报文分别发给客户端和服务端，这样双方的 TCP 连接都会被释放，这种方式活跃和非活跃的 TCP 连接都可以杀掉。</p><p><strong>tcpkill原理</strong>：在双方进行 TCP 通信时，拿到对方下一次期望收到的序列号，然后将序列号填充到伪造的 RST 报文，并将其发送给对方，达到关闭 TCP 连接的效果。这种方式无法关闭非活跃的 TCP 连接；</p><blockquote><p>如何伪造成四元组相同的连接？报文伪造很简单，但是对方会根据报文的IP来发送回文，不是主机IP也收不到</p><p>应该需要拦截发送的报文进行处理</p></blockquote><h2 id="3-6-四次挥手中收到乱序的-FIN-包会如何处理？"><a href="#3-6-四次挥手中收到乱序的-FIN-包会如何处理？" class="headerlink" title="3.6 四次挥手中收到乱序的 FIN 包会如何处理？"></a>3.6 四次挥手中收到乱序的 FIN 包会如何处理？</h2><blockquote><p>如果服务端在二三次回收之间发了数据，但因为网络延迟而导致第三次握手的FIN比数据包先到，会怎么处理？</p></blockquote><p><strong>答案</strong></p><ul><li>在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。</li><li>等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。</li></ul><h2 id="3-7-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？"><a href="#3-7-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？" class="headerlink" title="3.7 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？"></a>3.7 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</h2><ul><li><strong>收到合法 SYN</strong><ul><li>如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程。</li></ul></li><li><strong>收到非法的 SYN</strong><ul><li>如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，就会再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端。</li></ul></li></ul><p><strong>在 TIME_WAIT 状态，收到 RST 会断开连接吗？</strong></p><ul><li>如果 <code>net.ipv4.tcp_rfc1337</code> 参数为 0，则提前结束 TIME_WAIT 状态，释放连接。</li><li>如果 <code>net.ipv4.tcp_rfc1337</code> 参数为 1，则会丢掉该 RST 报文。</li></ul><blockquote><ul><li><strong>合法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。</li><li><strong>非法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。</li></ul></blockquote><h2 id="3-8-12-TCP-连接，一端断电和进程崩溃有什么区别？"><a href="#3-8-12-TCP-连接，一端断电和进程崩溃有什么区别？" class="headerlink" title="3.8 12 TCP 连接，一端断电和进程崩溃有什么区别？"></a>3.8 12 TCP 连接，一端断电和进程崩溃有什么区别？</h2><p>当TCP没有开启keepalive，也没有数据交换时：</p><ul><li><strong>主机崩溃</strong><ul><li>客户端主机崩溃了（断电也属于崩溃一种），服务端是无法感知到的，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。</li></ul></li><li><strong>进程崩溃</strong><ul><li>TCP 的连接信息是由内核维护的，内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与</li></ul></li></ul><p>当TCP没有开启keepalive，却有数据交换时：</p><ul><li><strong>客户端主机宕机，又迅速重启</strong><ul><li>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发超时重传机制。</li><li>服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：<ul><li>如果客户端主机上没有进程绑定该 TCP 报文的目标端口号，那么客户端内核就会回复 RST 报文，重置该 TCP 连接；</li><li>如果客户端主机上有进程绑定该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会回复 RST 报文，重置该 TCP 连接。</li><li>因此，只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接</li></ul></li></ul></li><li><strong>客户端主机宕机，一直没有重启</strong><ul><li>服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，于是服务端的 TCP 连接就会断开。</li></ul></li></ul><blockquote><p><strong>TCP 的数据报文具体重传几次呢？</strong></p><p>Linux中tcp_retries2 默认为15，但还会根据tcp_retries2 算出一个timeout，如果重传间隔超过这个 timeout，则认为超过了阈值，就会停止重传，然后就会断开 TCP 连接。</p></blockquote><h2 id="3-9-拔掉网线后，-原本的-TCP-连接还存在吗？"><a href="#3-9-拔掉网线后，-原本的-TCP-连接还存在吗？" class="headerlink" title="3.9 拔掉网线后， 原本的 TCP 连接还存在吗？"></a>3.9 拔掉网线后， 原本的 TCP 连接还存在吗？</h2><p>客户端拔掉网线后，并不会直接影响 TCP 连接状态。拔掉网线后，TCP 连接是否还会存在，关键要看有没有进行数据传输：</p><ul><li><p><strong>有数据传输的情况：</strong></p><ul><li><p>如果服务端发送了数据报文，在服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在。</p></li><li><p>如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。</p></li></ul></li><li><p><strong>没有数据传输的情况：</strong></p><ul><li><p>如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。</p></li><li><p>如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。</p></li></ul></li></ul><h2 id="3-10-tcp-tw-reuse-为什么默认是关闭的？"><a href="#3-10-tcp-tw-reuse-为什么默认是关闭的？" class="headerlink" title="3.10 tcp_tw_reuse 为什么默认是关闭的？"></a>3.10 tcp_tw_reuse 为什么默认是关闭的？</h2><blockquote><p>这题在变相问「<strong>如果 TIME_WAIT 状态持续时间过短或者没有，会有什么问题？</strong>」</p></blockquote><p>开启 tcp_tw_reuse 会有 2 个问题：</p><ol><li>虽然 tcp_tw_reuse 的同时，也需要开启 tcp_timestamps，但 <strong>RST 报文的时间戳即使过期了，只要 RST 报文的序列号在对方的接收窗口内，也是能被接受的</strong>。<ul><li>这样如果有历史RST报文存在可能会导致新连接被断开，如果设置了timewait状态，历史rst报文就会消失。</li></ul></li><li>如果第四次挥手的 ACK 报文丢失了，服务端会触发超时重传，重传第三次挥手报文，而重用后的连接处于 syn_sent 状态，收到服务端重传第三次挥手报文，则会回 RST 给服务端，导致服务端不能被正常关闭。</li></ol><blockquote><p><strong>如果 TIME_WAIT 状态被快速复用后，刚好第四次挥手的 ACK 报文丢失了，那客户端复用 TIME_WAIT 状态后发送的 SYN 报文被处于 last_ack 状态的服务端收到了会发生什么呢？</strong></p><ul><li>处于 last_ack 状态的服务端收到了 SYN 报文后，会回复确认号与服务端上一次发送 ACK 报文一样的 ACK 报文，这个 ACK 报文称为 Challenge ACK ，并不是确认收到 SYN 报文。</li><li>处于 syn_sent 状态的客户端收到服务端的 Challenge ACK后，发现不是自己期望收到的确认号，于是就会回复 RST 报文，服务端收到后，就会断开连接。</li></ul></blockquote><h2 id="3-11-HTTPS-中-TLS-和-TCP-能同时握手吗？"><a href="#3-11-HTTPS-中-TLS-和-TCP-能同时握手吗？" class="headerlink" title="3.11 HTTPS 中 TLS 和 TCP 能同时握手吗？"></a>3.11 HTTPS 中 TLS 和 TCP 能同时握手吗？</h2><p>一般情况下，不管 TLS 握手次数如何，都得先经过 TCP 三次握手后才能进行。</p><p>HTTPS 中的 TLS 握手过程同时进行三次握手需要特定条件：</p><ul><li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong><ul><li>开启了TCP FAST OPEN后，当第二次建立连接时可以绕过三次握手直接发送数据，携带Cookies即可</li><li>TLS1.3也存在会话恢复机制，在第一次发送数据时携带上TLS握手数据即可。</li></ul></li><li><strong>客户端和服务端已经完成过一次通信。</strong></li></ul><blockquote><p><strong>TCP 连接的第三次握手是可以携带数据的，如果客户端在第三次握手发送了 TLSv1.3 第一次握手数据，是不是就表示「<em>HTTPS 中的 TLS 握手过程可以同时进行三次握手</em>」？</strong></p><ul><li>TLS握手是在应用层，服务端只有在收到客户端的 TCP 的第三次握手后，才能和客户端进行后续 TLSv1.3 握手。</li></ul></blockquote><h2 id="3-12-TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？"><a href="#3-12-TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？" class="headerlink" title="3.12 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？"></a>3.12 TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</h2><p>这两个完全是两样不同东西，实现的层面也不同：</p><ul><li><p><strong>HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接；</strong></p><ul><li><p>HTTP 的 Keep-Alive 实现了使用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销，这个方法称为 HTTP 长连接。</p></li><li><p>其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态</p><blockquote><p>如果客户端完成一个 HTTP 请求后，就不再发起新的请求，会导致资源浪费。因此一般会设置一个定时器，在一定时间没有请求则释放连接。</p></blockquote></li></ul></li><li><p><strong>TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制；</strong></p><ul><li>TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活</li><li>keepalive的默认时间为2小时，由于过于长久，因此可以设定一个心跳机制来判断是否存活</li></ul></li></ul><h2 id="3-13-TCP-协议有什么缺陷？"><a href="#3-13-TCP-协议有什么缺陷？" class="headerlink" title="3.13 TCP 协议有什么缺陷？"></a>3.13 TCP 协议有什么缺陷？</h2><p>TCP 协议缺陷：</p><ul><li><strong>升级 TCP 的工作很困难</strong>：TCP 协议是在内核中实现的，应用程序只能使用不能修改，如果要想升级 TCP 协议，那么只能升级内核，而升级内核工作十分繁琐。</li><li><strong>TCP 建立连接的延迟</strong>：TCP Fast Open能解决延迟问题，但需要客户端和服务端都支持，而现在却并未普及。<ul><li>对 HTTPS 来说，TLS 是在应用层实现的握手，而 TCP 是在内核实现的握手，这两个握手过程是无法结合在一起的，总是得先完成 TCP 握手，才能进行 TLS 握手。</li><li>TCP 是在内核实现的，所以 TLS 是无法对 TCP 头部加密的，这意味着 TCP 的序列号都是明文传输，所以就存安全的问题。</li></ul></li><li><strong>TCP 存在队头阻塞问题</strong>：TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据</li><li><strong>网络迁移需要重新建立 TCP 连接</strong>：TCP是通过四元组确定一条连接，当设备从网络切换时需要重新建立TCP连接。</li></ul><h2 id="3-14-如何基于-UDP-协议实现可靠传输？"><a href="#3-14-如何基于-UDP-协议实现可靠传输？" class="headerlink" title="3.14 如何基于 UDP 协议实现可靠传输？"></a>3.14 如何基于 UDP 协议实现可靠传输？</h2><h3 id="QUIC-是如何实现可靠传输的？"><a href="#QUIC-是如何实现可靠传输的？" class="headerlink" title="QUIC 是如何实现可靠传输的？"></a><strong>QUIC 是如何实现可靠传输的？</strong></h3><p>如HTTP3为例，在 UDP 报文头部与 HTTP 消息之间，共有 3 层头部：<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403155224700.png" style="zoom:67%;" /></p><ul><li><p><strong>Packet Header</strong></p><ul><li><p>可分为两种头部：</p><ul><li>Long Packet Header 用于首次建立连接。包含源连接ID和目标连接ID。</li><li>Short Packet Header 用于日常传输数据。包含目标连接ID、编号和数据（没有源连接ID）<img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403155523216.png" style="zoom: 33%;" /></li></ul></li><li><p>QUIC 也是需要三次握手来建立连接的，主要目的是为了协商连接 ID。协商出连接 ID 后，后续传输时，双方只需要固定住连接 ID，从而实现连接迁移功能。</p></li><li><p><code>Packet Number</code> 是每个报文独一无二的编号，它是<strong>严格递增</strong>的，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。原因如下：</p><ul><li>如果使用原来的编号，发送方无法知道确认号是对第一次的确认还是重传的确认，使得RTT采样不准确</li><li>更便于支持乱序确认，不会因重传而阻塞在原地</li></ul><blockquote><p>编号不一样，那报文？岂不是乱序</p><p>QUIC分离了编号的确认功能和数据有序功能，在frame层还有一个序号用于数据顺序</p></blockquote></li></ul></li><li><p><strong>QUIC Frame Header</strong></p><ul><li><p>一个 Packet 报文中可以存放多个 QUIC Frame，每一个 Frame 都有明确的类型，针对类型的不同，功能也不同，自然格式也不同。例如stream类型的frame格式如下：</p><ul><li>Stream ID ：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别，类似于 HTTP2 的 Stream ID；</li><li>Offset ：类似于 TCP 协议中的 Seq 序号，<strong>保证数据的顺序性和可靠性</strong>；</li><li>Length ：指明了 Frame 数据的长度。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403160152234.png" style="zoom:33%;" /></li><li><p><strong>通过 Stream ID + Offset 字段信息实现数据的有序性</strong>，通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。</p></li></ul><p>QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装</p></li></ul><hr><h3 id="QUIC-是如何解决-TCP-队头阻塞问题的？"><a href="#QUIC-是如何解决-TCP-队头阻塞问题的？" class="headerlink" title="QUIC 是如何解决 TCP 队头阻塞问题的？"></a>QUIC 是如何解决 TCP 队头阻塞问题的？</h3><blockquote><p>HTTP&#x2F;2 多个 Stream 请求都是在一条 TCP 连接上传输，这意味着多个 Stream 共用同一个 TCP 滑动窗口，那么当发生数据丢失，滑动窗口是无法往前移动的，此时就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。</p></blockquote><p><strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。</p><hr><h3 id="QUIC-是如何做流量控制的？"><a href="#QUIC-是如何做流量控制的？" class="headerlink" title="QUIC 是如何做流量控制的？"></a>QUIC 是如何做流量控制的？</h3><p>QUIC 实现流量控制的方式：</p><ul><li>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。</li><li>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。</li></ul><p>QUIC 实现了两种级别的流量控制：</p><ul><li><p><strong>Stream 级别的流量控制</strong>：</p><ul><li><p>Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</p></li><li><p>整个滑动窗口可以分为最大接受窗口和接收窗口：</p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403161209035.png" style="zoom:50%;" /></li><li><p>接收窗口的左边界取决于接收到的最大偏移字节数，此时的接收窗口 &#x3D; 最大窗口数 - 接收到的最大偏移数。</p></li><li><p>当图中的绿色部分数据超过最大接收窗口的一半后，最大接收窗口向右移动，接收窗口的右边界也向右扩展，同时给对端发送「窗口更新帧」，当发送方收到接收方的窗口更新帧后，发送窗口的右边界也会往右扩展，以此达到窗口滑动的效果。</p><blockquote><p>QUIC 的流量控制和 TCP 区别：</p><ul><li>TCP 的接收窗口只有在前面所有的 Segment 都接收的情况下才会移动左边界，当在前面还有字节未接收但收到后面字节的情况下，窗口也不会移动。</li><li>QUIC 的接收窗口的左边界滑动条件取决于接收到的最大偏移字节数。</li></ul></blockquote></li></ul></li><li><p><strong>Connection 流量控制</strong>：</p><ul><li>限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。</li><li>其接收窗口大小就是各个 Stream 接收窗口大小之和。</li></ul></li></ul><blockquote><p><strong>QUIC如何做到乱序确认？</strong></p><ul><li>发送缓冲区根据尚未接收到确认的数据包来移动缓冲区左边界（即当前已提交的偏移量）</li><li>当发送方的缓存区收缩到阈值，接收方发送 MAX_STREAM_DATA Frame（协商缓存大小的特定帧）给发送方，请求增长最大绝对字节偏移量。协商完毕后最大绝对字节偏移量右移，发送方的缓存区变大</li><li>当发送方发现有数据包超时，则将超时数据包重新编号为 当前最大值继续发送</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403162210765.png" style="zoom:50%;" /></blockquote><hr><h3 id="QUIC-对拥塞控制改进"><a href="#QUIC-对拥塞控制改进" class="headerlink" title="QUIC 对拥塞控制改进"></a>QUIC 对拥塞控制改进</h3><ul><li>QUIC 协议当前默认使用了 TCP 的 Cubic 拥塞控制算法（慢开始、拥塞避免、快重传、快恢复策略），同时也支持 CubicBytes、Reno、RenoBytes、BBR、PCC 等拥塞控制算法</li><li>QUIC 是处于应用层的，应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。因此可以可以针对不同的应用设置不同的拥塞控制算法。</li></ul><hr><h3 id="QUIC-更快的连接建立"><a href="#QUIC-更快的连接建立" class="headerlink" title="QUIC 更快的连接建立"></a>QUIC 更快的连接建立</h3><p>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p><ul><li>当HTTP&#x2F;3 使用会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT</li></ul><hr><h3 id="QUIC-是如何迁移连接的？"><a href="#QUIC-是如何迁移连接的？" class="headerlink" title="QUIC 是如何迁移连接的？"></a>QUIC 是如何迁移连接的？</h3><p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><h2 id="3-15-TCP-和-UDP-可以使用同一个端口吗？"><a href="#3-15-TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="3.15 TCP 和 UDP 可以使用同一个端口吗？"></a>3.15 TCP 和 UDP 可以使用同一个端口吗？</h2><p><strong>TCP 和 UDP 可以同时绑定相同的端口吗？</strong></p><ul><li>可以</li><li>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，然后模块根据报文「端口号」确定送给哪个应用程序处理</li></ul><p><strong>多个 TCP 服务进程可以绑定同一个端口吗？</strong></p><ul><li>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。</li><li>有些机器有多个IP，此时如果绑定IP不同，而端口相同也是能绑定成功</li><li>注意，0.0.0.0 地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0 地址，相当于把主机上的所有 IP 地址都绑定了</li></ul><blockquote><p>如果想多个进程绑定相同的 IP 地址和端口，也是有办法的，就是对 socket 设置 SO_REUSEPORT 属性（内核 3.9 版本提供的新特性）</p></blockquote><p><strong>客户端的端口可以重复使用吗？</strong></p><ul><li>客户端在执行 connect 函数的时候，会在内核里随机选择一个端口，然后向服务端发起 SYN 报文，然后与服务端进行三次握手。</li><li>如果重复使用端口是连接不同IP+端口，那么可以重复使用。否则不可重复使用（主机只有一个IP情况下）</li></ul><p><strong>多个客户端可以 bind 同一个端口吗？</strong></p><ul><li>如果多个客户端绑定的 IP + PORT 相同，那么在执行 bind() 时候就会出错。否则不会出错。</li></ul><p><strong>客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？</strong></p><ul><li>如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了</li><li>只要客户端连接的服务器不同，端口资源可以重复使用的</li></ul><p><strong>客户端端口选择的流程</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401205103176.png" style="zoom: 25%;" /><h2 id="3-16-服务端没有-listen，客户端发起连接建立，会发生什么？"><a href="#3-16-服务端没有-listen，客户端发起连接建立，会发生什么？" class="headerlink" title="3.16 服务端没有 listen，客户端发起连接建立，会发生什么？"></a>3.16 服务端没有 listen，客户端发起连接建立，会发生什么？</h2><p>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。</p><ul><li>没有调用 listen 函数，也就找不到监听该端口的 socket</li></ul><p><strong>不使用 listen ，可以建立 TCP 连接吗？</strong></p><ul><li>可以的，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接。</li></ul><p><strong>那没有listen，为什么还能建立连接？</strong></p><ul><li>因为<strong>半连接队列和全连接队列都是在执行 listen 方法时内核创建的</strong>，所以客户端没有执行listen也就不会创建两种队列。</li><li>但内核还有个全局 hash 表，可以用于存放 sock 连接的信息。<ul><li>在 TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash 表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash 中取出信息。于是握手包一来一回，最后成功建立连接。</li><li>而两个客户端同时打开原理也类似</li></ul></li></ul><h2 id="3-17-用了-TCP-协议，数据一定不会丢吗？"><a href="#3-17-用了-TCP-协议，数据一定不会丢吗？" class="headerlink" title="3.17 用了 TCP 协议，数据一定不会丢吗？"></a>3.17 用了 TCP 协议，数据一定不会丢吗？</h2><p>数据包的发送和接收流程：</p><ul><li>消息会从应用所在的用户空间拷贝到内核空间的发送缓冲区（send buffer），数据包就这样顺着传输层、网络层，进入到数据链路层，在这里数据包会经过流控（qdisc），再通过RingBuffer发到物理层的网卡。数据就这样顺着网卡发到了纷繁复杂的网络世界里。这里头数据会经过n多个路由器和交换机之间的跳转，最后到达目的机器的网卡处。</li><li>目的机器的网卡会通知DMA将数据包信息放到RingBuffer中，再触发一个硬中断给CPU，CPU触发软中断让ksoftirqd去RingBuffer收包，于是一个数据包就这样顺着物理层，数据链路层，网络层，传输层，最后从内核空间拷贝到用户空间里的聊天软件里。</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230401212856546.png" style="zoom:80%;" /><p>数据传输中可能发生丢包的情况：</p><ul><li><p><strong>建立连接时丢包</strong></p><ul><li>半连接、全连接队列都有长度限制，如果它们满了，那新来的包就会被丢弃。</li></ul></li><li><p><strong>流量控制丢包</strong></p><ul><li>应用层发送的数据在通过传输层、网络层后，进入网卡前会进行排队处理，其队列名叫qdisc。当发送数据过快，流控队列长度txqueuelen又不够大时，就容易出现丢包现象</li></ul></li><li><p><strong>RingBuffer过小导致丢包</strong></p><ul><li>在接收数据时，会将数据暂存到RingBuffer接收缓冲区中，然后等着内核触发软中断慢慢收走。如果这个缓冲区过小，而这时候发送的数据又过快，就有可能发生溢出，此时也会产生丢包。</li></ul></li><li><p><strong>网卡性能不足</strong></p><ul><li>网卡传输速度是有上限的。当网络传输速度过大，达到网卡上限时，就会发生丢包</li></ul></li><li><p><strong>接收缓冲区丢包</strong></p><ul><li>在TCP编程中，会为每一个socket建立一个发送缓冲区和接收缓冲区。当收到数据后，将数据拷贝到接收缓冲区就完事，发送数据也是拷贝到发送缓冲区就完事。发送缓冲区在这种情况下一般不会丢失数据，但接受缓冲区满了之后，虽然会向发送方报告接收窗口为0，但仍然可能有数据被发送过来，从而导致数据丢失。</li></ul></li><li><p><strong>两端之间的网络丢包</strong></p><ul><li>数据传输链路上可能会发生丢包</li></ul></li></ul><p><strong>TCP只保证数据从A机器的传输层可靠地发到B机器的传输层，即保证发到了对方的传输层TCP接收缓冲区</strong>，但应用还需要将数据从TCP的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。发送端以为自己发的消息已经发给对方了，但接收端却并没有收到这条消息。</p><ul><li>解决方法：在应用层实现可靠性</li></ul><blockquote><p><strong>两端通信的时候也能对账，为什么还要引入第三端服务器？</strong></p><ul><li>如果引入服务端，你只需要跟服务器建立<code>1个</code>连接，而不需要跟每个人建立连接。</li><li>安全问题，如果是两端通信，随便一个人找你对账一下，你就把聊天记录给同步过去了，这并不合适吧。如果对方别有用心，信息就泄露了。引入第三方服务端就可以很方便的做各种鉴权校验。</li><li>软件版本问题。两端的软件版本跨度太大，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件。</li></ul></blockquote><h2 id="3-18-TCP-四次挥手，可以变成三次吗？"><a href="#3-18-TCP-四次挥手，可以变成三次吗？" class="headerlink" title="3.18 TCP 四次挥手，可以变成三次吗？"></a>3.18 TCP 四次挥手，可以变成三次吗？</h2><p><strong>为什么 TCP 挥手需要四次呢？</strong></p><ul><li>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序</li><li>因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，所以服务端的 ACK 和 FIN 一般都会分开发送</li></ul><p><strong>粗暴关闭 vs 优雅关闭</strong></p><ul><li>close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。由于不再具有发送和接收数据的能力，所以内核会回 RST 报文给服务端，也就不经过四次挥手。</li><li>shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。</li></ul><p><strong>什么情况会出现三次挥手？</strong></p><ul><li>当被动关闭方在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></li><li>TCP 延迟确认机制是默认开启的</li></ul><blockquote><p>什么是 TCP 延迟确认机制？</p><ul><li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li><li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li><li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li></ul></blockquote><h2 id="3-19-TCP-序列号和确认号是如何变化的？"><a href="#3-19-TCP-序列号和确认号是如何变化的？" class="headerlink" title="3.19 TCP 序列号和确认号是如何变化的？"></a>3.19 TCP 序列号和确认号是如何变化的？</h2><p><strong>发送的 TCP 报文序列号和确认号变化：</strong></p><ul><li>公式一：序列号 &#x3D; 上一次发送的序列号 + 上次len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</li><li>公式二：确认号 &#x3D; 上一次收到的报文中的序列号 + 上次len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</li></ul><blockquote><p><strong>为什么第二次和第三次握手报文中的确认号是将对方的序列号 + 1 后作为确认号呢？</strong></p><p> TCP 将 SYN 报文视为 1 字节的数据，目的如下：</p><ul><li>告诉对方，我方已经收到 SYN 报文。</li><li>告诉对方，我方下一次「期望」收到的报文的序列号为此确认号，比如客户端与服务端完成三次握手之后，服务端接下来期望收到的是序列号为 client_isn + 1 的 TCP 数据报文。</li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403105347105.png" style="zoom: 67%;" /><h1 id="四、IP篇"><a href="#四、IP篇" class="headerlink" title="四、IP篇"></a>四、IP篇</h1><h2 id="4-1-IP-基础知识"><a href="#4-1-IP-基础知识" class="headerlink" title="4.1 IP 基础知识"></a>4.1 IP 基础知识</h2><p>网络层的主要作用是：<strong>实现主机与主机之间的通信，也叫点对点（end to end）通信</strong></p><p><strong>网络层与数据链路层区别</strong></p><ul><li>MAC 的作用则是实现「直连」的两个设备之间通信， IP 则负责在「没有直连」的两个网络之间进行通信传输</li><li>传输过程汇中，源IP地址和目标IP地址在传输过程中是不会变化的，源 MAC 地址和目标 MAC 一直在变化</li></ul><p><strong>IP 地址的分类</strong></p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403164233104.png" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403164323231.png" style="zoom:50%;" /><blockquote><p>在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。</p><ul><li>主机号全为 1 指定某个网络下的所有主机，用于广播</li><li>主机号全为 0 指定某个网络</li></ul><p>广播地址可以分为本地广播和直接广播两种。</p><ul><li><strong>在本网络内广播的叫做本地广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的情况下，广播地址是 192.168.0.255 ，不会到达 192.168.0.0&#x2F;24 以外的其他链路上。</li><li><strong>在不同网络之间的广播叫做直接广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的主机向 192.168.1.255&#x2F;24 的目标地址发送 IP 包。使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包。</li></ul><p>D 类常被用于多播，多播地址用于什么？</p><ul><li>多播用于将包发送给特定组内的所有主机。</li></ul></blockquote><p><strong>无分类地址 CIDR</strong></p><ul><li>由于IP分类缺少地址的灵活性，因此出现了CIDR。32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号</li><li>表示形式 <code>a.b.c.d/x</code>，其中 <code>/x</code> 表示前 x 位属于网络号</li></ul><p><strong>子网掩码</strong></p><ul><li>另一种划分网络号与主机号形式。子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址。</li><li>将子网掩码和 IP 地址按位计算 AND，就可得到网络号。</li></ul><p><strong>公有 IP 地址与私有 IP 地址</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403165306620.png"></p><blockquote><p>公有 IP 地址由谁管理呢？</p><ul><li>私有 IP 地址通常是内部的 IT 人员管理，公有 IP 地址是由 <code>ICANN</code> 组织管理。IANA 是 ICANN 的其中一个机构，它负责分配互联网 IP 地址，是按州的方式层层分配。</li></ul></blockquote><p><strong>IP地址如何路由？</strong></p><ul><li>IP地址的网络地址这一部分是用于进行路由控制。</li><li>从路由控制表中找到与目标地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是<strong>最长匹配</strong>。</li></ul><p><strong>环回地址</strong></p><ul><li>环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。</li><li>计算机使用一个特殊的 IP 地址 127.0.0.1 作为环回地址。与该地址具有相同意义的是一个叫做 localhost 的主机名。使用这个 IP 或主机名时，数据包不会流向网络</li></ul><p><strong>IPv6 基本认识</strong></p><ul><li>IPv6 可自动配置，即使没有 DHCP 服务器也可以实现自动分配IP地址</li><li>IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大提升了安全性</li><li>IPv6 相比 IPv4 的首部改进：<ul><li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li><li><strong>取消了分片&#x2F;重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li><li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 <code>40</code> 字节。</li></ul></li></ul><hr><h3 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a><strong>DNS</strong></h4><p>域名解析的工作流程：</p><ul><li>浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 <code>hosts</code>，如果还是没有，就会 DNS 服务器进行查询</li><li>客户端首先向本地 DNS 服务器发出一个 DNS 请求，本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 请求域名，则直接返回 IP 地址。如果没有，本地 DNS 会去问根域名服务器</li><li>根 DNS 收到来自本地 DNS 的请求后，会返回对应的顶级域名服务器，本地DNS再向顶级域名服务器发起请求</li><li>顶级域名服务器会返回一个负责该域名的权威DNS服务器，DNS再向其发起请求</li><li>权威DNS服务器返回IP地址，本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接</li></ul><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403171127948.png" style="zoom:80%;" /><h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>在发送数据时，需要知道下一跳主机的MAC地址，ARP就是用于通过IP地址查询MAC地址，工作流程如下：</p><ul><li>主机会通过广播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li><li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。</li></ul><p>操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址，但缓存是有一定期限的。</p><blockquote><p><strong>RARP</strong>：已知 自己MAC 地址求自己的 IP 地址，工作流程如下：</p><ul><li>该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li><li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。</li></ul><p><strong>RARP和DHCP区别</strong>：</p><ul><li>DHCP是BOOTP协议的升级，而BOOTP在某种意义上又是RARP协议的升级</li><li>RARP是在数据链路层实现的，而DHCP是在应用层实现的</li><li>RARP只能实现简单的从MAC地址到IP地址的查询工作，RARP server上的MAC地址和IP地址是必须事先静态配置好的。但DHCP却可以实现除静态分配外的动态IP地址分配以及IP地址租期管理等等相对复杂的功能。</li><li>由于RAPR是链路层协议，因此当RARP客户与RARP服务器不在同一网段,中间有路由器等设备连接时无法获取到IP地址</li></ul></blockquote><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>DHCP全程都是使用 UDP 广播通信，工作流程如下：</p><ul><li>客户端发起 DHCP 发现报文的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP 广播通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。</li><li>DHCP 服务器收到 DHCP 发现报文时，用 DHCP 提供报文向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。</li><li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 DHCP 请求报文（DHCP REQUEST进行响应，回显配置的参数。</li><li>最后，服务端用 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数。</li><li>一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址</li></ul><blockquote><p><strong>如果 DHCP 服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络都要配一个 DHCP 服务器？</strong></p><p>为了解决这一问题，就出现了 DHCP 中继代理。其工作流程如下：</p><ul><li>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以<strong>单播</strong>的形式发给 DHCP 服务器。</li><li>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包广播给 DHCP 客户端 。</li></ul></blockquote><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>通过路由器的端口映射，把私有 IP 地址转换成公有 IP 地址。</p><p>缺点：</p><ul><li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li><li>转换表的生成与转换操作都会产生性能开销。</li><li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li></ul><h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><p>ICMP 大致可以分为两大类：</p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403201453060.png"></p><h4 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h4><p><strong>IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong></p><ul><li>IGMP 报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过 IGMP 加入到组播组，主机申请加入到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了。</li><li>IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为 1，因为 IGMP 是工作在主机与连接的路由器之间。</li></ul><p>IGMP常规查询与响应工作机制：</p><ol><li>路由器会周期性发送目的地址为 <code>224.0.0.1</code>（表示同一网段内所有主机和路由器） <strong>IGMP 常规查询报文</strong>。</li><li>主机1 和 主机 3 收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是 0~10 秒，计时器超时后主机就会发送 <strong>IGMP 成员关系报告报文</strong>（源 IP 地址为自己主机的 IP 地址，目的 IP 地址为组播地址）。如果在定时器超时之前，收到同一个组内的其他主机发送的成员关系报告报文，则自己不再发送，这样可以减少网络中多余的 IGMP 报文数量。</li><li>路由器收到主机的成员关系报文后，就会在 IGMP 路由表中加入该组播组，后续网络中一旦该组播地址的数据到达路由器，它会把数据包转发出去。</li></ol><p>IGMP离开组播组工作机制：</p><ol><li>主机 1 要离开组 224.1.1.1，发送 IGMP 离组报文，报文的目的地址是 224.0.0.2（表示发向网段内的所有路由器）</li><li>路由器 收到该报文后，以 1 秒为间隔连续发送 IGMP 特定组查询报文（共计发送 2 个），以便确认该网络是否还有 224.1.1.1 组的其他成员。</li><li>主机 3 仍然是组 224.1.1.1 的成员，因此它立即响应这个特定组查询。路由器知道该网络中仍然存在该组播组的成员，于是继续向该网络转发 224.1.1.1 的组播数据包。</li><li>当主机3也离开，路由器连续发送查询报文，如果没有响应，将不会再向这个网段转发该组播地址的数据包。</li></ol><h2 id="4-2-ping-的工作原理"><a href="#4-2-ping-的工作原理" class="headerlink" title="4.2 ping 的工作原理"></a>4.2 ping 的工作原理</h2><p>ping 是基于 <code>ICMP</code> 协议工作的，</p><ul><li>ping 命令执行的时候，源主机首先会构建一个 <strong>ICMP 回送请求消息</strong>数据包，字段类型为8.</li><li>然后，由 ICMP 协议将这个数据包连同目标地址一起交给 IP 层，构建一个 IP 数据包。</li><li>目的主机收到消息后，会构建一个 <strong>ICMP 回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为 <code>0</code>，<strong>序号</strong>为接收到的请求数据包中的序号，然后再发送出去</li><li>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</li><li>此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230403203128549.png"></p><h4 id="traceroute-——-差错报文类型的使用"><a href="#traceroute-——-差错报文类型的使用" class="headerlink" title="traceroute —— 差错报文类型的使用"></a>traceroute —— 差错报文类型的使用</h4><p>traceroute作用：</p><ul><li>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。<ul><li>利用 IP 包的生存期限 从 1 开始按照顺序递增的同时发送 UDP 包，强制接收 ICMP 超时消息的一种方法。traceroute 就可以拿到了所有的途径路由器 IP。</li><li>发送方如何知道发出的 UDP 包是否到达了目的主机呢？<ul><li>traceroute 在发送 UDP 包时，会填入一个不可能的端口号值作为 UDP 目标端口号。当目的主机收到 UDP 包后，会返回 ICMP 差错报文消息，其类型是「端口不可达」。</li></ul></li></ul></li><li>为了得到路径MTU大小，故意设置不分片，从而确定路径的 MTU<ul><li>发送端主机发送 IP 数据报时，将 IP 包首部的<strong>分片禁止标志位设置为 1</strong>。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。</li><li>随后，通过一个 ICMP 的不可达消息将<strong>数据链路上 MTU 的值</strong>一起给发送主机，不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」。</li><li>发送主机端每次收到 ICMP 差错报文时就<strong>减少</strong>包的大小，以此来定位一个合适的 <code>MTU</code> 值，以便能到达目标主机。</li></ul></li></ul><h2 id="4-3-断网了，还能-ping-通-127-0-0-1-吗？"><a href="#4-3-断网了，还能-ping-通-127-0-0-1-吗？" class="headerlink" title="4.3 断网了，还能 ping 通 127.0.0.1 吗？"></a>4.3 断网了，还能 ping 通 127.0.0.1 吗？</h2><p>答案：可以ping通。</p><p><strong>什么是127.0.0.1？</strong></p><ul><li>127 开头的都属于回环地址，而127.0.0.1是众多回环地址中的一个</li><li>在ipv6下环回地址是 ::1</li></ul><p><strong>TCP发数据和ping的区别</strong></p><ul><li>TCP 传输中创建的方式是 <code>socket(AF_INET, SOCK_STREAM, 0);</code>，其中 <code>AF_INET</code> 表示将使用 IPV4 里 host:port 的方式去解析待会你输入的网络地址。<code>SOCK_STREAM</code> 是指使用面向字节流的 TCP 协议，工作在传输层。</li><li>ping创建 <code>socket</code> 的时候用的是 <code>socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)</code>，<code>SOCK_RAW</code> 是原始套接字 ，工作在网络层</li></ul><h4 id="为什么断网了还能-ping-通-127-0-0-1"><a href="#为什么断网了还能-ping-通-127-0-0-1" class="headerlink" title="为什么断网了还能 ping 通 127.0.0.1"></a>为什么断网了还能 ping 通 127.0.0.1</h4><ul><li>发送数据时，到了网络层，系统会根据目的IP，在路由表中获取对应的路由信息，而这其中就包含选择哪个网卡把消息发出。</li><li>当发现目标IP是外网IP时，会从”真网卡”发出。当发现目标IP是回环地址时，就会选择本地网卡。</li><li>本地网卡，其实就是个”假网卡”，它不像”真网卡”那样有个ring buffer什么的，”假网卡”会把数据推到一个叫 input_pkt_queue 的 链表 中。这个链表是所有网卡共享的，上面挂着发给本机的各种消息。消息被发送到这个链表后，会再触发一个软中断。</li><li>ksoftirqd在收到软中断后就会立马去链表里把消息取出，然后顺着数据链路层、网络层等层层往上传递最后给到应用程序。</li></ul><h4 id="ping回环地址和ping本机地址有什么区别"><a href="#ping回环地址和ping本机地址有什么区别" class="headerlink" title="ping回环地址和ping本机地址有什么区别"></a>ping回环地址和ping本机地址有什么区别</h4><p>ping 本机IP 跟 ping 回环地址一样，相关的网络数据都是走的本地回环接口。只要走了本地回环接口，那数据都不会发送到网络中，在本机网络协议栈中兜一圈，就发回来了。因此 <strong>ping回环地址和ping本机地址没有区别</strong>。</p><h4 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗"></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h4><ul><li>127.0.0.1 是回环地址</li><li>localhost是一个域名，默认解析为127.0.0.1</li><li>0.0.0.0表示本机上的所有IPV4地址。执行 ping 0.0.0.0会失败的，因为它在IPV4中表示的是无效的目标地址。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1619. 删除某些元素后的数组均值</title>
      <link href="/2023/02/15/leetcode/other/leetcode-1619-simple/"/>
      <url>/2023/02/15/leetcode/other/leetcode-1619-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="1619-删除某些元素后的数组均值"><a href="#1619-删除某些元素后的数组均值" class="headerlink" title="1619. 删除某些元素后的数组均值"></a><a href="https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/">1619. 删除某些元素后的数组均值</a></h1><p>FIrst：排序，再去掉前后数相加求平均</p><hr><p><strong>方法1</strong>：<strong>排序</strong></p><p>先排序，然后去掉前后各5%的数，将剩下的数相加求和即可</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    double trimMean(vector&lt;int&gt;&amp; arr) &#123;        sort(arr.begin(),arr.end());        long long sum&#x3D;0;        for(int i&#x3D;arr.size()*0.05;i&lt;arr.size()*0.95;++i)&#123;            sum+&#x3D;arr[i];        &#125;        return sum&#x2F;(arr.size()*0.9);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>341. 扁平化嵌套列表迭代器</title>
      <link href="/2023/02/15/leetcode/other/leetcode-341-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8-middle/"/>
      <url>/2023/02/15/leetcode/other/leetcode-341-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="341-扁平化嵌套列表迭代器"><a href="#341-扁平化嵌套列表迭代器" class="headerlink" title="341. 扁平化嵌套列表迭代器"></a><a href="https://leetcode.cn/problems/flatten-nested-list-iterator/description/">341. 扁平化嵌套列表迭代器</a></h1><p>FIrst：不难，按逻辑来即可</p><hr><p><strong>方法1</strong>：<strong>深度优先搜索</strong></p><p>先深度遍历得到所有的值，然后使用一个index来记录当前遍历的位置。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class NestedIterator &#123;    vector&lt;int&gt; nums;    int index;public:    void traverse(const vector&lt;NestedInteger&gt; &amp;nestedList)&#123;        if(nestedList.empty()) return;        for(const auto &amp;a:nestedList)&#123;            if(a.isInteger())&#123;                nums.push_back(a.getInteger());            &#125;else&#123;                traverse(a.getList());            &#125;        &#125;    &#125;    NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList):nums(),index(0) &#123;        traverse(nestedList);    &#125;        int next() &#123;        return nums[index++];    &#125;        bool hasNext() &#123;        return index&lt;nums.size();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-深度搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>670. 最大交换</title>
      <link href="/2023/02/15/leetcode/other/leetcode-670-middle/"/>
      <url>/2023/02/15/leetcode/other/leetcode-670-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="670-最大交换"><a href="#670-最大交换" class="headerlink" title="670. 最大交换"></a><a href="https://leetcode.cn/problems/maximum-swap/">670. 最大交换</a></h1><p>FIrst：看着数也不大，直接每两两交换也会很快，但复杂度较高。想着是找到最大的可交换的数，但逻辑还是没理清</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>要想找到最大交换值，那么应该找到最大数字，但这数字必须能与前面数字交换才有用，能交换的要求是其前面存在比它小的数字。</p><p>因此，问题就变成找一个能与前面数字交换的最大数字，然后再找一个能与此数字交换的最靠前数字。数字相同情况下，最大数字位置应越靠末尾越好，被交换数字应越靠前越好。</p><ul><li>时间复杂度：O(lognum)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maximumSwap(int num) &#123;        string s&#x3D;to_string(num);        int maxid&#x3D;s.length();        int resmin&#x3D;-1,resmax&#x3D;-1;        for(int i&#x3D;s.length()-1;i&gt;&#x3D;0;--i)&#123;            if(s[maxid]&lt;s[i])&#123;                maxid&#x3D;i;            &#125;else if(s[maxid]&gt;s[i])&#123;                resmin&#x3D;i;                resmax&#x3D;maxid;            &#125;        &#125;        if(resmin!&#x3D;-1)&#123;            swap(s[resmin],s[resmax]);            return stoi(s);        &#125;else&#123;            return num;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>直接遍历</strong></p><p>直接遍历查找</p><ul><li>时间复杂度：O(log^2^num)</li><li>空间复杂度：O(lognum)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多线程服务器编程：使用muduo C++网络库 笔记</title>
      <link href="/2023/02/15/%E9%A1%B9%E7%9B%AE/muduo%E7%BD%91%E7%BB%9C%E5%BA%93-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/02/15/%E9%A1%B9%E7%9B%AE/muduo%E7%BD%91%E7%BB%9C%E5%BA%93-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>阅读《Linux多线程服务器编程：使用muduo C++网络库》笔记</p><hr><hr><h1 id="第1章-线程安全的对象生命期管理"><a href="#第1章-线程安全的对象生命期管理" class="headerlink" title="第1章 线程安全的对象生命期管理"></a>第1章 线程安全的对象生命期管理</h1><h2 id="1-1-当析构函数遇到多线程"><a href="#1-1-当析构函数遇到多线程" class="headerlink" title="1.1 当析构函数遇到多线程"></a>1.1 当析构函数遇到多线程</h2><blockquote><p>当一个对象能被多个线程同时看到时，那么对象的销毁时机就会变得模糊不清，可能出现多种竞态条件（race condition）</p><ul><li>在即将析构一个对象时，从何而知此刻是否有别的线程正在执行该对象的成员函数</li><li>如何保证在执行成员函数期间，对象不会在另一个线程被析构？</li><li>在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？</li></ul></blockquote><p>使用shared_ptr能一劳永逸地解决这些问题，减轻C++多线程编程的精神负担</p><h3 id="1-1-1-线程安全的定义"><a href="#1-1-1-线程安全的定义" class="headerlink" title="1.1.1 线程安全的定义"></a>1.1.1 线程安全的定义</h3><p>一个线程安全的class应当满足以下三个条件：</p><ul><li>多个线程同时访问时，其表现出正确的行为。</li><li>无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织（interleaving）</li><li>调用端代码无须额外的同步或其他协调动作。</li></ul><blockquote><p>C++标准库里的大多数class都不是线程安全的，包括std:: string、std::vector、std::map等，因为这些class通常需要在外部加锁才能供多个线程同时访问</p></blockquote><p>本书中定义了两个有关锁的工具类：</p><ul><li>MutexLock类：封装临界区，其是一个简单的资源类，用RALL手法封装互斥器的创建与销毁</li><li>MutexLockGuard类：封装临界区的进入和退出，即加锁和解锁。MutexLockGuard一般是个栈上对象，它的作用域刚好等于临界区域。（创建了一个此类对象，其析构通常在return后，因此保护了共享数据）</li></ul><p>编写单个的线程安全的class不算太难，只需用同步原语保护其内部状态。但如果此对象是通过动态指针创建的，那么仍需要解决race condition。</p><h2 id="1-2-对象的创建很简单"><a href="#1-2-对象的创建很简单" class="headerlink" title="1.2 对象的创建很简单"></a>1.2 对象的创建很简单</h2><p>对象构造要做到线程安全，&#x3D;&#x3D;唯一的要求是在构造期间不要泄露this指针&#x3D;&#x3D;，即：</p><ul><li>不要在构造函数中注册任何回调</li><li>也不要在构造函数中把this传给跨线程的对象</li><li>即便在构造函数的最后一行也不行（此类可能是一个基类，其先于派生类构造，此时派生类可能还没构造完）</li></ul><p><strong>原因</strong>：在构造函数执行期间对象还没有完成初始化，如果this被泄露（escape）给了其他对象（其自身创建的子对象除外），那么别的线程有可能访问这个半成品对象，这会造成难以预料的后果。</p><h2 id="1-3-销毁太难"><a href="#1-3-销毁太难" class="headerlink" title="1.3 销毁太难"></a>1.3 销毁太难</h2><p>对一般成员函数而言，做到线程安全的办法是让它们顺次执行，而不要并发执行，也就是让每个成员函数的临界区不重叠</p><blockquote><p>但是成员函数用来保护临界区的互斥器可能会被析构函数销毁掉</p><p>比如，一个类对象能被所有线程所见，一个线程执行到析构函数并持有互斥锁，另一个线程开始执行某函数，此时这个线程可能永远阻塞，也可能进入临界区然后core dump</p></blockquote><p><strong>作为数据成员的mutex不能保护析构</strong></p><p>作为class数据成员的MutexLock只能用于同步本class的其他数据成员的读和写，它不能保护安全地析构</p><blockquote><p>因为MutexLock成员的生命期最多与对象一样长，而析构动作可说是发生在对象身故之后</p></blockquote><p>同时读写一个class的两个对象，有潜在的死锁可能</p><blockquote><p>比如swap函数，两个线程都使用swap调用相同的两个对象，则有可能锁死</p><p>一个函数如果要锁住相同类型的多个对象，为了保证始终按相同的顺序加锁，我们可以比较mutex对象的地址，始终先加锁地址较小的mutex</p></blockquote><h2 id="1-4-线程安全的Observer有多难"><a href="#1-4-线程安全的Observer有多难" class="headerlink" title="1.4 线程安全的Observer有多难"></a>1.4 线程安全的Observer有多难</h2><p>Observer模式示例：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220911221246890.png"></p><p>一个动态创建的对象是否还活着，光看指针是看不出来的（引用也一样看不出来）</p><blockquote><p>针就是指向了一块内存，这块内存上的对象如果已经销毁，那么就根本不能访问。既然不能访问又如何知道对象的状态呢？</p><p>且万一原址又创建了一个新的对象呢？再万一这个新的对象的类型异于老的对象呢？</p></blockquote><p>对象的关系主要有三种：</p><ul><li>composition组合：在类中定义一个对象，其生命周期一致。在多线程里不会遇到什么麻烦，因为对象x的生命期由其唯一的拥有者owner控制，owner析构的时候会把x也析构掉</li><li>association关联：表示一个对象a用到了另一个对象b，调用了后者的成员函数（将一个类指针传到了类中使用）。从代码形式上看，a持有b的指针（或引用），但是b的生命期不由a单独控制。（似乎一个简单的解决办法是创建一个对象池，其只创建但不销毁，但也会存在许多问题）</li><li>aggregation聚合：聚合是一种特殊的关联关系，它是较强的一种关联关系（在类中动态创建了一个对象）。其面对情况和关联类似。</li></ul><h2 id="1-5-原始指针有何不妥"><a href="#1-5-原始指针有何不妥" class="headerlink" title="1.5 原始指针有何不妥"></a>1.5 原始指针有何不妥</h2><p>直接给其他类传指针对象是不妥得，无法判断此对象是否存货，可以使用shared_ptr，但需要注意循环引用</p><p><strong>空悬指针</strong></p><p>有两个指针p1和p2，指向堆上的同一个对象Object，p1和p2位于不同的线程中。假设线程A通过p1指针将对象销毁了，那p2就成了空悬指针。</p><blockquote><p>一种解决办法就是添加一个中间层指针proxy，此中间指针指向对象地址，p1和p2都指向proxy。（但如果p2看第一眼的时候proxy不是零，正准备去调用Object的成员函数，期间对象已经被p1给销毁了，此时也会存在问题）</p><p>另一种解决办法就是使用shared_ptr，其自带引用计数，当不存在引用时才销毁对象</p></blockquote><h2 id="1-6-神器shared-ptr-x2F-weak-ptr"><a href="#1-6-神器shared-ptr-x2F-weak-ptr" class="headerlink" title="1.6 神器shared_ptr&#x2F;weak_ptr"></a>1.6 神器shared_ptr&#x2F;weak_ptr</h2><p>shared_ptr和weak_ptr是引用计数型智能指针，具体用法略过</p><p>一些关键点：</p><ul><li>shared_ptr控制对象的生命期。shared_ptr是强引用，只要有一个指向x对象的shared_ptr存在，该x对象就不会析构。当指向对象x的最后一个shared_ptr析构或reset()的时候，x保证会被销毁</li><li>weak_ptr不控制对象的生命期，但是它知道对象是否还活着。如果对象还活着，那么它可以提升为有效的shared_ptr；如果对象已经死了，提升会失败，返回一个空的shared_ptr。<em>“提升／lock()”行为是线程安全的</em>。</li><li>shared_ptr&#x2F;weak_ptr的“计数”在主流平台上是原子操作，没有用锁，性能不俗</li><li>shared_ptr&#x2F;weak_ptr的线程安全级别与std::string和STL容器一样</li></ul><h2 id="1-7-插曲：系统地避免各种指针错误"><a href="#1-7-插曲：系统地避免各种指针错误" class="headerlink" title="1.7 插曲：系统地避免各种指针错误"></a>1.7 插曲：系统地避免各种指针错误</h2><p>C++里可能出现的内存问题大致有这么几个方面：</p><ul><li>1．缓冲区溢出：用std::vector<char>&#x2F;std::string或自己编写Buffer class来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区</li><li>2．空悬指针／野指针：用shared_ptr&#x2F;weak_ptr</li><li>3．重复释放：用scoped_ptr，只在对象析构的时候释放一次</li><li>4．内存泄漏：用scoped_ptr，对象析构的时候自动释放内存</li><li>5．不配对的new[]&#x2F;delete：把new[]统统替换为std::vector&#x2F;scoped_array</li><li>6．内存碎片：在9.2.1和1.8探讨</li></ul><blockquote><p>scoped_ptr&#x2F;shared_ptr&#x2F;weak_ptr都是值语意，要么是栈上对象，或是其他对象的直接数据成员，或是标准库容器里的元素。（其实就是说这几种智能指针用得时候都是使用对象，而不是定义这几种智能指针的指针）</p><p>如果这几种智能指针是对象x的数据成员，而它的模板参数T是个incomplete类型，那么x的析构函数不能是默认的或内联的，必须在.cpp文件里边显式定义，否则会有编译错或运行错</p></blockquote><h2 id="1-8-应用到Observer上"><a href="#1-8-应用到Observer上" class="headerlink" title="1.8 应用到Observer上"></a>1.8 应用到Observer上</h2><p>observer使用weak_ptr</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220911221605354.png"></p><p>使用weak_ptr能部分解决Observer模式的线程安全，但还有以下问题待解决：</p><ul><li>侵入性：强制要求Observer必须以shared_ptr来管理。</li><li>不是完全线程安全：observer的析构函数可能会调用其他对象的函数，但是此函数可能不存在</li><li>锁争用：即Observable的三个成员函数都用了互斥器来同步，这会造成register_()和unregister()等待notifyObservers()，而后者的执行时间是无上限的，因为它同步回调了用户提供的update()函数</li><li>死锁：万一L62的update()虚函数中调用了(un)register呢？如果mutex_是不可重入的，那么会死锁</li></ul><h2 id="1-9-再论shared-ptr的线程安全"><a href="#1-9-再论shared-ptr的线程安全" class="headerlink" title="1.9 再论shared_ptr的线程安全"></a>1.9 再论shared_ptr的线程安全</h2><p>shared_ptr本身不是100％线程安全的，它的引用计数本身是安全且无锁的，但对象的读写则不是，因为shared_ptr有两个数据成员，读写操作不能原子化</p><ul><li>一个shared_ptr对象实体可被多个线程同时读取</li><li>两个shared_ptr对象实体可以被两个线程同时写入，“析构”算写操作</li><li>如果要从多个线程读写同一个shared_ptr对象，那么需要加锁。</li><li><em>以上是shared_ptr对象本身的线程安全级别，不是它管理的对象的线程安全级别。</em></li></ul><p>&#x3D;&#x3D;在多个线程中同时访问同一个shared_ptr，正确的做法是用mutex保护&#x3D;&#x3D;</p><h2 id="1-10-shared-ptr技术与陷阱"><a href="#1-10-shared-ptr技术与陷阱" class="headerlink" title="1.10 shared_ptr技术与陷阱"></a>1.10 shared_ptr技术与陷阱</h2><p><strong>意外延长对象的生命期</strong>：shared_ptr是强引用（“铁丝”绑的），只要有一个指向x对象的shared_ptr存在，该对象就不会析构，而其又能拷贝和赋值</p><p><strong>函数参数</strong>：因为要修改引用计数shared_ptr的拷贝开销比拷贝原始指针要高，在不拷贝的情况下可以使用const reference方式传递</p><p><strong>析构动作在创建时被捕获</strong>：这是一个非常有用的特性，这意味着</p><ul><li>虚析构不再是必需的。</li><li>shared_ptr<void>可以持有任何对象，而且能安全地释放。</li><li>shared_ptr对象可以安全地跨越模块边界，比如从DLL里返回，而不会造成从模块A分配的内存在模块B里被释放这种错误。</li><li>二进制兼容性，即便Foo对象的大小变了，那么旧的客户代码仍然可以使用新的动态库，而无须重新编译</li><li>析构动作可以定制。</li></ul><p><strong>析构所在的线程</strong>：</p><ul><li>当最后一个指向x的shared_ptr离开其作用域的时候，x会在线程中析构，这个线程不一定是对象诞生的线程。</li><li>如果对象的析构比较耗时，那么可能会拖慢关键线程的速度</li><li>可以用一个单独的线程来专门做析构，通过一个BlockingQueue&lt;shared_ptr<void> &gt;把对象的析构都转移到那个专用线程，从而解放关键线程。</li></ul><p><strong>现成的RAII handle</strong></p><ul><li>RAII（资源获取即初始化）是C++语言区别于其他所有编程语言的最重要的特性</li><li>&#x3D;&#x3D;每一个明确的资源配置动作（例如new）都应该在单一语句中执行，并在该语句中立刻将配置获得的资源交给handle对象（如shared_ptr），程序中一般不出现delete&#x3D;&#x3D;</li><li>避免循环引用的通常做法是owner持有指向child的shared_ptr，child持有指向owner的weak_ptr</li></ul><h2 id="1-11-对象池"><a href="#1-11-对象池" class="headerlink" title="1.11 对象池"></a>1.11 对象池</h2><blockquote><p>有时只允许程序中出现一个类对象，但其可以被多个线程使用，当有线程使用而对象不存在时则创建对象，当没有线程使用时则析构，解决办法则是定义一个<em>对象池</em></p></blockquote><p>一个简单的对象池示例，其根据key返回对象</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220911225550229.png"></p><p>但是，上述map定义会导致stock对象永远不会销毁，应改成weak_ptr定义</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220911225749678.png"></p><p>但是stocks的大小只增不减，stocks.size()是曾经存活过的Stock对象的总数，即便活的Stock对象数目降为0。当对象创建很多时，就会导致内存一直得不到释放。</p><p>解决的办法是，利用shared_ptr的定制析构功能</p><blockquote><p>定义shared_ptr时，自定义一个析构函数来释放空间</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220911230353031.png"></p><p>上面代码在定义析构函数时，将this指针绑定在了析构函数中，这会导致线程安全问题：如果这个StockFactory先于Stock对象析构，那么会core dump</p><p><em>解决办法是使用下面的弱回调技术</em></p></blockquote><h3 id="1-11-1-enable-shared-from-this"><a href="#1-11-1-enable-shared-from-this" class="headerlink" title="1.11.1 enable_shared_from_this"></a>1.11.1 <strong>enable_shared_from_this</strong></h3><p>上小节中，StockFactory可能先于Stock对象析构，解决办法就是使用shared_ptr来管理stockfactory，获得当前对象的shared_ptr可以先继承enable_shared_from_this类，然后调用shared_from_this()函数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912094909137.png"></p><blockquote><p>function里保存了一份shared_ptr<StockFactory>，可以保证调用StockFactory::deleteStock的时候那个StockFactory对象还活着</p></blockquote><p><strong>注意</strong>：shared_from_this()不能在构造函数里调用，因为在构造StockFactory的时候，它还没有被交给shared_ptr接管</p><h3 id="1-11-2-弱回调"><a href="#1-11-2-弱回调" class="headerlink" title="1.11.2 弱回调"></a>1.11.2 弱回调</h3><blockquote><p>shared_ptr绑到boost:function里，那么回调的时候StockFactory对象始终存在</p><p>有时候我们需要“如果对象还活着，就调用它的成员函数，否则忽略之”，称之为“弱回调”</p></blockquote><p>利用weak_ptr可以实现弱回调，可以把weak_ptr绑到boost::function里，这样对象的生命期就不会被延长。然后在回调的时候先尝试提升为shared_ptr，如果提升成功，说明接受回调的对象还健在，那么就执行回调；如果提升失败，就不必劳神了。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912095447284.png"></p><h2 id="1-12-替代方案"><a href="#1-12-替代方案" class="headerlink" title="1.12 替代方案"></a>1.12 替代方案</h2><p>除了使用shared_ptr&#x2F;weak_ptr，做到线程安全的对象回调与析构还有以下办法：</p><ul><li>所有线程通过一个全局对象去访问想访问的对象（加了个中间层）</li><li>只创建不销毁</li><li>自己编写引用计数的智能指针</li><li>使用unique_ptr</li></ul><h2 id="1-13-心得与体会"><a href="#1-13-心得与体会" class="headerlink" title="1.13 心得与体会"></a>1.13 心得与体会</h2><ul><li>尽量减少使用跨线程的对象</li><li>原始指针暴露给多个线程往往会造成race condition或额外的簿记负担</li><li>统一用shared_ptr&#x2F;scoped_ptr来管理对象的生命期，在多线程中尤其重要</li><li>shared_ptr是值语意，当心意外延长对象的生命期。例如boost::bind和容器都可能拷贝shared_ptr</li><li>weak_ptr是shared_ptr的好搭档，可以用作弱回调、对象池等</li></ul><h1 id="第2章-线程同步精要"><a href="#第2章-线程同步精要" class="headerlink" title="第2章 线程同步精要"></a>第2章 线程同步精要</h1><blockquote><p>并发编程有两种基本模型，一种是message passing，另一种是shared memory。</p><p>在分布式系统中，运行在多台机器上的多个进程的并行编程只有一种实用模型：message passing1。</p><p>在单机上，可以使用message passing作为多个进程的并发模型。这样整个分布式系统的架构的一致性很强，扩容（scale out）起来也较容易。</p></blockquote><p><strong>线程同步的四项原则</strong>：</p><ul><li>首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑immutable对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。</li><li>其次是使用高级的并发编程构件，如TaskQueue、Producer-Consumer Queue、CountDownLatch等等。</li><li>最后不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。</li><li>除了使用atomic整数之外，不自己编写lock-free代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如spin lock vs. mutex。</li></ul><h2 id="2-1-互斥器"><a href="#2-1-互斥器" class="headerlink" title="2.1 互斥器"></a>2.1 互斥器</h2><p>互斥器（mutex）保护了临界区，任何一个时刻最多只能有一个线程在此mutex划出的临界区内活动。单独使用mutex时，主要为了保护共享数据。</p><p><strong>主要使用原则</strong></p><ul><li>用RAII手法封装mutex的创建、销毁、加锁、解锁这四个操作，保证锁的生效期间等于一个作用域（scope），不会因异常而忘记解锁。</li><li>只用非递归的mutex（即不可重入的mutex）</li><li>不手工调用lock()和unlock()函数，一切交给栈上的Guard对象的构造和析构函数负责。Guard对象的生命期正好等于临界区。保证始终在同一个函数同一个scope里对某个mutex加锁和解锁。避免在foo()里加锁，然后跑到bar()里解锁；也避免在不同的语句分支中分别加锁、解锁。这种做法被称为Scoped Locking。</li><li>在每次构造Guard对象的时候，思考一路上（调用栈上）已经持有的锁，防止因加锁顺序不同而导致死锁（deadlock）。由于Guard对象是栈上对象，看函数调用栈就能分析用锁的情况，非常便利</li></ul><p><strong>次要使用原则</strong></p><ul><li>不使用<em>跨进程</em>的mutex，进程间通信只用TCP sockets</li><li>加锁、解锁在同一个线程，线程a不能去unlock线程b已经锁住的mutex（RAII自动保证）</li><li>别忘了解锁（RAII自动保证）</li><li>不重复解锁（RAII自动保证）</li><li>必要的时候可以考虑用PTHREAD_MUTEX_ERRORCHECK来排错</li></ul><h3 id="2-1-1-只使用非递归的mutex"><a href="#2-1-1-只使用非递归的mutex" class="headerlink" title="2.1.1 只使用非递归的mutex"></a>2.1.1 只使用非递归的mutex</h3><blockquote><p>mutex分为递归（recursive）和非递归（non-recursive）两种，或叫可重入（reentrant）与非可重入</p><p>唯一区别在于：同一个线程可以重复对recursive mutex加锁，但是不能重复对non-recursive mutex加锁。</p><p>non-recursive和recursive的性能差别其实不大，因为少用一个计数器，前者略快一点点</p></blockquote><p>non-recursive mutex优点就是多次加锁会立刻导致死锁，使得代码问题及时暴露</p><p>典型情况是以为拿到一个锁就能修改对象了，没想到外层代码已经拿到了锁，正在修改（或读取）同一个对象</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912112117338.png"></p><p>post()加锁，然后修改foos对象；traverse()加锁，然后遍历foos向量。这些都是正确的。</p><p>但是，如果Foo::doit()间接调用了post()，那么会很有戏剧性的结果：</p><ul><li>mutex是非递归的，于是死锁了。</li><li>mutex是递归的，由于push_back()可能（但不总是）导致vector迭代器失效，程序偶尔会crash。</li></ul><p>使用非递归的优点就体现出来了，使我们能更早发现程序的逻辑错误并解决</p><p>如果一个函数既可能在已加锁的情况下调用，又可能在未加锁的情况下调用，那么就拆成两个函数：</p><ul><li>跟原来的函数同名，函数加锁，转而调用第2个函数。</li><li>给函数名加上后缀WithLockHold，不加锁，把原来的函数体搬过来。</li></ul><blockquote><p>可能出现两个问题：</p><ul><li><p>（a）误用了加锁版本，死锁了（使用2.1.2方法解决）</p></li><li><p>（b）误用了不加锁版本，数据损坏了</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912112442239.png"></p></li></ul></blockquote><h3 id="2-1-2-死锁"><a href="#2-1-2-死锁" class="headerlink" title="2.1.2 死锁"></a>2.1.2 死锁</h3><p>解决死锁：应使得临界区不交叉</p><h2 id="2-2-条件变量"><a href="#2-2-条件变量" class="headerlink" title="2.2 条件变量"></a>2.2 条件变量</h2><p>条件变量即等待某个条件成立然后被唤醒，其学名叫<em>管程</em></p><p><strong>条件变量wait使用</strong>：</p><ul><li>1．必须与mutex一起使用，该布尔表达式的读写需受此mutex保护。</li><li>2．在mutex已上锁的时候才能调用wait()。</li><li>3．把判断布尔条件和wait()放到while循环中。</li></ul><p><strong>条件变量signal&#x2F;broadcast使用</strong>：</p><ul><li>1．不一定要在mutex已上锁的情况下调用signal（理论上）</li><li>2．在signal之前一般要修改布尔表达式。</li><li>3．修改布尔表达式通常要用mutex保护（至少用作full memory barrier）。</li><li>4．注意区分signal与broadcast：“broadcast通常用于表明状态变化，signal通常用于表示资源可用。</li></ul><p>条件变量是非常底层的同步原语，很少直接使用，一般都是用它来实现高层的同步措施，如BlockingQueue<T>或CountDownLatch。</p><blockquote><p>倒计时（CountDownLatch）是一种常用且易用的同步手段。它主要有两种用途：</p><ul><li>主线程发起多个子线程，等这些子线程各自都完成一定的任务之后，主线程才继续执行。通常用于主线程等待多个子线程完成初始化。</li><li>主线程发起多个子线程，子线程都等待主线程，主线程完成其他一些任务之后通知所有子线程开始执行。通常用于多个子线程等待主线程发出“起跑”命令。</li></ul><p>CountDownLatch简单实现如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912195311021.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912195328455.png"></p></blockquote><blockquote><p>BlockingQueue简单实现如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912195438814.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912195500887.png"></p></blockquote><p>互斥器和条件变量构成了多线程编程的全部必备同步原语，用它们即可完成任何多线程同步任务，二者不能相互替代</p><h2 id="2-3-不要用读写锁和信号量"><a href="#2-3-不要用读写锁和信号量" class="headerlink" title="2.3 不要用读写锁和信号量"></a>2.3 不要用读写锁和信号量</h2><p><strong>读写锁区分了read和write两种行为，但是其并不一定比mutex好</strong></p><ul><li>正确性，在持有read lock时可能会调用修改数据的函数</li><li>性能，读写锁因为要更新当前reader数目，因此其开销不比mutex小，且如果竞争不激烈，mutex会更快</li><li>如果允许读锁提升为写锁，那么有些情况本应发生死锁的情况只是发生了程序崩溃，使得不易排查</li><li>通常reader lock是可重入的，writer lock是不可重入的。但是为了防止writer饥饿，writer lock通常会阻塞后来的reader lock，因此reader lock在重入的时候可能死锁</li><li>如果确实对并发读写有极高的性能要求，可以考虑read-copy-update</li></ul><p><strong>条件变量配合互斥器可以完全替代信号量</strong></p><ul><li>信号量有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能</li><li>使用信号量的一些场景如哲学家就餐，可以进行简化，设计成简单的资源争抢</li></ul><h2 id="2-4-封装MutexLock、MutexLockGuard、Condition"><a href="#2-4-封装MutexLock、MutexLockGuard、Condition" class="headerlink" title="2.4 封装MutexLock、MutexLockGuard、Condition"></a>2.4 封装MutexLock、MutexLockGuard、Condition</h2><p>MutexLock、MutexLockGuard类定义</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220913110208143.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220913110223337.png"></p><p>注意上面代码的最后一行定义了一个宏，这个宏的作用是防止程序里出现如下错误：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220913110443295.png"></p><p>上述代码还有改进地方：</p><ul><li>mutex创建为PTHREAD_MUTEX_DEFAULT类型，而不是PTHREAD_MUTEX_NORMAL类型（实际上这二者很可能是等同的），严格的做法是用mutexattr来显示指定mutex的类型</li><li>没有检查返回值。这里不能用assert()检查返回值，因为assert()在release build里是空语句。</li></ul></blockquote><p>Condition类将mutex和条件变量绑定了，没有实现wait时指定mutex，定义如下</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914095528426.png"></p><p>如果一个class要包含MutexLock和Condition，请注意它们的声明顺序和初始化顺序，mutex_应先于condition_构造，并作为后者的构造参数：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914095635228.png"></p></blockquote><h2 id="2-5-线程安全的Singleton实现"><a href="#2-5-线程安全的Singleton实现" class="headerlink" title="2.5 线程安全的Singleton实现"></a>2.5 线程安全的Singleton实现</h2><p>Singleton的线程安全实现使用double checked locking也是靠不住的，可使用pthread_once来保证</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914100255773.png"></p><p>使用方法：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914100320437.png"></p><blockquote><p>这个Singleton没有考虑对象的销毁。在长时间运行的服务器程序里，这不是一个问题，反正进程也不打算正常退出。在短期运行的程序中，程序退出的时候自然就释放所有资源了（前提是程序里不使用不能由操作系统自动关闭的资源，比如跨进程的mutex）</p></blockquote><h2 id="2-6-sleep-3-不是同步原语"><a href="#2-6-sleep-3-不是同步原语" class="headerlink" title="2.6 sleep(3)不是同步原语"></a>2.6 sleep(3)不是同步原语</h2><blockquote><p>生产代码中线程的等待可分为两种：</p><ul><li>一种是等待资源可用（要么等在select&#x2F;poll&#x2F;epoll_wait上，要么等在条件变量上43）；</li><li>一种是等着进入临界区（等在mutex上）以便读写共享数据。后一种等待通常极短，否则程序性能和伸缩性就会有问题。</li></ul></blockquote><p>在程序的正常执行中，如果需要等待一段已知的时间，应该往event loop里注册一个timer，然后在timer的回调函数里接着干活，因为线程是个珍贵的共享资源，不能轻易浪费</p><p>如果等待某个事件发生，那么应该采用条件变量或IO事件回调，不能用sleep来轮询</p><p>等待某个事件发生，正确的做法是用select()等价物或Condition，抑或（更理想地）高层同步工具；在用户态做轮询（polling）是低效的。</p><h2 id="2-7-归纳与总结"><a href="#2-7-归纳与总结" class="headerlink" title="2.7 归纳与总结"></a>2.7 归纳与总结</h2><p>前面几节内容归纳如下：</p><ul><li>线程同步的四项原则，尽量用高层同步设施（线程池、队列、倒计时）</li><li>使用普通互斥器和条件变量完成剩余的同步任务，采用RAII惯用手法（idiom）和Scoped Locking。</li></ul><h2 id="2-8-借shared-ptr实现copy-on-write"><a href="#2-8-借shared-ptr实现copy-on-write" class="headerlink" title="2.8 借shared_ptr实现copy-on-write"></a>2.8 借shared_ptr实现copy-on-write</h2><p>使用普通mutex替换读写锁，都基于用shared_ptr来管理共享数据，原理如下：</p><ul><li>shared_ptr是引用计数型智能指针，如果当前只有一个观察者，那么引用计数的值为147。</li><li>对于write端，如果发现引用计数为1，这时可以安全地修改共享对象，不必担心有人正在读它。</li><li>对于read端，在读之前把引用计数加1，读完之后减1，这样保证在读的期间其引用计数大于1，可以阻止并发写。</li><li>比较难的是，对于write端，如果发现引用计数大于1，该如何处理？将原来数据复制一份，在复制数据上进行修改，然后再拷贝回去（不直接在原来数据上修改是因为还有线程在读，读线程的互斥锁可能只有取数据那一小部分临界区，而进行处理的操作可能没在临界区）。</li></ul><blockquote><p>示例</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914105842469.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914105909144.png"></p><p>读函数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914110003319.png"></p><p>写函数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914110031548.png"></p></blockquote><h1 id="第3章-多线程服务器的适用场合与常用编程模型"><a href="#第3章-多线程服务器的适用场合与常用编程模型" class="headerlink" title="第3章 多线程服务器的适用场合与常用编程模型"></a>第3章 多线程服务器的适用场合与常用编程模型</h1><h2 id="3-1-进程与线程"><a href="#3-1-进程与线程" class="headerlink" title="3.1 进程与线程"></a>3.1 进程与线程</h2><p>多进程设计时需要思考以下内容：</p><ul><li>容错</li><li>扩容</li><li>负载均衡</li><li>退休（暂停使用）</li></ul><p>线程的特点是共享地址空间，从而可以高效地共享数据</p><h2 id="3-2-单线程服务器的常用编程模型"><a href="#3-2-单线程服务器的常用编程模型" class="headerlink" title="3.2 单线程服务器的常用编程模型"></a>3.2 单线程服务器的常用编程模型</h2><p>Reactor模式：non-blocking IO＋IO multiplexing（IO多路复用）</p><p>其基本结构是一个事件循环（event loop），以事件驱动（event-driven）和事件回调的方式实现业务逻辑：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220914111640559.png"></p><blockquote><p>基于事件驱动的编程模型也有其本质的缺点，它要求事件回调函数必须是非阻塞的。对于涉及网络IO的请求响应式协议，它容易割裂业务逻辑，使其散布于多个回调函数之中，相对不容易理解和维护</p></blockquote><h2 id="3-3-多线程服务器的常用编程模型"><a href="#3-3-多线程服务器的常用编程模型" class="headerlink" title="3.3 多线程服务器的常用编程模型"></a>3.3 多线程服务器的常用编程模型</h2><p>主要有以下几种方法：</p><ul><li>每个请求创建一个线程，使用阻塞式IO操作</li><li>使用线程池，同样使用阻塞式IO操作（相比上一种能提高性能）</li><li>使用non-blocking IO＋IO multiplexing（one loop per thread）</li><li>Leader&#x2F;Follower等高级模式</li></ul><h3 id="3-3-1-one-loop-per-thread"><a href="#3-3-1-one-loop-per-thread" class="headerlink" title="3.3.1 one loop per thread"></a>3.3.1 one loop per thread</h3><p>此模型下，程序里的每个IO线程有一个event loop（或者叫Reactor），用于处理读写和定时事件</p><blockquote><p>好处：</p><ul><li>线程数目基本固定，可以在程序启动的时候设置，不会频繁创建与销毁。</li><li>可以很方便地在线程间调配负载。</li><li>IO事件发生的线程是固定的，同一个TCP连接不必考虑事件并发。</li></ul></blockquote><p>Eventloop代表了线程的主循环，需要让哪个线程干活，就把timer或IOchannel（如TCP连接）注册到哪个线程的loop里即可，因此这个loop必须得是线程安全的</p><p>对于non-trivial的服务端程序，一般会采用non-blocking IO＋IO multiplexing，每个connection&#x2F;acceptor都会注册到某个event loop上，程序里有多个event loop，每个线程至多有一个event loop。</p><h3 id="3-3-2-线程池"><a href="#3-3-2-线程池" class="headerlink" title="3.3.2 线程池"></a>3.3.2 线程池</h3><p>对于没有IO而光有计算任务的线程，使用event loop有点浪费，用blocking queue实现的任务队列（TaskQueue）效果会更好</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220915095054503.png"></p><p>用这种方式实现线程池特别容易，以下是启动容量（并发数）为N的线程池：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220915095146398.png"></p><p>使用方法：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220915095225249.png"></p><p>可以用BlockingQueue<T>实现数据的生产者消费者队列，T是数据类型而非函数对象，queue的消费者从中拿到数据进行处理</p><h3 id="3-3-3-推荐模式"><a href="#3-3-3-推荐模式" class="headerlink" title="3.3.3 推荐模式"></a>3.3.3 推荐模式</h3><p>推荐的C++多线程服务端编程模式为：one (event) loop per thread+ thread pool：</p><ul><li>event loop（也叫IO loop）用作IO multiplexing，配合non-blocking IO和定时器。</li><li>thread pool用来做计算，具体可以是任务队列或生产者消费者队列。</li></ul><h2 id="3-4-进程间通信只用TCP"><a href="#3-4-进程间通信只用TCP" class="headerlink" title="3.4 进程间通信只用TCP"></a>3.4 进程间通信只用TCP</h2><blockquote><p>Linux下进程间通信（IPC）的方式很多：匿名管道（pipe）、具名管道（FIFO）、POSIX消息队列、共享内存、信号（signals）等等，更不必说Sockets了。同步原语（synchronization primitives）也很多，如互斥器（mutex）、条件变量（condition variable）、读写锁（reader-writer lock）、文件锁（record locking）、信号量（semaphore）等等</p></blockquote><p>进程间通信选Sockets主要好处在于：可以跨主机，具有伸缩性。而其他IPC都不能跨机器。</p><p>使用TCP这种字节流（byte stream）方式通信，会有marshal&#x2F;unmarshal的开销，这要求选用合适的消息格式，准确地说是wire format，推荐Google Protocol Buffers</p><blockquote><p>优点：</p><ul><li>TCP port由一个进程独占，且操作系统会自动回收（<em>listening port和已建立连接的TCP socket都是文件描述符，在进程结束时操作系统会关闭所有文件描述符</em>）</li><li>port是独占的，那么可以防止程序重复启动，后面那个进程抢不到port，自然就没法初始化了，避免造成意料之外的结果</li><li>两个进程通过TCP通信，如果一个崩溃了，操作系统会关闭连接，另一个进程几乎立刻就能感知</li><li>TCP协议的一个天生的好处是“可记录、可重现”，很方便使用工具进行分析</li><li>TCP连接是可再生的，连接的任何一方都可以退出再启动，重建连接之后就能继续工作，这对开发牢靠的分布式系统意义重大</li></ul></blockquote><p><strong>分布式系统中使用TCP长连接通信</strong></p><ul><li>分布式系统的软件设计和功能划分一般应该以“进程”为单位。从宏观上看，一个分布式系统是由运行在多台机器上的多个进程组成的，进程之间采用TCP长连接通信</li><li>容易定位分布式系统中的服务之间的依赖关系，TCP短连接和UDP则不具备这一特性</li><li>通过接收和发送队列的长度也较容易定位网络或程序故障</li></ul><h2 id="3-5-多线程服务器的适用场合"><a href="#3-5-多线程服务器的适用场合" class="headerlink" title="3.5 多线程服务器的适用场合"></a>3.5 多线程服务器的适用场合</h2><blockquote><p>开发服务端程序的一个基本任务是处理并发连接，现在服务端网络编程处理并发连接主要有两种方式：</p><ul><li>当“线程”很廉价时，一台机器上可以创建远高于CPU数目的“线程”。这时一个线程只处理一个TCP连接，通常使用阻塞IO。例如，Python gevent、Go goroutine、Erlang actor。这里的“线程”由语言的runtime自行调度，与操作系统线程不是一回事。</li><li>当线程很宝贵时，一台机器上只能创建与CPU数目相当的线程。这时一个线程要处理多个TCP连接上的IO，通常使用非阻塞IO和IO multiplexing。例如，libevent、muduo、Netty。这是原生线程，能被操作系统的任务调度器看见。</li></ul></blockquote><p>如果要在一台多核机器上提供一种服务或执行一个任务，可用的模式有：</p><ul><li>1．运行一个单线程的进程（不可伸缩，无法发挥多喝机器的计算能力）</li><li>2．运行一个多线程的进程</li><li>3．运行多个单线程的进程<ul><li>a. 简单地把模式1中的进程运行多份</li><li>b. 主进程+woker进程，如果必须绑定到一个TCP port，比如httpd+fastcgi</li></ul></li><li>4．运行多个多线程的进程</li></ul><p><strong>程序是否应该使用多线程判断方法</strong>：</p><ul><li>如果执行任务时间远大于进程启动和销毁开销，那么应该使用进程</li><li>如果执行任务时间接近进程开销大很多且也并未接近线程开销，那么使用线程（这里的接近是指大约在高一个数量级左右）</li><li>如果执行任务时间接近线程开销，那么直接就在当前线程执行或使用线程池</li></ul><h3 id="3-5-1-必须用单线程的场合"><a href="#3-5-1-必须用单线程的场合" class="headerlink" title="3.5.1 必须用单线程的场合"></a>3.5.1 必须用单线程的场合</h3><p>有两种场合必须使用单线程：</p><ul><li>1．程序可能会fork()（作者认为只有守护进程类型必须坚持单线程模式）</li><li>2．限制程序的CPU占用率（单线程最多使用一个核，占用率不会很高，不会影响其他任务）</li></ul><h3 id="3-5-2-单线程程序的优缺点"><a href="#3-5-2-单线程程序的优缺点" class="headerlink" title="3.5.2 单线程程序的优缺点"></a>3.5.2 单线程程序的优缺点</h3><p>单线程程序的优势：简单</p><p>单线程程序的缺点：非抢占（如果事件a优先级高级事件b，而a所需时间比b短，但如果b先来则开始处理，其实已经发生优先级反转）</p><h3 id="3-5-3-适用多线程程序的场景"><a href="#3-5-3-适用多线程程序的场景" class="headerlink" title="3.5.3 适用多线程程序的场景"></a>3.5.3 适用多线程程序的场景</h3><p>多线程的适用场景是：提高响应速度，让IO和“计算”相互重叠，降低延迟</p><p>一个程序要做成多线程的，大致要满足：</p><ul><li>有多个CPU可用。单核机器上多线程没有性能优势</li><li>线程间有共享数据，即内存中的全局状态（如果没有共享数据，用模型3b就行。虽然我们应该把线程间的共享数据降到最低，但不代表没有）</li><li>共享的数据是可以修改的，而不是静态的常量表（如果数据不能修改，那么可以在进程间用shared memory，模式3就能胜任）</li><li>提供非均质的服务。即，事件的响应有优先级差异，我们可以用专门的线程来处理优先级高的事件。防止优先级反转。</li><li>不是逻辑简单的IO bound或CPU bound程序，即程序要有相当的计算量。</li><li>利用异步操作。比如logging。无论往磁盘写log file，还是往log server发送消息都不应该阻塞critical path。</li><li>能scale up。一个好的多线程程序应该能享受增加CPU数目带来的好处</li><li>具有可预测的性能。随着负载增加，性能缓慢下降，超过某个临界点之后会急速下降。线程数目一般不随负载变化。</li><li>多线程能有效地划分责任与功能，让每个线程的逻辑比较简单，任务单一，便于编码。而不是把所有逻辑都塞到一个event loop里，不同类别的事件之间相互影响</li></ul><p>书里提供了一个服务器集群管理示例，可阅读</p><p><strong>线程的分类</strong></p><ul><li>1．IO线程，这类线程的主循环是IO multiplexing，阻塞地等在select&#x2F;poll&#x2F;epoll_wait系统调用上。这类线程也处理定时事件。有些简单计算也可以放入其中，比如消息的编码或解码。</li><li>2．计算线程，这类线程的主循环是blockingqueue，阻塞地等在conditionvariable上。这类线程一般位于thread pool中。这种线程通常不涉及IO，一般要避免任何阻塞操作。</li><li>3．第三方库所用的线程，比如logging，又比如database connection。</li></ul><p>服务器程序一般不会频繁地启动和终止线程，可在程序启动的时候就创建</p><h2 id="3-6-“多线程服务器的适用场合”例释与答疑"><a href="#3-6-“多线程服务器的适用场合”例释与答疑" class="headerlink" title="3.6 “多线程服务器的适用场合”例释与答疑"></a>3.6 “多线程服务器的适用场合”例释与答疑</h2><ol><li>Linux能同时启动多少个线程？</li></ol><blockquote><p>对于32-bit Linux，一个进程的地址空间是4GiB，其中用户态能访问3GiB左右，而一个线程的默认栈（stack）大小是10MB，一个进程大约最多能同时启动300个线程。对于64-bit系统，线程数目可大大增加</p></blockquote><ol start="2"><li>多线程能提高并发度吗？</li></ol><blockquote><p>单纯采用thread per connection的模型，那么并发连接数最多300，这远远低于基于Reactor模式的并发连接数（几千乃至上万，甚至几万）</p><p>thread per connection不适合高并发场合，其scalability不佳。one loop per thread的并发度足够大，且与CPU数目成正比</p></blockquote><ol start="3"><li>多线程能提高吞吐量吗？</li></ol><blockquote><p>对于计算密集型服务，不能。这里指的时总体吞吐量，能加快单个任务运算速度。</p></blockquote><ol start="4"><li>多线程能降低响应时间吗？</li></ol><blockquote><p>如果设计合理，充分利用多核资源的话，可以。在突发（burst）请求时效果尤为明显</p></blockquote><ol start="5"><li>多线程程序如何让IO和“计算”相互重叠，降低latency？</li></ol><blockquote><p>基本思路是，把IO操作（通常是写操作）通过BlockingQueue交给别的线程去做，自己不必等待。</p></blockquote><ol start="6"><li>为什么第三方库往往要用自己的线程？</li></ol><blockquote><p>event loop模型没有标准实现。如果自己写代码，尽可以按所用Reactor的推荐方式来编程。但是第三方库不一定能很好地适应并融入这个event loop framework，有时需要用线程来做一些串并转换。</p><p>比方说检测串口上的数据到达可以用文件描述符的可读事件，因此可以方便地融入event loop。但是检测串口上的某些控制信号只能用轮询或阻塞等待，要想融入event loop，需要单独起一个线程来查询串口信号翻转，再转换为文件描述符的读写事件。</p></blockquote><ol start="7"><li>什么是线程池大小的阻抗匹配原则？</li></ol><blockquote><p>如果线程在执行任务时密集计算所占的时间比重为P，而系统一共有C个CPU，为了让这C个CPU跑满而又不过载，线程池大小的经验公式T＝C&#x2F;P，但是P小于0.2时则不适用了，T可以取项目所需的固定值</p></blockquote><ol start="8"><li>除了你推荐的Reactor＋thread poll，还有别的non-trivial多线程编程模型吗？</li></ol><blockquote><p>Proactor。如果一次请求响应中要和别的进程打多次交道，那么Proactor模型往往能做到更高的并发度。当然，代价是代码变得支离破碎，难以理解。</p><p>Proactor模式依赖操作系统或库来高效地调度这些子任务，每个子任务都不会阻塞，因此能用比较少的线程达到很高的IO并发度。</p><p>Proactor能提高吞吐，但不能降低延迟</p><p>书中有个案例</p></blockquote><ol start="9"><li>模式2和模式3a该如何取舍？</li></ol><blockquote><p>模式2是一个多线程的进程，模式3a是多个相同的单线程进程</p><p>在其他条件相同的情况下，可以根据工作集（work set）的大小来取舍。工作集是指服务程序响应一次请求所访问的内存大小。如果工作集较大，那么就用多线程，避免CPU cache换入换出，影响性能；否则，就用单线程多进程，享受单线程编程的便利。</p><p>举例来说如果程序有一个较大的本地cache，用于缓存一些基础参考数据，几乎每次请求都会访问cache，那么多线程更适合一些，因为可以避免每个进程都自己保留一份cache，增加内存使用。</p></blockquote><h1 id="第4章-C-多线程系统编程精要"><a href="#第4章-C-多线程系统编程精要" class="headerlink" title="第4章 C++多线程系统编程精要"></a>第4章 C++多线程系统编程精要</h1><p>学习多线程编程思维方式的转变有两点：</p><ul><li>当前线程可能随时会被切换出去，或者说被抢占了</li><li>多线程程序中事件的发生顺序不再有全局统一的先后关系</li></ul><h2 id="4-1-基本线程原语的选用"><a href="#4-1-基本线程原语的选用" class="headerlink" title="4.1 基本线程原语的选用"></a>4.1 基本线程原语的选用</h2><p>11个最基本的Pthreads函数是：</p><ul><li>2个：线程的创建和等待结束（join）。封装为muduo::Thread</li><li>4个：mutex的创建、销毁、加锁、解锁。封装为muduo::MutexLock</li><li>5个：条件变量的创建、销毁、等待、通知、广播。封装为muduo::Condition。</li></ul><p>可以酌情使用的有：</p><ul><li>pthread_once，封装为muduo::Singleton<T>。其实不如直接用全局变量。</li><li>pthread_key*，封装为muduo::ThreadLocal<T>。可以考虑用_thread替换之。不建议使用</li><li>pthread_rwlock，读写锁通常应慎用。muduo没有封装读写锁，这是有意的。</li><li>sem_*，避免用信号量（semaphore）。它的功能与条件变量重合，但容易用错。</li><li>pthread{cancel, kill}。程序中出现了它们，则通常意味着设计出了问题。</li></ul><h2 id="4-2-C-x2F-C-系统库的线程安全性"><a href="#4-2-C-x2F-C-系统库的线程安全性" class="headerlink" title="4.2 C&#x2F;C++系统库的线程安全性"></a>4.2 C&#x2F;C++系统库的线程安全性</h2><p>编写线程安全程序的一个难点在于线程安全是不可组合的（两个函数是线程安全的，但组合调用则不一定线程安全）</p><p>设计线程安全的接口基本思路是尽量把class设计成immutable的</p><p>C++系统库：</p><ul><li><p>C++的标准库容器和std::string都不是线程安全的</p></li><li><p>C++标准库中的绝大多数泛型算法是线程安全的12，因为这些都是无状态纯函数。只要输入区间是线程安全的，那么泛型函数就是线程安全的。</p></li><li><p>C++的iostream不是线程安全的，因为流式输出多个数据相当于调用了多个函数（可以改用printf，但不高效）</p></li></ul><h2 id="4-3-Linux上的线程标识"><a href="#4-3-Linux上的线程标识" class="headerlink" title="4.3 Linux上的线程标识"></a>4.3 Linux上的线程标识</h2><blockquote><p>threads库提供了pthread_self函数用于返回当前进程的标识符，其类型为pthread_t，不一定是一个数值类型，也有可能是一个结构体。专门提供了pthread_equal函数用于对比两个线程标识符是否相等。这就带来一系列问题，包括：</p><ul><li>无法打印输出pthread_t，因为不知道其确切类型</li><li>无法比较pthread_t的大小或计算其hash值，因此无法用作关联容器的key</li><li>无法定义一个非法的pthread_t值，用来表示绝对不可能存在的线程id，因此MutexLock class没有办法有效判断当前线程是否已经持有本锁</li><li>pthread_t值只在进程内有意义，与操作系统的任务调度之间无法建立有效关联。比方说在&#x2F;proc文件系统中找不到pthread_t对应的task。</li></ul><p>glibc的Pthreads实现实际上把pthread_t用作一个结构体指针，指向一块动态分配的内存，而且这块内存是反复使用的。这就造成pthread_t的值很容易重复。Pthreads只保证同一进程之内，同一时刻的各个线程的id不同；不能保证同一进程先后多个线程具有不同的id，更不要说一台机器上多个进程之间的id唯一性了。</p></blockquote><p>在Linux上，建议使用gettid()系统调用的返回值作为线程id，这么做的好处有：</p><ul><li>它的类型是pid_t，其值通常是一个小整数，便于在日志中输出。</li><li>在现代Linux中，它直接表示内核的任务调度id，因此在&#x2F;proc文件系统中可以轻易找到对应项</li><li>在其他系统工具中也容易定位到具体某一个线程，例如在top()中我们可以按线程列出任务，然后找出CPU使用率最高的线程id，再根据程序日志判断到底哪一个线程在耗用CPU。</li><li>任何时刻都是全局唯一的，并且由于Linux分配新pid采用递增轮回办法，短时间内启动的多个线程也会具有不同的线程id。</li><li>0是非法值，因为操作系统第一个进程init的pid是1。</li></ul><p>每次都执行一次gettid()系统调用效率不高，解决办法是缓存第一次请求返回的值。</p><h2 id="4-4-线程的创建与销毁的守则"><a href="#4-4-线程的创建与销毁的守则" class="headerlink" title="4.4 线程的创建与销毁的守则"></a>4.4 线程的创建与销毁的守则</h2><p><strong>线程的创建遵循原则：</strong></p><ul><li><p>程序库不应该在未提前告知的情况下创建自己的“背景线程”</p><blockquote><p>否则会导致资源规划漏算且不能安全fork</p></blockquote></li><li><p>尽量用相同的方式创建线程，例如muduo::Thread</p></li><li><p>在进入main()函数之前不应该启动线程</p><blockquote><p>也就是别在全局对象中创建线程，这会影响其他全局对象的安全构造，C++保证在进入main()之前完成全局对象16的构造</p></blockquote></li><li><p>程序中线程的创建最好能在初始化阶段全部完成</p><blockquote><p>一个服务程序的线程数目应该与当前负载无关，而应该与机器的CPU数目有关，即应该规划好线程个数</p></blockquote></li></ul><p><strong>线程的销毁方式：</strong></p><ul><li>自然死亡。从线程主函数返回，线程正常退出。</li><li>非正常死亡。从线程主函数抛出异常或线程触发segfault信号等非法操作18。</li><li>自杀。在线程中调用pthread_exit()来立刻退出线程。</li><li>他杀。其他线程调用pthread_cancel()来强制终止某个线程。</li></ul><p>线程正常退出的方式只有一种，即自然死亡。任何从外部强行终止线程的做法和想法都是错的</p><blockquote><p>如果确实需要强行终止一个耗时很长的计算任务，而又不想在计算期间周期性地检查某个全局退出标志，那么可以考虑把那一部分计算任务代码fork()，以一个新进程启动，杀一个进程比杀本进程内的线程要安全得多</p><p>新进程与本进程的通信方式最好用文件描述符</p></blockquote><h3 id="4-4-1-pthread-cancel与C"><a href="#4-4-1-pthread-cancel与C" class="headerlink" title="4.4.1 pthread_cancel与C++"></a>4.4.1 pthread_cancel与C++</h3><p>POSIX threads有cancellation point这个概念，意思是线程执行到这里有可能会被终止（cancel）</p><p>在C++中，cancellation point的实现与C语言有所不同，线程不是执行到此函数就立刻终止，而是该函数会抛出异常。这样可以有机会执行stack unwind，析构栈上对象（特别是释放持有的锁）</p><h3 id="4-4-2-exit-3-在C-中不是线程安全的"><a href="#4-4-2-exit-3-在C-中不是线程安全的" class="headerlink" title="4.4.2　exit(3)在C++中不是线程安全的"></a>4.4.2　exit(3)在C++中不是线程安全的</h3><p>exit(3)函数在C++中的作用除了终止进程，还会析构全局对象和已经构造完的函数静态对象。这有潜在的死锁可能</p><blockquote><p>例子如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220917173424329.png"></p><p>书中还有个exit推出例子，意思是一个全局对象被多个线程调用，在一个线程中调用了exit(3)，那么这个全局对象被析构，另一个线程调用此全局对象则会发生崩溃</p></blockquote><p>如果确实需要主动结束线程，则可以考虑用_exit(2)系统调用。它不会试图析构全局对象，但是也不会执行其他任何清理工作，比如flush标准输出。</p><h2 id="4-5-善用-thread关键字"><a href="#4-5-善用-thread关键字" class="headerlink" title="4.5 善用__thread关键字"></a>4.5 善用__thread关键字</h2><p>__thread是<a href="https://so.csdn.net/so/search?q=GCC&spm=1001.2101.3001.7020">GCC</a>内置的线程局部存储设施。thread变量每一个线程有一份独立实体，各个线程的值互不干扰。</p><p>__thread变量的存取效率可与全局变量相比</p><p><strong>thread使用规则</strong>：</p><ul><li>只能用于修饰POD类型，不能修饰class类型，因为无法自动调用构造函数和析构函数。</li><li>thread可以用于修饰全局变量、函数内的静态变量，但是不能用于修饰函数的局部变量或者class的普通成员变量。</li><li>__thread变量的初始化只能用编译期常量。</li><li>可以用来修饰那些带有全局性且值可能变，但是又不值得用全局变量保护的变量。</li></ul><h2 id="4-6-多线程与IO"><a href="#4-6-多线程与IO" class="headerlink" title="4.6 多线程与IO"></a>4.6 多线程与IO</h2><blockquote><p>操作文件描述符的系统调用本身是线程安全的，不用担心多个线程同时操作文件描述符会造成进程崩溃或内核崩溃</p></blockquote><p><strong>多线程程序应该遵循的原则</strong>是：每个文件描述符只由一个线程操作，从而轻松解决消息收发的顺序性问题，也避免了关闭文件描述符的各种race condition。一个线程可以操作多个文件描述符，但一个线程不能操作别的线程拥有的文件描述符。epoll也遵循相同的原则。</p><p><strong>两个例外</strong>：对于磁盘文件，在必要的时候多个线程可以同时调用pread(2)&#x2F;pwrite(2)来读写同一个文件；对于UDP，由于协议本身保证消息的原子性，在适当的条件下（比如消息之间彼此独立）可以多个线程同时读写同一个UDP文件描述符。</p><h2 id="4-7-用RAII包装文件描述符"><a href="#4-7-用RAII包装文件描述符" class="headerlink" title="4.7 用RAII包装文件描述符"></a>4.7 用RAII包装文件描述符</h2><blockquote><p>Linux的文件描述符（file descriptor）是小整数，在程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这时如果我们新打开一个文件，它的文件描述符会是3，因为POSIX标准要求每次新打开文件（含socket）的时候必须使用当前最小可用的文件描述符号码。</p><p>这种分配文件描述符的方式稍不注意就会造成串话，比如一个线程正准备read()某个socket，而第二个线程几乎同时close()了此socket；第三个线程又恰好open()了另一个文件描述符，其号码正好与前面的socket相同</p></blockquote><p><strong>使用RAII来解决文件描述符串话问题</strong>：用Socket对象包装文件描述符，所有对此文件描述符的读写操作都通过此对象进行，在对象的析构函数里关闭文件描述符。这样一来，只要Socket对象还活着，就不会有其他Socket对象跟它有一样的文件描述符，也就不可能串话。剩下的问题就是做好多线程中的对象生命期管理。</p><p>为什么服务端程序不应该关闭标准输出（fd＝1）和标准错误（fd＝2）？</p><blockquote><p>因为有些第三方库在特殊紧急情况下会往stdout或stderr打印出错信息，如果我们的程序关闭了标准输出（fd＝1）和标准错误（fd＝2），这两个文件描述符有可能被网络连接占用，结果造成对方收到莫名其妙的数据。</p><p>正确的做法是把stdout或stderr重定向到磁盘文件（最好不要是&#x2F;dev&#x2F;null），这样我们不至于丢失关键的诊断信息。</p></blockquote><p>在非阻塞网络编程中，也有可能发生socket串话，解决方法仍然是使用一个类封装socket，然后使用shared_ptr来管理其声明周期。</p><h2 id="4-8-RAII与fork"><a href="#4-8-RAII与fork" class="headerlink" title="4.8 RAII与fork()"></a>4.8 RAII与fork()</h2><blockquote><p>在编写C++程序的时候，设法保证对象的构造和析构是成对出现的，否则就几乎一定会有内存泄漏。用对象来包装资源，把资源管理与对象生命期管理统一起来（RAII）。但是，假如程序会fork()，这一假设就会被破坏了。</p></blockquote><p>fork()之后，子进程继承了父进程的几乎全部状态，但也有少数例外。子进程会继承地址空间和文件描述符，因此用于管理动态内存和文件描述符的RAII class都能正常工作。但是子进程不会继承：</p><ul><li>父进程的内存锁，mlock(2)、mlockall(2)。</li><li>父进程的文件锁，fcntl(2)。</li><li>父进程的某些定时器，setitimer(2)、alarm(2)、timer_create(2)等等。</li></ul><p>通常我们会用RAII手法来管理以上种类的资源（加锁解锁、创建销毁定时器等等），但是在fork()出来的子进程中不一定正常工作，因为资源在fork()时已经被释放了。</p><h2 id="4-9-多线程与fork"><a href="#4-9-多线程与fork" class="headerlink" title="4.9 多线程与fork()"></a>4.9 多线程与fork()</h2><p>fork()一般不能在多线程程序中调用，因为Linux的fork()只克隆当前线程的thread of control，不克隆其他线程。fork()之后，除了当前线程之外，其他线程都消失了。也就是说不能一下子fork()出一个和父进程一样的多线程子进程。</p><blockquote><p>Linux没有forkall()这样的系统调用，forkall()其实也是很难办的（从语意上），因为其他线程可能等在condition variable上，可能阻塞在系统调用上，可能等着mutex以跨入临界区，还可能在密集的计算中，这些都不好全盘搬到子进程里。</p></blockquote><p>fork()之后子进程中只有一个线程，其他线程都消失了，这就造成一个危险的局面。其他线程可能正好位于临界区之内，持有了某个锁，而它突然死亡，再也没有机会去解锁了。如果子进程试图再对同一个mutex加锁，就会立刻死锁。</p><p>在fork()之后，子进程就相当于处于signal handler之中，你不能调用线程安全的函数（除非它是可重入的），而只能调用异步信号安全（async-signal-safe）的函数。比方说，fork()之后，子进程不能调用：</p><ul><li>malloc(3)。因为malloc()在访问全局状态时几乎肯定会加锁。</li><li>任何可能分配或释放内存的函数，包括new、map::insert()、snprintf33……</li><li>任何Pthreads函数。你不能用pthread_cond_signal()去通知父进程，只能通过读写pipe(2)来同步。</li><li>printf()系列函数，因为其他线程可能恰好持有stdout&#x2F;stderr的锁。</li><li>除了man 7 signal中明确列出的“signal安全”函数之外的任何函数。</li></ul><p>唯一安全的做法是在fork()之后立即调用exec()执行另一个程序，彻底隔断子进程与父进程的联系。</p><h2 id="4-10-多线程与signal"><a href="#4-10-多线程与signal" class="headerlink" title="4.10 多线程与signal"></a>4.10 多线程与signal</h2><p>在多线程程序中，使用signal的第一原则是<strong>不要使用signal</strong>：</p><ul><li>不要用signal作为IPC的手段，包括不要用SIGUSR1等信号来触发服务端的行为。如果确实需要，可以用§9.5介绍的增加监听端口的方式来实现双向的、可远程访问的进程控制。</li><li>不要使用基于signal实现的定时函数，包括alarm&#x2F;ualarm&#x2F;setitimer&#x2F;timer_create、sleep&#x2F;usleep等等。</li><li>不主动处理各种异常信号（SIGTERM、SIGINT等等），只用默认语义：结束进程。有一个例外：SIGPIPE，服务器程序通常的做法是忽略此信号40，否则如果对方断开连接，而本机继续write的话，会导致程序意外终止。</li><li>在没有别的替代方法的情况下（比方说需要处理SIGCHLD信号），把异步信号转换为同步的文件描述符事件。</li></ul><h2 id="4-11-Linux新增系统调用的启示"><a href="#4-11-Linux新增系统调用的启示" class="headerlink" title="4.11 Linux新增系统调用的启示"></a>4.11 Linux新增系统调用的启示</h2><p>Linux服务器开发的主流模型正在由fork()＋worker processes模型转变为第3章推荐的多线程模型。fork()的使用频度会大大降低，将来或许只有专门负责启动别的进程的“看门狗程序”才会调用fork()，而一般的网络服务器程序不会再fork()出子进程了。原因之一是，fork()一般不能在多线程程序中调用（§4.9）。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>编写多线程C++程序的原则如下：</p><ul><li>线程是宝贵的，一个程序可以使用几个或十几个线程。一台机器上不应该同时运行几百个、几千个用户线程，这会大大增加内核scheduler的负担，降低整体性能。</li><li>线程的创建和销毁是有代价的，一个程序最好在一开始创建所需的线程，并一直反复使用。不要在运行期间反复创建、销毁线程，如果必须这么做，其频度最好能降到1分钟1次（或更低）。</li><li>每个线程应该有明确的职责，例如IO线程（运行EventLoop::loop()，处理IO事件）、计算线程（位于ThreadPool中，负责计算）等等。</li><li>线程之间的交互应该尽量简单，理想情况下，线程之间只用消息传递（例如BlockingQueue）方式交互。如果必须用锁，那么最好避免一个线程同时持有两把或更多的锁，这样可彻底防止死锁。</li><li>要预先考虑清楚一个mutable shared对象将会暴露给哪些线程，每个线程是读还是写，读写有无可能并发进行。</li></ul><h1 id="第5章-高效的多线程日志"><a href="#第5章-高效的多线程日志" class="headerlink" title="第5章 高效的多线程日志"></a>第5章 高效的多线程日志</h1><blockquote><p>“日志（logging）”有两个意思：</p><ul><li>诊断日志（diagnostic log）：常用日志库提供的日志功能。</li><li>交易日志（transaction log）：即数据库的write-ahead log、文件系统的journaling等，用于记录状态变更，通过回放日志可以逐步恢复每一次修改之后的状态。</li></ul></blockquote><p><strong>对于关键进程，日志通常要记录</strong>：</p><ul><li>1．收到的每条内部消息的id（还可以包括关键字段、长度、hash等）；</li><li>2．收到的每条外部消息的全文；</li><li>3．发出的每条消息的全文，每条消息都有全局唯一的id；</li><li>4．关键内部状态的变更，等等。</li></ul><p>一个日志库大体可分为前端和后端两部分。前端是供应用程序使用的接口，并生成日志消息；后端则负责把日志消息写到目的地</p><h2 id="5-1-功能需求"><a href="#5-1-功能需求" class="headerlink" title="5.1 功能需求"></a>5.1 功能需求</h2><blockquote><p>常规的通用日志库如log4j13&#x2F;logback14通常会提供丰富的功能，但这些功能不一定全都是必需的：</p><ul><li>1．日志消息有多种级别（level），如TRACE、DEBUG、INFO、WARN、ERROR、FATAL等。</li><li>2．日志消息可能有多个目的地（appender），如文件、socket、SMTP等。</li><li>3．日志消息的格式可配置（layout），例如org.apache.log4j.PatternLayout。</li><li>4．可以设置运行时过滤器（filter），控制不同组件的日志消息的级别和目的地。</li></ul><p>作者认为除了第一项之外，其余三项都是非必需的功能</p></blockquote><p>日志的输出级别在运行时可调，这样同一个可执行文件可以分别在QA测试环境的时候输出DEBUG级别的日志，在生产环境输出INFO级别的日志</p><p>对于分布式系统中的服务进程而言，日志的目的地只有一个：本地文件。往网络写日志消息是不靠谱的，因为诊断日志的功能之一正是诊断网络故障，比如连接断开。</p><p><strong>一个典型的日志文件的文件名</strong>如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220921103201748.png"></p><ul><li>第1部分logfile_test是进程的名字。通常是main()函数参数中argv[0]的basename(3)，这样容易区分究竟是哪个服务程序的日志。必要时还可以把程序版本加进去。</li><li>第2部分是文件的创建时间（GMT时区）。这样很容易通过文件名来选择某一时间范围内的日志，例如用通配符</li><li>第3部分是机器名称。这样即便把日志文件拷贝到别的机器上也能追溯其来源。</li><li>第4部分是进程id。如果一个程序一秒之内反复重启，那么每次都会生成不同的日志文件。</li><li>第5部分是统一的后缀名.log。同样是为了便于周边配套脚本的编写。</li></ul><p><strong>往文件写日志的一个常见问题是，万一程序崩溃，那么最后若干条日志往往就丢失了</strong>，因为日志库不能每条消息都flush硬盘，更不能每条日志都open&#x2F;close文件，这样性能开销太大。</p><blockquote><p>muduo日志库用两个办法来应对这一点：</p><ul><li>其一是定期（默认3秒）将缓冲区内的日志消息flush到硬盘</li><li>其二是每条内存中的日志消息都带有cookie（或者叫哨兵值&#x2F;sentry），其值为某个函数的地址，这样通过在core dump文件中查找cookie就能找到尚未来得及写入磁盘的消息。</li></ul></blockquote><p><strong>日志消息格式有几个要点</strong>：</p><ul><li>尽量每条日志占一行。这样很容易用awk、sed、grep等命令行工具来快速联机分析日志</li><li>时间戳精确到微秒。每条消息都通过gettimeofday(2)获得当前时间，这么做不会有什么性能损失。因为在x86-64 Linux上，gettimeofday(2)不是系统调用，不会陷入内核</li><li>始终使用GMT时区（Z）。对于跨洲的分布式系统而言，可省去本地时区转换的麻烦，更易于追查事件的顺序</li><li>打印线程id。便于分析多线程程序的时序，也可以检测死锁</li><li>打印日志级别。在线查错的时候先看看有无ERROR日志，通常可加速定位问题。</li><li>打印源文件名和行号。修复bug的时候不至于搞错对象。</li></ul><h2 id="5-2-性能需求"><a href="#5-2-性能需求" class="headerlink" title="5.2 性能需求"></a>5.2 性能需求</h2><p>高效性体现在几方面：</p><ul><li>每秒写几千上万条日志的时候没有明显的性能损失。</li><li>能应对一个进程产生大量日志数据的场景，例如1GB&#x2F;min。</li><li>不阻塞正常的执行流程。</li><li>在多线程程序中，不造成争用。这里列举一些具体的性能指标，考虑往普通7200rpm SATA硬盘写日志文件的情况：<ul><li>磁盘带宽约是110MB&#x2F;s，日志库应该能瞬时写满这个带宽（不必持续太久）。</li><li>假如每条日志消息的平均长度是110字节，这意味着1秒要写100万条日志。</li></ul></li></ul><p><strong>muduo日志库的几点优化措施</strong>：</p><ul><li>时间戳字符串中的日期和时间两部分是缓存的，一秒之内的多条日志只需重新格式化微秒部分</li><li>日志消息的前4个字段是定长的，因此可以避免在运行期求字符串长度（不会反复调用strlen）。因为编译器认识memcpy()函数，对于定长的内存复制，会在编译期把它inline展开为高效的目标代码</li><li>线程id是预先格式化为字符串，在输出日志消息时只需简单拷贝几个字节</li><li>每行日志消息的源文件名部分采用了编译期计算来获得basename，避免运行期strrchr(3)开销。见SourceFile class，这里利用了gcc的内置函数。</li></ul><h2 id="5-3-多线程异步日志"><a href="#5-3-多线程异步日志" class="headerlink" title="5.3 多线程异步日志"></a>5.3 多线程异步日志</h2><blockquote><p>多线程程序对日志库提出了新的需求：线程安全，即多个线程可以并发写日志，两个线程的日志消息不会出现交织。线程安全不难办到，简单的办法是用一个全局mutex保护IO，或者每个线程单独写一个日志文件，但这两种做法的高效性就堪忧了。前者会造成全部线程抢一个锁，后者有可能让业务线程阻塞在写磁盘操作上。</p><p>在多线程服务程序中，异步日志（叫“非阻塞日志”似乎更准确）是必需的，因为如果在网络IO线程或业务线程中直接往磁盘写数据的话，写操作偶尔可能阻塞长达数秒之久（原因很复杂，可能是磁盘或磁盘控制器复位）。这可能导致请求方超时，或者耽误发送心跳消息，在分布式系统中更可能造成多米诺骨牌效应，例如误报死锁引发自动failover等</p></blockquote><p>muduo日志库采用的是双缓冲技术，基本思路是准备两块buffer：A和B，前端负责往buffer A填数据（日志消息），后端负责将buffer B的数据写入文件。当buffer A写满之后，交换A和B，让后端将buffer A的数据写入文件，而前端则往buffer B填入新的日志消息，如此往复。</p><blockquote><p>用两个buffer的好处是在新建日志消息的时候不必等待磁盘文件操作，也避免每条新日志消息都触发（唤醒）后端日志线程。</p><p>换言之，前端不是将一条条日志消息分别传送给后端，而是将多条日志消息拼成一个大的buffer传送给后端，相当于批处理，减少了线程唤醒的频度，降低开销。</p><p>另外，为了及时将日志消息写入文件，即便buffer A未满，日志库也会每3秒执行一次上述交换写入操作。</p></blockquote><p><strong>代码实现</strong></p><p>实际实现采用了四个缓冲区，这样可以进一步减少或避免日志前端的等待。数据结构如下</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220921113405077.png"></p><p>前端发送消息函数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220921113439416.png"></p><p>后端写接收消息函数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220921113508976.png"></p><p>书中还分析了四种运行时的情况，详细见书中此章节</p><p>使用四个缓冲还是可能不够用，导致消息多的时候需要新分配内存，改进措施就是使用一个缓冲池</p><p><strong>如果日志消息堆积怎么办</strong></p><p>muduo日志库处理日志堆积的方法很简单：直接丢掉多余的日志buffer，以腾出内存。这样可以防止日志库本身引起程序故障，是一种自我保护措施</p><h2 id="5-4-其他方案"><a href="#5-4-其他方案" class="headerlink" title="5.4 其他方案"></a>5.4 其他方案</h2><p>使用常规的muduo::BlockingQueue<a href="std::string">std::string</a>或muduo::BoundedBlockingQueue<a href="std::string">std::string</a>在前后端之间传递日志消息，其中每个std::string是一条消息。</p><ul><li>这种做法每条日志消息都要分配内存，特别是在前端线程分配的内存要由后端线程释放，因此对malloc的实现要求较高，需要针对多线程特别优化</li><li>相比前面展示的直接拷贝日志消息的做法，这个传递指针的方案似乎会更高效，但是据测试，直接拷贝日志数据的做法比传递指针快3倍（在每条日志消息不大于4kB的时候），估计是内存分配的开销所致</li></ul><p>muduo现在的异步日志实现用了一个全局锁。尽管临界区很小，但是如果线程数目较多，锁争用（lock contention）也可能影响性能。一种解决办法是像Java的ConcurrentHashMap那样用多个桶子（bucket），前端写日志的时候再按线程id哈希到不同的bucket中，以减少contention。</p><h1 id="第6章-muduo网络库简介"><a href="#第6章-muduo网络库简介" class="headerlink" title="第6章 muduo网络库简介"></a>第6章 muduo网络库简介</h1><p>为什么需要网络库？</p><blockquote><p>网络库能降低开发难度，能方便地处理并发连接</p></blockquote><h2 id="6-3-目录结构"><a href="#6-3-目录结构" class="headerlink" title="6.3 目录结构"></a>6.3 目录结构</h2><p>muduo的目录结构如下</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922104903753.png"></p><p><strong>基础库</strong></p><p>muduo&#x2F;base目录是一些基础库，都是用户可见的类，内容包括：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922104942922.png"></p><p><strong>网络核心库</strong></p><blockquote><p>muduo是基于Reactor模式的网络库，其核心是个事件循环EventLoop，用于响应计时器和IO事件。muduo采用基于对象（object-based）而非面向对象（objectoriented）的设计风格，其事件回调接口多以boost::function＋boost::bind表达，用户在使用muduo的时候不需要继承其中的class。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922105015431.png"></p><p><strong>网络附属库</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922105049130.png"></p><p><strong>代码结构</strong></p><p>muduo的头文件明确分为客户可见和客户不可见两类。以下是安装之后暴露的头文件和库文件。对于使用muduo库而言，只需要掌握5个关键类：Buffer、EventLoop、TcpConnection、TcpClient、TcpServer。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922105401035.png"></p><p>muduo的网络核心库的头文件包含关系，用户可见的为白底，用户不可见的为灰底</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922105429605.png"></p><p><strong>公开接口</strong></p><ul><li>Buffer仿Netty ChannelBuffer的buffer class，数据的读写通过buffer进行。用户代码不需要调用read(2)&#x2F;write(2)，只需要处理收到的数据和准备好要发送的数据（§7.4）。</li><li>InetAddress封装IPv4地址（end point），注意，它不能解析域名，只认IP地址。因为直接用gethostbyname(3)解析域名会阻塞IO线程。</li><li>EventLoop事件循环（反应器Reactor），每个线程只能有一个EventLoop实体，它负责IO和定时器事件的分派。它用eventfd(2)来异步唤醒，这有别于传统的用一对pipe(2)的办法。它用TimerQueue作为计时器管理，用Poller作为IO multiplexing。</li><li>EventLoopThread启动一个线程，在其中运行EventLoop::loop()。</li><li>TcpConnection整个网络库的核心，封装一次TCP连接，注意它不能发起连接。</li><li>TcpClient用于编写网络客户端，能发起连接，并且有重试功能。·TcpServer用于编写网络服务器，接受客户的连接。</li></ul><blockquote><p>在这些类中，TcpConnection的生命期依靠shared_ptr管理（即用户和库共同控制）。Buffer的生命期由TcpConnection控制。其余类的生命期由用户控制。Buffer和InetAddress具有值语义，可以拷贝；其他class都是对象语义，不可以拷贝。</p></blockquote><p><strong>内部实现</strong></p><ul><li>Channel是selectable IO channel，负责注册与响应IO事件，注意它不拥有file descriptor。它是Acceptor、Connector、EventLoop、TimerQueue、TcpConnection的成员，生命期由后者控制。</li><li>Socket是一个RAIIhandle，封装一个filedescriptor，并在析构时关闭fd。它是Acceptor、TcpConnection的成员，生命期由后者控制。EventLoop、TimerQueue也拥有fd，但是不封装为Socket class。</li><li>SocketsOps封装各种Sockets系统调用。</li><li>Poller是PollPoller和EPollPoller的基类，采用“电平触发”的语意。它是EventLoop的成员，生命期由后者控制。</li><li>PollPoller和EPollPoller封装poll(2)和epoll(4)两种IO multiplexing后端。poll的存在价值是便于调试，因为poll(2)调用是上下文无关的，用strace(1)很容易知道库的行为是否正确。</li><li>Connector用于发起TCP连接，它是TcpClient的成员，生命期由后者控制。</li><li>Acceptor用于接受TCP连接，它是TcpServer的成员，生命期由后者控制。</li><li>TimerQueue用timerfd实现定时，这有别于传统的设置poll&#x2F;epoll_wait的等待时长的办法。TimerQueue用std::map来管理Timer，常用操作的复杂度是O(logN)，N为定时器数目。它是EventLoop的成员，生命期由后者控制。</li><li>EventLoopThreadPool用于创建IO线程池，用于把TcpConnection分派到某个EventLoop线程上。它是TcpServer的成员，生命期由后者控制。</li></ul><p><strong>muduo的简化类图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922111701453.png"></p><p><strong>线程模型</strong></p><ul><li><p>muduo的线程模型符合主张的one loop per thread＋thread pool模型。每个线程最多有一个EventLoop，每个TcpConnection必须归某个EventLoop管理，所有的IO会转移到这个线程。</p></li><li><p>TcpConnection和EventLoop是线程安全的，可以跨线程调用</p></li><li><p>TcpServer直接支持多线程，它有两种模式：</p><ul><li>单线程，accept(2)与TcpConnection用同一个线程做IO。</li><li>多线程，accept(2)与EventLoop在同一个线程，另外创建一个EventLoopThreadPool，新到的连接会按round-robin方式分配到线程池中。</li></ul></li></ul><h2 id="6-4-使用教程"><a href="#6-4-使用教程" class="headerlink" title="6.4 使用教程"></a>6.4 使用教程</h2><h3 id="6-4-1-TCP网络编程本质论"><a href="#6-4-1-TCP网络编程本质论" class="headerlink" title="6.4.1 TCP网络编程本质论"></a>6.4.1 TCP网络编程本质论</h3><p><strong>基于事件的非阻塞网络编程思路</strong>：注册一个收数据的回调，网络库收到数据会调用我，直接把数据提供给我，供我消费。注册一个接受连接的回调，网络库接受了新连接会回调我，直接把新的连接对象传给我，供我使用。需要发送数据的时候，只管往连接中写，网络库会负责无阻塞地发送</p><p><strong>TCP网络编程最本质的是处理三个半事件</strong>：</p><ul><li>1．连接的建立，包括服务端接受（accept）新连接和客户端成功发起（connect）连接。TCP连接一旦建立，客户端和服务端是平等的，可以各自收发数据。</li><li>2．连接的断开，包括主动断开（close、shutdown）和被动断开（read(2)返回0）。</li><li>3．消息到达，文件描述符可读。这是最为重要的一个事件，对它的处理方式决定了网络编程的风格（阻塞还是非阻塞，如何处理分包，应用层的缓冲如何设计，等等）。</li><li>3.5　消息发送完毕，这算半个。对于低流量的服务，可以不必关心这个事件；另外，这里的“发送完毕”是指将数据写入操作系统的缓冲区，将由TCP协议栈负责数据的发送与重传，不代表对方已经收到数据。</li></ul><p>假设应用程序需要发送40kB数据，但是操作系统的TCP发送缓冲区只有25kB剩余空间，那么剩下的15kB数据怎么办？</p><blockquote><p>如果等待OS缓冲区可用，会阻塞当前线程，因为不知道对方什么时候收到并读取数据。</p><p>因此网络库应该把这15kB数据缓存起来，放到这个TCP链接的应用层发送缓冲区中，等socket变得可写的时候立刻发送数据，这样“发送”操作不会阻塞。</p><p>如果应用程序随后又要发送50kB数据，而此时发送缓冲区中尚有未发送的数据（若干kB），那么网络库应该将这50kB数据追加到发送缓冲区的末尾，而不能立刻尝试write()，因为这样有可能打乱数据的顺序。</p></blockquote><p>在非阻塞网络编程中，为什么要使用应用层接收缓冲区？</p><blockquote><p>假如一次读到的数据不够一个完整的数据包，那么这些已经读到的数据应该先暂存在某个地方，等剩余的数据收到之后再一并处理</p></blockquote><p><strong>常见几种方案对比</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220924161855858.png"></p><h1 id="第7章-muduo编程示例"><a href="#第7章-muduo编程示例" class="headerlink" title="第7章 muduo编程示例"></a>第7章 muduo编程示例</h1><h2 id="7-3-Boost-Asio的聊天服务器"><a href="#7-3-Boost-Asio的聊天服务器" class="headerlink" title="7.3 Boost.Asio的聊天服务器"></a>7.3 Boost.Asio的聊天服务器</h2><h3 id="7-3-1-TCP分包"><a href="#7-3-1-TCP分包" class="headerlink" title="7.3.1 TCP分包"></a>7.3.1 TCP分包</h3><blockquote><p>分包指的是在发生一个消息（message）或一帧（frame）数据时，通过一定的处理，让接收方能从字节流中识别并截取（还原）出一个个消息</p></blockquote><p>对于短连接的TCP服务，分包不是一个问题，只要发送方主动关闭连接，就表示一条消息发送完毕，接收方read()返回0，从而知道消息的结尾。</p><p>对于长连接的TCP服务，分包有四种方法：</p><ul><li>1．消息长度固定，比如muduo的roundtrip示例就采用了固定的16字节消息。</li><li>2．使用特殊的字符或字符串作为消息的边界，例如HTTP协议的headers以“\r\n”为字段的分隔符。</li><li>3．在每条消息的头部加一个长度字段，这恐怕是最常见的做法，本文的聊天协议也采用这一办法。</li><li>4．利用消息本身的格式来分包，例如XML格式的消息中<root>…</root>的配对，或者JSON格式中的{ … }的配对。解析这种消息格式通常会用到状态机（state machine）。</li></ul><p><strong>聊天服务</strong></p><p>由服务端程序和客户端程序组成，协议如下：</p><ul><li>服务端程序在某个端口侦听（listen）新的连接。·客户端向服务端发起连接。</li><li>连接建立之后，客户端随时准备接收服务端的消息并在屏幕上显示出来。</li><li>客户端接受键盘输入，以回车为界，把消息发送给服务端。</li><li>服务端接收到消息之后，依次发送给每个连接到它的客户端；原来发送消息的客户端进程也会收到这条消息。</li><li>一个服务端进程可以同时服务多个客户端进程。当有消息到达服务端后，每个客户端进程都会收到同一条消息，服务端广播发送消息的顺序是任意的，不一定哪个客户端会先收到这条消息。</li><li>（可选）如果消息A先于消息B到达服务端，那么每个客户端都会先收到A再收到B。</li></ul><p><strong>需要解决的问题</strong></p><p>聊天服务的特点是“连接之间的数据有交流，从a连接收到的数据要发给b连接。这样对连接管理提出了更高的要求：</p><ul><li>如何用一个程序同时处理多个连接？fork()-per-connection似乎是不行的。</li><li>如何防止串话？b有可能随时断开连接，而新建立的连接c可能恰好复用了b的文件描述符，那么a会不会错误地把消息发给c？”</li></ul><h2 id="7-4-muduo-Buffer类的设计与使用"><a href="#7-4-muduo-Buffer类的设计与使用" class="headerlink" title="7.4 muduo Buffer类的设计与使用"></a>7.4 muduo Buffer类的设计与使用</h2><h3 id="7-4-2-为什么non-blocking网络编程中应用层buffer是必需的"><a href="#7-4-2-为什么non-blocking网络编程中应用层buffer是必需的" class="headerlink" title="7.4.2　为什么non-blocking网络编程中应用层buffer是必需的"></a>7.4.2　为什么non-blocking网络编程中应用层buffer是必需的</h3><blockquote><p>non-blocking IO的核心思想是避免阻塞在read()或write()或其他IO系统调用上，这样可以最大限度地复用thread-of-control，让一个线程能服务于多个socket连接。IO线程只能阻塞在IO multiplexing函数上，如select&#x2F;poll&#x2F;epoll_wait。这样一来，应用层的缓冲是必需的，每个TCP socket都要有stateful的input buffer和output buffer。</p></blockquote><p><strong>TcpConnection必须要有output buffer</strong></p><blockquote><p>程序想通过TCP连接发送100kB的数据，但是在write()调用中，操作系统只接受了80kB，你肯定不想在原地等待，因为不知道会等多久（取决于对方什么时候接收数据，然后滑动TCP窗口）。程序应该尽快交出控制权，返回event loop。在这种情况下，剩余的20kB数据只能暂时存在buffer中。</p></blockquote><p><strong>TcpConnection必须要有input buffer</strong></p><blockquote><p>TCP是一个无边界的字节流协议，接收方必须要处理“收到的数据尚不构成一条完整的消息”和“一次收到两条消息的数据”等情况。一个常见的场景是，发送方send()了两条1kB的消息（共2kB），接收方收到数据的情况可能是一次收到或分多次收到。</p><p>网络库在处理“socket可读”事件的时候，必须一次性把socket里的数据读完（从操作系统buffer搬到应用层buffer），否则会反复触发POLLIN事件，造成busy-loop。那么网络库必然要应对“数据不完整”的情况，收到的数据先放到input buffer里，等构成一条完整的消息再通知程序的业务逻辑。</p></blockquote><h3 id="7-4-3-Buffer的功能需求"><a href="#7-4-3-Buffer的功能需求" class="headerlink" title="7.4.3　Buffer的功能需求"></a>7.4.3　Buffer的功能需求</h3><p>muduo Buffer的设计要点：</p><ul><li>对外表现为一块连续的内存(char* p, int len)，以方便客户代码的编写。</li><li>其size()可以自动增长，以适应不同大小的消息。它不是一个fixed size array（例如char buf[8192]）。</li><li>内部以std::vector<char>来保存数据，并提供相应的访问函数。</li></ul><p>muduo::net::Buffer的类图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014111142399.png"></p><p><strong>Buffer::readFd()</strong> </p><p>如果有10000个并发连接，每个连接一建立就分配各50kB的读写缓冲区的话，将占用1GB内存，而大多数时候这些缓冲区的使用率很低。muduo用readv(2)结合栈上空间巧妙地解决了这个问题。</p><blockquote><p>具体做法是，在栈上准备一个65536字节的extrabuf，然后利用readv()来读取数据，iovec有两块，第一块指向muduo Buffer中的writable字节，另一块指向栈上的extrabuf。这样如果读入的数据不多，那么全部都读到Buffer中去了；如果长度超过Buffer的writable字节数，就会读到栈上的extrabuf里，然后程序再把extrabuf里的数据append()到Buffer中</p><p>这么做利用了临时栈上空间14，避免每个连接的初始Buffer过大造成的内存浪费，也避免反复调用read()的系统开销（由于缓冲区足够大，通常一次readv()系统调用就能读完全部数据）。由于muduo的事件触发采用level trigger，因此这个函数并不会反复调用read()直到其返回EAGAIN，从而可以降低消息处理的延迟。</p><p>我的理解是如果不使用extrabuf而在read时让buffer增长的话，read时可能很耗时，降低了效率。（待验证）</p></blockquote><p><strong>线程安全？</strong></p><p>muduo::net::Buffer不是线程安全的（其安全性跟std::vector相同）</p><p>，这么设计的原因是buffer使用通常是在TcpConnection所在的IO线程中，而TcpConnection是线程安全的。</p><blockquote><p>如果TcpConnection::send()调用发生在该TcpConnection所属的那个IO线程，那么它会转而调用TcpConnection::sendInLoop()，sendInLoop()会在当前线程（也就是IO线程）操作output buffer</p><p>如果TcpConnection::send()调用发生在别的线程，它不会在当前线程调用sendInLoop()，而是通过EventLoop::runInLoop()把sendInLoop()函数调用转移到IO线程</p><ul><li>跨线程的函数转移调用涉及函数参数的跨线程传递，一种简单的做法是把数据拷贝一份，绝对安全。</li><li>另一种更为高效的做法是用swap()。这就是为什么TcpConnection::send()的某个重载以Buffer*为参数，而不是const Buffer&amp;，这样可以避免拷贝，而用Buffer::swap()实现高效的线程间数据转移。（作者还未实现）</li></ul></blockquote><h3 id="7-4-4-Buffer的数据结构"><a href="#7-4-4-Buffer的数据结构" class="headerlink" title="7.4.4　Buffer的数据结构"></a>7.4.4　Buffer的数据结构</h3><p>Buffer的内部是一个std::vector<char>，它是一块连续的内存。此外，Buffer有两个data member，即readIndex和writeIndex，指向该vector中的可读的位置和可写的位置。这两个index的类型是int，不是char*，目的是应对迭代器失效。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112018159.png"></p><p>prependable是预留的空间，初始时</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112127653.png"></p><h3 id="7-4-5-Buffer的操作"><a href="#7-4-5-Buffer的操作" class="headerlink" title="7.4.5　Buffer的操作"></a>7.4.5　Buffer的操作</h3><p>如果向Buffer写入了200字节，那么其布局如图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112218728.png"></p><p>如果从Buffer read() &amp; retrieve()（下称“读入”）了50字节</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112235569.png"></p><p>然后又写入了200字节</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112303651.png"></p><p>接下来，一次性读入350字节，请注意，由于全部数据读完了，readIndex和writeIndex返回原位以备新一轮使用</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112323734.png"></p><p><strong>自动增长</strong></p><p>假设当前的状态如图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112355413.png"></p><p>客户代码一次性写入1000字节，而当前可写的字节数只有624，那么buffer会自动增长以容纳全部数据，得到的结果如图。<strong>由于vector重新分配了内存，原来指向其元素的指针会失效，这就是为什么readIndex和writeIndex是整数下标而不是指针。</strong>（注意：在目前的实现中prependable会保持58字节，留待将来修正。）</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014112415262.png"></p><p>注意buffer不会缩小大小，只要增长了就不会减少其size</p><p><strong>为什么我们不需要调用reserve()来预先分配空间？</strong></p><p>因为Buffer在构造函数里把初始size()设为1KiB，这样当size()超过1KiB的时候vector会把capacity()加倍，等于说resize()替我们做了reserve()的事。</p><blockquote><p>resize会有点性能浪费，因为其初始化时会将容器中的元素进行初始化</p></blockquote><p><strong>内部腾挪</strong></p><p>有时候，经过若干次读写，readIndex移到了比较靠后的位置，留下了巨大的prependable空间，这时候，如果我们想写入300字节，而writable只有200字节，怎么办？</p><blockquote><p>muduo Buffer在这种情况下不会重新分配内存，而是先把已有的数据移到前面去，腾出writable空间。</p><p>这么做的原因是，如果重新分配内存，反正也是要把数据拷贝到新分配的内存区域，代价只会更大。</p></blockquote><p><strong>前方添加（prepend）</strong></p><p>muduo Buffer有个小小的创新，即提供prependable空间，让程序能以很低的代价在数据前面添加几个字节，也就是预留一段空间用于后面存储消息长度。</p><h3 id="7-4-6-其他设计方案"><a href="#7-4-6-其他设计方案" class="headerlink" title="7.4.6　其他设计方案"></a>7.4.6　其他设计方案</h3><p><strong>zero copy</strong></p><p>如果对性能有极高的要求，受不了copy()与resize()，那么可以考虑实现分段连续的zero copy buffer再配合gather scatter IO，数据结构如图。<strong>基本思路都是不要求数据在内存中连续，而是用链表把数据块链接到一起。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221014193804231.png"></p><h2 id="7-5-一种自动反射消息类型的Google-Protobuf网络传输方案"><a href="#7-5-一种自动反射消息类型的Google-Protobuf网络传输方案" class="headerlink" title="7.5　一种自动反射消息类型的Google Protobuf网络传输方案"></a>7.5　一种自动反射消息类型的Google Protobuf网络传输方案</h2><blockquote><p>1.protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于通信协议、数据存储等。</p><p>2.protocol buffers是一种灵活，高效，自动化机制的结构化数据序列化方法，可以类比XML，但是比XML更小、更快、更为简单。</p><p>3.你可以定义数据的结构，然后使用特殊生成的源代码轻松的在各种数据流中使用各种语言进行编写和读取结构数据。你甚至可以更新数据结构，而不破坏旧数据结构编译而成并且已经部署的程序。</p></blockquote><p>本节要解决的问题是：通信双方在编译时就共享proto文件的情况下，接收方在收到Protobuf二进制数据流之后，如何自动创建具体类型的Protobuf Message对象，并用收到的数据填充该Message对象（即反序列化）。</p><blockquote><p>“自动”的意思是：当程序中新增一个Protobuf Message类型时，这部分代码不需要修改，不需要自己去注册消息类型。其实，Google Protobuf本身具有很强的反射（reflection）功能，可以根据type name创建具体类型的Message对象。</p></blockquote><h3 id="7-5-1-网络编程中使用Protobuf的两个先决条件"><a href="#7-5-1-网络编程中使用Protobuf的两个先决条件" class="headerlink" title="7.5.1　网络编程中使用Protobuf的两个先决条件"></a>7.5.1　网络编程中使用Protobuf的两个先决条件</h3><p>在网络编程中使用Protobuf需要解决以下两个问题：</p><ul><li>1．长度，Protobuf打包的数据没有自带长度信息或终结符，需要由应用程序自己在发生和接收的时候做正确的切分。</li><li>2．类型，Protobuf打包的数据没有自带类型信息，需要由发送方把类型信息传给给接收方，接收方创建具体的Protobuf Message对象，再做反序列化。</li></ul><p>第一个问题很好解决，通常的做法是在每个消息前面加个固定长度的lengthheader</p><p>第二个问题其实也很好解决，Protobuf对此有内建的支持</p><h3 id="7-5-2-根据type-name反射自动创建Message对象"><a href="#7-5-2-根据type-name反射自动创建Message对象" class="headerlink" title="7.5.2　根据type name反射自动创建Message对象"></a>7.5.2　根据type name反射自动创建Message对象</h3><p><strong>原理简述</strong></p><blockquote><p>Protobuf Message class采用了Prototype pattern18，Message class定义了New()虚函数，用以返回本对象的一份新实体，类型与本对象的真实类型相同。也就是说，拿到Message*指针，不用知道它的具体类型，就能创建和其类型一样的具体Message type的对象。</p><p>每个具体Message type都有一个default instance，可以通过ConcreteMessage::default_instance()获得，也可以通过MessageFactory::GetPrototype(const Descriptor*)来获得。所以，现在问题转变为：1．如何拿到MessageFactory；2．如何拿到Descriptor*。</p><p>使用DescriptorPool，它可以根据type name查到Descriptor*，只要找到合适的DescriptorPool，再调用DescriptorPool::FindMessageTypeByName(const string&amp; type_name)即可</p></blockquote><p><strong>根据type name自动创建Messagee的关键代码</strong></p><p>创建步骤：</p><ul><li>1．用DescriptorPool::generated_pool()找到一个DescriptorPool对象，它包含了程序编译的时候所链接的全部Protobuf Message types。</li><li>2．根据type name用DescriptorPool::FindMessageTypeByName()查找Descriptor。</li><li>3．再用MessageFactory::generated_factory()找到MessageFactory对象，它能创建程序编译的时候所链接的全部Protobuf Message types。</li><li>4．然后，用MessageFactory::GetPrototype()找到具体Message type的default instance。</li><li>5．最后，用prototype-&gt;New()创建对象。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221015202643723.png"></p><p>注意，createMessage()返回的是动态创建的对象的指针，调用方有责任释放它，不然就会使内存泄漏。在muduo里，用shared_ptr<Message>来自动管理Message对象的生命期。</p><p><strong>线程安全性</strong></p><p>Google的文档说，用到的那几个MessageFactory和DescriptorPool都是线程安全的，Message::New()也是线程安全的。并且它们都是const member function。</p><h3 id="7-5-3-Protobuf传输格式"><a href="#7-5-3-Protobuf传输格式" class="headerlink" title="7.5.3　Protobuf传输格式"></a>7.5.3　Protobuf传输格式</h3><p>设计了一个简单的格式，包含Protobuf data和其对应的长度与类型信息，消息的末尾还有一个check sum</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221015203509467.png"></p><p>用C struct伪代码描述：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221015203533090.png"></p><p><strong>例子</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221015203637476.png"></p><p><strong>设计决策</strong></p><ul><li>signed int。消息中的长度字段只使用了signed 32-bit int，而没有使用unsigned int，这是为了跨语言移植性，因为Java语言没有unsigned类型。另外，Protobuf一般用于打包小于1MB的数据，unsigned int也没用。</li><li>check sum。虽然TCP是可靠传输协议，虽然Ethernet有CRC-32校验，但是网络传输必须要考虑数据损坏的情况，对于关键的网络应用，check sum是必不可少的。对于Protobuf这种紧凑的二进制格式而言，肉眼看不出数据有没有问题，需要用check sum。</li><li>adler32算法。我没有选用常见的CRC-32，而是选用了adler32，因为它的计算量小、速度比较快，强度和CRC-32差不多。另外，zlib和java.unit.zip都直接支持这个算法。</li><li>type name以’\0’结束。这是为了方便troubleshooting，比如通过tcpdump抓下来的包可以用肉眼很容易看出type name，而不用根据nameLen去一个个数字节。同时，为了方便接收方处理，加入了nameLen，节省了strlen()，这是以空间换时间的做法。</li><li>没有版本号。Protobuf Message的一个突出优点是用optional fields来避免协议的版本号（凡是在Protobuf Message里放版本号的人都没有理解Protobuf的设计，甚至可能没有仔细阅读Protobuf的文档），让通信双方的程序能各自升级，便于系统演化。</li></ul><h2 id="7-6-在muduo中实现Protobuf编解码器与消息分发器"><a href="#7-6-在muduo中实现Protobuf编解码器与消息分发器" class="headerlink" title="7.6　在muduo中实现Protobuf编解码器与消息分发器"></a>7.6　在muduo中实现Protobuf编解码器与消息分发器</h2><p><strong>为什么Protobuf的默认序列化格式没有包含消息的长度与类型</strong></p><p>哪些情况下不需要在Protobuf序列化得到的字节流中包含消息的长度和（或）类型？</p><blockquote><ul><li>如果把消息写入文件，一个文件存一个消息，那么序列化结果中不需要包含长度和类型，因为从文件名和文件长度中可以得知消息的类型与长度。</li><li>如果把消息写入文件，一个文件存多个消息，那么序列化结果中不需要包含类型，因为文件名就代表了消息的类型。</li><li>如果把消息存入数据库（或者NoSQL），以VARBINARY字段保存，那么序列化结果中不需要包含长度和类型，因为从字段名和字段长度中可以得知消息的类型与长度。</li><li>如果把消息以UDP方式发送给对方，而且对方一个UDP port只接收一种消息类型，那么序列化结果中不需要包含长度和类型，因为从port和UDP packet长度中可以得知消息的类型与长度。</li><li>如果把消息以TCP短连接方式发给对方，而且对方一个TCP port只接收一种消息类型，那么序列化结果中不需要包含长度和类型，因为从port和TCP字节流长度中可以得知消息的类型与长度。</li><li>如果把消息以TCP长连接方式发给对方，但是对方一个TCP port只接收一种消息类型，那么序列化结果中不需要包含类型，因为port代表了消息的类型。</li><li>如果采用RPC方式通信，那么只需要告诉对方method name，对方自然能推断出Request和Response的消息类型，这些可以由protoc生成的RPC stubs自动搞定。<ul><li><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221015204519514.png"></li><li>那么RPC method SudokuService.Solve对应的请求和响应分别是SudokuRequest和SudokuResponse。在发送RPC请求的时候，不需要包含SudokuRequest的类型，只需要发送method name SudokuService.Solve，对方自然知道应该按照SudokuRequest来解析（parse）请求。</li></ul></li></ul></blockquote><p>对于上述这些情况，如果Protobuf无条件地把长度和类型放到序列化的字节串中，只会浪费网络带宽和存储。</p><p>只有在使用TCP长连接，且在一个连接上传递不止一种消息的情况下（比方同时发Heartbeat和Request&#x2F;Response），才需要前文提到的那种打包方案。这时候需要一个分发器dispatcher，把不同类型的消息分给各个消息处理函数。</p><p><strong>7.6.1　什么是编解码器（codec）</strong></p><blockquote><p>编解码器（codec）是encoder和decoder的缩写</p></blockquote><p>codec的基本功能之一是做TCP分包：确定每条消息的长度，为消息划分界限。</p><p>Protobuf codec与asio中chat的codec十分相似，只不过编解码消息类型从std::string变成了protobuf::Message。</p><ul><li><p>对于只接收处理Query消息的QueryServer来说，用ProtobufCodec非常方便，收到protobuf::Message之后向下转型成Query来用就行，如图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221015205343127.png"></p></li><li><p>如果要接收处理不止一种消息，ProtobufCodec还不能单独完成工作</p></li></ul><h3 id="7-6-2-实现ProtobufCodec"><a href="#7-6-2-实现ProtobufCodec" class="headerlink" title="7.6.2　实现ProtobufCodec"></a>7.6.2　实现ProtobufCodec</h3><p>解码算法有几个要点：</p><ul><li>protobuf::Message是new出来的对象，它的生命期如何管理？muduo采用shared_ptr<Message>来自动管理对象生命期，与整体风格保持一致。</li><li>出错如何处理？比方说长度超出范围、check sum不正确、message type name不能识别、message parse出错等等。ProtobufCodec定义了ErrorCallback，用户代码可以注册这个回调。如果不注册，默认的处理是断开连接，让客户重连重试。codec的单元测试里模拟了各种出错情况。</li><li>如何处理一次收到半条消息、一条消息、一条半消息、两条消息等等情况？这是每个non-blocking网络程序中的codec都要面对的问题。在分包处理中已经解决了这个问题。</li></ul><p>目前ProtobufCodec的实现非常初级，它没有充分利用ZeroCopyInputStream和ZeroCopyOutputStream，而是把收到的数据作为byte array交给Protobuf Message去解析，这给性能优化留下了空间。</p><p>Protobuf Message不要求数据连续（像vector那样），只要求数据分段连续（像deque那样），这给buffer管理带来了性能上的好处（避免重新分配内存，减少内存碎片），当然也使得代码变得更为复杂。</p><h3 id="7-6-3-消息分发器（dispatcher）有什么用"><a href="#7-6-3-消息分发器（dispatcher）有什么用" class="headerlink" title="7.6.3　消息分发器（dispatcher）有什么用"></a>7.6.3　消息分发器（dispatcher）有什么用</h3><p>ProtobufCodec拦截了TcpConnection的数据，把它转换为Message，ProtobufDispatcher拦截了ProtobufCodec的callback，按消息具体类型把它分派给多个callbacks</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017191310880.png"></p><h3 id="7-6-4-ProtobufCodec与ProtobufDispatcher的综合运用"><a href="#7-6-4-ProtobufCodec与ProtobufDispatcher的综合运用" class="headerlink" title="7.6.4　ProtobufCodec与ProtobufDispatcher的综合运用"></a>7.6.4　ProtobufCodec与ProtobufDispatcher的综合运用</h3><p>示例代码中client和server，把ProtobufCodec和ProtobufDispatcher串联起来使用。server响应Query消息，发送回Answer消息，如果收到未知消息类型，则断开连接。client可以选择发送Query或Empty消息，由命令行控制。</p><h3 id="7-6-5-ProtobufDispatcher的两种实现"><a href="#7-6-5-ProtobufDispatcher的两种实现" class="headerlink" title="7.6.5　ProtobufDispatcher的两种实现"></a>7.6.5　ProtobufDispatcher的两种实现</h3><p><strong>要完成消息分发，其实就是对消息做type-switch</strong></p><p>先定义ProtobufMessageCallback回调：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017192112693.png"></p><p>ProtobufDispatcherLite有一个map&lt;Descriptor* ,ProtobufMessageCallback&gt;成员，客户代码可以以Descriptor*为key注册回调（回想：每个具体消息类型都有一个全局的Descriptor对象，其地址是不变的，可以用来当key）。在收到Protobuf Message之后，在map中找到对应的ProtobufMessageCallback，然后调用之。如果找不到，就调用defaultCallback。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017192123255.png"></p><p>但是，这样设计有个缺陷，注册消息处理函数类型就被写死了，消息处理函数参数为Message* 指针，而在消息处理函数中还需要对Message* 指针转换类型，但却不知道转换成何种类型。</p><p>解决办法是：<strong>多态与模板结合</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017201206625.png"></p><p>ProtobufDispatcher的消息注册函数改为模板成员函数，接受注册任意消息类型T的回调，然后它创建一个模板化的派生类CallbackT<T>，这样消息的类型信息就保存在了CallbackT<T>中，做down cast就简单了</p><p>注册回调示例</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017201622002.png"></p><h3 id="7-6-6-ProtobufCodec和ProtobufDispatcher有何意义"><a href="#7-6-6-ProtobufCodec和ProtobufDispatcher有何意义" class="headerlink" title="7.6.6　ProtobufCodec和ProtobufDispatcher有何意义"></a>7.6.6　ProtobufCodec和ProtobufDispatcher有何意义</h3><p>ProtobufCodec和ProtobufDispatcher把每个直接收发Protobuf Message的网络程序都会用到的功能提炼出来做成了公用的utility，这样以后新写Protobuf网络程序就不必为打包分包和消息分发劳神</p><h2 id="7-7-限制服务器的最大并发连接数"><a href="#7-7-限制服务器的最大并发连接数" class="headerlink" title="7.7　限制服务器的最大并发连接数"></a>7.7　限制服务器的最大并发连接数</h2><p>“并发连接数”是指一个服务端程序能同时支持的客户端连接数，连接由客户端主动发起，服务端被动接受（accept(2)）连接。</p><h3 id="7-7-1-为什么要限制并发连接数"><a href="#7-7-1-为什么要限制并发连接数" class="headerlink" title="7.7.1　为什么要限制并发连接数"></a>7.7.1　为什么要限制并发连接数</h3><p>一方面，我们不希望服务程序超载；另一方面，更因为filedescriptor是稀缺资源，如果出现filedescriptor耗尽，很棘手</p><blockquote><p>当使用Reactor模式，epoll_wait返回EMFILE时，意味着本进程的文件描述符已经达到上限，无法为新连接创建socket文件描述符。</p><p>但是，既然没有socket文件描述符来表示这个连接，我们就无法close(2)它。程序继续运行，回到L11再一次调用epoll_wait。这时候epoll_wait会立刻返回，因为新连接还等待处理，listening fd还是可读的。这样程序立刻就陷入了busy loop，CPU占用率接近100％</p></blockquote><p><strong>几种做法：</strong></p><ul><li>1．调高进程的文件描述符数目。治标不治本，因为只要有足够多的客户端，就一定能把一个服务进程的文件描述符用完。</li><li>2．死等。鸵鸟算法。</li><li>3．退出程序。似乎小题大做，为了这种暂时的错误而中断现有的服务似乎不值得。</li><li>4．关闭listening fd。那么什么时候重新打开呢？</li><li>5．改用edge trigger。如果漏掉了一次accept(2)，程序再也不会收到新连接。</li><li>6．准备一个空闲的文件描述符。遇到这种情况，先关闭这个空闲文件，获得一个文件描述符的名额；再accept(2)拿到新socket连接的描述符；随后立刻close(2)它，这样就优雅地断开了客户端连接；最后重新打开一个空闲文件，把“坑”占住，以备再次出现这种情况时使用。</li></ul><p>muduo的Acceptor正是用第6种方案实现的，但这个做法在多线程下不能保证正确，会有race condition</p><p>有另外一种比较简单的办法：file descriptor是hard limit，我们可以自己设一个稍低一点的soft limit，如果超过soft limit就主动关闭新连接，这样就可避免触及“file descriptor耗尽”这种边界条件</p><h3 id="7-7-2-在muduo中限制并发连接数"><a href="#7-7-2-在muduo中限制并发连接数" class="headerlink" title="7.7.2　在muduo中限制并发连接数"></a>7.7.2　在muduo中限制并发连接数</h3><p>在muduo中限制并发连接数的做法简单得出奇。只需要为它增加一个int成员，表示当前的活动连接数。</p><p>然后，在EchoServer::onConnection()中判断当前活动连接数。如果超过最大允许数，则踢掉连接。（muduo库中已经使用第6种方案解决了死等状态，因此能收到连接）</p><h2 id="7-8-定时器"><a href="#7-8-定时器" class="headerlink" title="7.8　定时器"></a>7.8　定时器</h2><h3 id="7-8-1-程序中的时间"><a href="#7-8-1-程序中的时间" class="headerlink" title="7.8.1　程序中的时间"></a>7.8.1　程序中的时间</h3><blockquote><p>在一般的服务端程序设计中，与时间有关的常见任务有：</p><ul><li>1．获取当前时间，计算时间间隔。</li><li>2．时区转换与日期计算；把纽约当地时间转换为上海当地时间；2011-02-05之后第100天是几月几号星期几；等等。</li><li>3．定时操作，比如在预定的时间执行任务，或者在一段延时之后执行任务。</li></ul></blockquote><p>其中第2项看起来比较复杂，但其实最简单。日期计算用Julian Day Number30，时区转换用tz database31；唯一麻烦一点的是夏令时，但也可以用tz database解决。需要特别注意的是，用tzset&#x2F;localtime_r来做时区转换在多线程环境下可能会有问题；对此解决办法是写一个TimeZone class，以避免影响全局。</p><p>真正麻烦的是第1项和第3项。一方面，Linux有一大把令人眼花缭乱的与时间相关的函数和结构体，在程序中该如何选用？另一方面，计算机中的时钟不是理想的计时器，它可能会漂移或跳变。最后，民用的UTC时间与闰秒的关系也让定时任务变得复杂和微妙。当然，与系统当前时间有关的操作也让单元测试变得困难。</p><h2 id="7-8-2-Linux时间函数"><a href="#7-8-2-Linux时间函数" class="headerlink" title="7.8.2　Linux时间函数"></a>7.8.2　Linux时间函数</h2><ul><li>（计时）只使用gettimeofday(2)来获取当前时间。</li><li>（定时）只使用timerfd_*系列函数来处理定时任务。</li></ul><blockquote><p>gettimeofday(2)入选原因（这也是muduo::Timestamp class的主要设计考虑）：</p><ul><li>1．time(2)的精度太低，ftime(3)已被废弃；clock_gettime(2)精度最高，但是其系统调用的开销比gettimeofday(2)大。</li><li>2．在x86-64平台上，gettimeofday(2)不是系统调用，而是在用户态实现的，没有上下文切换和陷入内核的开销32。</li><li>3．gettimeofday(2)的分辨率（resolution）是1微秒，现在的实现确实能达到这个计时精度，足以满足日常计时的需要。muduo::Timestamp用一个int64_t来表示从Unix Epoch到现在的微秒数，其范围可达上下30万年。</li></ul><p>timerfd_*入选的原因：</p><ul><li>1．sleep(3) &#x2F; alarm(2) &#x2F; usleep(3)在实现时有可能用了SIGALRM信号，在多线程程序中处理信号是个相当麻烦的事情，应当尽量避免，</li><li>2．nanosleep(2)和clock_nanosleep(2)是线程安全的，但是在非阻塞网络编程中，绝对不能用让线程挂起的方式来等待一段时间，这样一来程序会失去响应。正确的做法是注册一个时间回调函数。</li><li>3．getitimer(2)和timer_create(2)也是用信号来deliver超时，在多线程程序中也会有麻烦。timer_create(2)可以指定信号的接收方是进程还是线程，算是一个进步，不过信号处理函数（signal handler）能做的事情实在很受限。</li><li>4．timerfd_create(2)把时间变成了一个文件描述符，该“文件”在定时器超时的那一刻变得可读，这样就能很方便地融入select(2)&#x2F;poll(2)框架中，用统一的方式来处理IO事件和超时事件，这也正是Reactor模式的长处。</li><li>5．传统的Reactor利用select(2)&#x2F;poll(2)&#x2F;epoll(4)的timeout来实现定时功能，但poll(2)和epoll_wait(2)的定时精度只有毫秒，远低于timerfd_ settime(2)的定时精度。</li></ul></blockquote><h3 id="7-8-3-muduo的定时器接口"><a href="#7-8-3-muduo的定时器接口" class="headerlink" title="7.8.3　muduo的定时器接口"></a>7.8.3　muduo的定时器接口</h3><p>muduo EventLoop有三个定时器函数：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017205027209.png"></p><h3 id="7-8-4-Boost-Asio-Timer示例"><a href="#7-8-4-Boost-Asio-Timer示例" class="headerlink" title="7.8.4　Boost.Asio Timer示例"></a>7.8.4　Boost.Asio Timer示例</h3><blockquote><p>1．阻塞式的定时，muduo不支持这种用法，无代码。</p><p>2．非阻塞定时。</p><p>3．在TimerCallback里传递参数</p><p>4．以成员函数为TimerCallback</p><p>5．在多线程中回调，用mutex保护共享变量</p><p>6．在多线程中回调，缩小临界区，把不需要互斥执行的代码移出来</p><p>代码都在examples&#x2F;asio&#x2F;tutorial&#x2F;</p></blockquote><p><strong>在非阻塞服务端编程中，绝对不能用sleep()或类似的办法来让程序原地停留等待，这会让程序失去响应，因为主事件循环被挂起了，无法处理IO事件。</strong></p><h3 id="7-8-5-Java-Netty示例"><a href="#7-8-5-Java-Netty示例" class="headerlink" title="7.8.5　Java Netty示例"></a>7.8.5　Java Netty示例</h3><p>Netty版的echo和discard服务端有流量统计功能，这需要用到固定间隔的定时器（EventLoop::runEvery）。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017212754487.png"></p><p>构造函数注册了一个间隔为3秒的定时器，调用DiscardServer::printThroughput()打印出吞吐量</p><p>消息回调统计收到的数据长度和消息次数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221017212848962.png"></p><h2 id="7-9-测量两台机器的网络延迟和时间差"><a href="#7-9-测量两台机器的网络延迟和时间差" class="headerlink" title="7.9　测量两台机器的网络延迟和时间差"></a>7.9　测量两台机器的网络延迟和时间差</h2><p>测量round trip time的办法：</p><ul><li>host A发一条消息给host B，其中包含host A发送消息的本地时间。</li><li>host B收到之后立刻把消息echo回host A。</li><li>host A收到消息之后，用当前时间减去消息中的时间就得到了round trip time。</li></ul><p>协议如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018110740747.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018110816658.png"></p><p>消息格式如下，T1 和T2 都是muduo::Timestamp，成员是一个int64_t，表示从Unix Epoch到现在的微秒数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018111304630.png"></p><p>实例如图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018111534885.png"></p><h2 id="7-10-用timing-wheel踢掉空闲连接"><a href="#7-10-用timing-wheel踢掉空闲连接" class="headerlink" title="7.10　用timing wheel踢掉空闲连接"></a>7.10　用timing wheel踢掉空闲连接</h2><blockquote><p>一个连接如果若干秒没有收到数据，就被认为是空闲连接。</p><p>在严肃的网络程序中，应用层的心跳协议是必不可少的。应该用心跳消息来判断对方进程是否能正常工作，“踢掉空闲连接”只是一时的权宜之计。</p></blockquote><p>如果一个连接连续几秒内没有收到数据，就把它断开，为此有两种简单、粗暴的做法：</p><ul><li>每个连接保存“最后收到数据的时间lastReceiveTime”，然后用一个定时器，每秒遍历一遍所有连接，断开那些(now - connection.lastReceiveTime)＞8s的connection。这种做法全局只有一个repeated timer，不过每次timeout都要检查全部连接，如果连接数目比较大（几千上万），这一步可能会比较费时。</li><li>每个连接设置一个one-shot timer，超时定为8s，在超时的时候就断开本连接。当然，每次收到数据要去更新timer。这种做法需要很多个one-shot timer，会频繁地更新timers。如果连接数目比较大，可能对EventLoop的TimerQueue造成压力。</li></ul><h3 id="7-10-1-timing-wheel原理"><a href="#7-10-1-timing-wheel原理" class="headerlink" title="7.10.1　timing wheel原理"></a>7.10.1　timing wheel原理</h3><p>使用timing wheel能避免上述两种做法的缺点。</p><p>处理连接超时可用一个简单的数据结构：8个桶组成的循环队列。</p><p>第1个桶放1秒之后将要超时的连接，第2个桶放2秒之后将要超时的连接。每个连接一收到数据就把自己放到第8个桶，然后在每秒的timer里把第一个桶里的连接断开，把这个空桶挪到队尾。这样大致可以做到8秒没有数据就超时断开连接。更重要的是，每次不用检查全部的连接，只要检查第一个桶里的连接，相当于把任务分散了。</p><h3 id="7-10-2-代码实现与改进"><a href="#7-10-2-代码实现与改进" class="headerlink" title="7.10.2　代码实现与改进"></a>7.10.2　代码实现与改进</h3><p>在具体实现中，格子里放的不是连接，而是一个特制的Entry struct，每个Entry包含TcpConnection的weak_ptr。Entry的析构函数会判断连接是否还存在（用weak_ptr），如果还存在则断开连接。</p><p><strong>数据结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018161739059.png"></p><p>在实现中，为了简单起见，采用引用计数的办法，用shared_ptr来管理Entry。</p><ul><li>如果从连接收到数据，就把对应的EntryPtr放到这个格子里，这样它的引用计数就递增了（只有每个格子中都没有对应的entryptr，才会被自动销毁）。</li><li>当Entry的引用计数递减到零时，说明它没有在任何一个格子里出现，那么连接超时，Entry的析构函数会断开连接。</li></ul><blockquote><p>直到Boost 1.47.0之前，unordered_set&lt;shared_ptr<T> &gt;虽然可以编译通过，但是其hash_value是shared_ptr隐式转换为bool的结果。也就是说，如果不自定义hash函数，那么unordered_{set&#x2F;map}会退化为链表。</p></blockquote><p><strong>改进</strong></p><ul><li>每次收到消息都会往队尾添加EntryPtr（hash set会帮我们去重（deduplication））。一个简单的改进措施是，在TcpConnection里保存“最后一次往队尾添加引用时的tail位置”，收到消息时先检查tail是否变化，若无变化则不重复添加EntryPtr，若有变化则把EntryPtr从旧的Bucket移到当前队尾Bucket。</li><li>另外一个思路是“选择排序”：使用链表将TcpConnection串起来，TcpConnection每次收到消息就把自己移到链表末尾，这样链表是按接收时间先后排序的。再用一个定时器定期从链表前端查找并踢掉超时的连接。代码示例位于同一目录。</li></ul><h2 id="7-11-简单的消息广播服务"><a href="#7-11-简单的消息广播服务" class="headerlink" title="7.11　简单的消息广播服务"></a>7.11　简单的消息广播服务</h2><p>muduo示例中的Hub分为几个部分：</p><ul><li>Hub服务程序，负责一对多的消息分发。它会记住每个client订阅了哪些topic，只把消息发给特定的订阅者。</li><li>pubsub库，为了方便编写使用Hub服务的应用程序，我写了一个简单的client library，用来和Hub打交道。这个library可以订阅topic、退订topic、往指定的topic发布消息。</li><li>sub示例程序，这个命令行程序订阅一个或多个topic，然后等待Hub的数据。</li><li>pub示例程序，这个命令行程序往某个topic发布一条消息，消息内容由命令行参数指定</li></ul><p><strong>多线程的高效广播</strong></p><p>假如有一条消息要广播给1000个订阅者，那么只能一个一个地发，第1个订阅者收到消息和第1000个订阅者收到消息的时差可以长达若干毫秒。那么，有没有办法提高速度、降低延迟呢？</p><blockquote><p>但是简单的办法并不一定能奏效，因为一个全局锁就把多线程程序退化为单线程执行（为啥需要加全局锁，是发送消息时必须加锁？？）。为了真正提速，我想到了用thread local（设置的订阅者变量？？）的办法，比如把1000个订阅者分给4个线程，每个线程的操作基本都是无锁的，这样可以做到并行地发送消息。</p></blockquote><h2 id="7-12-“串并转换”连接服务器及其自动化测试"><a href="#7-12-“串并转换”连接服务器及其自动化测试" class="headerlink" title="7.12　“串并转换”连接服务器及其自动化测试"></a>7.12　“串并转换”连接服务器及其自动化测试</h2><p><strong>功能需求</strong></p><p>连接服务器把多个客户连接汇聚为一个内部TCP连接，起到“数据串并转换”的作用，让backend的逻辑服务器专心处理业务，而无须顾及多连接的并发性。系统的框图如图</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018195046299.png"></p><p><strong>实现</strong></p><p>对每个新client connection分配一个新的整数id，如果id用完了，则断开新连接（这样通过控制id的数目就能控制最大连接数）。另外，<strong>为了避免id过快地被复用（有可能造成backend串话），multiplexer采用queue来管理free id，每次从队列的头部取id，用完之后放回queue的尾部</strong></p><p>主要是处理四种事件：</p><ul><li>当client connection到达或断开时，向backend发出通知。</li><li>当从client connection收到数据时，把数据连同connection id一同发给backend。</li><li>当从backend connection收到数据时，辨别数据是发给哪个client connection，并执行相应的转发操作。</li><li>如果backend connection断开连接，则断开所有client connections（假设client会自动重试）</li></ul><p><strong>TcpConnection的id如何存放？</strong></p><p>当从backend收到数据，如何根据id找到对应的client connection？当从client connection收到数据，如何得知其id？</p><blockquote><p>第一个问题比较好解决，用std::map&lt;int, TcpConnectionPtr&gt; clientConns_保存从id到client connection的映射就行。</p><p>第二个问题固然可以用类似的办法解决，借此介绍一下muduo::net:: TcpConnection的context功能。每个TcpConnection都有一个boost::any成员，可由客户代码自由支配（get&#x2F;set）。这个boost::any是TcpConnection的context，可以用于保存与connection绑定的任意数据（比方说connectionid、connection的最后数据到达时间、connection所代表的用户的名字等等）。这样客户代码不必继承TcpConnection就能attach自己的状态，而且也用不着TcpConnectionFactory了（如果允许继承，那么必然要向TcpServer注入此factory）。</p></blockquote><h2 id="7-13-socks4a代理服务器"><a href="#7-13-socks4a代理服务器" class="headerlink" title="7.13　socks4a代理服务器"></a>7.13　socks4a代理服务器</h2><h3 id="7-13-1-TCP中继器"><a href="#7-13-1-TCP中继器" class="headerlink" title="7.13.1　TCP中继器"></a>7.13.1　TCP中继器</h3><blockquote><p>有时候，我们想在client和server之间放一个中继器（relay），把client与server之间的通信内容记录下来。这时用tcpdump是最方便省事的，但是tcpdump需要root权限，万一拿不到权限呢？穷人有穷人的办法，自己写一个TcpRelay，让client连接TcpRelay，再让TcpRelay连接server</p></blockquote><p>TcpRelay需要考虑以下问题：</p><ul><li>1．建立连接。为了真实模拟client，TcpRelay在accept连接C之后才向server发起连接S，那么在S建立起来之前，从C收到数据怎么办？要不要暂存起来？</li><li>2．并发连接的管理。图7-54中只画出了一个client，实际上TcpRelay可以服务多个client，左右两边这些并发连接如何管理，如何防止串话（cross talk）？</li><li>3．连接断开。client和server都可能主动断开连接。当client主动断开连接C时，TcpRelay应该立刻断开S。当server主动断开连接S时，TcpRelay应立刻断开C。这样才能比较精确地模拟client和server的行为。在关闭连接的一刹那，又有新的client连接进来，复用了刚刚close的fd号码，会不会造成串话？万一client和server几乎同时主动断开连接，TcpRelay如何应对？</li><li>4．速度不匹配。如果连接C的带宽是100kB&#x2F;s，而连接S的带宽是10MB&#x2F;s，不巧server是个chargen服务，会全速发送数据，那么会不会撑爆TcpRelay的buffer？如何限速？特别是在使用non-blocking IO和level-trigger polling的时候如何限制读取数据的速度？</li></ul><p>前三个问题的解决见示例代码，第四个问题的解法比较粗暴，用的是HighWaterMarkCallback，如果发送缓冲区堆积的数据大于10MiB就断开连接（更好的办法见§8.9.3）</p><h3 id="7-13-2-socks4a代理服务器"><a href="#7-13-2-socks4a代理服务器" class="headerlink" title="7.13.2　socks4a代理服务器"></a>7.13.2　socks4a代理服务器</h3><p>socks4a的功能与TcpRelay非常相似，它与TcpRelay的区别在于，TcpRelay固定连到某个server地址，而socks4a允许client指定要连哪个server。在accept连接C之后，socks4a server会读几个字节，以了解server的地址，再发起连接S。</p><h3 id="7-13-3-N∶1与1∶N连接转发"><a href="#7-13-3-N∶1与1∶N连接转发" class="headerlink" title="7.13.3　N∶1与1∶N连接转发"></a>7.13.3　N∶1与1∶N连接转发</h3><p>云风在《写了一个proxy用途你懂的》41中写了一个TCP隧道tunnel，程序由三部分组成：N∶1连接转发服务，1∶N连接转发服务，socks代理服务。</p><h2 id="7-14-短址服务"><a href="#7-14-短址服务" class="headerlink" title="7.14　短址服务"></a>7.14　短址服务</h2><p>muduo内置了一个简陋的HTTP服务器，可以处理简单的HTTP请求。这个HTTP服务器是面向内网的暴露进程状态的监控端口，不是面向公网的功能完善且健壮的httpd</p><p>使用方法</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221018202416051.png"></p><h2 id="7-15-与其他库集成"><a href="#7-15-与其他库集成" class="headerlink" title="7.15　与其他库集成"></a>7.15　与其他库集成</h2><blockquote><p>Channel class是IO事件回调的分发器（dispatcher），它在handleEvent()中根据事件的具体类型分别回调ReadCallback、WriteCallback等，代码见§8.1.1。每个Channel对象服务于一个文件描述符，但并不拥有fd，在析构函数中也不会close(fd)。Channel也使用muduo一贯的boost::function来表示函数回调，它不是基类43。这样用户代码不必继承Channel，也无须override虚函数。</p></blockquote><p>通过Channel class可以把其他一些现成的网络库融入muduo的event loop中。</p><h3 id="7-15-1-UDNS"><a href="#7-15-1-UDNS" class="headerlink" title="7.15.1　UDNS"></a>7.15.1　UDNS</h3><p>UDNS44是一个stub45DNS解析器，它能够异步地发起DNS查询，再通过回调函数通知结果。</p><h3 id="7-15-2-c-ares-DNS"><a href="#7-15-2-c-ares-DNS" class="headerlink" title="7.15.2　c-ares DNS"></a>7.15.2　c-ares DNS</h3><p>c-ares DNS48是一款常用的异步DNS解析库</p><h3 id="7-15-3-curl"><a href="#7-15-3-curl" class="headerlink" title="7.15.3　curl"></a>7.15.3　curl</h3><p>libcurl是一个常用的HTTP客户端库53，可以方便地下载HTTP和HTTPS数据。libcurl有两套接口，easy和multi，本节介绍的是使用其multi接口54以达到单线程并发访问多个URL的效果。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>106. 从中序与后序遍历序列构造二叉树</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h1><p>First：没想到可以利用pos1求出的长度来求出pos2所在位置</p><hr><p><strong>方法1</strong>：<strong>递归</strong></p><p>postorder的最后一个数k可以将inorder分为两部分，这两部分分别是k的左右两个子树构成。而这两部分也可以将postorder划成两部分，从而构成新的两组inorder和postorder然后不断递归构造二叉树。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    unordered_map&lt;int,int&gt; inmap,postmap;public:    &#x2F;&#x2F; TreeNode* creatTree(vector&lt;int&gt;&amp; inorder,vector&lt;int&gt;&amp; postorder,int inl,int inr,int postl,int postr)&#123;    &#x2F;&#x2F;     if(inl&gt;inr||postl&gt;postr) return nullptr;    &#x2F;&#x2F;     TreeNode *root&#x3D;new TreeNode(postorder[postr]);    &#x2F;&#x2F;     int pos1&#x3D;inmap[postorder[postr]];&#x2F;&#x2F;pos1是在inorder中的分割    &#x2F;&#x2F;     int pos2&#x3D;-1;&#x2F;&#x2F;pos2是在postorder中的分割    &#x2F;&#x2F;     for(int i&#x3D;inl;i&lt;pos1;++i)&#123;    &#x2F;&#x2F;         pos2&#x3D;max(pos2,postmap[inorder[i]]);    &#x2F;&#x2F;     &#125;    &#x2F;&#x2F;     root-&gt;left&#x3D;creatTree(inorder,postorder,inl,pos1-1,postl,pos2);    &#x2F;&#x2F;     root-&gt;right&#x3D;creatTree(inorder,postorder,pos1+1,inr,pos2+1,postr-1);    &#x2F;&#x2F;     return root;    &#x2F;&#x2F; &#125;    &#x2F;&#x2F;上面方法还专门计算post2来找到在postorder中的切割点，但是中序遍历和后序遍历数组是相同的，可以用post1得到的数组大小来直接推导post2    TreeNode* creatTree(vector&lt;int&gt;&amp; inorder,vector&lt;int&gt;&amp; postorder,int inl,int inr,int postl,int postr)&#123;        if(inl&gt;inr||postl&gt;postr) return nullptr;        TreeNode *root&#x3D;new TreeNode(postorder[postr]);        int pos1&#x3D;inmap[postorder[postr]];&#x2F;&#x2F;pos1是在inorder中的分割        int pos2&#x3D;pos1-1-inl+postl;&#x2F;&#x2F;pos2是在postorder中的分割        root-&gt;left&#x3D;creatTree(inorder,postorder,inl,pos1-1,postl,pos2);        root-&gt;right&#x3D;creatTree(inorder,postorder,pos1+1,inr,pos2+1,postr-1);        return root;    &#125;    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;        for(int i&#x3D;0;i&lt;inorder.size();++i)&#123;            inmap[inorder[i]]&#x3D;i;            postmap[postorder[i]]&#x3D;i;        &#125;        return creatTree(inorder,postorder,0,inorder.size()-1,0,postorder.size()-1);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>116. 填充每个节点的下一个右侧节点指针</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h1><p>First：普通解法挺简单，进阶要求要复杂些。此题和117题解法一模一样，没任何差别。</p><hr><p><strong>方法1</strong>：<strong>层序遍历</strong></p><p>使用层序遍历，每次将前一个节点指向后一个节点即可</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    Node* connect(Node* root) &#123;        &#x2F;&#x2F;层序遍历        queue&lt;Node*&gt; que;        if(root!&#x3D;nullptr) que.push(root);        while(!que.empty())&#123;            int size&#x3D;que.size();            for(int i&#x3D;0;i&lt;size;++i)&#123;                Node *tem&#x3D;que.front();                que.pop();                if(i&lt;size-1)&#123;                    tem-&gt;next&#x3D;que.front();                &#125;else&#123;                    tem-&gt;next&#x3D;nullptr;                &#125;                if(tem-&gt;left) que.push(tem-&gt;left);                if(tem-&gt;right) que.push(tem-&gt;right);            &#125;        &#125;        return root;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>使用指针记录</strong></p><p>此方法无法使用队列，使得为常数空间。</p><p>使用curLen和nextLen分别记录当前层节点数和下一层节点数，使用p记录当前需要处理的节点，nextP记录下一层第一个节点，last记录当前节点的前一个节点。</p><p>p指针如果为空则结束遍历，在每次遍历时，分别判断p的左右节点情况，如果此时nextLen为0，则说明此子节点是下一层的第一个节点，使用nextP记录下此子节点，并将last置为此几点。否则，将last指向当前节点并更新last。每次遍历都需要将curLen减1，如果curLen等于0则说明当前层已经遍历完成，更新上述变量皆可，否则p应该更新为下一个节点。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    Node* connect(Node* root) &#123;        &#x2F;&#x2F;进阶        int curLen&#x3D;1,nextLen&#x3D;0;&#x2F;&#x2F;记录当前层节点数和下一层节点数        Node *p&#x3D;root,*nextP&#x3D;nullptr,*last&#x3D;nullptr;&#x2F;&#x2F;p记录当前需要处理的节点，nextP记录下一层第一个节点，last记录当前节点的前一个节点        while(p)&#123;            --curLen;            if(p-&gt;left)&#123;                if(nextLen&#x3D;&#x3D;0) &#123;&#x2F;&#x2F;如果下一层节点数为0则表示此节点是下一层第一个节点                    nextP&#x3D;p-&gt;left;                    last&#x3D;p-&gt;left;                &#125;                else &#123;&#x2F;&#x2F;设置next                    last-&gt;next&#x3D;p-&gt;left;                    last&#x3D;p-&gt;left;                &#125;                 ++nextLen;            &#125;            if(p-&gt;right)&#123;                if(nextLen&#x3D;&#x3D;0) &#123;                    nextP&#x3D;p-&gt;right;                    last&#x3D;p-&gt;right;                &#125;                else&#123;                    last-&gt;next&#x3D;p-&gt;right;                    last&#x3D;p-&gt;right;                &#125;                ++nextLen;            &#125;            if(curLen&#x3D;&#x3D;0)&#123;                curLen&#x3D;nextLen;                nextLen&#x3D;0;                p&#x3D;nextP;                nextP&#x3D;nullptr;                last&#x3D;nullptr;            &#125;else&#123;                p&#x3D;p-&gt;next;            &#125;        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重写Muduo库笔记</title>
      <link href="/2023/02/15/%E9%A1%B9%E7%9B%AE/%E9%87%8D%E5%86%99muduo%E5%BA%93/"/>
      <url>/2023/02/15/%E9%A1%B9%E7%9B%AE/%E9%87%8D%E5%86%99muduo%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p><em>根据施磊<strong>剖析muduo网络库核心代码</strong>项目所写</em>, <a href="https://fixbug.ke.qq.com/">视频地址</a></p><hr><hr><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><p><strong>知识储备</strong></p><ul><li>1、TCP协议和UDP协议</li><li>2、TCP编程和UDP编程步骤</li><li>3、IO复用接口编程select、poll、epoll编程</li><li>4、Linux的多线程编程pthread、进程和线程模型 C++20标准加入了协程的支持</li></ul><h2 id="1-1-阻塞、非阻塞、同步、异步"><a href="#1-1-阻塞、非阻塞、同步、异步" class="headerlink" title="1.1 阻塞、非阻塞、同步、异步"></a>1.1 <strong>阻塞、非阻塞、同步、异步</strong></h2><blockquote><p>典型的一次IO的两个阶段是什么？ 数据准备 和 数据读写</p></blockquote><p> 在数据准备上，根据系统IO操作的就绪状态可以分为：</p><ul><li>阻塞：调用IO方法的线程会进入阻塞状态。比如epoll_wait（阻塞类sockfd），调用此方法，会使得线程被阻塞</li><li>非阻塞：调用IO方法的线程不会进入阻塞状态，不改变线程的状态，其通过调用方法返回值进行判断。</li></ul><p>在数据读写上，根据应用程序和内核的交互方式可以分为：</p><ul><li>同步：当前线程需要等待数据读写完成才能进行下一步操作。例如，当epoll_wait返回之后使用recv去读数据，此时需要等recv读完数据才能进行下一步操作</li><li>异步：当前线程将数据读写工作交给其他线程（如内核），读写操作完成后再通知当前线程，其无需等待当前线程完成就能进行下一步操作（在IO异步上一般都需要操作系统提供支持，如Linux下使用aio_read）。</li></ul><p><strong>陈硕大神原话：在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步IO。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328153046452.png"></p><p><strong>总结</strong>：无论是同步异步、阻塞非阻塞，其差异都是等待任务完成或不等任务完成而是完成后发出通知提醒（等通知，这通知是系统级别实现，而无需死等。如果应用层面则也可以是回调）。</p><p>上面说的同步异步指的是IO层级，应用级别的同步异步也一样（比如A需要处理任务，A向B传入需要处理的任务和任务结束后的回调函数，B在任务处理完后进行回调）</p><blockquote><p><strong>作者总结</strong>：</p><ul><li><p>一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪”和“数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。</p></li><li><p>同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。</p></li></ul></blockquote><h2 id="1-2-Unix-x2F-Linux上的五种IO模型"><a href="#1-2-Unix-x2F-Linux上的五种IO模型" class="headerlink" title="1.2 Unix&#x2F;Linux上的五种IO模型"></a>1.2 <strong>Unix&#x2F;Linux上的五种IO模型</strong></h2><p><strong>（同步）阻塞blocking</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105628921.png"></p><p><strong>同步非阻塞 non-blocking</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105721152.png"></p><p><strong>IO复用（IO multiplexing）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105734893.png"></p><p><strong>信号驱动（signal-driven）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105744974.png"></p><p>内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。</p><p><strong>异步不阻塞（asynchronous）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024105758521.png"></p><p>aio_read所使用的结构体</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">aiocb</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> aio_fildesoff_t aio_offset<span class="token keyword">volatile</span> <span class="token keyword">void</span> <span class="token operator">*</span>aio_bufsize_t aio_nbytes<span class="token keyword">int</span> aio_reqprio<span class="token keyword">struct</span> <span class="token class-name">sigevent</span> aio_sigevent <span class="token comment">//信号量</span><span class="token keyword">int</span> aio_lio_opcode<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-好的网络服务器设计"><a href="#1-3-好的网络服务器设计" class="headerlink" title="1.3 好的网络服务器设计"></a>1.3 <strong>好的网络服务器设计</strong></h2><blockquote><p>在这个多核时代，服务端网络编程如何选择线程模型呢？ 赞同libev作者的观点：one loop per thread is usually a good model，这样多线程服务端编程的问题就转换为如何设计一个高效且易于使用的event loop，然后每个线程run一个event loop就行了（当然线程间的同步、互斥少不了，还有其它的耗时事件需要起另外的线程来做）。</p></blockquote><p>event loop 是 non-blocking 网络编程的核心，在现实生活中，non-blocking 几乎总是和 IO multiplexing 一起使用，原因有两点：</p><ul><li><p>没有人真的会用轮询 (busy-pooling) 来检查某个 non-blocking IO 操作是否完成，这样太浪费</p><p>CPU资源了。</p></li><li><p>IO-multiplex 一般不能和 blocking IO 用在一起，因为 blocking IO 中read() &#x2F;write() &#x2F;accept() &#x2F;connect() 都有可能阻塞当前线程，这样线程就没办法处理其他 socket上的 IO 事件了。</p></li></ul><p>所以，当我们提到 non-blocking 的时候，实际上指的是 non-blocking + IO-multiplexing，单用其中任何一个都没有办法很好的实现功能。（这里的非阻塞主要指的还是异步，是指在当前线程中除了IO复用时进行阻塞，其他操作都不能阻塞当前线程，其实就是把处理事件交给其他线程</p><blockquote><p>epoll + fork不如epoll + pthread？</p><p>强大的nginx服务器采用了epoll+fork模型作为网络模块的架构设计，实现了简单好用的负载算法，使各个fork网络进程不会忙的越忙、闲的越闲，并且通过引入一把乐观锁解决了该模型导致的<strong>服务器惊群</strong>现象，功能十分强大。</p></blockquote><h2 id="1-4-Reactor模型"><a href="#1-4-Reactor模型" class="headerlink" title="1.4 Reactor模型"></a>1.4 <strong>Reactor模型</strong></h2><blockquote><p>The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.</p></blockquote><p><strong>重要组件</strong>：<strong>Event事件、Reactor反应堆、Demultiplex事件分发器（应该叫事件解码器，将多个事件进行聚合，如epoll）、Evanthandler事件处理器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024113236711.png"></p><p>muduo库的Multiple Reactors模型如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221024113253413.png"></p><p>在这个模型中，其实是将reactor和demultiplex都结合到reactor中，mainReactor将事件进一步细分到subReactor中（例如mainReactor负责新用户的链接，然后将这些链接分发到subReactor中）</p><h2 id="1-5-epoll"><a href="#1-5-epoll" class="headerlink" title="1.5 epoll"></a>1.5 <strong>epoll</strong></h2><p><strong>select的缺点</strong></p><ul><li>1、单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，当然可以更改数量，但由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；(在linux内核头文件中，有这样的定义：#define __FD_SETSIZE 1024</li><li>2、内核 &#x2F; 用户空间内存拷贝问题，select需要复制大量的句柄数据结构，产生巨大的开销</li><li>3、select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件</li><li>4、select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程（也不能算缺点，只是不支持ET）</li></ul><p>相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依</p><p>然存在。</p><blockquote><p>以select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核&#x2F;用户空间大量的句柄结构内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到100万级别的并发访问，是一个很难完成的任务。</p></blockquote><p><strong>epoll原理以及优势</strong></p><blockquote><p><strong>设想一下如下场景</strong>：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p><p>在select&#x2F;poll时代，服务器进程每次都把这100万个连接告诉操作系统（从用户态复制句柄数据结构到内核态），让操作系统内核去查询这些套接字上是否有事件发生，轮询完成后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select&#x2F;poll一般只能处理几千的并发连接。</p></blockquote><p>epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统（文件系统一般用什么数据结构实现？B+树，磁盘IO消耗低，效率很高）。把原先的select&#x2F;poll调用分成以下3个部分：</p><ul><li>调用epoll_create()建立一个epoll对象（在epoll文件系统中为这个句柄对象分配资源）</li><li>调用epoll_ctl向epoll对象中添加这100万个连接的套接字</li><li>调用epoll_wait收集发生的事件的fd资源</li></ul><p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除事件。</p><p>epoll_wait的效率也非常高，因为调用epoll_wait时，并没有向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接（猜测当内核得知某sockfd有消息时，会去epoll中找到对应的sockfd进行标记，而epoll的实现使得查找非常块）。</p><p>epoll_create在内核上创建的eventpoll结构如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> rbr<span class="token punctuation">;</span><span class="token comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span><span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdlist<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>LT模式</strong></p><p>内核数据没被读完，就会一直上报数据。</p><p><strong>ET模式</strong></p><p>内核数据只上报一次。</p><p><strong>muduo采用的是LT</strong></p><ul><li>不会丢失数据或者消息<ul><li>应用没有读取完数据，内核是会不断上报的</li></ul></li><li>低延迟处理<ul><li>每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息</li></ul></li><li>跨平台处理<ul><li>像select一样可以跨平台使用</li></ul></li></ul><h1 id="2-muduo"><a href="#2-muduo" class="headerlink" title="2. muduo"></a>2. muduo</h1><p>muduo主要分为了以下几大类：</p><ul><li><strong>Channel</strong>：封装了每个sockfd设置感兴趣事件和对发生事件的处理，其成员主要包括fd、events、revents、callbacks </li><li><strong>Poller</strong>：封装系统IO复用的通用接口，其主要成员包括ownerLoop、记录注册的channels<ul><li><strong>EPollPoller</strong>：Poller类的派生类，使用epoll实现了Poller类的各种接口，其成员包括epollfd、记录发生事件的events_</li></ul></li><li><strong>EventLoop</strong>：是一个Reactor，其作为Poller类和Channel类的使用者，Poller和Channel的通信都是通过EventLoop来完成，其使用Poller类来获得发生事件的Channel，然后调用Channel的相应回调。<ul><li>主要成员包括poller、wakeupfd（唤醒当前Eventloop）、activeChannels_(记录发生事件的channel)、pendingFuctors_（当前需要执行的回调）。</li></ul></li><li><strong>Thread</strong>：封装了线程创建、线程启动等线程基础操作</li><li><strong>EventLoopThread</strong>：将EventLoop和Thread绑定，封装成一个Thread执行一个loop<ul><li><strong>EventLoopThreadPool</strong>：EventLoopThread的线程池封装，使得mainLoop更方便进行subLoop任务的分发</li></ul></li><li><strong>Socket</strong>：封装socket的常用操作，如设置非阻塞、监听、noDelay等，但并不包含创建sockfd</li><li><strong>Acceptor</strong>：主要封装了listenfd相关的操作，其监听新连接用户，并分发给subLoop</li><li><strong>Buffer</strong>：封装缓冲区常见操作，其内部是一个char类型的vector</li><li><strong>TcpConnection</strong>：封装一个连接信息，其内包含本地地址、对端地址、socket、channel、以及读写buffer</li><li><strong>TcpServer</strong>：上述所有类的综合使用者，用户通过使用此类来设置各种回调，通过此类来管理subLoop个数等</li></ul><p><strong>读</strong>：</p><ul><li>设置读事件回调</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110214049385.png"></p><ul><li>当读事件发生</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110214042301.png"></p><p><strong>写</strong>：</p><ul><li><p>发送数据</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110215931048.png"></p></li><li><p>当写事件发生：和读事件发生流程一样，只是最后一步执行的writeCallback</p></li></ul><p><strong>新用户到来</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110214730307.png"></p><p><strong>服务器启动</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110215755177.png"></p><p>流程图都在飞书的processon上</p><h2 id="2-1-Channel"><a href="#2-1-Channel" class="headerlink" title="2.1 Channel"></a>2.1 Channel</h2><p>封装了每个sockfd设置感兴趣事件函数和对发生事件的处理，注意！Channel不直接与Poller打交道，其通过EventLoop来与Poller进行通信，比如向Poller中设置感兴趣事件，Poller返回事件等。</p><p>通过设置sockfd的各种回调，当有事件发生时，Poller调用每个事件对应channel的<em>HandleEvent</em>函数进行判断处理发生了哪些事件以及调用相应回调</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//这三个是作为事件标识</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kNoneEvent<span class="token punctuation">;</span>   <span class="token comment">// 0</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kReadEvent<span class="token punctuation">;</span>   <span class="token comment">// EPOLLIN | EPOLLPRI</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kWriteEvent<span class="token punctuation">;</span>  <span class="token comment">// EPOLLOUT;</span>EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>  <span class="token comment">//事件循环</span><span class="token keyword">const</span> <span class="token keyword">int</span> fd_<span class="token punctuation">;</span>     <span class="token comment">//监听的sockfd</span><span class="token keyword">int</span> revents_<span class="token punctuation">;</span>      <span class="token comment">//返回的事件</span><span class="token keyword">int</span> events_<span class="token punctuation">;</span>       <span class="token comment">// sockfd上监听的事件</span><span class="token keyword">int</span> index_<span class="token punctuation">;</span>  <span class="token comment">// 此Poller的状态，如新添加、已删除等，主要是用于Poller中判断状态</span><span class="token comment">//绑定TcpConnection对象的弱引用，可用于判断对象是否存活和得到shared指针</span><span class="token comment">//用于观察注册回调的TcpConnection对象是否存活，避免调用回调函数时出错</span>std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> tie_<span class="token punctuation">;</span><span class="token keyword">bool</span> tied_<span class="token punctuation">;</span>  <span class="token comment">//是否绑定标志</span><span class="token comment">//用于处理revents的四种回调函数</span>ReadEventCallback readCallback_<span class="token punctuation">;</span>EventCallback writeCallback_<span class="token punctuation">;</span>EventCallback closeCallback_<span class="token punctuation">;</span>EventCallback errorCallback_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> EventCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token keyword">using</span> ReadEventCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>Timestamp<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token function">Channel</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">Channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fd得到poller通知以后，处理事件的函数</span> <span class="token keyword">void</span> <span class="token function">HandleEvent</span><span class="token punctuation">(</span>Timestamp receiveTime<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置回调函数</span> <span class="token keyword">void</span> <span class="token function">setReadCallback</span><span class="token punctuation">(</span>ReadEventCallback cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   readCallback_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">//这里使用move感觉没啥用，除非function中有申请的资源</span> <span class="token keyword">void</span> <span class="token function">setWriteCallback</span><span class="token punctuation">(</span>EventCallback cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> writeCallback_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">setCloseCallback</span><span class="token punctuation">(</span>EventCallback cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> closeCallback_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">setErrorCallback</span><span class="token punctuation">(</span>EventCallback cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> errorCallback_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//绑定TcpConnection对象，防止当TcpConnection对象被手动remove后，channel还在执行回调操作</span> <span class="token keyword">void</span> <span class="token function">tie</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> fd_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//获取当前设置的Event</span> <span class="token keyword">int</span> <span class="token function">events</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> events_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//供poller设置发生事件</span> <span class="token keyword">int</span> <span class="token function">setRevents</span><span class="token punctuation">(</span><span class="token keyword">int</span> revt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> revents_ <span class="token operator">=</span> revt<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>   <span class="token comment">//设置或取消读 写事件:</span> <span class="token keyword">void</span> <span class="token function">enableReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   events_ <span class="token operator">|=</span> kReadEvent<span class="token punctuation">;</span>   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">disableReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   events_ <span class="token operator">&amp;=</span> <span class="token operator">~</span>kReadEvent<span class="token punctuation">;</span>   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">enableWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   events_ <span class="token operator">|=</span> kWriteEvent<span class="token punctuation">;</span>   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">disableWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   events_ <span class="token operator">&amp;=</span> <span class="token operator">~</span>kWriteEvent<span class="token punctuation">;</span>   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">disableAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   events_ <span class="token operator">=</span> kNoneEvent<span class="token punctuation">;</span>   <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//判断当前事件状态，是否设置读或写事件或无事件</span> <span class="token keyword">bool</span> <span class="token function">isWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> events_ <span class="token operator">&amp;</span> kWriteEvent<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">bool</span> <span class="token function">isReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> events_ <span class="token operator">&amp;</span> kReadEvent<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">bool</span> <span class="token function">isNoneEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> events_ <span class="token operator">==</span> kNoneEvent<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//得到Channel状态</span> <span class="token keyword">int</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> index_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//设置Channel状态</span> <span class="token keyword">void</span> <span class="token function">setIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> index_ <span class="token operator">=</span> index<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//返回此channel所属的eventloop</span> EventLoop <span class="token operator">*</span><span class="token function">ownerLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> loop_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//在所属的eventloop移除此channel</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//更新poller中对应的channel的事件</span> <span class="token comment">//安全的处理事件，作为handleEvent函数的底层函数</span> <span class="token keyword">void</span> <span class="token function">handleEventWithGuard</span><span class="token punctuation">(</span>Timestamp receiveTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-Poller"><a href="#2-2-Poller" class="headerlink" title="2.2 Poller"></a>2.2 Poller</h2><h3 id="2-2-1-Poller基类"><a href="#2-2-1-Poller基类" class="headerlink" title="2.2.1 Poller基类"></a>2.2.1 Poller基类</h3><p>主要封装统一IO复用的接口，以便实现Poll、Epoll等。其成员比较简单，就一个channels记录管理的channel和ownerLoop记录所属的EventLoop</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">protected</span><span class="token operator">:</span> <span class="token comment">// key:sockfd value:sockfd所属的channel通道类型</span> <span class="token keyword">using</span> ChannelMap <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> Channel <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span> ChannelMap channels_<span class="token punctuation">;</span><span class="token comment">//记录管理的Channel</span><span class="token keyword">private</span><span class="token operator">:</span> EventLoop <span class="token operator">*</span>ownerLoop_<span class="token punctuation">;</span><span class="token comment">//记录poller绑定的EventLoop</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> ChannelList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Channel <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token function">Poller</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Poller</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">//统一IO复用接口，扩展类如select、poll和Epoll都必须实现这几个接口</span> <span class="token keyword">virtual</span> Timestamp <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">int</span> timeousMs<span class="token punctuation">,</span> ChannelList <span class="token operator">*</span>activeChannels<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">updateChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">removeChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//判断channel是否存在此poller中</span> <span class="token keyword">bool</span> <span class="token function">hasChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">// eventloop通过该接口获取默认的IO复用的具体实现</span> <span class="token comment">//为避免基类引用派生类头文件，此函数是在一个单独的cc文件中进行实现</span> <span class="token keyword">static</span> Poller <span class="token operator">*</span><span class="token function">newDefaultPoller</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><p>hasChannel函数中通过判断channel指针避免了由于sockfd复用而导致的错乱情况</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token class-name">Poller</span><span class="token double-colon punctuation">::</span><span class="token function">hasChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> it<span class="token operator">=</span>channels_<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>channel<span class="token operator">-></span><span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//it->second==channel应该是为了避免sockfd被复用时而channel不对的情况</span>    <span class="token keyword">return</span> it<span class="token operator">!=</span>channels_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>it<span class="token operator">-></span>second<span class="token operator">==</span>channel<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-2-EPollPoller"><a href="#2-2-2-EPollPoller" class="headerlink" title="2.2.2 EPollPoller"></a>2.2.2 EPollPoller</h3><p>基于Poller接口实现了Epoll，相比Poller，主要增加了epollfd和events成员以及epoll常用函数的封装</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> EventList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>epoll_event<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">int</span> epollfd_<span class="token punctuation">;</span><span class="token comment">//epoll的fd</span>EventList events_<span class="token punctuation">;</span><span class="token comment">//记录epoll返回的发生事件</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kInitEventListSize <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>  <span class="token comment">//给events的初始长度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token function">EPollPoller</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">EPollPoller</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>  <span class="token comment">//重写Poller的抽象方法</span> Timestamp <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">int</span> timeoutMs<span class="token punctuation">,</span> ChannelList <span class="token operator">*</span>activeChannels<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">updateChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">removeChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">//将poll返回的发生事件的channel写入到activeChannels中</span> <span class="token keyword">void</span> <span class="token function">fillActiveChannels</span><span class="token punctuation">(</span><span class="token keyword">int</span> numEvents<span class="token punctuation">,</span> ChannelList <span class="token operator">*</span>activeChannels<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">//更新channel通道设置的事件</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> operation<span class="token punctuation">,</span> Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-EventLoop"><a href="#2-3-EventLoop" class="headerlink" title="2.3 EventLoop"></a>2.3 EventLoop</h2><p>EventLoop相当于提供了一个Reactor，通过Poller来获取发生的事件，再调用相应的channel的回调函数</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> ChannelList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Channel <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>atomic_bool looping_<span class="token punctuation">;</span>  <span class="token comment">//原子操作，通过CAS实现</span>std<span class="token double-colon punctuation">::</span>atomic_bool quit_<span class="token punctuation">;</span>     <span class="token comment">//标志是否退出loop循环</span><span class="token keyword">const</span> pid_t threadId_<span class="token punctuation">;</span>      <span class="token comment">//当前loop所在线程id</span>Timestamp pollReturnTime_<span class="token punctuation">;</span>  <span class="token comment">// poller返回发生事件的时间点</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Poller<span class="token operator">></span> poller_<span class="token punctuation">;</span><span class="token comment">//唤醒当前loop所在线程的fd</span><span class="token keyword">int</span> wakeupFd_<span class="token punctuation">;</span>  <span class="token comment">//当mainLoop获取新用户channel时，通过轮询算法选择一个subloop，通过该成员唤醒subLoop处理channel</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Channel<span class="token operator">></span> wakeupChanel_<span class="token punctuation">;</span>  <span class="token comment">// wakeupfd_的channel的指针</span>ChannelList activeChannels_<span class="token punctuation">;</span>  <span class="token comment">//记录发生事件的所有channel</span>Channel <span class="token operator">*</span>currentActiveChannel_<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>atomic_bool callingPendingFuctors_<span class="token punctuation">;</span>  <span class="token comment">//当前loop是否有需要执行的回调操作</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Functor<span class="token operator">></span> pendingFuctors_<span class="token punctuation">;</span>  <span class="token comment">//存储loop需要执行的所有回调操作</span>std<span class="token double-colon punctuation">::</span>mutex mutex_<span class="token punctuation">;</span>  <span class="token comment">//保护pendingFuctors_的线程安全操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> Functor <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token function">EventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">EventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//开启事件循环</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//退出事件循环</span> <span class="token keyword">void</span> <span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Timestamp <span class="token function">pollReturnTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> pollReturnTime_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//在当前loop中执行</span> <span class="token keyword">void</span> <span class="token function">runInLoop</span><span class="token punctuation">(</span>Functor cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//把cb放入队列中，唤醒loop所在的线程，再执行cb</span> <span class="token keyword">void</span> <span class="token function">queueInLoop</span><span class="token punctuation">(</span>Functor cb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//唤醒loop所在线程</span> <span class="token keyword">void</span> <span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// eventloop使用poller对channel操作的方法</span> <span class="token keyword">void</span> <span class="token function">updateChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">removeChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">bool</span> <span class="token function">hasChannel</span><span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//判断eventloop对象是否在自己线程中</span> <span class="token keyword">bool</span> <span class="token function">isInLoopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> threadId_ <span class="token operator">==</span> <span class="token class-name">CurrentThread</span><span class="token double-colon punctuation">::</span><span class="token function">tid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token function">handleRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// wakeupfd_的读回调函数</span> <span class="token keyword">void</span> <span class="token function">doPendingFunctors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//执行需要执行的回调操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-Thread"><a href="#2-4-Thread" class="headerlink" title="2.4 Thread"></a>2.4 Thread</h2><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> started_<span class="token punctuation">;</span><span class="token comment">//是否已经启动</span><span class="token keyword">bool</span> joined_<span class="token punctuation">;</span><span class="token comment">//是否join</span><span class="token comment">//使用智能指针，避免使用thread初始化是就开始启动线程</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">></span> thread_<span class="token punctuation">;</span>pid_t tid_<span class="token punctuation">;</span><span class="token comment">//记录线程id</span>ThreadFunc func_<span class="token punctuation">;</span><span class="token comment">//线程执行的回调函数</span>std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span><span class="token comment">//线程名</span><span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>atomic_int numCreated_<span class="token punctuation">;</span><span class="token comment">//现有线程创建个数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> ThreadFunc <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token keyword">explicit</span> <span class="token function">Thread</span><span class="token punctuation">(</span>ThreadFunc<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//启动线程</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取线程是否启动</span> <span class="token keyword">bool</span> <span class="token function">started</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> started_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//获取线程id</span> pid_t <span class="token function">tid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> tid_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//获取设置的线程名</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> name_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//获取当前通过Thread创建的线程数量</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numCreated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> numCreated_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token function">setDefaultName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//一个thread对象记录的就是一个新线程的详细信息</span><span class="token keyword">void</span> <span class="token class-name">Thread</span><span class="token double-colon punctuation">::</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  started_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  sem_t sem<span class="token punctuation">;</span>  <span class="token comment">//信号量 muduo书中说多线程别用信号量？？</span>  <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//开启线程，</span>  thread_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//获取线程的tid值</span>    tid_ <span class="token operator">=</span> <span class="token class-name">CurrentThread</span><span class="token double-colon punctuation">::</span><span class="token function">tid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//开启一个新线程，专门执行该线程函数</span>    <span class="token function">func_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//必须等待上面新创建的线程的tid值</span>  <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5-EventLoopThread"><a href="#2-5-EventLoopThread" class="headerlink" title="2.5 EventLoopThread"></a>2.5 EventLoopThread</h2><p>将EventLoop和Thread绑定，封装成一个Thread执行一个loop</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span><span class="token keyword">bool</span> exiting_<span class="token punctuation">;</span>      <span class="token comment">//线程是否正在退出</span>Thread thread_<span class="token punctuation">;</span>     <span class="token comment">//线程</span>std<span class="token double-colon punctuation">::</span>mutex mutex_<span class="token punctuation">;</span>  <span class="token comment">//互斥访问loop_</span>std<span class="token double-colon punctuation">::</span>condition_variable cond_<span class="token punctuation">;</span>  <span class="token comment">//条件变量，用于是否已经成功创建通信</span>ThreadInitCallback callback_<span class="token punctuation">;</span>  <span class="token comment">//上层设置的回调函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> ThreadInitCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token function">EventLoopThread</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadInitCallback <span class="token operator">&amp;</span>cb <span class="token operator">=</span> <span class="token function">ThreadInitCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                 <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">EventLoopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建线程，启动loop</span> EventLoop <span class="token operator">*</span><span class="token function">startLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">//线程创建时传入的回调函数，里面进行创建loop等操作</span> <span class="token keyword">void</span> <span class="token function">threadFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-1-EventLoopThreadPool"><a href="#2-5-1-EventLoopThreadPool" class="headerlink" title="2.5.1 EventLoopThreadPool"></a>2.5.1 EventLoopThreadPool</h3><p>封装成一个线程池，使得TcpServer能更方便管理多个subLoop。</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// mainReactor，设置这个成员是考虑轮询算法寻找subLoop时，当不存在subLoop时能将mainLoop作为作为返回结果</span>EventLoop <span class="token operator">*</span>baseLoop_<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span><span class="token keyword">bool</span> started_<span class="token punctuation">;</span><span class="token keyword">int</span> numThreads_<span class="token punctuation">;</span><span class="token comment">//轮询时下一个位置指向</span><span class="token keyword">int</span> next_<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>EventLoopThread<span class="token operator">>></span> threads_<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>EventLoop <span class="token operator">*</span><span class="token operator">></span> loops_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> ThreadInitCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token function">EventLoopThreadPool</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>baseLoop<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>nameArg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">EventLoopThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setThreadNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> numThreads<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> numThreads_ <span class="token operator">=</span> numThreads<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadInitCallback <span class="token operator">&amp;</span>cb <span class="token operator">=</span> <span class="token function">ThreadInitCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//如果工作在多线程中，baseLoop以轮询方式分配channel给subloop</span> EventLoop <span class="token operator">*</span><span class="token function">getNextLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>EventLoop <span class="token operator">*</span><span class="token operator">></span> <span class="token function">getAllLoops</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">bool</span> <span class="token function">started</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> started_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> name_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">EventLoopThreadPool</span><span class="token double-colon punctuation">::</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadInitCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  started_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numThreads_<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>name_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> buf<span class="token punctuation">,</span> <span class="token string">"%s%d"</span><span class="token punctuation">,</span> name_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    EventLoopThread <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">EventLoopThread</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    threads_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>EventLoopThread<span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//底层创建线程，绑定一个新的Eventloop，并记录该loop地址</span>    loops_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token operator">-></span><span class="token function">startLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//没有创建其他线程，只有一个mainLoop</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>numThreads_ <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">cb</span><span class="token punctuation">(</span>baseLoop_<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//如果用户传了cb则需执行下回调******************</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-6-Socket"><a href="#2-6-Socket" class="headerlink" title="2.6 Socket"></a>2.6 Socket</h2><p>Socket封装socket的常用操作，如设置非阻塞、监听、noDelay等，但并不包含创建sockfd。</p><p>注意与Channel的区别，Channel是管理事件和事件发生回调，而Socket则设置socket的属性、绑定监听等</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> sockfd_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">explicit</span> <span class="token function">Socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">sockfd_</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token operator">~</span><span class="token function">Socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> sockfd_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">bindAddress</span><span class="token punctuation">(</span><span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>localAddr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span>InetAddress <span class="token operator">*</span>peeraddr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">shutdownWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置不等待而直接发送</span> <span class="token keyword">void</span> <span class="token function">setTcpNoDelay</span><span class="token punctuation">(</span><span class="token keyword">bool</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置端口释放后立即就可以被再次使用</span> <span class="token keyword">void</span> <span class="token function">setReuseAddr</span><span class="token punctuation">(</span><span class="token keyword">bool</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//允许许多个线程或进程，绑定在同一个端口上</span> <span class="token keyword">void</span> <span class="token function">setReusePort</span><span class="token punctuation">(</span><span class="token keyword">bool</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置是否开启心跳</span> <span class="token keyword">void</span> <span class="token function">setKeepAlive</span><span class="token punctuation">(</span><span class="token keyword">bool</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-7-Acceptor"><a href="#2-7-Acceptor" class="headerlink" title="2.7 Acceptor"></a>2.7 Acceptor</h2><p>封装了listenfd相关的操作，其监听新连接用户，并分发给subLoop</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>  <span class="token comment">// acceptor使用的用户定义的loop，也叫mainloop</span>Socket acceptSocket_<span class="token punctuation">;</span><span class="token comment">//listenfd对应的socket</span>Channel acceptChannel_<span class="token punctuation">;</span><span class="token comment">//listenfd对应的channel</span>NewConnectionCallback newConnectionCallback_<span class="token punctuation">;</span>  <span class="token comment">//当有新连接到来，需要做的回调</span><span class="token keyword">bool</span> listenning_<span class="token punctuation">;</span><span class="token comment">//是否监听标志</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> NewConnectionCallback <span class="token operator">=</span>     std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token function">Acceptor</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>listenAddr<span class="token punctuation">,</span> <span class="token keyword">bool</span> reuseport<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">Acceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setNewConnectionCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> NewConnectionCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   newConnectionCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">bool</span> <span class="token function">listenning</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> listenning_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//开始监听</span> <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">// listenfd有事件发生即有新用户连接，调用此函数</span> <span class="token keyword">void</span> <span class="token function">handleRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// listenfd有事件发生即有新用户连接，调用此函数</span><span class="token keyword">void</span> <span class="token class-name">Acceptor</span><span class="token double-colon punctuation">::</span><span class="token function">handleRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  InetAddress peerAddr<span class="token punctuation">;</span>  <span class="token keyword">int</span> connfd <span class="token operator">=</span> acceptSocket_<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>peerAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>connfd <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newConnectionCallback_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//轮询找到subloop，将其唤醒，分发当前客户端的channel</span>      <span class="token function">newConnectionCallback_</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> peerAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token double-colon punctuation">::</span><span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"%s:%s:%d accept err:%d \n"</span><span class="token punctuation">,</span> <span class="token constant">__FILE__</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span>              errno<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// EMFILE表示服务器sockfd资源用完</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EMFILE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"%s:%s:%d sockfd reached limit \n"</span><span class="token punctuation">,</span> <span class="token constant">__FILE__</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">,</span>                <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-8-Buffer"><a href="#2-8-Buffer" class="headerlink" title="2.8 Buffer"></a>2.8 <strong>Buffer</strong></h2><p>封装缓冲区常见操作，其内部是一个char类型的vector</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer</span><span class="token comment">///</span><span class="token comment">/// @code</span><span class="token comment">/// +-------------------+------------------+------------------+</span><span class="token comment">/// | prependable bytes |  readable bytes  |  writable bytes  |</span><span class="token comment">/// |                   |     (CONTENT)    |                  |</span><span class="token comment">/// +-------------------+------------------+------------------+</span><span class="token comment">/// |                   |                  |                  |</span><span class="token comment">/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> buffer_<span class="token punctuation">;</span>  <span class="token comment">//缓冲区</span>size_t readerIndex_<span class="token punctuation">;</span>        <span class="token comment">//可读位置</span>size_t writerIndex_<span class="token punctuation">;</span>        <span class="token comment">//可写位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">static</span> <span class="token keyword">const</span> size_t kCheapPrepend <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token keyword">static</span> <span class="token keyword">const</span> size_t kInitialSize <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token keyword">explicit</span> <span class="token function">Buffer</span><span class="token punctuation">(</span>size_t initialSize <span class="token operator">=</span> kInitialSize<span class="token punctuation">)</span>     <span class="token operator">:</span> <span class="token function">buffer_</span><span class="token punctuation">(</span>kCheapPrepend <span class="token operator">+</span> initialSize<span class="token punctuation">)</span><span class="token punctuation">,</span>       <span class="token function">readerIndex_</span><span class="token punctuation">(</span>kCheapPrepend<span class="token punctuation">)</span><span class="token punctuation">,</span>       <span class="token function">writerIndex_</span><span class="token punctuation">(</span>kCheapPrepend<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//可读数据长度</span> size_t <span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> writerIndex_ <span class="token operator">-</span> readerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//可写数据长度</span> size_t <span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> buffer_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> writerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//预留空间长度，初始的预留空间是为消息长度而准备</span> size_t <span class="token function">prependableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> readerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//返回缓冲区中可读地址的起始地址</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> readerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//读取len长度后调用此函数</span> <span class="token keyword">void</span> <span class="token function">retrieve</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">//如果数据没读完</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     readerIndex_ <span class="token operator">+=</span> len<span class="token punctuation">;</span>  <span class="token comment">//应用只读取了可读缓冲区的一部分，</span>   <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>     <span class="token function">retrieveAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//已经读完，需将缓冲区复位为初始状态</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">retrieveAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> readerIndex_ <span class="token operator">=</span> writerIndex_ <span class="token operator">=</span> kCheapPrepend<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//把onMessage函数上报的buffer数据，转成string类型返回</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">retrieveAllAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">return</span> <span class="token function">retrieveAsString</span><span class="token punctuation">(</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">retrieveAsString</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   std<span class="token double-colon punctuation">::</span>string <span class="token function">result</span><span class="token punctuation">(</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//上面已经把缓冲区的数据读出，需要对缓冲区进行复位操作</span>   <span class="token function">retrieve</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> result<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//确保len长度的数据能被写入</span> <span class="token keyword">void</span> <span class="token function">ensureWriteableBytes</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token function">makeSpace</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//把data中的len长的数据添加到缓冲区中</span> <span class="token keyword">void</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> data<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">ensureWriteableBytes</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span><span class="token function">copy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> data <span class="token operator">+</span> len<span class="token punctuation">,</span> <span class="token function">beginWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   writerIndex_ <span class="token operator">+=</span> len<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//从fd上读取数据</span> size_t <span class="token function">readFd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> saveErrno<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//通过fd发送数据</span> size_t <span class="token function">writeFd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> saveErrno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">//返回buffer首元素地址，即数组的起始地址，&amp;*不能抵消，因为*被重写过</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token operator">*</span>buffer_<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token operator">*</span>buffer_<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//通过整理buffer空间或增加buffer空间使得容量够写</span> <span class="token keyword">void</span> <span class="token function">makeSpace</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">//如果可写空间加上前面预留空间（预留空间可能由于依次被读完而变长）还是小于要求的长度</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">prependableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> len <span class="token operator">+</span> kCheapPrepend<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     buffer_<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>writerIndex_ <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>     <span class="token comment">//如果数据空间够用，则将现有数据前移</span>     size_t readable <span class="token operator">=</span> <span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     std<span class="token double-colon punctuation">::</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> readerIndex_<span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>               <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> kCheapPrepend<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//返回可写处的指针</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">beginWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> writerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">beginWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> writerIndex_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * @brief 从fd上读取数据  低层的Poller工作在LT模式 * buffer缓冲区有大小，但是从fd上读数据时，却不知道tcp数据最终的大小， * 如果不断将buffer进行扩容，效率很低;而如果预先就设为很大空间，当用户数量很多时，内存容量消耗极大 * 因此，使用一个栈上临时变量来存储现有缓冲区不够存的数据，最后将其写入缓冲区中 * @param fd sockfd * @param saveErrno 错误 * @return size_t 成功读取大小 */</span>size_t <span class="token class-name">Buffer</span><span class="token double-colon punctuation">::</span><span class="token function">readFd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> saveErrno<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> extrabuf<span class="token punctuation">[</span><span class="token number">65536</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">//栈上空间 64k</span>  <span class="token keyword">struct</span> <span class="token class-name">iovec</span> vec<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// buffer缓冲区剩余的可写空间大小</span>  <span class="token keyword">const</span> size_t writeable <span class="token operator">=</span> <span class="token function">writeableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_base <span class="token operator">=</span> <span class="token function">beginWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_len <span class="token operator">=</span> writeable<span class="token punctuation">;</span>  vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_base <span class="token operator">=</span> extrabuf<span class="token punctuation">;</span>  vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_len <span class="token operator">=</span> <span class="token keyword">sizeof</span> extrabuf<span class="token punctuation">;</span>  <span class="token comment">/**************************************************************************/</span>  <span class="token comment">//当缓冲区可写空间小于extrabuf时，使用buffer和extrabuf一起作为readv写入的空间</span>  <span class="token comment">//反之，如果可写空间大于extrabuf空间时，就没有必要再使用一个extrabuf来作为暂存了</span>  <span class="token comment">//因为buffer在写入数据时，如果空间不够会自动扩容为原来2倍，而即使加上一个extrabuf能存储的数据也没有扩容后的大</span>  <span class="token comment">//这样效率效率还没有直接使用一个buffer让其自动扩容效率高，毕竟buffer</span>  <span class="token comment">//resize时也会进行拷贝复制</span>  <span class="token comment">//使用extra就会在readv中写入一次数据，还需再将其拷贝到buffer中，而不使用的话就是只有readv将数据写入到buf中</span>  <span class="token comment">// extrabuf的使用原因是为了避免buffer不断扩容而导致效率低</span>  <span class="token comment">//这里不用担心如果空间不够存，使用的是LT模式，没读完的数据后面会不断唤醒读</span>  <span class="token keyword">const</span> <span class="token keyword">int</span> iovcnt <span class="token operator">=</span> <span class="token punctuation">(</span>writeable <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span> extrabuf<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// readv能自动将数据写入到多个缓冲区中，缓冲区都在vec数组中</span>  <span class="token keyword">const</span> size_t n <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">readv</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> vec<span class="token punctuation">,</span> iovcnt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>saveErrno <span class="token operator">=</span> errno<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> writeable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// buffer的缓冲区够存储数据</span>    writerIndex_ <span class="token operator">+=</span> n<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// extrabuf里也写入了数据</span>    writerIndex_ <span class="token operator">=</span> buffer_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将extrabuf追加到buffer中</span>    <span class="token function">append</span><span class="token punctuation">(</span>extrabuf<span class="token punctuation">,</span> n <span class="token operator">-</span> writeable<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-9-TcpConnection"><a href="#2-9-TcpConnection" class="headerlink" title="2.9 TcpConnection"></a>2.9 <strong>TcpConnection</strong></h2><p>封装一个连接信息，其内包含本地地址、对端地址、socket、channel、以及读写buffer</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>  <span class="token comment">// subLoop地址</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>atomic_int state_<span class="token punctuation">;</span><span class="token comment">//TcpConnection状态</span>  <span class="token keyword">bool</span> reading_<span class="token punctuation">;</span>  <span class="token comment">//可读标志</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Socket<span class="token operator">></span> socket_<span class="token punctuation">;</span><span class="token comment">//one Tcpconnection one socket</span>  std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Channel<span class="token operator">></span> channel_<span class="token punctuation">;</span><span class="token comment">//one Tcpconnection one channel</span>  <span class="token keyword">const</span> InetAddress localAddr_<span class="token punctuation">;</span>  <span class="token comment">//本地地址</span>  <span class="token keyword">const</span> InetAddress peerAddr_<span class="token punctuation">;</span>   <span class="token comment">//对端地址</span>  ConnectionCallback connectionCallback_<span class="token punctuation">;</span>        <span class="token comment">//有新连接时的回调</span>  MessageCallback messageCallback_<span class="token punctuation">;</span>              <span class="token comment">//有读写消息的回调</span>  WriteCompleteCallback writeCompleteCallback_<span class="token punctuation">;</span>  <span class="token comment">//消息发送完成的回调</span>  <span class="token comment">// HighWaterMarkCallback:读写数据达到警戒线的回调。比如当发送数据过快，接收方来不及接受时，此时发送方需要进行处理比如需要停止发送，</span>  HighWaterMarkCallback highWaterMarkCallback_<span class="token punctuation">;</span>  CloseCallback closeCallback_<span class="token punctuation">;</span>  size_t highWaterMark_<span class="token punctuation">;</span>  <span class="token comment">//水位线标志，超过此数则表示达到警戒线</span>  Buffer inputBuffer_<span class="token punctuation">;</span>   <span class="token comment">//接受数据缓冲</span>  Buffer outputBuffer_<span class="token punctuation">;</span>  <span class="token comment">//发送数据缓冲</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">TcpConnection</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span> sockfd<span class="token punctuation">,</span>                <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>localAddr<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>peerAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">~</span><span class="token function">TcpConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  EventLoop <span class="token operator">*</span><span class="token function">getLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> loop_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> name_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span><span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> localAddr_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span><span class="token function">peerAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> peerAddr_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">bool</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> state_ <span class="token operator">==</span> kConnected<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">//发送数据</span>  <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// void send(const void *message, int len);</span>  <span class="token comment">//关闭连接</span>  <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//设置回调函数</span>  <span class="token keyword">void</span> <span class="token function">setConnectionCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> ConnectionCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    connectionCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">setMessageCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> MessageCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> messageCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">setWriteCompleteCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> WriteCompleteCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    writeCompleteCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">setHighWaterMarkCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> HighWaterMarkCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    highWaterMarkCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">setCloseCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> CloseCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> closeCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">//连接建立时的回调函数</span>  <span class="token keyword">void</span> <span class="token function">connectEstablished</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//连接销毁的回调函数</span>  <span class="token keyword">void</span> <span class="token function">connectDestroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">enum</span> <span class="token class-name">StateE</span> <span class="token punctuation">&#123;</span> kDisconnected<span class="token punctuation">,</span> kConnecting<span class="token punctuation">,</span> kConnected<span class="token punctuation">,</span> kDisconnecting <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>StateE state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> state_ <span class="token operator">=</span> state<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//发送数据</span><span class="token comment">//应用写得快，而内核发送数据慢，需要把待发送数据写入缓冲区，而且设置水位回调</span><span class="token keyword">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">sendInLoop</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>message<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  size_t nwrote <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  size_t remaining <span class="token operator">=</span> len<span class="token punctuation">;</span>  <span class="token keyword">bool</span> faultError <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">//之前已经调用过shutdown，不能再进行发送了</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>state_ <span class="token operator">==</span> kDisconnected<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"disconnected, give up writing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// channel未设置写感兴趣事件（说明无数据待从缓冲区中写入）且缓冲区没有待发送数据</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel_<span class="token operator">-></span><span class="token function">isWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> outputBuffer_<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    nwrote <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">write</span><span class="token punctuation">(</span>channel_<span class="token operator">-></span><span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> message<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nwrote <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      remaining <span class="token operator">=</span> len <span class="token operator">-</span> nwrote<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> writeCompleteCallback_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//当一次将数据发送完成，就不用再给channel设置epollout事件了</span>        loop_<span class="token operator">-></span><span class="token function">queueInLoop</span><span class="token punctuation">(</span>            std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>writeCompleteCallback_<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      nwrote <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> EWOULDBLOCK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"TcpConnection::sendInLoop\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EPIPE <span class="token operator">||</span> errno <span class="token operator">==</span> ECONNREFUSED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          faultError <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/****************************************************/</span>  <span class="token comment">//说明这次write没有全部发送出去，剩余数据需要保存到缓冲区中，</span>  <span class="token comment">//然后给channel注册epollout事件，poller发现tcp的发送缓冲区有空间，会通知相应的sock-channel，调用WriteCallback方法</span>  <span class="token comment">//最终也就是调用handleWrite方法，把发送缓冲区中的数据全部发送完成</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>faultError <span class="token operator">&amp;&amp;</span> remaining <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//目前发送缓冲区剩余的待发送数据长度</span>    size_t oldLen <span class="token operator">=</span> outputBuffer_<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldLen <span class="token operator">+</span> remaining <span class="token operator">>=</span> highWaterMark_ <span class="token operator">&amp;&amp;</span> oldLen <span class="token operator">&lt;</span> highWaterMark_ <span class="token operator">&amp;&amp;</span>        highWaterMarkCallback_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      loop_<span class="token operator">-></span><span class="token function">queueInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>highWaterMarkCallback_<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                   oldLen <span class="token operator">+</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    outputBuffer_<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>message <span class="token operator">+</span> nwrote<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>channel_<span class="token operator">-></span><span class="token function">isWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//这里一定要注册channel的写事件，否则poller不会给channel通知epollout</span>      channel_<span class="token operator">-></span><span class="token function">enableWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//啥时候执行写回调？poller怎么通知写回调，数据不是都先到buffer中的吗</span><span class="token comment">//这是因为只要注册了EPOLLOUT事件，当内核写缓冲可写时，会不断发送EPOLLOUT信号，然后调用此函数将buffer中的数据进行发送</span><span class="token keyword">void</span> <span class="token class-name">TcpConnection</span><span class="token double-colon punctuation">::</span><span class="token function">handleWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>channel_<span class="token operator">-></span><span class="token function">isWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> savedError <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ssize_t n <span class="token operator">=</span> outputBuffer_<span class="token punctuation">.</span><span class="token function">writeFd</span><span class="token punctuation">(</span>channel_<span class="token operator">-></span><span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>savedError<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      outputBuffer_<span class="token punctuation">.</span><span class="token function">retrieve</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>outputBuffer_<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        channel_<span class="token operator">-></span><span class="token function">disableWriting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>writeCompleteCallback_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">//唤醒loop_对应的thread线程，执行回调</span>          <span class="token comment">//其实此时就是在loop_对应的thread线程中</span>          loop_<span class="token operator">-></span><span class="token function">queueInLoop</span><span class="token punctuation">(</span>              std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>writeCompleteCallback_<span class="token punctuation">,</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//当用户shutdown时数据如果没发送完成，不会真的shutdown，只是将标志置为kDisconnecting，而是会等待用户把数据发送完成</span>        <span class="token comment">//当数据发送完成后，则再执行一次shutdownInLoop</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>state_ <span class="token operator">==</span> kDisconnecting<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token function">shutdownInLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"TcpConnection::handleWrite() error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"TcpConnection fd=%d is down, no more writing \n"</span><span class="token punctuation">,</span>              channel_<span class="token operator">-></span><span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-10-TcpServer"><a href="#2-10-TcpServer" class="headerlink" title="2.10 TcpServer"></a>2.10 <strong>TcpServer</strong></h2><p>上述所有类的综合使用者，用户通过使用此类来设置各种回调，通过此类来管理subLoop个数等</p><p><strong>成员变量</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> ConnectionMap <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> TcpConnectionPtr<span class="token operator">></span><span class="token punctuation">;</span>EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>  <span class="token comment">//用户定义的loop</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string ipPort_<span class="token punctuation">;</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string name_<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Acceptor<span class="token operator">></span> acceptor_<span class="token punctuation">;</span>  <span class="token comment">// mainLoop的监听新连接事件</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>EventLoopThreadPool<span class="token operator">></span> threadPool_<span class="token punctuation">;</span>  <span class="token comment">// one loop per thread</span>ConnectionCallback connectionCallback_<span class="token punctuation">;</span>        <span class="token comment">//有新连接时的回调</span>MessageCallback messageCallback_<span class="token punctuation">;</span>              <span class="token comment">//有读写消息的回调</span>WriteCompleteCallback writeCompleteCallback_<span class="token punctuation">;</span>  <span class="token comment">//消息发送完成的回调</span>ThreadInitCallback threadInitCallback_<span class="token punctuation">;</span>  <span class="token comment">//线程初始化的回调</span>std<span class="token double-colon punctuation">::</span>atomic_int started_<span class="token punctuation">;</span><span class="token keyword">int</span> nextConnId_<span class="token punctuation">;</span><span class="token comment">//TcpConnection的id，是用来加到TcpConnection名字中</span>ConnectionMap connections_<span class="token punctuation">;</span>  <span class="token comment">//保存所有的连接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>成员函数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">using</span> ThreadInitCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token keyword">enum</span> <span class="token class-name">Option</span> <span class="token punctuation">&#123;</span>   kNoReusePort<span class="token punctuation">,</span>   kReusePort<span class="token punctuation">,</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token function">TcpServer</span><span class="token punctuation">(</span>EventLoop <span class="token operator">*</span>loop<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>listenAddr<span class="token punctuation">,</span>           <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string nameArg<span class="token punctuation">,</span> Option option <span class="token operator">=</span> kNoReusePort<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token function">TcpServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setThreadInitCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> ThreadInitCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   threadInitCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">setConnectionCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> ConnectionCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   connectionCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">setMessageCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> MessageCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> messageCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">setWriteCompleteCallback</span><span class="token punctuation">(</span><span class="token keyword">const</span> WriteCompleteCallback <span class="token operator">&amp;</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   writeCompleteCallback_ <span class="token operator">=</span> cb<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//设置低层subloop的个数</span> <span class="token keyword">void</span> <span class="token function">setThreadNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> numThreads<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//开启服务器监听</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">//当Acceptor有新连接时会调用的回调函数</span> <span class="token keyword">void</span> <span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>peerAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">removeConnection</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr <span class="token operator">&amp;</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">removeConnectionInLoop</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr <span class="token operator">&amp;</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//当有新的客户端连接，acceptor会执行这个回调</span><span class="token comment">//根据轮询算法选择一个subLoop，唤醒subLoop，把当前connfd封装成channel分发给subloop</span><span class="token keyword">void</span> <span class="token class-name">TcpServer</span><span class="token double-colon punctuation">::</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> InetAddress <span class="token operator">&amp;</span>peerAddr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//根据轮询选择一个subloop来管理channel</span>  EventLoop <span class="token operator">*</span>ioLoop <span class="token operator">=</span> threadPool_<span class="token operator">-></span><span class="token function">getNextLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> buf<span class="token punctuation">,</span> <span class="token string">"-%s#%d"</span><span class="token punctuation">,</span> ipPort_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nextConnId_<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">++</span>nextConnId_<span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>string connName <span class="token operator">=</span> name_ <span class="token operator">+</span> buf<span class="token punctuation">;</span>  <span class="token function">LOG_INFO</span><span class="token punctuation">(</span><span class="token string">"TcpServer::newConnection [%s] - new connection [%s] from %s\n"</span><span class="token punctuation">,</span>           name_<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> connName<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> peerAddr<span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//通过sockfd获取其绑定的ip地址和端口信息</span>  sockaddr_in local<span class="token punctuation">;</span>  <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>local<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> local<span class="token punctuation">)</span><span class="token punctuation">;</span>  socklen_t addrlen <span class="token operator">=</span> <span class="token keyword">sizeof</span> local<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token double-colon punctuation">::</span><span class="token function">getsockname</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>sockaddr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>local<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addrlen<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">LOG_ERROR</span><span class="token punctuation">(</span><span class="token string">"sockets::getLocalAddr\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  InetAddress <span class="token function">localAddr</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//根据连接成功的sockfd，创建TcpConnection连接对象</span>  TcpConnectionPtr <span class="token function">conn</span><span class="token punctuation">(</span>      <span class="token keyword">new</span> <span class="token function">TcpConnection</span><span class="token punctuation">(</span>ioLoop<span class="token punctuation">,</span> connName<span class="token punctuation">,</span> sockfd<span class="token punctuation">,</span> localAddr<span class="token punctuation">,</span> peerAddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  connections_<span class="token punctuation">[</span>connName<span class="token punctuation">]</span> <span class="token operator">=</span> conn<span class="token punctuation">;</span>  <span class="token comment">//下面的回调都来源于用户设置给TcpServer => TcpConnection => channel =>Poller</span>  <span class="token comment">//=>notify channel调用回调</span>  conn<span class="token operator">-></span><span class="token function">setConnectionCallback</span><span class="token punctuation">(</span>connectionCallback_<span class="token punctuation">)</span><span class="token punctuation">;</span>  conn<span class="token operator">-></span><span class="token function">setMessageCallback</span><span class="token punctuation">(</span>messageCallback_<span class="token punctuation">)</span><span class="token punctuation">;</span>  conn<span class="token operator">-></span><span class="token function">setWriteCompleteCallback</span><span class="token punctuation">(</span>writeCompleteCallback_<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//设置如何关闭连接的回调 用户调用shutdwon => socket关闭写端 =></span>  <span class="token comment">// poller通知channel EPOLLHUP事件 => channel调用closeCallback =></span>  <span class="token comment">// TcpConnection::handleClose() => TcpServer::removeConnection</span>  conn<span class="token operator">-></span><span class="token function">setCloseCallback</span><span class="token punctuation">(</span>      std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpServer<span class="token double-colon punctuation">::</span>removeConnection<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//直接调用connectEstablished方法</span>  ioLoop<span class="token operator">-></span><span class="token function">runInLoop</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TcpConnection<span class="token double-colon punctuation">::</span>connectEstablished<span class="token punctuation">,</span> conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-问题"><a href="#3-问题" class="headerlink" title="3. 问题"></a>3. 问题</h1><h2 id="介绍一下项目"><a href="#介绍一下项目" class="headerlink" title="介绍一下项目"></a>介绍一下项目</h2><p>此项目是一个基于Reactor模式的web服务器，采用epoll多路复用机制+线程池来高效处理并发连接。在实现中，使用epoll的水平触发模式来进行监听，使用C++11提供的智能指针来避免内存泄露，使用了eventfd来高效唤醒线程，为统一管理日志文件，实现了一个简单的异步日志系统。</p><h2 id="什么是优雅关闭连接？"><a href="#什么是优雅关闭连接？" class="headerlink" title="什么是优雅关闭连接？"></a>什么是优雅关闭连接？</h2><blockquote><p>优雅关闭：如果发送缓存中还有数据未发出则将其发出去，并且收到所有数据的ACK之后，发送FIN包，开始关闭过程。使用shutdown函数。</p><p>强制关闭：如果缓存中还有数据，则这些数据都将被丢弃，然后发送RST包，直接重置TCP连接。使用close()函数。</p><p>close()和shutdown()的区别：</p><ul><li>close会关闭连接，并释放所有连接对应的资源，而shutdown并不会释放掉套接字和所有资源。</li><li>close有引用计数，例如父子进程都打开了某个文件描述符，其中某个进程调用了close函数，会使close函数的引用计数减1，直到套接字的引用计数为0，才会真正的关闭连接。而shutdown函数可以无视引用计数，直接关闭连接。</li><li>close的引用计数的存在导致不一定会发出FIN结束报文，而shutdown一定会发出FIN报文。</li><li>shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() &#x2F; closesocket() 将套接字从内存清除。</li><li>调用 close()关闭套接字时，或调用 shutdown() 关闭输出流时，都会向对方发送 FIN 包。FIN 包表示数据传输完毕，计算机收到 FIN 包就知道不会再有数据传送过来。</li><li>默认情况下，close()引用计数为0后会立即往网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。<em><strong>*也就意味着，调用 close()将丢失输出缓冲区中的数据，而调用 shutdown() 不会。*</strong></em></li></ul></blockquote><p>在代码实现中，当用户调用shutdown函数时，不会马上就调用shutdown关闭socket，而是先将状态置为disconnecting，如果当前连接发送缓冲区无数据则调用shutdown函数关闭socket，否则等到每次处理写事件时当数据发送完成都会判断当前状态是否是disconnecting，如果是则调用shutdown关闭socket</p><h2 id="eventfd是什么？有什么好处？"><a href="#eventfd是什么？有什么好处？" class="headerlink" title="eventfd是什么？有什么好处？"></a>eventfd是什么？有什么好处？</h2><blockquote><p>参考 <a href="https://juejin.cn/post/6844903592457928711">1</a> <a href="https://zhuanlan.zhihu.com/p/40572954">2</a> <a href="https://zhuanlan.zhihu.com/p/424198922">3</a></p></blockquote><p><strong>简介</strong></p><ul><li>eventfd是linux系统提供的一个轻量级的进程间通信的系统调用，eventfd通过一个进程间共享的64位计数器完成进程间通信，这个计数器由在linux内核空间维护，用户可以通过调用write方法向内核空间写入一个64位的值，也可以调用read方法读取这个值。</li></ul><p><strong>使用</strong></p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/eventfd.h></span></span><span class="token keyword">int</span> <span class="token function">eventfd</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> initval<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>flags可以设置以下三个标志位：</p><ul><li>EFD_CLOEXEC：简单说就是fork子进程时不继承，对于多线程的程序设上这个值不会有错的。</li><li>EFD_NONBLOCK：如果没有设置了这个标志位，那read操作将会阻塞直到计数器中有值。如果有设置这个标志位，计数器没有值的时候也会立即返回-1；</li><li>EFD_SEMAPHORE：支持semophore语义的read，简单说就值递减1。</li></ul></li></ul><p><strong>典型应用场景及优势</strong></p><p>在信号通知的场景下，相比pipe有非常大的资源和性能优势。其根本在于counter（计数器）和channel（数据信道）的区别。</p><ul><li>第一，是打开文件数量的巨大差别。由于pipe是半双工的传统IPC方式，所以两个线程通信需要两个pipe文件，而用eventfd只要打开一个文件，省了一半。另外，pipe只能在两个进程&#x2F;线程间使用，即需要之前准备好两个pipe；而eventfd是广播式的通知，可以多对多的。</li><li>第二，是内存使用的差别。eventfd是一个计数器，内核维护几乎成本忽略不计，大概是自旋锁+唤醒队列，8个字节的传输成本也微乎其微。但pipe可就完全不是了，一来一回数据在用户空间和内核空间有多达4次的复制，而且更糟糕的是，内核还要为每个pipe分配至少4K的虚拟内存页，即便传输的数据长度为0。</li></ul><p><strong>实现原理</strong></p><ul><li><p>eventfd在内核中的数据结构如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">eventfd_ctx</span> <span class="token punctuation">&#123;</span>        wait_queue_head_t wqh<span class="token punctuation">;</span><span class="token comment">//等待队列头节点</span>        __u64 count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//等待队列是内核中的重要数据结构，在进程调度、异步通知等多种场景都有很多的应用。其节点结构并不复杂，即自带自旋锁的双向循环链表的节点</span><span class="token keyword">struct</span> <span class="token class-name">__wait_queue_head</span> <span class="token punctuation">&#123;</span>spinlock_t lock<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">list_head</span> task_list<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">__wait_queue_head</span> wait_queue_head_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>read()函数：read操作目的是要将count值返回用户空间并清零。ctx中的count值是共享数据，通过加irq自旋锁实现对其的独占安全访问。</p></li></ul><p><strong>进程是如何被唤醒的</strong></p><ul><li>当写进程调用eventfd_write过程中，会调用 waitqueue_active(&amp;ctx-&gt;wqh) 判断ctx-&gt;wqh是否为空，若不为空，则调用 wake_up_locked_poll(&amp;ctx-&gt;wqh, EPOLLIN); 激活可写事件（因为读进程读取时发现不可读，会生成一个 wait 对象放到 ctx-&gt;wqh队列中，然后休眠，所以此时 ctx-&gt;wqh）。</li></ul><h2 id="实现一个无锁队列-用原子操作"><a href="#实现一个无锁队列-用原子操作" class="headerlink" title="实现一个无锁队列(用原子操作)"></a>实现一个无锁队列(用原子操作)</h2><blockquote><p>参考 <a href="https://www.cnlzhnn.com/cas%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/">1</a> <a href="https://luyuhuang.tech/2022/10/30/lock-free-queue.html">2</a> <a href="https://developer.aliyun.com/article/497473">3</a></p><p><code>c++</code>提供了<code>atomic</code>模板支持一系列原子操作的类，提供的方法能保证操作具有原子性，即获取该类型变量的值时，永远能获得修改前或修改后的值，不会获得修改过程中的值，以确保不会在并发操作时产生不明确的行为。</p><p>该模板不具有拷贝构造函数，因为原子读和原子写是两个独立的原子操作，不能确保两个独立的操作加在一起仍然能保证原子性。</p><p>该类提供了如下几种接口：</p><ul><li><code>stroe</code> 原子写操作</li><li><code>load</code> 原子读操作</li><li><code>exchange</code> 修改当前值，并保证过程具有原子性</li><li><code>compare_exchange_weak</code></li><li><code>compare_exchange_strong</code></li></ul><p><code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>即为<code>CAS</code>操作，参数要求传入期待值和设定值：</p><ul><li>若当前值与期待值相等，则将当前值修改为设定值，返回<code>true</code></li><li>若当前值与期待值不等，则将期待值修改为当前值，返回<code>false</code></li></ul><p><code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>的区别：</p><ul><li><code>weak</code>允许偶然出乎意料的返回，比如当前值和期待值相等时候返回<code>false</code>，但在多数循环算法中是可以接受的，通常比<code>strong</code>具有更高的性能。</li></ul></blockquote><p><strong>CAS无锁栈</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*  CAS无锁栈  */</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">ConcurrentStack</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        Node<span class="token operator">*</span> new_node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        new_node<span class="token operator">-></span>m_next <span class="token operator">=</span> m_head<span class="token punctuation">;</span>        <span class="token comment">//如果m_head没有发生变化，则将其置为new_node；如果m_head发生变化，此时compare_exchange_weak函数返回false，并将new_node->m_next更改为新的m_head值，此时继续循环。</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>m_head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>new_node<span class="token operator">-></span>m_next<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    T <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        Node<span class="token operator">*</span> _now <span class="token operator">=</span> m_head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Node<span class="token operator">*</span> _next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">do</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>_now <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            _next <span class="token operator">=</span> _now<span class="token operator">-></span>m_next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>m_head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>_now<span class="token punctuation">,</span> _next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果m_head没有发生变化，则将其更改为_next；否则将now更改为新的m_head，继续不断循环遍历</span>        T _tmp <span class="token operator">=</span> _now<span class="token operator">-></span>m_data<span class="token punctuation">;</span>        <span class="token keyword">delete</span> _now<span class="token punctuation">;</span>        <span class="token keyword">return</span> _tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> <span class="token class-name">Node</span>    <span class="token punctuation">&#123;</span>        <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token function">m_data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        T m_data<span class="token punctuation">;</span>        Node<span class="token operator">*</span> m_next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span> m_head <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>CAS无锁队列</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*  CAS无锁队列  */</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">lock_free_queue</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span>    <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> data<span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">></span> next<span class="token punctuation">;</span>        <span class="token function">node</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> data_<span class="token punctuation">)</span> <span class="token operator">:</span>            <span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>data_<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">></span> head <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">></span> tail <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node<span class="token operator">*</span> new_node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token operator">*</span> _ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token comment">//判断是否是空队列</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>tail<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">)</span>            _ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        node<span class="token operator">*</span> old_tail <span class="token operator">=</span> tail<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//感觉原来的有点问题，做了一点修改 old_tail不是原子变量         </span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>old_tail <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span>tail<span class="token operator">-></span>next<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            old_tail <span class="token operator">=</span> tail<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            _ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        tail<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>old_tail<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node<span class="token operator">*</span> old_head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>old_head <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>old_head<span class="token punctuation">,</span> old_head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            old_head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//感觉不太需要这一步，这一步应该是为了最后返回的时候判断值是否更改</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> old_head <span class="token operator">?</span> old_head<span class="token operator">-></span>data <span class="token operator">:</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双缓冲区异步日志是什么？为什么要这样做？"><a href="#双缓冲区异步日志是什么？为什么要这样做？" class="headerlink" title="双缓冲区异步日志是什么？为什么要这样做？"></a>双缓冲区异步日志是什么？为什么要这样做？</h2><p>由于消费者的写文件速度比较慢，一定不能影响了生产者的写入效率，所以我们可以用两个消息队列来分别存储：正在写入的日志信息，正在读取的日志信息，也就是所谓的“双缓冲”技术。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230311205746535.png"></p><p><strong>缓冲区什么时候交换？</strong></p><p>当生产者所写的缓冲区已满时，需要将两个缓冲区进行交换，为了加快交换效率只需交换两个缓冲区地址即可。例如可使用queue来作为缓冲区。</p><ul><li>满足一定大小时进行交换。每次生产者像缓冲区中写数据时，如果缓冲区带下超过限制，则交换缓冲区（缓冲区2如果此时如果还有数据则不进行交换，继续写）</li><li>超过一定时间进行交换。可能写日志频率较低，很久都无法满足交换数量，此时应该设定一个timerfd，每当达到一定时间就交换缓冲区，避免过久不写日志导致日志丢失。</li></ul><h2 id="定时器是怎么实现的？还有什么实现方式？"><a href="#定时器是怎么实现的？还有什么实现方式？" class="headerlink" title="定时器是怎么实现的？还有什么实现方式？"></a>定时器是怎么实现的？还有什么实现方式？</h2><p>定时器可使用timerfd实现，timerfd 可以和 epoll 配合起来，让 epoll 监听 timerfd 的可读事件，这样 timerfd 超时触发可读事件，<code>epoll_wait</code> 被唤醒，业务进行周期处理，从而也能达到定时器的目的。</p><p><strong>timerfd简介</strong>：</p><ul><li><p>timerfd 被 new 出来之后 （ <code>timerfd_create</code> ），可以设置超时时间（ <code>timerfd_setting</code> ），超时之后，该句柄可读，读出来的是超时的次数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 创建一个 timerfd 句柄</span><span class="token keyword">int</span> <span class="token function">timerfd_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> clockid<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 启动或关闭 timerfd 对应的定时器</span><span class="token keyword">int</span> <span class="token function">timerfd_settime</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">itimerspec</span> <span class="token operator">*</span>new_value<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">itimerspec</span> <span class="token operator">*</span>old_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取指定 timerfd 距离下一次超时还剩的时间</span><span class="token keyword">int</span> <span class="token function">timerfd_gettime</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">itimerspec</span> <span class="token operator">*</span>curr_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>timerfd原理</strong></p><ul><li><p>核心结构体：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">timerfd_ctx</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 真正的内核定时器</span>    <span class="token keyword">union</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">hrtimer</span> tmr<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">alarm</span> alarm<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> t<span class="token punctuation">;</span>    <span class="token comment">// wait 对象挂接的表头</span>    wait_queue_head_t wqh<span class="token punctuation">;</span>    <span class="token comment">// 记录超时的次数</span>    u64 ticks<span class="token punctuation">;</span>    <span class="token comment">// 定时器类型</span>    <span class="token keyword">int</span> clockid<span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>timerfd_create内部过程</p><ul><li>创建并初始化了一个 <code>timerfd_ctx</code> 的结构体（在这个 ctx 结构体内有个表头 <code>ctx-&gt;wqh</code> 很重要，是和 epoll 产生联系的关键点）；</li><li>初始化了定时器，根据类型可以创建 <code>alarm</code> 类型或者高精度的 <code>hrtimer</code> 类型的定时器（ 注意：timerfd 本身并没有实现定时器的功能，定时器直接使用的是内核封装好的定时器，timerfd 只针对“文件”的封装）；</li><li>创建一个匿名 fd，绑定 <code>timerfd_fops</code> 操作表；</li></ul></li><li><p>timerfd_settime</p><ul><li>通过 fd 获取到 file，再获取到核心结构体 timerfd_ctx；</li><li>然后再操作定时器，启动定时器即可；</li></ul></li><li><p>timerfd_gettime</p><ul><li>通过 fd 获取到 file，再获取到核心结构体 <code>timerfd_ctx</code> ；</li><li>然后通过 <code>timerfd_ctx</code> 里面存储的信息，计算举例下一次超时的时间即可；</li></ul></li></ul><p><strong>timerfd 怎么唤醒 epoll_wait？</strong></p><ul><li><p>定时器到期之后，内核调用回调：</p><pre class="line-numbers language-none"><code class="language-none">timerfd_tmrproc (在初始化的时候配置)-&gt; timerfd_trigger    -&gt; wake_up_locked_poll （唤醒 timerfd 上所有的等待对象）        -&gt; ep_poll_callback<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>应该就是epoll_ctl注册时像timerfd的wqh注册事件，然后当定时器到期后，内核不断唤醒队列中的事件，调用回调操作</p></li></ul><p><strong>定时器其他实现方法</strong></p><p>linux提供以下多种计时函数：</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230311214830639.png"></p><ul><li>前四个函数比较鸡肋，会让调用线程挂起，原地等待定时器超时。但是在非阻塞网络编程中，绝对不能用让线程挂起的方式来等待一段时间，这样一来程序会失去响应。</li><li>alarm()和setitimer()，它们的通知机制采用了信号SIGALRM，由于SIGALRM信号不可靠，会造成超时通知不可靠，而且多线程中处理信号也是一个麻烦事，也不考虑。</li><li>timer_create()&#x2F;timer_settime()系列函数是POSIX规定，精度达到纳秒级，提供了一个数据结构<code>struct sigevent</code>可以指定一个实时信号作为通知信号，同时也可以设置线程ID，将信号传递到指定的线程。</li></ul><h2 id="epoll的边沿触发和水平触发有什么区别？"><a href="#epoll的边沿触发和水平触发有什么区别？" class="headerlink" title="epoll的边沿触发和水平触发有什么区别？"></a>epoll的边沿触发和水平触发有什么区别？</h2><p><strong>定义</strong></p><ul><li>水平触发：只要套接字可读&#x2F;可写epollwait都会将描述符返回。即只要套接字的接收缓冲中尚有数据或发送缓冲有空间容纳要发送的数据。这个套接字都会被epoll_wait返回。</li><li>边缘触发：当套接字的缓冲状态发生变化时返回。对于读缓冲，有新到达的数据被添加到读缓冲时触发。对于写缓冲，当缓冲发生容量变更的时候触发</li></ul><p><strong>内核调度实现方式</strong></p><ul><li>在epoll_wait的时候，阻塞等待事件发生， 事件发生时通过回调挂到ready list链表中</li><li>epoll_wait返回， 处理ready list, 返回事件给调用者</li><li>此时ET模式已经将事件从ready list中删除，LT模式中还存在</li><li>此时假设应用程序处理完了事件， 再次epoll_wait.  ET模式继续阻塞</li><li>LT模式由于ready list中依然存在事件则不会阻塞， 对这些socket调用poll方法获取最新的事件信息，如果确认没事件了才会删除。</li></ul><p><strong>边缘触发可能造成饥饿</strong></p><p>如果用边缘触发处理，对一个套接字就需要循环读取，直到没有数据可读为止。如果其中一个连接源源不断的发送数据，这个套接口的读循环就无法退出，导致其它连接没有机会被处理。</p><p><strong>边缘触发优势场景</strong></p><p>对于水平触发模式out事件必须按需注册。主要的注册方式有以下两种：</p><ul><li>上层调用send，将数据添加到应用层的发送缓冲，如果当前没有注册out则注册out,当epoll通知out激活时，发送应用缓冲中的数据，如果数据发送完毕注销out。</li><li>上层调用send，直接发送，如果数据未发送完或返回EAGAIN,则注册out，当epoll通知out激活时，继续发送未发送完成的数据，如果数据发送完毕注销out。</li></ul><p>上述的添加和注销out都是通过epoll_ctl完成，因此水平触发需要不断开关out信号，当数据频繁发送但一次不能写成功时就会不断开关out信号。</p><p>而对于边缘触发模式则无此需要。</p><ul><li>假如发送每次均能将数据全部发完。那么out的注册和注销都不会发生。</li><li>如果接收方慢导致每次均无法将数据全部发送完，那么out将只会注册一次，注销不会发生。</li></ul><p><strong>为什么选择使用LT？</strong></p><p>虽然ET在某些场景如一直读写下会更高效，但可能会遗漏事件产生bug，从而导致代码编写逻辑更为复杂。</p><h2 id="epoll为什么高效，相比select和poll"><a href="#epoll为什么高效，相比select和poll" class="headerlink" title="epoll为什么高效，相比select和poll"></a>epoll为什么高效，相比select和poll</h2><blockquote><p>自己简单理解</p><p>select使用一个结构体来管理sockfd，其内有一个bitmap，向select添加sockfd也就是将bitmap对应值进行更改为1。同理，当有事件发生时，系统返回的bitmap中如果值为1则代表此sockfd有事件 发生。</p><ul><li>由于select返回的是一个bitmap而不是发生事件的集合，因此还需要遍历整个bitmap找出有事件发生的sockfd，导致其效率很低。</li><li>且bitmap需要在内核态和用户态不断复制，导致效率很低。</li></ul><p>相比select，poll变化不大，原理也相同，poll使用数组来取代bitmap，因而也就没有大小限制。同样，poll也需要遍历整个数组来找出有事件发生的sockfd，其也只有水平触发。</p><p>epoll的一个巨大改进之处在于将发生事件的sockfd使用一个数据进行保存（通过在内核空间直接建立一个文件系统，使用红黑树），提高了效率</p></blockquote><blockquote><p>参考 <a href="https://heapdump.cn/article/3841322">1</a> <a href="https://zhuanlan.zhihu.com/p/530640921">2</a></p></blockquote><p><strong>epoll原理详解</strong></p><ul><li><p><em>当</em>某一进程调用 epoll_create 方法时，Linux 内核会创建一个 eventpoll 结构体，这个结构体中有两个成员与epoll的使用方式密切相关，如下所示：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token punctuation">&#123;</span>　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>　　<span class="token comment">/*红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，　　也就是这个epoll监控的事件*/</span>　　<span class="token keyword">struct</span> <span class="token class-name">rb_root</span> rbr<span class="token punctuation">;</span>　　<span class="token comment">/*双向链表rdllist保存着将要通过epoll_wait返回给用户的、满足条件的事件*/</span>　　<span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdllist<span class="token punctuation">;</span>　　<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在调用 epoll_create 时，内核除了帮我们在 epoll 文件系统里建了个 file 结点，在内核 cache 里建了个红黑树用于存储以后 epoll_ctl 传来的 socket 外，还会再建立一个 rdllist 双向链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 rdllist 双向链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到 timeout 时间到后即使链表没数据也返回。所以，epoll_wait 非常高效。</p></li><li><p>所有添加到epoll中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的事件放到上面的rdllist双向链表中。</p></li><li><p>当调用 epoll_wait 检查是否有发生事件的连接时，只是检查eventpoll对象中的rdllist双向链表是否有元素而已，如果rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx效率非常高。epoll_ctl在向epoll对象中添加、修改、删除事件时，从rbr红黑树中查找事件也非常快，也就是说epoll是非常高效的，它可以轻易地处理百万级别的并发连接。</p></li></ul><h2 id="假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？-其实就是不间断的提供服务，参考nginx的平滑升级"><a href="#假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？-其实就是不间断的提供服务，参考nginx的平滑升级" class="headerlink" title="假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？(其实就是不间断的提供服务，参考nginx的平滑升级)"></a>假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？(其实就是不间断的提供服务，参考nginx的平滑升级)</h2><blockquote><p>参考 <a href="http://www.manongjc.com/detail/55-ddjnjhttaswtzpx.html">1</a></p></blockquote><p>简单想法：向代理服务器中添加新服务器ip，新服务器上运行新任务，新来的连接均导向新服务器。</p><h2 id="HTTP报文都有哪些字段？"><a href="#HTTP报文都有哪些字段？" class="headerlink" title="HTTP报文都有哪些字段？"></a>HTTP报文都有哪些字段？</h2><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230313115843376.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230313120014727.png"></p><p><strong>url和host区别</strong></p><p>url里面除了域名还包括端口号，当不指定时是默认端口号，url可使得同一台主机提供多个http服务。</p><p>通过host指定应用，你可以用相同的IP+端口访问不同的应用，而不必担心端口问题。例如nginx以下配置，server_name就是通过host来比较：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">server<span class="token punctuation">&#123;</span>    listen <span class="token number">80</span>;    server_name www.webkit.cc;    root /path/to/your/root/directory/;    index  index.html;<span class="token punctuation">&#125;</span>server<span class="token punctuation">&#123;</span>    listen <span class="token number">80</span>;    server_name another—website.com;    root /another/root/directory/;    index  index.html;<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一个请求到来具体的处理过程是怎样的"><a href="#一个请求到来具体的处理过程是怎样的" class="headerlink" title="一个请求到来具体的处理过程是怎样的"></a>一个请求到来具体的处理过程是怎样的</h2><ol><li>首先通过listenfd建立TCP连接，然后使用epoll通知程序调用listenfd的accept来获取连接</li><li>然后使用封装好的TcpConnection类来封装连接信息，为平衡个处理线程的负载，采取不断循环将此连接信息分配到各线程，然后使用eventfd将处理线程唤醒。</li><li>处理线程将此连接注册到所属线程的epoll上，当有消息进入时epoll_wait不再阻塞，将信息读入此连接所属缓存区中，然后从缓冲区中读出信息并进行处理。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221110214042301.png"></p><h2 id="线程的唤醒还有哪些方式？"><a href="#线程的唤醒还有哪些方式？" class="headerlink" title="线程的唤醒还有哪些方式？"></a>线程的唤醒还有哪些方式？</h2><blockquote><p>参考 <a href="handleR">1</a></p></blockquote><p>epoll等机制本身可以设置一个超时时间，但有时需要将epoll立即唤醒处理事件，可使用以下机制：</p><ol><li>使用eventfd方式，每个线程所使用的eventloop都会有一个eventfd，并将其注册到所属的epoll上，当需要唤醒此线程时，只需要向此eventfd写入一个1个64位的数即可。</li><li>使用管道<code>fd</code>，创建一个管道，将管道的一端（管道<code>fd</code>中的一个）绑定到<code>epollfd</code>上，需要唤醒时，向管道的另一端写入1字节，工作线程就立即被唤醒；</li><li>使用<code>socketpair</code>，<code>socketpair</code>是一对相互连接的<code>socket</code>，相当于服务器和客户端的两个端点，每一端都可以读写数据，向其中一端写入数据后，就可以从另一端读取数据了。</li></ol><p>其他的诸如pthread_cond_wait&#x2F;signal、semaphore等机制不好与epoll等结合。</p><h2 id="怎么检查内存泄漏的？"><a href="#怎么检查内存泄漏的？" class="headerlink" title="怎么检查内存泄漏的？"></a>怎么检查内存泄漏的？</h2><blockquote><p>参考<a href="%E6%80%8E%E4%B9%88%E6%A3%80%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%EF%BC%9F">1</a> <a href="https://sites.google.com/site/shuzhifeng/linux-ping-tai-zhong-diao-shi-c-c-nei-cun-xie-lou-fang-fa">2</a></p></blockquote><p>主要分为静态分析和动态分析：</p><ul><li>静态分析：<ul><li>review原来带，判断申请内存和释放内存是否匹配</li><li>参考1，重载new和delete等操作符，每次申请内存时多申请一块内存作为一个链表节点，当释放内存时重链表中删除此节点。最终如果链表为空则说明不存在内存泄露。</li></ul></li><li>动态分析：使用一些实时检测工具valgrind, Rational purify</li></ul><h2 id="用到了哪些智能指针和RAII机制，几种锁的区别是什么"><a href="#用到了哪些智能指针和RAII机制，几种锁的区别是什么" class="headerlink" title="用到了哪些智能指针和RAII机制，几种锁的区别是什么"></a>用到了哪些智能指针和RAII机制，几种锁的区别是什么</h2><p><strong>智能指针使用</strong>：</p><ul><li>unique_ptr: 包括Poller，Channel，Socket等</li><li>shared_ptr：TcpConnection、thread、EventLoopThreadPoll</li><li>weak_ptr：Channel中使用一个tie_来判断此channel是否被释放</li></ul><p><strong>几种锁定义及特点</strong>：</p><ul><li>互斥锁：对于读者和写者来说。只要有一方获取了锁，另一方则不能继续获取，进而执行临界区代码。</li><li>读写锁：读写锁适合于对数据结构的读次数比写次数多得多的情况.因为,读模式锁定时可以共享,以写 模式锁住时意味着独占,所以读写锁又叫共享-独占锁.</li><li>自旋锁：轮询忙等待。被自旋锁保护的临界区代码执行时不能进行挂起状态。自旋锁的初衷就是在短期间内进行轻量级的锁定。一个被争用的自旋锁使得请求它的线程在等待锁重新可用的期间进行不断轮询，所以自旋锁不应该被持有时间过长。如果需要长时间锁定的话, 最好使用信号量。</li></ul><h2 id="任务队列是怎么实现的，除了加锁还有什么方式"><a href="#任务队列是怎么实现的，除了加锁还有什么方式" class="headerlink" title="任务队列是怎么实现的，除了加锁还有什么方式"></a>任务队列是怎么实现的，除了加锁还有什么方式</h2><p>可用CAS原子操作实现，见无锁队列实现</p><h2 id="如何解决死锁"><a href="#如何解决死锁" class="headerlink" title="如何解决死锁"></a>如何解决死锁</h2><p><strong>死锁的必要条件</strong></p><ol><li>互斥：一个执行流获取互斥锁后，其它执行流不能再获取该锁；</li><li>不可剥夺：A执行流拿着锁，其它执行流不能释放；</li><li>循环等待：多个执行流拿着对方想要的锁，并且各执行流还去请求对方的锁；</li><li>请求与保持：执行流本身使用着一把锁并不释放，还在请求别的锁；</li></ol><p><strong>解决死锁的几种算法</strong></p><ol><li>有序资源分配法：所有资源的使用都要有序的使用，要保证资源一次申请完且在申请不同类资源时，必须按各类设备的编号依次申请</li><li>银行家算法：一个银行家的借贷业务，必须保证其借贷人在一定时间内归还本金，以至于资金可以顺利周转，不至于倒闭。</li></ol><p><strong>死锁的预防和恢复</strong></p><ol><li>资源掠夺法：当前系统中存在多个死锁程序时，选择葫芦一部分死锁程序，并抢占他的资源，将这些稀有分配给其他进程使用，直到死锁不存在为止；</li><li>撤销进程法：放弃处于死锁进程中的进程，直接撤销该进程，直到死锁不存在为止；</li><li>进程回退法：进程自按获取顺序自愿放弃获取的资源，系统保存进程的历史信息，设置还原点。</li></ol><h2 id="怎么进行压测的"><a href="#怎么进行压测的" class="headerlink" title="怎么进行压测的"></a>怎么进行压测的</h2><h2 id="为什么要用非阻塞io"><a href="#为什么要用非阻塞io" class="headerlink" title="为什么要用非阻塞io"></a>为什么要用非阻塞io</h2><p>如果使用阻塞io，会在数据准备阶段等待大量时间，而在等待期间线程会被挂起，若想此时处理其他任务就只能开启其他线程进行处理。</p><p>网络任务通常会有大量连接，如果每个连接都阻塞在数据准备阶段，则需要巨量线程来处理连接，会给线程调度带来巨大挑战，并导致数据处理效率降低、</p><h2 id="为什么要做这个项目"><a href="#为什么要做这个项目" class="headerlink" title="为什么要做这个项目"></a>为什么要做这个项目</h2><p>。。</p><h2 id="Reactor模式是什么"><a href="#Reactor模式是什么" class="headerlink" title="Reactor模式是什么"></a>Reactor模式是什么</h2><p>见1.4节</p><h1 id="5-出现哪些问题，如何解决"><a href="#5-出现哪些问题，如何解决" class="headerlink" title="5. 出现哪些问题，如何解决"></a>5. 出现哪些问题，如何解决</h1><p>一些小错误，使用eventfd唤醒时，向其中写入64位的数，判断的是写入1个字节，应该判断写入8个字节。</p><h2 id="5-1-有的连接shutdown错误，且会出现有的连接revent报错-errno-x3D-32，"><a href="#5-1-有的连接shutdown错误，且会出现有的连接revent报错-errno-x3D-32，" class="headerlink" title="5.1 有的连接shutdown错误，且会出现有的连接revent报错 errno&#x3D;32，"></a>5.1 有的连接shutdown错误，且会出现有的连接revent报错 errno&#x3D;32，</h2><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p>1000个客户端 60s</p><p>短连接</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328164436193.png"></p><p>线程池为4</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328170702370.png"></p><p>长连接</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328164909909.png"></p><p>线程池为4</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328170456563.png"></p><p>muduo测试</p><p>短连接</p><p>线程池为0</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328165926466.png"></p><p>线程池为4</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328170105847.png"></p><p>长连接</p><p>线程池为0</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328165709766.png"></p><p>线程池为4</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20230328165352821.png"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> muduo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>236. 二叉树的最近公共祖先</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h1><p>First：递归解法挺巧妙，但还是没写出来</p><hr><p><strong>方法1</strong>：<strong>递归遍历</strong></p><p>原理值得细看，原来只是知其然不知其所以然。<a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">解析</a></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        if(root&#x3D;&#x3D;nullptr||root&#x3D;&#x3D;p||root&#x3D;&#x3D;q) return root;        TreeNode *left&#x3D;lowestCommonAncestor(root-&gt;left,p,q);        TreeNode *right&#x3D;lowestCommonAncestor(root-&gt;right,p,q);        if(left&#x3D;&#x3D;nullptr) return right;        if(right&#x3D;&#x3D;nullptr) return left;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>根据路径判断</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>450. 删除二叉搜索树中的节点</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h1><p>First：方法不难，记一下细节</p><hr><p><strong>方法1</strong>：<strong>递归遍历</strong></p><p>由于当前被删节点是可能有父节点，父节点要删除此子节点，因此遍历时返回TreeNode*指针。先找到被删节点，如果被删节点左右孩子有一个不为空，返回不为空的那个即可。如果都不为空，则将右子树的左子树移到root的左子树的最右边或者直接将root的右子树移动到root的左子树的最右边</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    TreeNode* deleteNode(TreeNode* root, int key) &#123;        if(root&#x3D;&#x3D;nullptr) return root;        if(root-&gt;val&#x3D;&#x3D;key)&#123;            if(root-&gt;right&#x3D;&#x3D;nullptr) return root-&gt;left;            else if(root-&gt;left&#x3D;&#x3D;nullptr) return root-&gt;right;            else&#123;                &#x2F;&#x2F;法1 将右子树的左子树移到root的左子树的最右边                &#x2F;&#x2F; TreeNode *sonLeft&#x3D;root-&gt;right-&gt;left;                &#x2F;&#x2F; root-&gt;val&#x3D;root-&gt;right-&gt;val;                &#x2F;&#x2F; root-&gt;right&#x3D;root-&gt;right-&gt;right;                &#x2F;&#x2F; TreeNode *p&#x3D;root-&gt;left;                &#x2F;&#x2F; if(sonLeft!&#x3D;nullptr)&#123;                &#x2F;&#x2F;     while(p-&gt;right!&#x3D;nullptr)&#123;                &#x2F;&#x2F;     p&#x3D;p-&gt;right;                &#x2F;&#x2F;     &#125;                &#x2F;&#x2F;     p-&gt;right&#x3D;sonLeft;                &#x2F;&#x2F; &#125;                &#x2F;&#x2F;法2 直接将root的右子树移动到root的左子树的最右边                TreeNode *p&#x3D;root-&gt;left;                while(p-&gt;right!&#x3D;nullptr)&#123;                    p&#x3D;p-&gt;right;                &#125;                p-&gt;right&#x3D;root-&gt;right;                root&#x3D;root-&gt;left;            &#125;        &#125;else if(root-&gt;val&lt;key)&#123;            root-&gt;right&#x3D;deleteNode(root-&gt;right,key);        &#125;else&#123;            root-&gt;left&#x3D;deleteNode(root-&gt;left,key);        &#125;        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>617. 合并二叉树</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-simple/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h1><p>First：比较简单，只是解析答案有些巧妙，记录下</p><hr><p><strong>方法1</strong>：<strong>递归</strong></p><p>开始使用的创建新树来做，代码随想录的解法巧妙些。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    TreeNode* createTree(TreeNode* root1,TreeNode* root2)&#123;        if(root1&#x3D;&#x3D;nullptr&amp;&amp;root2&#x3D;&#x3D;nullptr) return nullptr;                int val1&#x3D;0,val2&#x3D;0;        if(root1!&#x3D;nullptr)&#123;            val1&#x3D;root1-&gt;val;        &#125;        if(root2!&#x3D;nullptr)&#123;            val2&#x3D;root2-&gt;val;        &#125;        TreeNode *root&#x3D;new TreeNode(val1+val2);        root-&gt;left&#x3D;createTree(root1&#x3D;&#x3D;nullptr?nullptr:root1-&gt;left,root2&#x3D;&#x3D;nullptr?nullptr:root2-&gt;left);        root-&gt;right&#x3D;createTree(root1&#x3D;&#x3D;nullptr?nullptr:root1-&gt;right,root2&#x3D;&#x3D;nullptr?nullptr:root2-&gt;right);        return root;    &#125;    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;        &#x2F;&#x2F;方法1 效率有点低        &#x2F;&#x2F; return createTree(root1,root2);        &#x2F;&#x2F;方法2 代码随想录,挺巧妙的        if(root1&#x3D;&#x3D;nullptr) return root2;        if(root2&#x3D;&#x3D;nullptr) return root1;        root1-&gt;val+&#x3D;root2-&gt;val;        root1-&gt;left&#x3D;mergeTrees(root1-&gt;left,root2-&gt;left);        root1-&gt;right&#x3D;mergeTrees(root1-&gt;right,root2-&gt;right);        return root1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>669. 修剪二叉搜索树</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h1><p>First：在细节处折腾挺久</p><hr><p><strong>方法1</strong>：<strong>后续遍历</strong></p><p>对于每个节点都需要进行判断是否满足要求，如果不满足要求那么在子节点中找到一个满足要求的进行填充，因此先对子节点进行判断，如果节点不满足要求才使用子节点进行替代，那么就应该使用后序遍历。</p><p>判断当前节点是否满足要求，如果不满足要求，则使用left或right中不为空的那个（当前节点不满足要求则说明left和right中最多只有一个不为空），若都为nullptr，则说明找不到替代节点，返回nullptr。若满足要求，返回当前节点既可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;        if(root&#x3D;&#x3D;nullptr) return nullptr;        root-&gt;left&#x3D;trimBST(root-&gt;left,low,high);        root-&gt;right&#x3D;trimBST(root-&gt;right,low,high);        if(root-&gt;val&gt;high||root-&gt;val&lt;low)&#123;            if(root-&gt;left!&#x3D;nullptr) root&#x3D;root-&gt;left;            else if(root-&gt;right!&#x3D;nullptr) root&#x3D;root-&gt;right;            else root&#x3D;nullptr;        &#125;        return root;    &#125;&#125;;&#x2F;&#x2F;代码随想录中的class Solution &#123;public:    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;        if (root &#x3D;&#x3D; nullptr) return nullptr;        if (root-&gt;val &lt; low) return trimBST(root-&gt;right, low, high);        if (root-&gt;val &gt; high) return trimBST(root-&gt;left, low, high);        root-&gt;left &#x3D; trimBST(root-&gt;left, low, high);        root-&gt;right &#x3D; trimBST(root-&gt;right, low, high);        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>98. 验证二叉搜索树</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h1><p>First：不难，使用中序遍历来验证即可，记录下技巧</p><hr><p><strong>方法1</strong>：<strong>中序遍历</strong></p><p>使用中序遍历，每次比较当前节点和前一个节点的大小，如果小于或等于前一个节点，则将flag置为false。使用TreeNode* last来记录上一个节点（使用数值来记录会有相同值影响）。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    bool flag;    TreeNode* last;&#x2F;&#x2F;last设置为数字会有一些局限性public:    void midorder(TreeNode* root)&#123;        if(flag&#x3D;&#x3D;false) return;        if(root&#x3D;&#x3D;nullptr) return;        midorder(root-&gt;left);        if(last!&#x3D;nullptr&amp;&amp;root-&gt;val&lt;&#x3D;last-&gt;val) flag&#x3D;false;        last&#x3D;root;        midorder(root-&gt;right);    &#125;    bool isValidBST(TreeNode* root) &#123;        flag&#x3D;true;        last&#x3D;nullptr;        midorder(root);        return flag;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 07. 重建二叉树</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-%E5%89%91%E6%8C%87Offer07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-%E5%89%91%E6%8C%87Offer07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/description/">剑指 Offer 07. 重建二叉树</a></h1><p>First：自己递归写的效率太低</p><hr><p><strong>方法1</strong>：<strong>递归</strong></p><p>每次找到新的preorder和inorder，不断递归遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        if(preorder.size()&#x3D;&#x3D;0&amp;&amp;inorder.size()&#x3D;&#x3D;0) return nullptr;        TreeNode *root&#x3D;new TreeNode(preorder[0]);        unordered_set&lt;int&gt; mset;        vector&lt;int&gt; curInFir,curInSec;        int idx&#x3D;0;        while(inorder[idx]!&#x3D;preorder[0]) &#123;            mset.insert(inorder[idx]);            curInFir.push_back(inorder[idx++]);        &#125;        ++idx;        while(idx&lt;inorder.size())&#123;            curInSec.push_back(inorder[idx++]);        &#125;        vector&lt;int&gt; curPreFir,curPreSec;        for(int i&#x3D;1;i&lt;preorder.size();++i)&#123;            if(mset.count(preorder[i]))&#123;                curPreFir.push_back(preorder[i]);            &#125;else&#123;                curPreSec.push_back(preorder[i]);            &#125;        &#125;        root-&gt;left&#x3D;buildTree(curPreFir,curInFir);        root-&gt;right&#x3D;buildTree(curPreSec,curInSec);        return root;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>递归</strong></p><p>前序遍历性质： 节点按照 <code>[ 根节点 | 左子树 | 右子树 ]</code> 排序。 中序遍历性质： 节点按照 <code>[ 左子树 | 根节点 | 右子树 ]</code> 排序。</p><p>只需要不断找到根节点从而构建树即可，左子树的根节点可由当前根节点在前序遍历中+1即可，右子树的根节点则需要先找到左子树的元素个数，然后即可找到右子树的根节点。使用一组left和right来指向当前树在inorder中的边界。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;int&gt; mpreorder;    unordered_map&lt;int,int&gt; map;    &#x2F;&#x2F;前序遍历的根节点，在中序遍历的左边界和右边界    TreeNode* build(int cur,int left,int right)&#123;        if(left&gt;right) return nullptr;        TreeNode *root&#x3D;new TreeNode(mpreorder[cur]);        int idx&#x3D;map[mpreorder[cur]];        root-&gt;left&#x3D;build(cur+1,left,idx-1);        root-&gt;right&#x3D;build(cur+idx-left+1,idx+1,right);        return root;    &#125;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        mpreorder&#x3D;preorder;        for(int i&#x3D;0;i&lt;inorder.size();++i)&#123;            map[inorder[i]]&#x3D;i;        &#125;        return build(0,0,preorder.size()-1);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 33. 二叉搜索树的后序遍历序列</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-%E5%89%91%E6%8C%87Offer33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode-%E5%89%91%E6%8C%87Offer33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/description/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h1><p>First：没写出来，还是没深刻理解到后序遍历的规律。题解中的单调栈后面还需要看懂。</p><hr><p><strong>方法1</strong>：<strong>递归分治</strong></p><p>后序遍历是[ 左子树 | 右子树 | 根节点 ]形式，而最后一个点是根节点，左子树中的节点都小于根节点，因此找到第一个大于根节点的数即为右子树区间的第一个节点，因而三个区间都可以得出了。右子树中的节点需要大于根节点，因此不满足要求的返回false。</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool traverse(vector&lt;int&gt;&amp; postorder,int start,int end)&#123;        if(start&gt;&#x3D;end) return true;        int idx&#x3D;start;        while(idx&lt;&#x3D;end&amp;&amp;postorder[idx]&lt;postorder[end]) ++idx;        int tmp&#x3D;idx;        while(tmp&lt;&#x3D;end) &#123;            if(postorder[tmp++]&lt;postorder[end]) return false;        &#125;        return traverse(postorder,start,idx-1)&amp;&amp;traverse(postorder,idx,end-1);    &#125;    bool verifyPostorder(vector&lt;int&gt;&amp; postorder) &#123;        return traverse(postorder,0,postorder.size()-1);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>单调栈</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
            <tag> Alg-单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的递归遍历理论笔记</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E7%A1%80%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E7%A1%80%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h1><p>对于前中后序的递归遍历，有统一的框架，只是读节点所处位置不同</p><p><strong>前序遍历</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) &#123;        if (cur &#x3D;&#x3D; NULL) return;        vec.push_back(cur-&gt;val);    &#x2F;&#x2F; 中        traversal(cur-&gt;left, vec);  &#x2F;&#x2F; 左        traversal(cur-&gt;right, vec); &#x2F;&#x2F; 右    &#125;    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        traversal(root, result);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中序遍历</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) &#123;    if (cur &#x3D;&#x3D; NULL) return;    traversal(cur-&gt;left, vec);  &#x2F;&#x2F; 左    vec.push_back(cur-&gt;val);    &#x2F;&#x2F; 中    traversal(cur-&gt;right, vec); &#x2F;&#x2F; 右&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>后序遍历</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) &#123;    if (cur &#x3D;&#x3D; NULL) return;    traversal(cur-&gt;left, vec);  &#x2F;&#x2F; 左    traversal(cur-&gt;right, vec); &#x2F;&#x2F; 右    vec.push_back(cur-&gt;val);    &#x2F;&#x2F; 中&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h1><p><strong>前序遍历</strong></p><p>前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; st;        vector&lt;int&gt; result;        if (root &#x3D;&#x3D; NULL) return result;        st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();                       &#x2F;&#x2F; 中            st.pop();            result.push_back(node-&gt;val);            if (node-&gt;right) st.push(node-&gt;right);           &#x2F;&#x2F; 右（空节点不入栈）            if (node-&gt;left) st.push(node-&gt;left);             &#x2F;&#x2F; 左（空节点不入栈）        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>中序遍历</strong></p><p>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;自己写得中序遍历迭代，但这会对原来的树进行修改class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        if(root&#x3D;&#x3D;nullptr) return&#123;&#125;;        &#x2F;&#x2F;迭代法        vector&lt;int&gt; ans;        stack&lt;TreeNode*&gt; st;        st.push(root);        while(!st.empty())&#123;            TreeNode *tem&#x3D;st.top();            while(tem-&gt;left!&#x3D;nullptr)&#123;                st.push(tem-&gt;left);                TreeNode *k&#x3D;tem;                tem&#x3D;tem-&gt;left;                k-&gt;left&#x3D;nullptr;&#x2F;&#x2F;left已经添加了，如不置为nullptr则会重复一直添加            &#125;            tem&#x3D;st.top();            st.pop();            ans.push_back(tem-&gt;val);            if(tem-&gt;right!&#x3D;nullptr) st.push(tem-&gt;right);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;代码随想录中的解法，将遍历节点和处理节点进行分开，使用一个指针来指向遍历节点class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        TreeNode* cur &#x3D; root;        while (cur !&#x3D; NULL || !st.empty()) &#123;            if (cur !&#x3D; NULL) &#123; &#x2F;&#x2F; 指针来访问节点，访问到最底层                st.push(cur); &#x2F;&#x2F; 将访问的节点放进栈                cur &#x3D; cur-&gt;left;                &#x2F;&#x2F; 左            &#125; else &#123;                cur &#x3D; st.top(); &#x2F;&#x2F; 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）                st.pop();                result.push_back(cur-&gt;val);     &#x2F;&#x2F; 中                cur &#x3D; cur-&gt;right;               &#x2F;&#x2F; 右            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>后序遍历</strong></p><p>先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20221023170330174.png" alt="image-20221023170330174"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; st;        vector&lt;int&gt; result;        if (root &#x3D;&#x3D; NULL) return result;        st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();            st.pop();            result.push_back(node-&gt;val);            if (node-&gt;left) st.push(node-&gt;left); &#x2F;&#x2F; 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）            if (node-&gt;right) st.push(node-&gt;right); &#x2F;&#x2F; 空节点不入栈        &#125;        reverse(result.begin(), result.end()); &#x2F;&#x2F; 将结果反转之后就是左右中的顺序了        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h1><p>以中序遍历为例，使用栈的话，<strong>无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况</strong>。</p><p><strong>那就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</strong></p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p><p>简单说，先判断栈顶元素是否为空指针，如果是则说明其后面元素是处理元素，如果不是则说明应对栈顶元素进行遍历，先将其弹出，以前中后序将其与其左右节点重新排序，然后压入栈中。</p><p><strong>中序遍历</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        if (root !&#x3D; NULL) st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();            if (node !&#x3D; NULL) &#123;                st.pop(); &#x2F;&#x2F; 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中                if (node-&gt;right) st.push(node-&gt;right);  &#x2F;&#x2F; 添加右节点（空节点不入栈）                st.push(node);                          &#x2F;&#x2F; 添加中节点                st.push(NULL); &#x2F;&#x2F; 中节点访问过，但是还没有处理，加入空节点做为标记。                if (node-&gt;left) st.push(node-&gt;left);    &#x2F;&#x2F; 添加左节点（空节点不入栈）            &#125; else &#123; &#x2F;&#x2F; 只有遇到空节点的时候，才将下一个节点放进结果集                st.pop();           &#x2F;&#x2F; 将空节点弹出                node &#x3D; st.top();    &#x2F;&#x2F; 重新取出栈中元素                st.pop();                result.push_back(node-&gt;val); &#x2F;&#x2F; 加入到结果集            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>前序排序</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        if (root !&#x3D; NULL) st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();            if (node !&#x3D; NULL) &#123;                st.pop();                if (node-&gt;right) st.push(node-&gt;right);  &#x2F;&#x2F; 右                if (node-&gt;left) st.push(node-&gt;left);    &#x2F;&#x2F; 左                st.push(node);                          &#x2F;&#x2F; 中                st.push(NULL);            &#125; else &#123;                st.pop();                node &#x3D; st.top();                st.pop();                result.push_back(node-&gt;val);            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>后序排序</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; result;        stack&lt;TreeNode*&gt; st;        if (root !&#x3D; NULL) st.push(root);        while (!st.empty()) &#123;            TreeNode* node &#x3D; st.top();            if (node !&#x3D; NULL) &#123;                st.pop();                st.push(node);                          &#x2F;&#x2F; 中                st.push(NULL);                if (node-&gt;right) st.push(node-&gt;right);  &#x2F;&#x2F; 右                if (node-&gt;left) st.push(node-&gt;left);    &#x2F;&#x2F; 左            &#125; else &#123;                st.pop();                node &#x3D; st.top();                st.pop();                result.push_back(node-&gt;val);            &#125;        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><p><strong>迭代解法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;自己写得，但不够简洁class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        if(root&#x3D;&#x3D;nullptr) return &#123;&#125;;        vector&lt;vector&lt;int&gt;&gt; ans;        vector&lt;int&gt; layer;        queue&lt;TreeNode*&gt; que;        que.push(root);        int curLen&#x3D;1,nextLen&#x3D;0;        while(!que.empty())&#123;            TreeNode *tem&#x3D;que.front();            que.pop();            if(tem-&gt;left)&#123;                que.push(tem-&gt;left);                ++nextLen;            &#125;            if(tem-&gt;right)&#123;                que.push(tem-&gt;right);                ++nextLen;            &#125;            layer.push_back(tem-&gt;val);            --curLen;            if(curLen&#x3D;&#x3D;0)&#123;                ans.push_back(layer);                layer&#x3D;vector&lt;int&gt;&#123;&#125;;                curLen&#x3D;nextLen;                nextLen&#x3D;0;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;代码随想录中的，简洁明了，处理一些复杂情况时逻辑更加清晰class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        queue&lt;TreeNode*&gt; que;        if (root !&#x3D; NULL) que.push(root);        vector&lt;vector&lt;int&gt;&gt; result;        while (!que.empty()) &#123;            int size &#x3D; que.size();            vector&lt;int&gt; vec;            &#x2F;&#x2F; 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的            for (int i &#x3D; 0; i &lt; size; i++) &#123;                TreeNode* node &#x3D; que.front();                que.pop();                vec.push_back(node-&gt;val);                if (node-&gt;left) que.push(node-&gt;left);                if (node-&gt;right) que.push(node-&gt;right);            &#125;            result.push_back(vec);        &#125;        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>递归法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"># 递归法class Solution &#123;public:    void order(TreeNode* cur, vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth)    &#123;        if (cur &#x3D;&#x3D; nullptr) return;        if (result.size() &#x3D;&#x3D; depth) result.push_back(vector&lt;int&gt;());        result[depth].push_back(cur-&gt;val);        order(cur-&gt;left, result, depth + 1);        order(cur-&gt;right, result, depth + 1);    &#125;    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        int depth &#x3D; 0;        order(root, result, depth);        return result;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>475. 供暖器</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="475-供暖器"><a href="#475-供暖器" class="headerlink" title="475. 供暖器"></a><a href="https://leetcode.cn/problems/heaters/description/">475. 供暖器</a></h1><p>First：这道题折腾了老久，方法上虽然知道了，但在边界处理上一直不行，最后看了一个评论说将所有数转为负数处理会更方便，真走进思维误区了。</p><hr><p><strong>方法1</strong>：<strong>二分查找</strong></p><p>由于不能用除法，那么先假设其商cur为1，此时divisorL&#x3D;divisor。如果divisorL&lt;dividend，那么将cur和divisorL都翻倍，如果此时divisorL&gt;dividend，则说明答案在cur&#x2F;2到cur之间。对此，可以使用递归对dividend-divisorL&#x2F;2求商，最后将结果相加即可。</p><p>此题不好处理的是正负数越界问题，为方便处理，需要将除数和被除数都转变为正数或负数，由于负数的临界值的绝对值比正数大，将所有数准变为负数进行处理更加方便。</p><ul><li>时间复杂度：O(logn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int divide(int dividend, int divisor) &#123;         int flag&#x3D;1;        if(dividend&gt;0)&#123;            dividend&#x3D;-dividend;            flag*&#x3D;-1;        &#125;        if(divisor&gt;0)&#123;            divisor&#x3D;-divisor;            flag*&#x3D;-1;        &#125;        if(divisor&lt;dividend) return 0;        long divisorL&#x3D;divisor;        long cur&#x3D;1;        while(divisorL&gt;&#x3D;dividend)&#123;            if(divisorL&#x3D;&#x3D;dividend) &#123;                if(flag*cur&gt;INT_MAX) return INT_MAX;                return flag*cur;            &#125;            cur+&#x3D;cur;            divisorL+&#x3D;divisorL;        &#125;        divisorL&gt;&gt;&#x3D;1;        cur&gt;&gt;&#x3D;1;        return flag*(cur+divide(dividend-divisorL,divisor));    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>475. 供暖器</title>
      <link href="/2023/02/15/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-475-%E4%BE%9B%E6%9A%96%E5%99%A8-middle/"/>
      <url>/2023/02/15/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/leetcode-475-%E4%BE%9B%E6%9A%96%E5%99%A8-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="475-供暖器"><a href="#475-供暖器" class="headerlink" title="475. 供暖器"></a><a href="https://leetcode.cn/problems/heaters/description/">475. 供暖器</a></h1><p>First：使用二分查找时，找上边界泽腾了挺久</p><hr><p><strong>方法1</strong>：<strong>对供暖器位置二分查找</strong></p><p>对于每间屋子，找到离它最近的供暖器，然后取所有最近值中的最大值即为供暖器半径。注意二分查找时，需要比较左右两个供暖器。</p><ul><li>时间复杂度：O((n+m)logn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isEnough(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters,int radius)&#123;        int i&#x3D;0,j&#x3D;0;        while(i&lt;houses.size()&amp;&amp;j&lt;heaters.size())&#123;            if(houses[i]&gt;&#x3D;heaters[j]-radius&amp;&amp;houses[i]&lt;&#x3D;heaters[j]+radius) ++i;            else ++j;        &#125;        if(j&gt;&#x3D;heaters.size()&amp;&amp;i&lt;houses.size()) return false;        return true;    &#125;    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;        sort(heaters.begin(),heaters.end());        int ans&#x3D;0;        for(auto &amp;house:houses)&#123;            int left&#x3D;0,right&#x3D;heaters.size()-1;            while(left&lt;right)&#123;                int mid&#x3D;left+(right-left)&#x2F;2;                if(heaters[mid]&lt;house) left&#x3D;mid+1;                else right&#x3D;mid;            &#125;            int t&#x3D;0;            if(left&lt;1) t&#x3D;abs(heaters[left]-house);            else t&#x3D;min(abs(heaters[left]-house),abs(heaters[left-1]-house));            ans&#x3D;max(ans,t);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法2</strong>：<strong>对供暖器半径二分查找</strong></p><p>直接使用二分查找判断每次半径是否满足要求，不断二分得到最终结果。需要注意的是二分查找边界等设定。</p><ul><li>时间复杂度：O((n+m)logn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isEnough(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters,int radius)&#123;        int i&#x3D;0,j&#x3D;0;        while(i&lt;houses.size()&amp;&amp;j&lt;heaters.size())&#123;            if(houses[i]&gt;&#x3D;heaters[j]-radius&amp;&amp;houses[i]&lt;&#x3D;heaters[j]+radius) ++i;            else ++j;        &#125;        if(j&gt;&#x3D;heaters.size()&amp;&amp;i&lt;houses.size()) return false;        return true;    &#125;    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;        sort(houses.begin(),houses.end());        sort(heaters.begin(),heaters.end());        int left&#x3D;0,right&#x3D;1e9;        while(left&lt;right)&#123;            int mid&#x3D;left+(right-left)&#x2F;2;            if(isEnough(houses,heaters,mid)) right&#x3D;mid;            else left&#x3D;mid+1;        &#125;        return left;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. 两数之和</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-1-simple/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-1-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h1><p>First：使用哈希表</p><hr><p><strong>方法1</strong>：<strong>哈希表</strong></p><p>直接使用哈希表判断是否存在数即可</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        if(nums.size()&lt;2) return &#123;&#125;;        unordered_map&lt;int,int&gt; s;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            auto f&#x3D;s.find(target-nums[i]);            if(f&#x3D;&#x3D;s.end())&#123;                s[nums[i]]&#x3D;i;            &#125;else&#123;                return &#123;f-&gt;second,i&#125;;            &#125;        &#125;        return &#123;&#125;;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>暴力法</strong></p><p>暴力遍历即可</p><ul><li>时间复杂度：O(n^2^)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 三数之和</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-15-middle/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-15-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h1><p>First：开始打算使用set来排除重复项，但太麻烦了。先进行排序，用一个哈希表记录下值和序号，然后用双重遍历找出结果。但这种打败比例很低，还是双指针快。</p><hr><p><strong>方法1</strong>：<strong>排序+哈希表</strong></p><p>先将数据进行排序，然后使用一个map记录下数组中的值和其出现的最大序号，然后使用双重遍历查找结果。为了避免重复值，遍历时遇见和前一个值相同时需要跳过。</p><ul><li>时间复杂度：O(n^2^)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        unordered_map&lt;int,int&gt; map;        int n&#x3D;nums.size();        for(int i&#x3D;0;i&lt;n;++i)&#123;            map[nums[i]]&#x3D;i;        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;             for(int i&#x3D;0;i&lt;n;++i)&#123;            if(nums[i]&gt;0) break;            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;            for(int j&#x3D;i+1;j&lt;n;++j)&#123;                if(nums[i]+nums[j]&gt;0) break;                if(j&gt;i+1&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]) continue;                int res&#x3D;-nums[i]-nums[j];                auto f&#x3D;map.find(res);                if(f!&#x3D;map.end())&#123;                    if(f-&gt;second&gt;j)&#123;                        ans.push_back(&#123;nums[i],nums[j],nums[f-&gt;second]&#125;);                    &#125;                &#125;            &#125;        &#125;                return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><hr><p><strong>方法2</strong>：<strong>排序+双指针</strong></p><p>先将数据进行排序，使用两重循环来遍历，第一重循环依次遍历数值i，第二重循环设置两个指针j、k分别指向数组前段和末端，如果i j k对应值相加小于0，则j右移；等于0，添加到结果中；大于0，则k左移。</p><ul><li>时间复杂度：O(n^2^)</li><li>空间复杂度：O(logn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> Alg-双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18. 四数之和</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-18-middle/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-18-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h1><p>First：将其当成四组数据再两两分组来做的话，感觉排除重复值太麻烦了。还是用的三重循环来做，但我先用的target减前两个值时，遇见了overflow情况，解决方法是先将target转为long long，虽然可以用加法但写起来不简洁且有可能也会overflow。</p><hr><p><strong>方法1</strong>：<strong>排序+双指针</strong></p><p>先将数组进行排序，然后类似三数求和那道题使用三重循环来做，外面写两重循环，在最里面一重循环中使用双指针来分别指向头部和尾部，若两个指针相加和小于值，则将左指针右移，大于则将右指针左移动，否则添加进结果容器中。</p><ul><li>时间复杂度：O(n^3^)</li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;        sort(nums.begin(),nums.end());        int n&#x3D;nums.size();        vector&lt;vector&lt;int&gt;&gt; ans;        for(int i&#x3D;0;i&lt;n;++i)&#123;            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;            for(int j&#x3D;i+1;j&lt;n;++j)&#123;                if(j&gt;i+1&amp;&amp;nums[j]&#x3D;&#x3D;nums[j-1]) continue;                long long remain&#x3D;(long long)target-nums[i]-nums[j];&#x2F;&#x2F;不转为long long有个例子会越界,转成long也不会报错，但迷惑的是long和int相同范围，猜测减法时long会提升到long long                for(int l&#x3D;j+1,r&#x3D;n-1;l&lt;r;)&#123;                    if(l&gt;j+1&amp;&amp;nums[l]&#x3D;&#x3D;nums[l-1])&#123;&#x2F;&#x2F;避免重复值                        ++l;                        continue;                    &#125;                    if(r&lt;n-1&amp;&amp;nums[r]&#x3D;&#x3D;nums[r+1])&#123;&#x2F;&#x2F;避免重复值                        --r;                        continue;                    &#125;                    int sum&#x3D;nums[l]+nums[r];                    if(sum&#x3D;&#x3D;remain)&#123;                        ans.push_back(&#123;nums[i],nums[j],nums[l],nums[r]&#125;);                        ++l;                    &#125;else if(sum&gt;remain)&#123;                        --r;                    &#125;else&#123;                        ++l;                    &#125;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202. 快乐数</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-202-%E5%BF%AB%E4%B9%90%E6%95%B0-simple/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-202-%E5%BF%AB%E4%B9%90%E6%95%B0-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h1><p>First：看到这题觉得值会越来越大，就没法判别无限大的情况，但是这种情况不会出现</p><p>Second: 22-11-19，干，虽然知道数到一定值后就不能再变大，但感觉也只能硬比，没想到再小区间中无限循环值是一定会重复的。</p><hr><p><strong>方法1</strong>：<strong>哈希表</strong></p><p>按题中描述，n可能出现三种情况：</p><ul><li>（1）循环得到1</li><li>（2）无限循环（存在环）</li><li>（3）值越来越大</li></ul><p>但是第三种情况不存在，观察下表可发现，随着原始值越大，其平方和后的数会变得很小（只要低于243以后，就不可能再回到243），所有值越来越大这种情况可以排除。</p><p>只需要考虑无限循环和得到1两种情况，在一个比较小的区间中无限循环必定存在环，因此此题也就变为是否存在环了。</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220912141214094.png" alt="image-20220912141214094"></p><ul><li>时间复杂度：O(logn) 计算方法可见官方解析</li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isHappy(int n) &#123;        unordered_set&lt;int&gt; s;        while(1)&#123;            int sum&#x3D;0;            while(n&gt;0)&#123;                sum+&#x3D;(n%10)*(n%10);                n&#x2F;&#x3D;10;            &#125;            if(sum&#x3D;&#x3D;1) return true;            if(s.count(sum)&gt;0) return false;            s.insert(sum);            n&#x3D;sum;        &#125;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>快慢指针</strong></p><p>使用快慢指针来判断是否有环</p><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int getSum(int n)&#123;        int sum&#x3D;0;        while(n&gt;0)&#123;            sum+&#x3D;(n%10)*(n%10);            n&#x2F;&#x3D;10;        &#125;        return sum;    &#125;    bool isHappy(int n) &#123;        int p&#x3D;n,q&#x3D;n;        while(1)&#123;            p&#x3D;getSum(p);            q&#x3D;getSum(q);            if(q&#x3D;&#x3D;1)return true;            q&#x3D;getSum(q);            if(q&#x3D;&#x3D;1)return true;            if(p&#x3D;&#x3D;q)return false;        &#125;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：数学</p><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> Alg-双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>204. 计数质数</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0-middle/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a><a href="https://leetcode.cn/problems/count-primes/description/">204. 计数质数</a></h1><p>First：刚开始的时候还判断了下是否属于质数，但细节问题导致超时了，后来想到直接每个质数倍乘，最后找出质数即可</p><hr><p><strong>方法1</strong>：<strong>埃氏筛</strong></p><p>如果x是质数，那么2x、3x一定不是质数，那么从2开始，不断将倍乘置为非质数，统计所有质数即可。</p><ul><li>时间复杂度：O(nloglogn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int countPrimes(int n) &#123;        vector&lt;int&gt; flags(n,0);        int ans&#x3D;0;        for(int i&#x3D;2;i&lt;n;++i)&#123;            if(flags[i]&#x3D;&#x3D;0)&#123;                if((long long) i*i&lt;n)&#123;                    for(int j&#x3D;i*i;j&lt;n;j+&#x3D;i)&#123;                        flags[j]&#x3D;1;                    &#125;                &#125;            &#125;        &#125;        for(int i&#x3D;2;i&lt;n;++i)&#123;            if(flags[i]&#x3D;&#x3D;0) &#123;                ++ans;            &#125;        &#125;        return ans;    &#125;&#125;;&#x2F;&#x2F;解析有点技巧，没有单独一次遍历来统计，因为找到的第一个flags[i]&#x3D;&#x3D;0就是质数class Solution &#123;public:    int countPrimes(int n) &#123;        vector&lt;int&gt; flags(n,0);        int ans&#x3D;0;        for(int i&#x3D;2;i&lt;n;++i)&#123;            if(flags[i]&#x3D;&#x3D;0)&#123;                ++ans;                if((long long) i*i&lt;n)&#123;                    for(int j&#x3D;i*i;j&lt;n;j+&#x3D;i)&#123;                        flags[j]&#x3D;1;                    &#125;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法1</strong>：<strong>线性筛</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>242. 有效的字母异位词</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-242-simple/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-242-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h1><p>First：直接定义一个数组来存储字母出现频率</p><hr><p><strong>方法1</strong>：<strong>哈希表</strong></p><p>定义两个数组来分别存储两个字符串中各自字符出现频率（官方解答中还有点优化空间，只定义一个数组来存储s频率，在遍历t时依次将s中对应字母个数减一，如减到小于0则返回false）</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(S) S为字符集大小</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isAnagram(string s, string t) &#123;        if(s.length()!&#x3D;t.length()) return false;        int sf[26]&#123;0&#125;,tf[26]&#123;0&#125;;        for(int i&#x3D;0;i&lt;s.length();++i)&#123;            sf[s[i]-&#39;a&#39;]++;            tf[t[i]-&#39;a&#39;]++;        &#125;        for(int i&#x3D;0;i&lt;26;++i)&#123;            if(sf[i]!&#x3D;tf[i]) return false;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>排序</strong></p><p>排序后比较是否相等</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>349. 两个数组的交集</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-349-simple/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-349-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h1><p>First：使用一个1001大小的数组来存储是否出现过</p><hr><p><strong>方法1</strong>：<strong>哈希表</strong></p><p>定义一个1001大小的数组来存储字符串s的频率，但这是已知值范围的情况下才可这么做。然后，直接遍历t中每个字符是否出现在频率数组中即可。</p><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(S) S为字符集大小</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int fq[1001]&#123;0&#125;;        vector&lt;int&gt; res;        for(int i&#x3D;0;i&lt;nums1.size();++i)&#123;            ++fq[nums1[i]];        &#125;        for(int i&#x3D;0;i&lt;nums2.size();++i)&#123;            if(fq[nums2[i]]&gt;0)&#123;                res.push_back(nums2[i]);                fq[nums2[i]]&#x3D;0;            &#125;        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>两个集合</strong></p><p>使用hash_set来存储出现过的字符，然后找相同字符</p><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(m+n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>383. 赎金信</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-383-simple/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-383-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h1><p>First：直接使用哈希表</p><hr><p><strong>方法1</strong>：<strong>哈希表</strong></p><p>直接使用哈希表或自己使用一个数组记录第二个字符串的字母出现次数，再遍历第一个字符串即可</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        if(ransomNote.size()&gt;magazine.size()) return false;        &#x2F;&#x2F; unordered_map&lt;char,int&gt; map;        &#x2F;&#x2F; for(auto c:magazine)&#123;        &#x2F;&#x2F;     ++map[c];        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; for(auto c:ransomNote)&#123;        &#x2F;&#x2F;     auto f&#x3D;map.find(c);        &#x2F;&#x2F;     if(f&#x3D;&#x3D;map.end()||f-&gt;second&lt;&#x3D;0)&#123;        &#x2F;&#x2F;         return false;        &#x2F;&#x2F;     &#125;else&#123;        &#x2F;&#x2F;         map[c]-&#x3D;1;        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; return true;        int col[26]&#123;0&#125;;        for(auto c:magazine)&#123;            ++col[c-&#39;a&#39;];        &#125;        for(auto c:ransomNote)&#123;            --col[c-&#39;a&#39;];            if(col[c-&#39;a&#39;]&lt;0)&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>454. 四数相加 II</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-454-middle/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-454-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h1><p>First：开始尝试了下三重循环做，但超时了。想过是否可以排除一些特殊分支，减少循环。想将两两分组来做，但感觉太麻烦了。</p><hr><p><strong>方法1</strong>：<strong>哈希表+两两分组</strong></p><p>将四组数据两两分组，将ab两组先加起来存储到哈希表中，再遍历cd两组数据，从哈希表中查找是否有满足循环的数据。</p><ul><li>时间复杂度：O(n^2^)</li><li>空间复杂度：O(n^2^)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;        unordered_map&lt;int,int&gt; ab;        for(auto a:nums1)&#123;            for(auto b:nums2)&#123;                ++ab[a+b];            &#125;        &#125;        int ans&#x3D;0;        for(auto c:nums3)&#123;            for(auto d:nums4)&#123;                auto f&#x3D;ab.find(-(c+d));                if(f!&#x3D;ab.end())&#123;                    ans+&#x3D;f-&gt;second;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>532. 数组中的 k-diff 数对</title>
      <link href="/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-532-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%20k-diff%20%E6%95%B0%E5%AF%B9-middle/"/>
      <url>/2023/02/15/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/leetcode-532-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%20k-diff%20%E6%95%B0%E5%AF%B9-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="532-数组中的-k-diff-数对"><a href="#532-数组中的-k-diff-数对" class="headerlink" title="532. 数组中的 k-diff 数对"></a><a href="https://leetcode.cn/problems/k-diff-pairs-in-an-array/description/">532. 数组中的 k-diff 数对</a></h1><p>FIrst：使用的方法1做出来，但效率不高，关键是去重的同时k&#x3D;0时也要能找到</p><hr><p><strong>方法1</strong>：<strong>排序+set</strong></p><p>先对数组进行从小到大排序，使用map存储已经出现的数字，再依次遍历数组，如果nums[i]-k已经在map中那么将nums[i]添加进set中，set自带去重。</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findPairs(vector&lt;int&gt;&amp; nums, int k) &#123;        int ans&#x3D;0;        sort(nums.begin(),nums.end());        set&lt;int&gt; ansSet;        unordered_map&lt;int,int&gt; map;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(map.find(nums[i]-k)!&#x3D;map.end())&#123;                ansSet.insert(nums[i])  ;            &#125;            map[nums[i]]&#x3D;1;                    &#125;        return ansSet.size();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>哈希表</strong></p><p>使用一个哈希表存储已经已经遍历过的值，依次遍历，由于不排序则需要判断当前值作为减数和被减数两种情况，注意！判断这两种情况时，如果找到数字则应该按相同规则将结果插入到set中，比如都插入被减数。最后统计set的大小即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findPairs(vector&lt;int&gt;&amp; nums, int k) &#123;        int ans&#x3D;0;        unordered_set&lt;int&gt; ansSet;        unordered_map&lt;int,int&gt; map;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(map.find(nums[i]-k)!&#x3D;map.end())&#123;                ansSet.insert(nums[i]);&#x2F;&#x2F;注意这里插入的数要按规则插，比如都插入被减数            &#125;            if(map.find(nums[i]+k)!&#x3D;map.end())&#123;                ansSet.insert(nums[i]+k);&#x2F;&#x2F;注意这里插入的数要按规则插，比如都插入被减数            &#125;            map[nums[i]]&#x3D;1;                    &#125;        return ansSet.size();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：<strong>排序+双指针</strong></p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1035. 不相交的线</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a><a href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></h1><p>First：虽然做出来了，但看了解析才知道可以转换为找最长公共子序列</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>要找不相交的线可以转换为找最长公共子序列（最长公共子序列之间的连线一定不相交，而最长又保证了不相交线是最多的）</p><p>使用二维dp数组来记录状态，dp[i] [j] 表示nums1前i个数和nums2前j个数公共子序列的长度。</p><p>当nums1[i]&#x3D;nums2[j]时，此时应该比dp[i-1] [j-1]多1。而不相等时，由于时找公共子序列的长度，那么dp[i] [j]&#x3D;max(dp[i-1] [j]，dp[i] [j-1])</p><p>皆初始化为0。</p><p>两重循环皆从小到大遍历</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(nums1.size()+1,vector&lt;int&gt;(nums2.size()+1,0));        for(int i&#x3D;1;i&lt;&#x3D;nums1.size();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;nums2.size();++j)&#123;                if(nums1[i-1]&#x3D;&#x3D;nums2[j-1])&#123;                    dp[i][j]&#x3D;dp[i-1][j-1]+1;                &#125;else&#123;                    dp[i][j]&#x3D;max(dp[i-1][j],dp[i][j-1]);                &#125;            &#125;        &#125;        return dp[nums1.size()][nums2.size()];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>组合数学</strong></p><p>从左上角到右下角的过程中，我们需要移动 m+n-2m+n−2 次，其中有 m-1m−1 次向下移动，n-1n−1 次向右移动。因此路径的总数，就等于从 m+n-2m+n−2 次移动中选择 m-1m−1 次向下移动的方案数，即组合数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922152234753.png" alt="image-20220922152234753"></p><ul><li>时间复杂度：O(m) </li><li>空间复杂度：O1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1049. 最后一块石头的重量 II</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h1><p>First：没想出来咋做，看了答案发现可以转换为01背包来做，还是对问题理解得不够深刻</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>问题实质就是将所有石头尽可能均分为2份，这两堆石头相互碰撞后就能得到最小重量。因此，先求所有石头重量之和，然后找0到sum&#x2F;2中最大能挑选出得石头重量之和，挑选方法和第343题类似，只是多了个flag来记录最大值即可。</p><ul><li>时间复杂度：O(sum × n) </li><li>空间复杂度：O(sum)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;        if(stones.size()&#x3D;&#x3D;1) return stones[0];        int sum&#x3D;0;        for(auto a:stones)&#123;            sum+&#x3D;a;        &#125;        int target&#x3D;sum&#x2F;2;        vector&lt;int&gt; dp(target+1,0);        int flag&#x3D;stones[0];        for(int i&#x3D;0;i&lt;stones.size();++i)&#123;            for(int j&#x3D;target;j&gt;&#x3D;stones[i];--j)&#123;                dp[j]&#x3D;max(dp[j],dp[j-stones[i]]+stones[i]);                if(dp[j]&#x3D;&#x3D;j) flag&#x3D;max(flag,j);&#x2F;&#x2F;找到最大能挑选出来得重量之和            &#125;        &#125;        return sum-2*flag;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1143. 最长公共子序列</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h1><p>First：和748题很像，只是在处理字符不相同情况时的处理方法不一样</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j] 表示text1前i个字符和text2前j个字符公共子序列的长度。</p><p>当text1[i]&#x3D;text2[j]时，此时应该比dp[i-1] [j-1]多1。而不相等时，由于时找公共子序列的长度，那么dp[i] [j]&#x3D;max(dp[i-1] [j]，dp[i] [j-1])</p><p>皆初始化为0。</p><p>两重循环皆从小到大遍历</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn) 可优化为n</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int longestCommonSubsequence(string text1, string text2) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(text1.length()+1,vector&lt;int&gt;(text2.length()+1,0));        int ans&#x3D;0;        for(int i&#x3D;1;i&lt;&#x3D;text1.length();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;text2.length();++j)&#123;                if(text2[j-1]&#x3D;&#x3D;text1[i-1])&#123;                    dp[i][j]&#x3D;dp[i-1][j-1]+1;                &#125;else&#123;                    dp[i][j]&#x3D;max(dp[i][j-1],dp[i-1][j]);                &#125;                ans&#x3D;max(ans,dp[i][j]);            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>115. 不同的子序列</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97-difficult/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></h1><p>First：没做出来，没推导出转移方程</p><p>Second：还是没做出来，淦</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j] 表示s的前i-1个字符的子序列中t的前j-1个字符出现的个数</p><p>当s[i - 1] 与 t[j - 1]相等，dp[i] [j]可以有两部分组成：一部分是用s[i - 1]来匹配，那么个数为dp[i - 1] [j - 1]。一部分是不用s[i - 1]来匹配，个数为dp[i - 1] [j]（这部分是因为s的第i-1个字符可选可不选，如果不选才能出现所有子序列匹配的情况）。 dp[i] [j] &#x3D; dp[i - 1] [j - 1] + dp[i - 1] [j]</p><p>当s[i - 1] 与 t[j - 1]不相等时，dp[i] [j]只有一部分组成，不用s[i - 1]来匹配，即：dp[i - 1] [j]</p><p>由定义可知，dp[i] [0]&#x3D;1（因为出现空字符个数为1）</p><p>dp[i] [j]由dp[i-1] [j-1]决定，因此需要以遍历s为外层，遍历t为内层循环。</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n^2^)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numDistinct(string s, string t) &#123;        vector&lt;vector&lt;unsigned int&gt;&gt; dp(s.length()+1,vector&lt;unsigned int&gt;(t.length()+1,0));        for(int i&#x3D;0;i&lt;&#x3D;s.length();++i)&#123;            dp[i][0]&#x3D;1;        &#125;        for(int i&#x3D;1;i&lt;&#x3D;s.length();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;t.length();++j)&#123;                if(s[i-1]&#x3D;&#x3D;t[j-1])&#123;                    dp[i][j]&#x3D;dp[i-1][j-1]+dp[i-1][j];                &#125;else&#123;                    dp[i][j]&#x3D;dp[i-1][j];                &#125;            &#125;        &#125;        return dp[s.length()][t.length()];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121. 买卖股票的最佳时机</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h1><p>First：卡住了，淦，dp时分成了三种状态：买、卖、持有，折腾了半天还是没把状态搞好</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>找最优间距，不断找到遍历前的最小值，然后使用当前值减去左边最小值，并记录最大差值即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int pMin&#x3D;INT_MAX,res&#x3D;0;        for(int i&#x3D;0;i&lt;prices.size();++i)&#123;            pMin&#x3D;min(pMin,prices[i]);            res&#x3D;max(prices[i]-pMin,res);        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>每天可以分为两种状态，持有股票和不持有股票，且这两种状态都可以由前一天推导出来</p><p>每个二维dp数组来记录状态，dp[i] [0]表示第i天持有股票所得最多现金，dp[i] [1]表示持有股票所得最多现金。</p><p>第i天持有股票可以由前一天推导出来，即dp[i] [0]&#x3D;max(dp[i-1] [0],-prices[i]) （注意，由于只能买一次股票，所以这里为-prices[i]；同理，dp[i] [1]&#x3D;max(dp[i-1] [1],dp[i-1] [0]+prices[i])。可以优化为两个值来记录即可。</p><p>第一天持有或不持有股票，则dp[0] [0]&#x3D;-prices[0], dp[0] [1]&#x3D;0。</p><p>由于根节点需要由左右节点状态所得，那么使用后序遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int have&#x3D;-prices[0],nohave&#x3D;0;        for(int i&#x3D;1;i&lt;prices.size();++i)&#123;            int t&#x3D;have;            have&#x3D;max(have,-prices[i]);            nohave&#x3D;max(t+prices[i],nohave);            &#x2F;&#x2F; cout&lt;&lt;have&lt;&lt;&quot; &quot;&lt;&lt;nohave&lt;&lt;endl;        &#125;        return max(have,nohave);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>322. 零钱兑换</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h1><p>First：做的时候陷入到挑选数的套路中去了，觉得还要记录以下选了单词后的剩余状态。最后看了点解析就发现还是没理解透动态规划关于挑选物品的核心。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用滚动一维dp数组来记录状态，dp[j] 表示凑成是否能凑成字符串前j个字符。</p><p>假设选择字符串str，其是否能拼接出前j个字符，与dp[j-str.length()]有关，且当前选择字符也必须与字符串中(j-str.length()-1, j-1) 必须相同。因此，dp[j]&#x3D;dp[j-str.length()]&amp;&amp;isSame(s,str,pos)（这是一个判断字符串是否相同的函数）。</p><p>dp[0]&#x3D;1，其余初始化为0。</p><p>字典中的单词可能在字符串的任意位置出现，如果先遍历物品（字典），那么先遍历的单词就不能在后面出现了，因此需要先遍历背包（字符串），再遍历物品（字典），由于字符串可以重复使用，那么内部循环应该从小到大遍历。</p><ul><li>时间复杂度：O(n*amount) </li><li>空间复杂度：O(amount)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isSame(const string &amp;s1,const string &amp;s2,int pos)&#123;        int t1&#x3D;pos,t2&#x3D;s2.length()-1;        while(t2&gt;&#x3D;0)&#123;            if(s1[t1--]!&#x3D;s2[t2--]) return false;        &#125;        return true;    &#125;    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;        vector&lt;int&gt; dp(s.length()+1,0);        dp[0]&#x3D;1;        for(int j&#x3D;1;j&lt;&#x3D;s.length();++j)&#123;            for(int i&#x3D;0;i&lt;wordDict.size();++i)&#123;                if(j&gt;&#x3D;wordDict[i].length()&amp;&amp;dp[j-wordDict[i].length()]&#x3D;&#x3D;1)&#123;                    if(isSame(s,wordDict[i],j-1))&#123;                        dp[j]&#x3D;1;                    &#125;                &#125;            &#125;        &#125;        return dp[s.length()];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>322. 零钱兑换</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h1><p>First：看着像01背包，但无法解决不能连续选的问题，后来做的方法和答案有些差别，想的是只有两种选择，要么选往前退第二个数，要么第三个数，但最后需要在最后两个数中选择最大的数。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[j] 表示前j个房屋最多能偷盗的金额。</p><p>dp[j]由选不选第j个房屋决定，因此dp[j]&#x3D;max(dp[j-1],dp[j-2]+nums[j])</p><p>dp初始化为0。</p><p>从小到大遍历皆可</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        int t1&#x3D;0,t2&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            int tem&#x3D;t2;            t2&#x3D;max(t1+nums[i],t2);            t1&#x3D;tem;        &#125;        return t2;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>213. 打家劫舍 II</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h1><p>First：没做出来，一直想着直接用dp来做，而不是转化为两次dp</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>由于房屋是环状，因此第一个房屋和最后一个房屋中最多只能选择其中一个，因此可以分成不考虑最后一个房屋和不考虑第一个房屋两种情况分别求最大值，然后选择其中最大值即可。</p><p>使用一维dp数组来记录状态，dp[j] 表示前j个房屋最多能偷盗的金额。</p><p>dp[j]由选不选第j个房屋决定，因此dp[j]&#x3D;max(dp[j-1],dp[j-2]+nums[j])</p><p>dp初始化为0。</p><p>从小到大遍历皆可</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()&#x3D;&#x3D;1) return nums[0];        return max(robRange(nums,0,nums.size()-2),robRange(nums,1,nums.size()-1));    &#125;    int robRange(const vector&lt;int&gt; &amp;nums,int s,int e)&#123;        int t1&#x3D;0,t2&#x3D;0;        for(int i&#x3D;s;i&lt;&#x3D;e;++i)&#123;            int tem&#x3D;t2;            t2&#x3D;max(t2,t1+nums[i]);            t1&#x3D;tem;        &#125;        return t2;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>279. 完全平方数</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h1><p>First：也是一道完全背包中求目标和所需最小数量类型题，和322一样，只是稍有变化</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>相比322题，此题只是需要自己求出物品值，其余皆类似</p><p>使用一维dp数组来记录状态，dp[j] 表示凑成j所需的最少数量。</p><p>凑足总额为j - i*i的最少个数为dp[j - i *i]，那么只需要加上一个平方数即dp[j - i *i] + 1就是dp[j]，所以dp[j] 要取所有 dp[j - i *i] + 1 中最小的。dp[j] &#x3D; min(dp[j - i *i] + 1, dp[j])</p><p>凑足目标为0所需平方的个数一定是0，那么dp[0] &#x3D; 0;dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p><p>求最小个数，那么平方数有顺序和没有顺序都可以，都不影响平方数的最小个数，因此先遍历背包容量还是物品都可。</p><ul><li>时间复杂度：O(n*amount) </li><li>空间复杂度：O(amount)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numSquares(int n) &#123;        int amount&#x3D;sqrt(n);        vector&lt;int&gt; dp(n+1,n+1);        dp[0]&#x3D;0;        for(int i&#x3D;1;i&lt;&#x3D;amount;++i)&#123;            int t&#x3D;i*i;            for(int j&#x3D;t;j&lt;&#x3D;n;++j)&#123;                dp[j]&#x3D;min(dp[j],dp[j-t]+1);            &#125;        &#125;        return dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法1</strong>：<strong>数学</strong></p><ul><li>时间复杂度：O(sqrt{n}) </li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>300. 最长递增子序列</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h1><p>First：以前做过，不难，就按动态规划思想来即可</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用滚动一维dp数组来记录状态，dp[i] 表示前i+1个字符的最长递增子序列长度。</p><p>dp[i]与前i个值都有关系，如果nums[i]&gt;nums[k]（k为0到i-1），那么dp[i]&#x3D;dp[k]+1，每次遍历第i+1个数时，都遍历前i个数，找到最大的dp[i]。dp[i]&#x3D;max(dp[k]+1) （nums[i]&gt;nums[k] k为0到i-1）</p><p>每个数自身变为长度为1的子序列，因此dp都初始化为1。</p><p>从左到右遍历即可</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        int ans&#x3D;1;        int n&#x3D;nums.size();        vector&lt;int&gt; dp(n,1);        for(int i&#x3D;1;i&lt;n;++i)&#123;            for(int j&#x3D;0;j&lt;i;++j)&#123;                if(nums[j]&lt;nums[i])&#123;                    dp[i]&#x3D;max(dp[i],dp[j]+1);                                    &#125;            &#125;            ans&#x3D;max(dp[i],ans);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>贪心 + 二分查找</strong></p><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>322. 零钱兑换</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h1><p>First：这次没做出来，但以前做过，是动态规划中又出现的一种类型题，主要是这道题的初始化没搞对，再加上遍历顺序也理解不深刻。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[j] 表示凑成j所需的最少硬币数量。</p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]，所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j])</p><p>凑足总金额为0所需钱币的个数一定是0，那么dp[0] &#x3D; 0;dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p><p>求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数，因此先遍历背包容量还是物品都可。</p><ul><li>时间复杂度：O(n*amount) </li><li>空间复杂度：O(amount)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;        vector&lt;int&gt; dp(amount+1,INT_MAX);        dp[0]&#x3D;0;        &#x2F;&#x2F;先遍历背包容量还是物品皆可，因为与顺序无关        for(int i&#x3D;0;i&lt;coins.size();++i)&#123;            for(int j&#x3D;coins[i];j&lt;&#x3D;amount;++j)&#123;                if(dp[j-coins[i]]!&#x3D;INT_MAX)                    dp[j]&#x3D;min(dp[j],dp[j-coins[i]]+1);            &#125;        &#125;        return dp[amount]&#x3D;&#x3D;INT_MAX?-1:dp[amount];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>213. 打家劫舍 II</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h1><p>First：没想出咋记录选与不选状态，感觉用数组来记录又消耗太大，这是到树形动态规划的基本题</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>每个节点使用大小为2的一维dp数组来记录状态，dp[0] 表示选当前节点所能获得的最大金额，dp[1]表示不选当前节点所能获得的最大金额，然后从中选择最大值即可。</p><p>如果选当前节点，那么dp[0]&#x3D;root-&gt;val+left[1]+right[1]；如果不选当前节点dp[1]&#x3D;max{left[0],left[1]}+max{right[0],right[1]}。</p><p>dp初始化为0。</p><p>由于根节点需要由左右节点状态所得，那么使用后序遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int rob(TreeNode* root) &#123;        vector&lt;int&gt; ans&#x3D;robTree(root);        return max(ans[0],ans[1]);    &#125;    vector&lt;int&gt; robTree(TreeNode *root)&#123;        if(root&#x3D;&#x3D;nullptr) return &#123;0,0&#125;;        vector&lt;int&gt; left&#x3D;robTree(root-&gt;left);        vector&lt;int&gt; right&#x3D;robTree(root-&gt;right);        int val1&#x3D;root-&gt;val+left[1]+right[1];&#x2F;&#x2F;偷当前节点        int val2&#x3D;max(left[0],left[1])+max(right[0],right[1]);&#x2F;&#x2F;不偷当前节点        return &#123;val1,val2&#125;;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>343. 整数拆分</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h1><p>First：用数学方法做出来的，虽然逻辑想清楚了，但最底层的原理大于4的数拆分成两项后的乘积大于原数没理出来，只是理出了只能用2和3进行拆分。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[i] 表示i拆分能获得的最大乘积。</p><p>拆分可以分为三种：</p><ul><li>只将当前值拆分为j和k，j和k不继续拆分</li><li>j和k其中一个继续拆分</li><li>j和k都继续拆分（解答中不考虑这种情况我认为是因为每个值最后都会拆成2和3的组合，2和3不能继续拆了，不然就变小了）</li></ul><p>因此dp[i]就取遍历时三种情况中最大的值</p><p>大数是由小数加起来，因此由小到大遍历</p><p>dp[1]&#x3D;1。</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int integerBreak(int n) &#123;        if(n&lt;4) return n-1;        vector&lt;int&gt; dp(n+1,0);        dp[1]&#x3D;1;        for(int i&#x3D;2;i&lt;&#x3D;n;++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;i&#x2F;2;++j)&#123;                dp[i]&#x3D;max(dp[i],max(j*(i-j),max(j*dp[i-j],dp[j]*dp[i-j])));                &#x2F;&#x2F; dp[i]&#x3D;max(dp[i],max(j*(i-j),j*dp[i-j])); &#x2F;&#x2F;官方解答是这个状态转换，但上面的更易懂，这个只是由于最后都是拆分为2和3，因此也就可以省略一种拆分            &#125;        &#125;        return dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>数学</strong></p><p>大于4的数拆分成两项后的乘积大于原数，而对于4也能拆分成2和2。因此每个数都是被拆分为由2和3组成，且应尽可能使3更多。</p><ul><li>时间复杂度：O(m) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int integerBreak(int n) &#123;        if(n&lt;&#x3D;3) return n-1;        int res&#x3D;n%3;        n&#x2F;&#x3D;3;        int ans&#x3D;1;        for(int i&#x3D;0;i&lt;n;++i)&#123;            ans*&#x3D;3;        &#125;        if(res&#x3D;&#x3D;1)&#123;            return ans&#x2F;3*4;        &#125;else if(res&#x3D;&#x3D;2)&#123;            return ans*2;        &#125;else&#123;            return ans;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>392. 判断子序列</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97-simple/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h1><p>First：开始使用动态规划找最长公共子序列来做的，虽然也能通过但比较耗时，后来一想这简单题也应该这么复杂。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>和1143题找最长公共子序列一样，只是最后判断最长子序列长度是否等于s长度即可。</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isSubsequence(string s, string t) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(s.length()+1,vector&lt;int&gt;(t.length()+1,0));        for(int i&#x3D;1;i&lt;&#x3D;s.length();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;t.length();++j)&#123;                if(s[i-1]&#x3D;&#x3D;t[j-1])&#123;                    dp[i][j]&#x3D;dp[i-1][j-1]+1;                &#125;else&#123;                    dp[i][j]&#x3D;max(dp[i-1][j],dp[i][j-1]);                &#125;            &#125;        &#125;        return dp[s.length()][t.length()]&#x3D;&#x3D;s.length()?true:false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>双指针</strong></p><p>定义两个指针分别指向字符按的串首，依次比较两个指针指向数是否相同，如果不同则指向字符串t的指针加1，否则两个指针同时加1。此方法能有效的原因是，如果s是t的子序列，那么s每个字符的排序在t中都能找到（无论其中是否有重复类似子序列）。</p><ul><li>时间复杂度：O(n+m) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    bool isSubsequence(string s, string t) &#123;        int i&#x3D;0,j&#x3D;0;        for(;i&lt;s.length()&amp;&amp;j&lt;t.length();++j)&#123;            if(s[i]&#x3D;&#x3D;t[j])&#123;                ++i;            &#125;        &#125;        return i&gt;&#x3D;s.length()?true:false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>377. 组合总和 Ⅳ</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h1><p>First：这是一道完全背包中求排列方法数量类型的题，此时需要注意必须容量在外层循环否则只是求得组合方法数量，注意求排列和组合两种类型遍历顺序的差别</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[j] 表示凑成i的排列个数。</p><p>dp[j]同样由前面状态推导出来，即dp[j]+&#x3D;dp[j-nums[i]]</p><p>必须将dp[0]&#x3D;1，否则没有基础方法累加</p><p>为了获得排列数，必须先遍历背包容量再遍历物品，比如有{1,3} {3,1}这样的结果，如果先遍历物品再遍历背包容量，那么就不会出现{3,1}结果，这是因为遍历时编号大的物品一定比编号小的物品后出现</p><blockquote><p>如果是求排列数，那么就应该先遍历物品再遍历背包容量</p></blockquote><p>此题中dp值会overflow，使用unsigned int就不会，但是使用long long任然会overflow，没搞明白为啥，按理说unsigned int 比long long最大值小。而答案是使用的int，只是多判断了一个是否overflow</p><ul><li>时间复杂度：O(n*target) </li><li>空间复杂度：O(target)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;unsigned int&gt; dp(target+1,0);        dp[0]&#x3D;1;        for(int j&#x3D;1;j&lt;&#x3D;target;++j)&#123;            for(int i&#x3D;0;i&lt;nums.size();++i)&#123;                if(nums[i]&lt;&#x3D;j)&#123;                &#x2F;&#x2F;if (nums[i]&lt;&#x3D;j &amp;&amp; dp[j] &lt; INT_MAX - dp[j - nums[i]]) &#123; &#x2F;&#x2F;答案是使用这种方法来解决overflow情况的，dp仍为int值                    dp[j]+&#x3D;dp[j-nums[i]];                &#125;            &#125;        &#125;        return dp[target];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>474. 一和零</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-474-%E4%B8%80%E5%92%8C%E9%9B%B6-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-474-%E4%B8%80%E5%92%8C%E9%9B%B6-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/">474. 一和零</a></h1><p>First：想了下，相比常规01背包只是变成了两个维度，dp多一维就行了。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>此题是找最大子集长度，和普通01背包中挑选最大和类似，只是相比1个维度的容量，此题容量变为两个维度，以每个string的0和1的个数作为两个维度的容量值weight，value皆为1。</p><p>使用二维dp数组来记录状态，dp[i] [j]表示最多有i个0和j个1的strs的最大子集的大小</p><p>dp[i] [j]&#x3D;max(dp[i] [j],dp[i-num0] [j-num1])，这里使用的滚动数组，num0指string中0的个数</p><p>到第0行第0列个格子的方法1中，所以dp[0] [0]&#x3D;1。</p><p>机器人只能向右或向下移动，那么要知道当前方格路径就需要知道上方方格和左边方格路径数，因此先从左到右遍历一行，再由上到下遍历每一行。</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));        for(string &amp;s:strs)&#123;            int l0&#x3D;0,l1&#x3D;0;            for(char c:s)&#123;                if(c&#x3D;&#x3D;&#39;0&#39;)&#123;                    ++l0;                &#125;else&#123;                    ++l1;                &#125;            &#125;            for(int j&#x3D;m;j&gt;&#x3D;l0;--j)&#123;                for(int k&#x3D;n;k&gt;&#x3D;l1;--k)&#123;                    dp[j][k]&#x3D;max(dp[j][k],dp[j-l0][k-l1]+1);                &#125;            &#125;         &#125;        return dp[m][n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>416. 分割等和子集</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h1><p>First：从代码备忘录中做到这题，考虑用动态规划方法，但开始想的是找n-1以下个数字，如果找到和的一半则返回true，但是忽略了找几个数字之和都是找到的最大和，但和的一般可能不是由几个数字的最大和组成，这种思路应该用回溯才能成功。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>根据题意，需要做到的是从数组挑出若干个数得到目标和target。可以转换为01背包问题：</p><ul><li>背包体积为sum&#x2F;2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum &#x2F; 2 的子集。</li><li>背包中每一个元素是不可重复放入。</li></ul><p>使用二维dp数组来记录状态，dp[i] [j] 表示容量为j的背包，对nums前i+1个数，能凑成的最大和。</p><p>对于dp[i] [j]只会有两种选择，取当前数或者不取，如果不取则和dp[i-1] [j]相同，如果取则需要对找到减去当前数所占体积的dp对应值，</p><p>即dp[i] [j]&#x3D;max(dp[i-1] [j],dp[i-1] [j-weight[i]]+value[i])</p><p>两重循环中，无论先遍历i还是先遍历j都可，都从小到大遍历，只是理解不同。</p><p>dp可以只使用一维数据来记录，注意这样就需要里面那层遍历从大到小遍历</p><ul><li>时间复杂度：O(n*target) </li><li>空间复杂度：O(target)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int n&#x3D;nums.size();        int sum&#x3D;0;        for(auto &amp;n:nums)&#123;            sum+&#x3D;n;        &#125;        if(sum%2&#x3D;&#x3D;1) return false;        sum&#x2F;&#x3D;2;        vector&lt;int&gt; dp(sum+1,0);        for(int i&#x3D;0;i&lt;n;++i)&#123;            for(int j&#x3D;sum;j&gt;&#x3D;nums[i];--j)&#123;                dp[j]&#x3D;max(dp[j],dp[j-nums[i]]+nums[i]);                if(dp[j]&#x3D;&#x3D;sum) return true;            &#125;        &#125;        return dp[sum]&#x3D;&#x3D;sum?true:false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>494. 目标和</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-494-%E7%9B%AE%E6%A0%87%E5%92%8C-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-494-%E7%9B%AE%E6%A0%87%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h1><p>First：以前做过，但还是没做出来，想到了要找(sum-target)&#x2F;2，但dp含义没理解透彻，初始化也没搞对。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>给定数组所有数相加和sum是确定的，因为只有两种符号，因此所有数就可以分为两堆，一堆全为+，一堆全为-，因此找到其中任意一堆的值有多少种组合方法即可。如果找减数堆都赋为减号，那么此时所有和加起来相比sum少了两倍减数堆之和，因此，减数堆之和a&#x3D;(sum-target)&#x2F;2。</p><p>由此，算法也就变成了nums组成a和的方法数。</p><p>使用二维dp数组来记录状态，dp[i] [j]表示由nums前i+1个数组成j的方法数。</p><p>dp[i] [j]也两种选择，</p><ul><li>当j&lt;nums[i]时，此时j不可能由nums[i]组成，因此dp[i] [j]&#x3D;dp[i-1] [j]</li><li>否则，j可能也有nums[i]组成，此时组成j就有两种可能，即不包含nums[i]和包含nums[i]，因此dp[i] [j]&#x3D;dp[i-1] [j]+dp[i-1] [j-nums[i]]</li></ul><p>当j&#x3D;0时，不需要挑选数就可以等于0，因此dp[0] [0]&#x3D;1。</p><p>更大的j是由更小的j组成，因此需要从小到大遍历</p><p>可以优化为以为数组</p><ul><li>时间复杂度：O(n*a) </li><li>空间复杂度：O(a)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;        int sum&#x3D;0;        for(auto a:nums)&#123;            sum+&#x3D;a;        &#125;                if((sum-target)%2!&#x3D;0||sum&lt;target) return 0;        target&#x3D;(sum-target)&#x2F;2;        vector&lt;int&gt; dp(target+1,0);        dp[0]&#x3D;1;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            for(int j&#x3D;target;j&gt;&#x3D;0;--j)&#123;                if(j&gt;&#x3D;nums[i])&#123;                    dp[j]&#x3D;dp[j]+dp[j-nums[i]];                &#125;            &#125;        &#125;        return dp[target];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>回溯</strong></p><ul><li>时间复杂度：O(2^n^) </li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>509. 斐波那契数</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0-simple/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></h1><p>First：直接使用递归来做，但时间打败率挺低。</p><hr><p><strong>方法1</strong>：<strong>递归</strong></p><p>不断递归找到最终结果即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int fib(int n) &#123;        if(n&lt;2)&#123;            return n;        &#125;else&#123;            return fib(n-1)+fib(n-2);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>循环遍历（动态规划）</strong></p><p>循环遍历得到每个数的斐波那契值即可</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int fib(int n) &#123;        if(n&lt;2) return n;        &#x2F;&#x2F; if(n&#x3D;&#x3D;1) return 1;        int a&#x3D;0,b&#x3D;1;        for(int i&#x3D;2;i&lt;&#x3D;n;++i)&#123;            int t&#x3D;a+b;            a&#x3D;b;            b&#x3D;t;        &#125;        return b;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>516. 最长回文子序列</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h1><p>First：开始看错题了，虽然后面也做出来了</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示以s以位置i开头位置j结尾所形成的字符串的最长回文子序列，因此选最大的dp返回。</p><p>递推公式：</p><ul><li><p>当s[i]&#x3D;&#x3D;s[j]时，此时最长回文长度是在由内层字符s[i+1]到s[j-1]基础上加2，所以dp[i] [j]&#x3D;dp[i-1] [j-1]+2，由于皆初始化为0，当i&#x3D;j和i&#x3D;j-1时，此时dp[i] [j]&#x3D;1;</p></li><li><p>当s[i]!&#x3D;s[j]时，此时回文长度不增加，而是由原来回文长度决定。而现有字符串可以由三种情况组成，字符串首部少一个字符，或尾部少一个字符，或首尾皆少一个字符（其实要么少首要么少尾两种情况就够了），因此dp[i] [j]&#x3D;max(dp[i+1] [j],max(dp[i] [j-1],dp[i+1] [j-1]))。</p></li></ul><p>dp皆初始化为0</p><p>从递推公式可以看出是从左下方推导出当前结果，因此需要先外层从大到小遍历s，再内层从小到大遍历s</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n^2^)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int longestPalindromeSubseq(string s) &#123;        int len&#x3D;s.length();        vector&lt;vector&lt;int&gt;&gt; dp(len,vector&lt;int&gt;(len,0));        int ans&#x3D;1;        for(int i&#x3D;len-1;i&gt;&#x3D;0;--i)&#123;            for(int j&#x3D;i;j&lt;len;++j)&#123;                if(s[i]&#x3D;&#x3D;s[j])&#123;                    if(i&#x3D;&#x3D;j) dp[i][j]&#x3D;1;                    else if(j-i&#x3D;&#x3D;1) dp[i][j]&#x3D;2;                    else dp[i][j]&#x3D;dp[i+1][j-1]+2;                &#125;else&#123;                    dp[i][j]&#x3D;max(dp[i+1][j-1],max(dp[i+1][j],dp[i][j-1]));                &#125;                ans&#x3D;max(ans,dp[i][j]);            &#125;                &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>518. 零钱兑换 II</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h1><p>First：是一道完全背包中找组合数类型的题</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>此题是一道完全背包找目标组合数类型的题，weight[i]&#x3D;nums[i]</p><p>使用滚动一维维dp数组来记录状态，dp[i]组成金额为i的组合数。</p><p>由于完全背包的遍历方法，dp[j]+&#x3D;dp[j-weight[i]]</p><p>dp[0] &#x3D;1。</p><ul><li>时间复杂度：O(n*amount) </li><li>空间复杂度：O(amount)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;        vector&lt;int&gt; dp(amount+1,0);        dp[0]&#x3D;1;        for(int i&#x3D;0;i&lt;coins.size();++i)&#123;            for(int j&#x3D;coins[i];j&lt;&#x3D;amount;++j)&#123;                dp[j]+&#x3D;dp[j-coins[i]];            &#125;        &#125;        return dp[amount];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53. 最大子数组和</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h1><p>First：没做出来，定义不好dp含义，用两重循环超时了</p><p>Second：才做几天，刷贪心算法系列题又遇见了，不过没用贪心做出来，对这题理解得不够透彻</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[i] 表示以nums[i-1]结尾的最大连续子数组的和，那么找到最大的dp即为结果。</p><p>要求以nums[i-1]结尾的最大和，那么对于nums[i-2]结尾的最大和dp[i-1]，如果dp[i-1]&gt;0，那么加上dp[i-1]才能使得dp[i]更大，否则就不应该加上dp[i-1]，而是从num[i-1]重新作为连续子数组的头和尾。因此，dp[i]&#x3D;max(dp[i-1]+nums[i-1],nums[i-1])。</p><p>皆初始化为0。</p><p>从小到大遍历即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n) 可优化为1</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int n&#x3D;nums.size();        vector&lt;int&gt; dp(n+1,0);        int ans&#x3D;INT_MIN;        for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;            dp[i]&#x3D;max(nums[i-1]+dp[i-1],nums[i-1]);            ans&#x3D;max(ans,dp[i]);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>贪心</strong></p><p>遍历整个数组，当遍历到任意位置k时，若现有连续子数组和为负时，nums[k]加上前面的连续子数组结果会更小，此时应该舍弃前面数组，而以nums[k]作为新子数组的起始。</p><p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p><p>全局最优：选取最大“连续和”</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int ans&#x3D;INT_MIN;        int count&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            count+&#x3D;nums[i];            ans&#x3D;max(ans,count);            if(count&lt;0) count&#x3D;0;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：<strong>分治法</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>583. 两个字符串的删除操作</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h1><p>First：虽然做出来了，但做出来后细想才发现有些没搞懂原因</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>对于两个字符串A、B，若AB相同时，此时A若添加一个字符后，其实可以堪称B减少了一个字符，因此，添加操作和删除操作可以看成 相等的。对于此题，使用添加操作进行推导（只能使用一种操作，不能使用两种操作，虽然本质相同）。</p><p>使用二维dp数组来记录状态，dp[i] [j]表示word1前i个字符和word2前j个字符相同所需最小步骤。</p><p>递推公式：</p><ul><li><p>当word1[i-1]&#x3D;&#x3D;word2[j-1]时，此时无需修改字符，所以dp[i] [j]&#x3D;dp[i-1] [j-1]；</p></li><li><p>当word1[i-1]!&#x3D;word2[j-1]时，此时有两种操作可以使得字符相等，要么在dp[i-1] [j]情况下对word1添加一个字符，要么在dp[i] [j-1]情况下对word2添加一个字符。因此，dp[i] [j]&#x3D;max(dp[i-1] [j],dp[i] [j-1])+1;</p></li></ul><p>由dp定义可知，dp[i] [0]&#x3D;i（word2的0个字符要变成word1前i个字符需要添加i次），dp[0] [j]&#x3D;j（原因同理）</p><p>从递推公式可以看出是从左上方推导出当前结果，因此需要先外层从小到大遍历word1，再内层从小到大遍历word2</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minDistance(string word1, string word2) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1,vector&lt;int&gt;(word2.size()+1,0));        for(int i&#x3D;1;i&lt;&#x3D;word1.size();++i)&#123;            dp[i][0]&#x3D;i;        &#125;        for(int j&#x3D;1;j&lt;&#x3D;word2.size();++j)&#123;            dp[0][j]&#x3D;j;        &#125;        for(int i&#x3D;1;i&lt;&#x3D;word1.size();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;word2.size();++j)&#123;                if(word1[i-1]&#x3D;&#x3D;word2[j-1])&#123;                    dp[i][j]&#x3D;dp[i-1][j-1];                &#125;else&#123;                    dp[i][j]&#x3D;min(dp[i-1][j],dp[i][j-1])+1;                &#125;            &#125;        &#125;        return dp[word1.size()][word2.size()];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>62. 不同路径</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h1><p>First：以前做过，但一下子没看懂组合数学方法。这次用的动态规划做。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示到第i行j列个网格时的不同路径。</p><p>由题中可知，只能向右或向下移动，因此到当前方格的路径则由左边方格路径和上方方格路径相加得到。</p><p>到第0行第0列个格子的方法1中，所以dp[0] [0]&#x3D;1。</p><p>机器人只能向右或向下移动，那么要知道当前方格路径就需要知道上方方格和左边方格路径数，因此先从左到右遍历一行，再由上到下遍历每一行。</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int uniquePaths(int m, int n) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,0));        dp[0][0]&#x3D;1;        for(int i&#x3D;0;i&lt;m;++i)&#123;            for(int j&#x3D;0;j&lt;n;++j)&#123;                if(j&gt;0) dp[i][j]&#x3D;dp[i][j-1];                if(i&gt;0) dp[i][j]+&#x3D;dp[i-1][j];            &#125;        &#125;        return dp[m-1][n-1];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>组合数学</strong></p><p>从左上角到右下角的过程中，我们需要移动 m+n-2m+n−2 次，其中有 m-1m−1 次向下移动，n-1n−1 次向右移动。因此路径的总数，就等于从 m+n-2m+n−2 次移动中选择 m-1m−1 次向下移动的方案数，即组合数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220922152234753.png" alt="image-20220922152234753"></p><ul><li>时间复杂度：O(m) </li><li>空间复杂度：O1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>63. 不同路径 II</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h1><p>First：以前做过，且和62题思想一样，只是需要判断是否有障碍即可</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示到第i行j列个网格时的不同路径数量。</p><p>由题中可知，只能向右或向下移动，因此到当前方格的路径则由左边方格路径和上方方格路径相加得到。若两个方向有障碍，则不加上那个方向的路径</p><p>到第0行第0列个格子的方法1中，所以dp[0] [0]&#x3D;1。</p><p>机器人只能向右或向下移动，那么要知道当前方格路径就需要知道上方方格和左边方格路径数，因此先从左到右遍历一行，再由上到下遍历每一行。</p><p>还可以对空间进行优化，只使用一行来存储数据，空间复杂度优化成O(m)。</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;        int m&#x3D;obstacleGrid.size(),n&#x3D;obstacleGrid[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,0));        if(obstacleGrid[0][0]&#x3D;&#x3D;1||obstacleGrid[m-1][n-1]&#x3D;&#x3D;1) return 0;        dp[0][0]&#x3D;1;        for(int i&#x3D;0;i&lt;m;++i)&#123;            for(int j&#x3D;0;j&lt;n;++j)&#123;                if(obstacleGrid[i][j]&#x3D;&#x3D;1) continue;                if(j&gt;0&amp;&amp;obstacleGrid[i][j-1]&#x3D;&#x3D;0) dp[i][j]&#x3D;dp[i][j-1];                if(i&gt;0&amp;&amp;obstacleGrid[i-1][j]&#x3D;&#x3D;0) dp[i][j]+&#x3D;dp[i-1][j];            &#125;        &#125;        return dp[m-1][n-1];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>647. 回文子串</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h1><p>First：使用的动态规划做，但效率比双指针低很多</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用二维dp数组来记录状态，dp[i] [j]表示以s以位置i开头位置j结尾所形成的字符串是否为回文。</p><p>递推公式：</p><ul><li><p>当s[i]&#x3D;&#x3D;s[j]时，此时是否为回文由内层字符s[i+1]到s[j-1]决定，所以dp[i] [j]&#x3D;dp[i-1] [j-1]，由于皆初始化为0，当i&#x3D;j和i&#x3D;j-1时，此时dp[i] [j]&#x3D;1;</p></li><li><p>当word1[i-1]!&#x3D;word2[j-1]时，dp[i] [j]&#x3D;0;</p></li></ul><p>dp皆初始化为0</p><p>从递推公式可以看出是从左下方推导出当前结果，因此需要先外层从大到小遍历s，再内层从小到大遍历s</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n^2^)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int countSubstrings(string s) &#123;        int len&#x3D;s.length();        vector&lt;vector&lt;int&gt;&gt; dp(len,vector&lt;int&gt;(len,0));        int ans&#x3D;0;        for(int i&#x3D;len-1;i&gt;&#x3D;0;--i)&#123;            for(int j&#x3D;i;j&lt;len;++j)&#123;                if(s[i]&#x3D;&#x3D;s[j])&#123;                    dp[i][j]&#x3D;j-i&gt;1?dp[i+1][j-1]:1;                &#125;                ans+&#x3D;dp[i][j];            &#125;                &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>双指针</strong></p><p>从头到尾遍历s，且对于每个s的每个字符，以当前字符和当前两个字符往两边扩散，判断是否为回文</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n^2^)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>674. 最长连续递增序列</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97-simple/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h1><p>First：基础题，方法可理解为动态规划也可以理解为贪心</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划（贪心）</strong></p><p>dp[i]表示以第i+1个数结尾能找到的最长连续递增子序列的长度</p><p>当nums[i-1]&lt;nums[i]，dp[i]&#x3D;dp[i-1]+1。否则dp[i]&#x3D;1</p><p>初始皆为0</p><p>从左到右遍历即可，并记录最大的dp值作为结果。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;        int cur&#x3D;1,ans&#x3D;1;        for(int i&#x3D;1;i&lt;nums.size();++i)&#123;            if(nums[i]&gt;nums[i-1])&#123;                ++cur;                ans&#x3D;max(cur,ans);            &#125;else&#123;                cur&#x3D;1;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70. 爬楼梯</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF-simple/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>First：爬到当前楼梯方法等于前面两级楼梯方法之和</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>dp[i]表示阶梯为i时的方法</p><p>当前阶梯方法等于前两阶阶梯方法和，即dp[i]&#x3D;dp[i-1]+dp[i-2]；</p><p>再确定初始值，然后遍历推导即可。</p><p>但是，dp使用过后就不会再使用，因此使用两个值来存储前两个阶梯状态即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int climbStairs(int n) &#123;        if(n&lt;3) return n;        int a&#x3D;1,b&#x3D;2;        for(int i&#x3D;3;i&lt;&#x3D;n;++i)&#123;            int t&#x3D;a+b;            a&#x3D;b;            b&#x3D;t;        &#125;        return b;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划+完全背包</strong></p><p>本题使用方法1就可，但如果可以每次爬1–m多个台阶，也就转换为了完全背包问题中的排列方法数</p><p>dp[j]表示爬到j阶的方法数</p><p>和完全背包求排列方法数一样，即dp[j]+&#x3D;dp[j-nums[i]]；</p><p>求排列方法数的第一个值为1，其余为0，dp[0]&#x3D;1;</p><p>由于是求排列数，因此需要先遍历背包容量再遍历物品，原因见leet377题解</p><ul><li>时间复杂度：O(2*n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int climbStairs(int n) &#123;        vector&lt;int&gt; dp(n+1,0);        dp[0]&#x3D;1;        for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;            for(int i&#x3D;1;i&lt;&#x3D;2;++i)&#123;                if(j&gt;&#x3D;i)&#123;                    dp[j]+&#x3D;dp[j-i];                &#125;            &#125;        &#125;        return dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>718. 最长重复子数组</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h1><p>First：用一维数组做的时候有些细节没弄好，最后还是先使用的二维数组，再优化一维数组</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>两个数组的最长重复子数组如果去除末尾不重复部分，那么最长重复子数组就都处于末尾，那么求所有处在末尾的重复子数组的大小即可，取其中最大值即为答案。</p><p>使用二维dp数组来记录状态，dp[i] [j] 表示nums1中前i个数和nums2中前j个数在末尾处的重复子数组长度，注意是末尾处重复子数组长度，如果末尾处不相等，则dp[i] [j]&#x3D;0，这是因为即使去除最长重复子串后面不相等的部分仍不会改变最长重复子串长度。</p><p>当nums1[i-1]&#x3D;nums[j-1]时，dp[i] [j]&#x3D;dp[i-1] [j-1]，否则dp[i] [j] &#x3D;0（dp两个维度上都加1是为了代码方便处理）;</p><p>皆初始化为0。</p><p>当前dp值与前面数有关系，因此两重循环皆从左到右遍历，记录最大dp值即可</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(nums1.size()+1,vector&lt;int&gt;(nums2.size()+1,0));        int ans&#x3D;0;        for(int i&#x3D;1;i&lt;&#x3D;nums1.size();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;nums2.size();++j)&#123;                if(nums2[j-1]&#x3D;&#x3D;nums1[i-1])&#123;                       dp[i][j]&#x3D;dp[i-1][j-1]+1;                &#125;                ans&#x3D;max(ans,dp[i][j]);                cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;            &#125;            cout&lt;&lt;endl;        &#125;        &#x2F;&#x2F;优化为1维数组        &#x2F;&#x2F; vector&lt;int&gt; dp(nums2.size()+1,0);        &#x2F;&#x2F; int ans&#x3D;0;        &#x2F;&#x2F; for(int i&#x3D;0;i&lt;nums1.size();++i)&#123;        &#x2F;&#x2F;     for(int j&#x3D;nums2.size();j&gt;0;--j)&#123;        &#x2F;&#x2F;         if(nums2[j-1]&#x3D;&#x3D;nums1[i])&#123;           &#x2F;&#x2F;             dp[j]&#x3D;dp[j-1]+1;        &#x2F;&#x2F;         &#125;else&#123;        &#x2F;&#x2F;             dp[j]&#x3D;0;        &#x2F;&#x2F;         &#125;        &#x2F;&#x2F;         ans&#x3D;max(ans,dp[j]);        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>二分查找 + 哈希</strong></p><ul><li>时间复杂度：O((<em>M</em>+<em>N</em>)log(min(<em>M</em>,<em>N</em>)) </li><li>空间复杂度：O(<em>N</em>)</li></ul><hr><p><strong>方法3</strong>：<strong>滑动窗口</strong></p><ul><li>时间复杂度：O((<em>N</em>+<em>M</em>)×min(<em>N</em>,<em>M</em>)) </li><li>空间复杂度：O(<em>1</em>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>72. 编辑距离</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-difficult/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h1><p>First：虽然做出来了，但不透</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>对于两个字符串A、B，若AB相同时，此时A若添加一个字符后，其实可以看成B减少了一个字符，因此，添加操作和删除操作可以看成相等的。对于此题，使用添加操作进行推导。</p><p>使用二维dp数组来记录状态，dp[i] [j]表示使word1前i个字符和word2前j个字符相同所需最小步骤（虽然题目是将world1转换为word2，但word2添加字符可以看成word1减少字符，其操作数是相同的，因此word2和word1子序列上都进行添加任然是求结果，为了逻辑更清晰，就只使用添加和替换操作）。</p><p>递推公式：</p><ul><li><p>当word1[i-1]&#x3D;&#x3D;word2[j-1]时，此时无需修改操作，所以dp[i] [j]&#x3D;dp[i-1] [j-1]；</p></li><li><p>当word1[i-1]!&#x3D;word2[j-1]时，此时有三种操作可以使得字符相等，要么在dp[i-1] [j]情况下对word1添加一个字符；要么在dp[i] [j-1]情况下对word2添加一个字符；要么在dp[i-1] [j-1]情况下将word1[i-1]替换为word2[j-1]。因此，dp[i] [j]&#x3D;min(dp[i-1] [j],min(dp[i-1] [j-1],dp[i] [j-1]))+1;</p></li></ul><p>由dp定义可知，dp[i] [0]&#x3D;i（word2的0个字符要变成word1前i个字符需要添加i次），dp[0] [j]&#x3D;j（原因同理）</p><p>从递推公式可以看出是从左上方推导出当前结果，因此需要先外层从小到大遍历word1，再内层从小到大遍历word2</p><ul><li>时间复杂度：O(mn) </li><li>空间复杂度：O(mn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minDistance(string word1, string word2) &#123;        vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1,vector&lt;int&gt;(word2.size()+1,0));        for(int i&#x3D;1;i&lt;&#x3D;word1.size();++i) dp[i][0]&#x3D;i;        for(int j&#x3D;1;j&lt;&#x3D;word2.size();++j) dp[0][j]&#x3D;j;        for(int i&#x3D;1;i&lt;&#x3D;word1.size();++i)&#123;            for(int j&#x3D;1;j&lt;&#x3D;word2.size();++j)&#123;                if(word1[i-1]&#x3D;&#x3D;word2[j-1]) dp[i][j]&#x3D;dp[i-1][j-1];                else dp[i][j]&#x3D;min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1]))+1;            &#125;        &#125;        return dp[word1.size()][word2.size()];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>746. 使用最小花费爬楼梯</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF-simple/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h1><p>First：爬到当前楼梯方法等于前面两级楼梯当前费用+继续爬代价中最小的</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>dp[i]表示爬到阶梯为i时的费用</p><p>当前阶梯费用等于前两阶阶梯费用+继续爬楼梯费用代价最小的，即dp[i]&#x3D;min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-1]；</p><p>再确定初始值，爬到第1阶和第2阶是不需要费用的。</p><p>然后遍历推导即可。同理，dp使用过后就不会再使用，因此使用两个值来存储前两个阶梯费用即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;        int n&#x3D;cost.size();        if(n&lt;2) return 0;        int a&#x3D;0,b&#x3D;0;        for(int i&#x3D;2;i&lt;&#x3D;n;++i)&#123;            int t&#x3D;min(a+cost[i-2],b+cost[i-1]);            a&#x3D;b;            b&#x3D;t;        &#125;        return b;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>96. 不同的二叉搜索树</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h1><p>First：以前做过，想了会找出状态转换公式即可。</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[i] 表示到i个节点拥有的互不相同二叉搜索树个数。</p><p>若有n个结点，假设其由1个节点添加n-1个节点得到，而这n-1个节点只能在这一个节点的左右进行组合，那么找出所有组合数之和就是n个节点的二叉搜索树个数。</p><p>即dp[i]&#x3D;sum(dp[k]*dp[i-1-k]) k: 0–i-1。</p><p>更多结点的个数是由更少节点的个数组合得到，因此就从小到大遍历。</p><ul><li>时间复杂度：O(n^2^) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int numTrees(int n) &#123;        vector&lt;int&gt; dp(n+1,0);        dp[0]&#x3D;1;        for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;            for(int j&#x3D;0;j&lt;i;++j)&#123;                dp[i]+&#x3D;dp[j]*dp[i-j-1];            &#125;        &#125;        return dp[n];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>数学</strong></p><p>求二叉树不同树的个数也就是求卡特兰数</p><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220923193749678.png" alt="image-20220923193749678"></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买卖股票类型算法总结</title>
      <link href="/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93-middle/"/>
      <url>/2023/02/15/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="买卖股票类型"><a href="#买卖股票类型" class="headerlink" title="买卖股票类型"></a>买卖股票类型</h1><ul><li><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2></li><li><h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h2></li><li><h2 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h2></li><li><h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h2></li></ul><p>买卖股票类型题总结，皆使用动态规划来做，动态规划步骤如下：</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><p>买卖股票使用</p><ul><li><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2></li></ul><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>找最优间距，不断找到遍历前的最小值，然后使用当前值减去左边最小值，并记录最大差值即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int pMin&#x3D;INT_MAX,res&#x3D;0;        for(int i&#x3D;0;i&lt;prices.size();++i)&#123;            pMin&#x3D;min(pMin,prices[i]);            res&#x3D;max(prices[i]-pMin,res);        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>每天可以分为两种状态，持有股票和不持有股票，且这两种状态都可以由前一天推导出来</p><p>每个二维dp数组来记录状态，dp[i] [0]表示第i天持有股票所得最多现金，dp[i] [1]表示持有股票所得最多现金。</p><p>第i天持有股票可以由前一天推导出来，即dp[i] [0]&#x3D;max(dp[i-1] [0],-prices[i]) （注意，由于只能买一次股票，所以这里为-prices[i]；同理，dp[i] [1]&#x3D;max(dp[i-1] [1],dp[i-1] [0]+prices[i])。可以优化为两个值来记录即可。</p><p>第一天持有或不持有股票，则dp[0] [0]&#x3D;-prices[0], dp[0] [1]&#x3D;0。</p><p>由于根节点需要由左右节点状态所得，那么使用后序遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int have&#x3D;-prices[0],nohave&#x3D;0;        for(int i&#x3D;1;i&lt;prices.size();++i)&#123;            int t&#x3D;have;            have&#x3D;max(have,-prices[i]);            nohave&#x3D;max(t+prices[i],nohave);            &#x2F;&#x2F; cout&lt;&lt;have&lt;&lt;&quot; &quot;&lt;&lt;nohave&lt;&lt;endl;        &#125;        return max(have,nohave);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h2><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>每天可以分为三种状态，刚买了股票buy和刚卖了股票sell，卖了股票第二天sell2，且这三种状态都可以由前一天推导出来</p><p>第i天持有股票可以由前一天推导出来，buy更新时只能将当前值和卖了股票第二天然后今天买进行比较，而sell2就只能等于前一天的sell，sell更新时将当前值和昨天买了股票然后今天卖进行比较。</p><p>由于根节点需要由左右节点状态所得，那么使用后序遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> buy<span class="token operator">=</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>sell<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>sell2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token keyword">int</span> t<span class="token operator">=</span>buy<span class="token punctuation">;</span>            buy<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>buy<span class="token punctuation">,</span>sell2<span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    sell2<span class="token operator">=</span>sell<span class="token punctuation">;</span>            sell<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">,</span>t<span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>sell<span class="token punctuation">,</span><span class="token function">max</span><span class="token punctuation">(</span>sell2<span class="token punctuation">,</span>buy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>131. 分割回文串</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h1><p>First：每理解到分割和组合取其实是差不多得，看了解析的这个分割理解才做出来。</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><blockquote><p><strong>切割问题类似组合问题</strong>。</p><p>例如对于字符串abcdef：</p><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</li></ul></blockquote><p>此题的分割也就是选结束的字符，已结束字符拼成的字符串是回文就说明结束字符满足要求。</p><p>中止条件：当需要遍历的起始位置index等于字符串长度时，将temp添加进结果中</p><p>遍历过程：从给定的起始位置index遍历，假设遍历到i，如果s[index:i]是回文，那么就可以将此字符串添加进temp中，且回溯递归遍历找到下一个回文子串。否则将i+1，继续判断。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;string&gt;&gt; ans;    vector&lt;string&gt; temp;public:    bool isPalindrome(const string &amp;s)&#123;        for(int i&#x3D;0,j&#x3D;s.size()-1;i&lt;j;++i,--j)&#123;            if(s[i]!&#x3D;s[j]) return false;        &#125;        return true;    &#125;    void backtrace(const string &amp;s,int index)&#123;        if(index&#x3D;&#x3D;s.size())&#123;            ans.push_back(temp);            return;        &#125;        string scur;        for(int i&#x3D;index;i&lt;s.size();++i)&#123;            scur.push_back(s[i]);            if(isPalindrome(scur)) temp.push_back(scur);            else continue;            backtrace(s,i+1);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        backtrace(s,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>回溯+动态规划</strong></p><p>方法1中每个都需要进行判断子串是否是回文，会造成很多重复计算。可以使用动态规划先判断每个子串是否是回文，动态规划判断每个子串是时间复杂度为O(n^2^)。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17. 电话号码的字母组合</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h1><p>First：回溯遍历即可</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>使用一个map记录下每个数字对应哪些字母，然后回溯遍历每个数字对应的字母即可</p><p>中止条件：遍历下标值和digits大小相等时</p><p>遍历过程：从小到大遍历digits每个数字对应的字母，将当前值添加进临时数组，再回溯。</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;string&gt; ans;    string tem;    vector&lt;string&gt; map;public:    void backtrace(int index,const string &amp;digits)&#123;        if(index&#x3D;&#x3D;digits.size())&#123;            ans.push_back(tem);            return;        &#125;        const string &amp;s&#x3D;map[digits[index]-&#39;2&#39;];        for(char c:s)&#123;            tem.push_back(c);            backtrace(index+1,digits);            tem.pop_back();        &#125;    &#125;    vector&lt;string&gt; letterCombinations(string digits) &#123;        if(digits.size()&#x3D;&#x3D;0) return&#123;&#125;;        map&#x3D;vector&lt;string&gt;&#123;&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;&#125;;        backtrace(0,digits);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>216. 组合总和 III</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h1><p>First：和77差不多</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>使用k记录还需多少个数，使用n记录还需寻找之和，不断递归重复找，按顺序遍历（只添加当前值后面的数）使得不存在重复值</p><p>中止条件：当n等于0且k&#x3D;&#x3D;0时，将收集到的数组添加到结果中</p><p>遍历过程：从小到大遍历，将当前值添加进临时数组，再回溯。</p><p>剪枝：当n小于0时进行剪枝</p><ul><li>时间复杂度：O((<em>k**n</em>)×<em>k</em>)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; tem;    int cursum;public:    void backtrace(int st,int k,int n)&#123;        if(n&#x3D;&#x3D;0&amp;&amp;k&#x3D;&#x3D;0)&#123;            ans.push_back(tem);            return;        &#125;else if(n&lt;0)&#123;            return;        &#125;        for(int i&#x3D;st;i&lt;&#x3D;9-k+1;++i)&#123;                        tem.push_back(i);            backtrace(i+1,k-1,n-i);            tem.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;        backtrace(1,k,n);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法1</strong>：<strong>二进制（子集）枚举</strong></p><ul><li>时间复杂度：O((<em>M</em>×2**M)</li><li>空间复杂度：O(M)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>332. 重新安排行程</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B-difficult/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332. 重新安排行程"></a><a href="https://leetcode.cn/problems/reconstruct-itinerary/">332. 重新安排行程</a></h1><p>First：思想挺简单，但比较麻烦</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>先使用一个set记录所有的机场名字，为了保证字典排序小的行程优先，因此需要对机场名字进行排序，得到sortNames。然后以sortName为序，使用一个矩阵来距离每两个机场间的票数（无票为0），为了快速找到机场名字在sortName中的位置，使用一个nameIndex数组来记录位置。使用temp记录当前添加的行程顺序，然后进行回溯遍历。</p><p>中止条件：当temp大小等于总票数+1时，此时已经找到所有形成，将flag置为true。</p><p>遍历过程：以index为行号，从index行从小到大遍历，如果matrix[index] [i]&gt;0，说明有票，此时将票数减1，然后进行回溯，回溯完成后应将票数加1.</p><p>剪枝：使用一个flag来记录是否找到答案，如果找到直接返回。</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;string&gt; ans;    vector&lt;string&gt; temp;    vector&lt;vector&lt;int&gt;&gt; matrix;    bool flag;public:    void backtrace(const vector&lt;string&gt; &amp;names,int index,int num)&#123;        if(flag) return;        temp.push_back(names[index]);        &#x2F;&#x2F; cout&lt;&lt;names[index]&lt;&lt;endl;        if(temp.size()&#x3D;&#x3D;num)&#123;            ans&#x3D;temp;            flag&#x3D;true;        &#125;        for(int i&#x3D;0;i&lt;names.size();++i)&#123;            if(matrix[index][i]&gt;0)&#123;                matrix[index][i]-&#x3D;1;                backtrace(names,i,num);                matrix[index][i]+&#x3D;1;            &#125;        &#125;        temp.pop_back();    &#125;    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;        flag&#x3D;false;        unordered_set&lt;string&gt; ticNames;&#x2F;&#x2F;记录有哪些机场        for(int i&#x3D;0;i&lt;tickets.size();++i)&#123;            for(auto &amp;name:tickets[i])&#123;                ticNames.insert(name);            &#125;        &#125;        vector&lt;string&gt; sortNames;&#x2F;&#x2F;将机场名字按顺序排列        int index&#x3D;-1;        for(auto &amp;s:ticNames)&#123;            sortNames.push_back(s);        &#125;        sort(sortNames.begin(),sortNames.end());        unordered_map&lt;string,int&gt; nameIndex;&#x2F;&#x2F;用于记录每个机场名字在sortNames中的位置        for(int i&#x3D;0;i&lt;sortNames.size();++i)&#123;            nameIndex[sortNames[i]]&#x3D;i;            if(sortNames[i]&#x3D;&#x3D;&quot;JFK&quot;) index&#x3D;i;        &#125;        matrix&#x3D;vector&lt;vector&lt;int&gt;&gt;(sortNames.size(),vector&lt;int&gt;(sortNames.size(),0));&#x2F;&#x2F;记录有哪些机场是之间是有票的        for(int i&#x3D;0;i&lt;tickets.size();++i)&#123;            int pos1&#x3D;nameIndex[tickets[i][0]];            int pos2&#x3D;nameIndex[tickets[i][1]];            matrix[pos1][pos2]+&#x3D;1;        &#125;        backtrace(sortNames,index,tickets.size()+1);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>37. 解数独</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC-difficult/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></h1><p>First：思想不难，但细节较多</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>使用used1矩阵来记录每一个3*3宫格内数字使用情况，使用used2来记录每行数字使用情况，使用used3矩阵来记录每列数字使用情况。计算出所有需要填充的空格数dianNum，然后开始回溯。</p><p>中止条件：当需要找的dianNum等于0时，将flag设为true，返回。</p><p>遍历过程：对board矩阵进行遍历，找到第一个空格。然后对这空格使用1到9尝试填充，只有当used1、used2、used3对应的数字都未使用时，才能使用此数字进行填充。<strong>注意</strong>，这里进行回溯后，如果flag为true则直接结束此次循环（不然会将正确答案覆盖），否则应该将board[i] [j]设置 ‘.’（不然如果此次填充失败，会导致下次寻找待填充位置时认为此空格已经被填充）。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; used1;    vector&lt;vector&lt;int&gt;&gt; used2;    vector&lt;vector&lt;int&gt;&gt; used3;    bool flag;public:    void backtrace(vector&lt;vector&lt;char&gt;&gt;&amp; board,int dianNum)&#123;        if(flag) return;        if(dianNum&#x3D;&#x3D;0)&#123;            flag&#x3D;true;            return;        &#125;        int i,j;        for(i&#x3D;0;i&lt;board.size();++i)&#123;            for(j&#x3D;0;j&lt;board.size();++j)&#123;                if(board[i][j]!&#x3D;&#39;.&#39;) continue;                for(int k&#x3D;1;k&lt;&#x3D;9;++k)&#123;                    if(used1[i&#x2F;3][j&#x2F;3][k-1]&#x3D;&#x3D;0&amp;&amp;used2[i][k-1]&#x3D;&#x3D;0&amp;&amp;used3[j][k-1]&#x3D;&#x3D;0)&#123;                        used1[i&#x2F;3][j&#x2F;3][k-1]&#x3D;1;                        used2[i][k-1]&#x3D;1;                        used3[j][k-1]&#x3D;1;                        board[i][j]&#x3D;&#39;0&#39;+k;                        cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;board[i][j]&lt;&lt;endl;                        backtrace(board,dianNum-1);                        if(flag) return;                        board[i][j]&#x3D;&#39;.&#39;;                        used1[i&#x2F;3][j&#x2F;3][k-1]&#x3D;0;                        used2[i][k-1]&#x3D;0;                        used3[j][k-1]&#x3D;0;                    &#125;                &#125;                                return;&#x2F;&#x2F;只是为了找一个空格而已            &#125;        &#125;    &#125;    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;        flag&#x3D;false;        int n&#x3D;board.size();        used1&#x3D;vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(3,vector&lt;vector&lt;int&gt;&gt;(3,vector&lt;int&gt;(9,0)));&#x2F;&#x2F;3*3使用情况        used2&#x3D;vector&lt;vector&lt;int&gt;&gt;(9,vector&lt;int&gt;(9,0));&#x2F;&#x2F;水平使用情况        used3&#x3D;vector&lt;vector&lt;int&gt;&gt;(9,vector&lt;int&gt;(9,0));&#x2F;&#x2F;竖直使用情况        int dianNum&#x3D;0;        for(int i&#x3D;0;i&lt;n;++i)&#123;            for(int j&#x3D;0;j&lt;n;++j)&#123;                if(board[i][j]!&#x3D;&#39;.&#39;)&#123;                used1[i&#x2F;3][j&#x2F;3][board[i][j]-&#39;0&#39;-1]&#x3D;1;                used2[i][board[i][j]-&#39;0&#39;-1]&#x3D;1;                used3[j][board[i][j]-&#39;0&#39;-1]&#x3D;1;                &#125;else&#123;                    ++dianNum;                &#125;            &#125;        &#125;        backtrace(board,dianNum);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39. 组合总和</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h1><p>First：基础的回溯算法再加上一点剪枝</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>先对数组进行排序，使得可以进行剪枝优化。再使用常规的回溯方法不断递归重复找即可。</p><p>中止条件：当需要找的target为0时，将其添加进结果中</p><p>遍历过程：从小到大遍历，将当前值添加进临时数组，再回溯。</p><p>剪枝：由于数组已经进行从小到大排序，那么当前值如果大于target了，则说明无法在数组中找到值来凑成target，此时就剪掉这个枝节。</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;public:    void backtrace(const vector&lt;int&gt;&amp; candidates,int index,int target)&#123;        if(target&#x3D;&#x3D;0)&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;index;i&lt;candidates.size()&amp;&amp;target&gt;&#x3D;candidates[i];++i)&#123;            temp.push_back(candidates[i]);            backtrace(candidates,i,target-candidates[i]);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;        sort(candidates.begin(),candidates.end());        backtrace(candidates,0,target);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>40. 组合总和 II</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h1><p>First：和39差不多，只是需要点技巧来避免重复</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>本题关键是避免重复值，先对数组进行排序，使得更容易剪枝优化。</p><p>中止条件：当需要找的target为0时，将其添加进结果中</p><p>遍历过程：从小到大遍历，假设遍历到i，如果candidates[i]&#x3D;&#x3D;candidates[i-1]，且i&gt;index（起始位置），那么就应该跳过。（此题避免重复值的原理在于树枝同层有相同值得话就不能重复，就只能取一个，而不同层得相同值可以重复取）</p><p>剪枝：由于数组已经进行从小到大排序，那么当前值如果大于target了，则说明无法在数组中找到值来凑成target，此时就剪掉这个枝节。</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;public:    void backtrace(const vector&lt;int&gt;&amp; candidates,int index,int target)&#123;        if(target&#x3D;&#x3D;0)&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;index;i&lt;candidates.size()&amp;&amp;candidates[i]&lt;&#x3D;target;++i)&#123;            if(i&gt;index&amp;&amp;candidates[i]&#x3D;&#x3D;candidates[i-1]) continue;            temp.push_back(candidates[i]);            backtrace(candidates,i+1,target-candidates[i]);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;        sort(candidates.begin(),candidates.end());        backtrace(candidates,0,target);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46. 全排列</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h1><p>First：挺简单，使用一个数组来标记已经使用过的数即可</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>使用一个数组used来标记当前已经添加进temp中的数。</p><p>中止条件：当index等于数组长度时，结束</p><p>遍历过程：每次回溯都从0开始遍历，若当前值并未使用过，则添加进temp中并再used数组中进行标记，否则跳过当前数。每次回溯完成后，都需要将当前值弹出，且将标记更改为未使用。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;    vector&lt;int&gt; used;public:    void backtrace(vector&lt;int&gt; &amp;nums)&#123;        if(temp.size()&#x3D;&#x3D;nums.size())&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(used[i]&#x3D;&#x3D;1) continue;            used[i]&#x3D;1;            temp.push_back(nums[i]);            backtrace(nums);            temp.pop_back();            used[i]&#x3D;0;        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        used&#x3D;vector&lt;int&gt;(nums.size(),0);        backtrace(nums);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>47. 全排列 II</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-47-%E5%85%A8%E6%8E%92%E5%88%97II-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-47-%E5%85%A8%E6%8E%92%E5%88%97II-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h1><p>First：和46题的唯一不同之处是需要去重</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>先对数组进行排序，使得相同值位于一处，以便于遍历的时候进行去重。使用一个数组used来标记当前已经添加进temp中的数。</p><p>中止条件：当index等于数组长度时，结束</p><p>遍历过程：每次回溯都从0开始遍历。去重：若当前值和前一个值相同且前一个值并未使用的话，就代表两个数是在同一层，应当去重，此时应跳过此数。若当前值并未使用过，则添加进temp中并再used数组中进行标记，否则跳过当前数。每次回溯完成后，都需要将当前值弹出，且将标记更改为未使用。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;    vector&lt;int&gt; used;public:    void backtrace(vector&lt;int&gt; &amp;nums)&#123;        if(temp.size()&#x3D;&#x3D;nums.size())&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(used[i]&#x3D;&#x3D;1) continue;            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]&amp;&amp;used[i-1]&#x3D;&#x3D;0) continue;&#x2F;&#x2F;去重            used[i]&#x3D;1;            temp.push_back(nums[i]);            backtrace(nums);            temp.pop_back();            used[i]&#x3D;0;        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        used&#x3D;vector&lt;int&gt;(nums.size(),0);        backtrace(nums);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>491. 递增子序列</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode.cn/problems/increasing-subsequences/">491. 递增子序列</a></h1><p>First：折腾了挺久，想着整体只用一个数组来去重，感觉始终只差一步，解析十分简单，每次遍历都用一个数组来去重</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>此题不能先进行排序，因此会导致相同的数分布在不同位置，因此对于每个遍历，都定义一个数组来去重，如果数已经出现过，则跳过当前值，否则进行回溯。</p><p>中止条件：当index等于数组长度时，结束</p><p>遍历过程：从index遍历，当前值如果未出现，则在去重数组中进行标记再进行回溯。否则跳过。为了保证序列有序，每次添加值时都与末尾数组进行比较，大于等于末尾数组时才添加进临时数组中。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;    unordered_map&lt;int,int&gt; appear;    vector&lt;int&gt; used;public:    void backtrace(const vector&lt;int&gt;&amp; nums,int index)&#123;        if(index&gt;&#x3D;nums.size()) return;        int used[201]&#x3D;&#123;0&#125;;        for(int i&#x3D;index;i&lt;nums.size();++i)&#123;            if(used[nums[i]+100]&#x3D;&#x3D;1) continue;            used[nums[i]+100]&#x3D;1;            if(temp.size()&gt;0&amp;&amp;nums[i]&lt;temp.back()) continue;            temp.push_back(nums[i]);            if(temp.size()&gt;&#x3D;2) ans.push_back(temp);            backtrace(nums,i+1);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;        backtrace(nums,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51. N 皇后</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-51-N%E7%9A%87%E5%90%8E-difficult/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-51-N%E7%9A%87%E5%90%8E-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h1><p>First：思想不难，但比较麻烦</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>显然，每行必须也只能放一个皇后。使用一个矩阵来表示当前哪些位置不能放，使用temp来记录目前结果，使用num表示当前应该在第几行放置皇后。</p><p>中止条件：当放置皇后数量num等于n时，将temp添加进答案中。</p><p>遍历过程：从index行从小到大遍历，如果matrix[num] [i]&#x3D;&#x3D;‘.’，说明此位置可以放置皇后，然后使用一个新矩阵来记录现在所有不能放的位置（使用原矩阵的话很难返回上次状态），在temp中将此位置标记为放置皇后，然后回溯遍历，此次回溯完成后应将temp更改为原来状态.</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;string&gt;&gt; ans;    vector&lt;string&gt; temp;public:    vector&lt;string&gt; changeMatrix(const vector&lt;string&gt; &amp;matrix,int i,int j)&#123;&#x2F;&#x2F;因放置新皇后，返回现在不能放的所有位置        vector&lt;string&gt; res&#x3D;matrix;        int sum&#x3D;i+j;        int dif&#x3D;i-j;        for(int a&#x3D;0;a&lt;matrix.size();++a)&#123;            res[i][a]&#x3D;&#39;Q&#39;;            res[a][j]&#x3D;&#39;Q&#39;;                 if(0&lt;&#x3D;sum-a&amp;&amp;sum-a&lt;matrix.size())&#123;                res[a][sum-a]&#x3D;&#39;Q&#39;;            &#125;            if(a+dif&lt;matrix.size())&#123;                res[a+dif][a]&#x3D;&#39;Q&#39;;            &#125;        &#125;        return res;    &#125;    void backtrace(vector&lt;string&gt; &amp;matrix,int n,int num)&#123;        if(num&#x3D;&#x3D;n)&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;0;i&lt;n;++i)&#123;            if(matrix[num][i]&#x3D;&#x3D;&#39;.&#39;)&#123;&#x2F;&#x2F;尝试放置                vector&lt;string&gt; newMatrex&#x3D;changeMatrix(matrix,num,i);                temp[num][i]&#x3D;&#39;Q&#39;;                backtrace(newMatrex,n,num+1);                temp[num][i]&#x3D;&#39;.&#39;;            &#125;        &#125;    &#125;    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;        vector&lt;string&gt; matrix&#x3D;vector&lt;string&gt;(n,string(n,&#39;.&#39;));        temp&#x3D;vector&lt;string&gt;(n,string(n,&#39;.&#39;));        backtrace(matrix,n,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>679. 24 点游戏</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-679-24%E7%82%B9%E6%B8%B8%E6%88%8F-difficult/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-679-24%E7%82%B9%E6%B8%B8%E6%88%8F-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="679-24-点游戏"><a href="#679-24-点游戏" class="headerlink" title="679. 24 点游戏"></a><a href="https://leetcode.cn/problems/24-game/description/">679. 24 点游戏</a></h1><p>First：开始使用的深度遍历来做，先取得所有树的排列组合，然后对每个组合都使用四个运算符进行回溯，按理说这样没问题，不过还是报错，以后有机会再检查吧（感觉是有些减法排列取不到）。</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>直接穷举，不断从数组中取出两个数进行计算，然后将新数插入回去，再进行列举，每次都可以减少一个数字，最后判断第一个数字是否为24即可。为了解决实数除法，需要先将所有数字转为double型。</p><p>剪枝：加法和乘法只需要遍历遍历一次即可，所以当第一个数大于第二个数时跳过，减少遍历次数。</p><ul><li>时间复杂度：O(1) ，总可能性是9216种，固定的</li><li>空间复杂度：O(1)，递归最多只调用4层，因此是常数级</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    static constexpr double Target&#x3D;24;public:    bool judgePoint24(vector&lt;int&gt;&amp; cards) &#123;        vector&lt;double&gt; ll;        for(auto &amp;a:cards)            ll.push_back(static_cast&lt;double&gt;(a));        return solve(ll);    &#125;    bool solve(vector&lt;double&gt; &amp;ll)&#123;        if(ll.size()&#x3D;&#x3D;0) return false;        if(ll.size()&#x3D;&#x3D;1) return fabs(ll[0]-Target)&lt;1e-6;        int n&#x3D;ll.size();        for(int i&#x3D;0;i&lt;n;++i)&#123;            for(int j&#x3D;0;j&lt;n;++j)&#123;                if(i!&#x3D;j)&#123;                    vector&lt;double&gt; list2;                    for(int k&#x3D;0;k&lt;n;++k)&#123;                        if(k!&#x3D;i&amp;&amp;k!&#x3D;j) list2.push_back(ll[k]);                    &#125;                    for(int k&#x3D;0;k&lt;4;++k)&#123;                        if(k&lt;2&amp;&amp;i&gt;j) continue;                        if(k&#x3D;&#x3D;0)&#123;                            list2.push_back(ll[i]+ll[j]);                        &#125;else if(k&#x3D;&#x3D;1)&#123;                            list2.push_back(ll[i]*ll[j]);                        &#125;else if(k&#x3D;&#x3D;2)&#123;                            list2.push_back(ll[i]-ll[j]);                        &#125;else if(k&#x3D;&#x3D;3)&#123;                            if(fabs(ll[j])&lt;1e-6) return false;                            list2.push_back(ll[i]&#x2F;ll[j]);                        &#125;                        if(solve(list2)) return true;                        list2.pop_back();                    &#125;                &#125;            &#125;        &#125;        return false;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>77. 组合</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-77-%E7%BB%84%E5%90%88-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-77-%E7%BB%84%E5%90%88-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h1><p>First：基础的回溯算法再加上一点剪枝</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>不断递归重复找，按顺序遍历（只添加当前值后面的数）使得不存在重复值</p><p>中止条件：当k值小于等于0时，将收集到的数组添加到结果种</p><p>遍历过程：从小到大遍历，将当前值添加进临时数组，再回溯。</p><p>剪枝：当不存在k个数时进行剪枝</p><ul><li>时间复杂度：O((<em>k**n</em>)×<em>k</em>)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;int&gt; tem;    vector&lt;vector&lt;int&gt;&gt; ans;public:    void backtrace(int st,int end,int k)&#123;        if(k&lt;&#x3D;0) &#123;            ans.push_back(tem);            return;        &#125;        for(int i&#x3D;st;i&lt;&#x3D;end&amp;&amp;(end-i+1&gt;&#x3D;k);++i)&#123;            tem.push_back(i);            backtrace(i+1,end,k-1);            tem.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;        backtrace(1,n,k);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>78. 子集</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-78-%E5%AD%90%E9%9B%86-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-78-%E5%AD%90%E9%9B%86-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h1><p>First：很简单，注意添加空就可</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>按回溯递归进行遍历，记录每次路径即可，需要在开头添加一个空容器。</p><p>中止条件：当index等于数组长度时，结束</p><p>遍历过程：从index遍历，每当添加一个数字到temp中后，就将temp添加到ans中，回溯结束后需要弹出。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;public:    void backtrace(const vector&lt;int&gt; &amp;nums,int index)&#123;        if(index&#x3D;&#x3D;nums.size())&#123;            return;        &#125;        for(int i&#x3D;index;i&lt;nums.size();++i)&#123;            temp.push_back(nums[i]);            ans.push_back(temp);            backtrace(nums,i+1);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        ans.push_back(&#123;&#125;);        backtrace(nums,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>90. 子集 II</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-90-%E5%AD%90%E9%9B%86%20II-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-90-%E5%AD%90%E9%9B%86%20II-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></h1><p>First：注意不遍历同层相同值即可</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>和78题差不多，只是本题关键是避免重复值，先对数组进行排序，使得避免重复。</p><p>中止条件：当index与数组大小相同时，结束</p><p>遍历过程：从小到大遍历，假设遍历到i，如果nums[i]&#x3D;&#x3D;nums[i-1]，且i&gt;index（起始位置），那么就应该跳过。（此题避免重复值的原理在于树枝同层有相同值得话就不能重复，就只能取一个，而不同层得相同值可以重复取）将每个路径添加进结果中即可。</p><p>剪枝：</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;public:    void backtrace(const vector&lt;int&gt; &amp;nums,int index)&#123;        if(index&#x3D;&#x3D;nums.size())&#123;            return;        &#125;        for(int i&#x3D;index;i&lt;nums.size();++i)&#123;            if(i&gt;index&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;            temp.push_back(nums[i]);            ans.push_back(temp);            backtrace(nums,i+1);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        ans.push_back(&#123;&#125;);        backtrace(nums,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>93. 复原 IP 地址</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80-middle/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/leetcode-93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h1><p>First：在细节处折腾了好久，虽然最后还是做出来了</p><hr><p><strong>方法1</strong>：<strong>回溯</strong></p><p>题目中规定了逗号只能有三个，因此使用k来记录现有逗号数量（不包括最后一个，因为是要删除的），index来记录从哪开始遍历。不断递归重复找，按顺序遍历（只添加当前值后面的数）使得不存在重复值</p><p>中止条件：当k等于4时，若index等于s长度，则将当前temp添加进结果（这里temp最后也有个逗号，需要删除）</p><p>遍历过程：从index遍历，将当前字符添加进段字符串scur中，如果临时字符串对应的值满足要求，则将scur添加进temp中，再回溯遍历，否则应该结束遍历。注意，为了保证前导不能有0，而0又能作为一段，所以当scur对应的值为0时，进行递归回溯，但是递归回溯结束后就结束遍历。</p><p>剪枝：无</p><ul><li>时间复杂度：O()</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;string&gt; ans;    string temp;public:    void backtrace(const string &amp;s,int index,int k)&#123;&#x2F;&#x2F;k表示逗号数量        if(k&#x3D;&#x3D;4)&#123;            if(index&#x3D;&#x3D;s.size())&#123;                ans.push_back(temp.substr(0,temp.size()-1));&#x2F;&#x2F;不能直接pop_back，否则后面删除时会出现错误            &#125;            return;        &#125;        string scur;        for(int i&#x3D;index;i&lt;s.size();++i)&#123;            scur+&#x3D;s[i];            int num&#x3D;atoi(scur.c_str());            if(num&lt;&#x3D;255&amp;&amp;num&gt;&#x3D;0)&#123;                temp+&#x3D;scur;                temp+&#x3D;&#39;.&#39;;            &#125;else break;            backtrace(s,i+1,k+1);            temp&#x3D;temp.substr(0,temp.size()-scur.size()-1);            if(num&#x3D;&#x3D;0) break;&#x2F;&#x2F;为了保证不含前导0                    &#125;    &#125;    vector&lt;string&gt; restoreIpAddresses(string s) &#123;        backtrace(s,0,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法理论总结</title>
      <link href="/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"/>
      <url>/2023/02/15/leetcode/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><h2 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h2><p><strong>回溯法解决的问题都可以抽象为树形结构</strong></p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p><p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h2><p>回溯三部曲</p><ul><li>回溯函数模板返回值以及参数</li></ul><blockquote><p>回溯算法中函数返回值一般为void。</p><p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void backtracking(参数)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><ul><li>回溯函数终止条件</li></ul><blockquote><p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (终止条件) &#123;    存放结果;    return;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li>回溯搜索的遍历过程</li></ul><blockquote><p>回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;    处理节点;    backtracking(路径，选择列表); &#x2F;&#x2F; 递归    回溯，撤销处理结果&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>回溯算法模板框架如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); &#x2F;&#x2F; 递归        回溯，撤销处理结果    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="去重方法"><a href="#去重方法" class="headerlink" title="去重方法"></a>去重方法</h2><p>去重可分为两种情况：</p><ul><li>相同值位于一处</li><li>相同值分散在不同地方</li></ul><p><strong>相同值位于一处</strong></p><p>去除重复值主要是去除树同层之间的重复，而树不同层之间的相同值无需去除。而要做到这一点，则每次回溯遍历时，如果当前值与前值相同，且此值又是此次遍历中第一次遇见（说明前一个值是在树中上一层），那么此值应该选，否则不选。代码如下：</p><p><em><strong>初始点去重</strong></em></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;40. 组合总和 IIclass Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;public:    void backtrace(const vector&lt;int&gt;&amp; candidates,int index,int target)&#123;        if(target&#x3D;&#x3D;0)&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;index;i&lt;candidates.size()&amp;&amp;candidates[i]&lt;&#x3D;target;++i)&#123;            if(i&gt;index&amp;&amp;candidates[i]&#x3D;&#x3D;candidates[i-1]) continue;&#x2F;&#x2F;去重代码            temp.push_back(candidates[i]);            backtrace(candidates,i+1,target-candidates[i]);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;        sort(candidates.begin(),candidates.end());        backtrace(candidates,0,target);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面方法是一种特殊情况：遍历起始点是从上一层后面一个节点开始，使得可以用是否是第一个节点来去重。如果，遍历起始点是从其他地方开始，上述方法就无效了。</p><p>比如每次遍历都是从0开始，此时需要使用一个数组来记录每个值是否使用。当遇见两个相同值，如果前一个值被使用（添加进路径容器），说明当前值是在前一个值得下层，当前值可以使用。否则，说明前一个值没在路径中，此时如果使用当前值会造成重复。</p><p><em><strong>全局used数组去重（单个used数组去重）</strong></em></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;47. 全排列 IIclass Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;    vector&lt;int&gt; used;public:    void backtrace(vector&lt;int&gt; &amp;nums)&#123;        if(temp.size()&#x3D;&#x3D;nums.size())&#123;            ans.push_back(temp);            return;        &#125;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(used[i]&#x3D;&#x3D;1) continue;            if(i&gt;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]&amp;&amp;used[i-1]&#x3D;&#x3D;0) continue;&#x2F;&#x2F;去重            used[i]&#x3D;1;            temp.push_back(nums[i]);            backtrace(nums);            temp.pop_back();            used[i]&#x3D;0;        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end());        used&#x3D;vector&lt;int&gt;(nums.size(),0);        backtrace(nums);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>相同值分散在不同地方</strong></p><p>当相同值分散在各处时，此时就需要每次遍历的时候去重了。使用数组记录每个数是否使用过，在同一个循环中如果当前值被使用过，那么应该跳过，否则需要选中。</p><p><em><strong>局部used数组去重（多个used数组去重）</strong></em></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;491. 递增子序列class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; ans;    vector&lt;int&gt; temp;    unordered_map&lt;int,int&gt; appear;public:    void backtrace(const vector&lt;int&gt;&amp; nums,int index)&#123;        if(index&gt;&#x3D;nums.size()) return;        int used[201]&#x3D;&#123;0&#125;;        for(int i&#x3D;index;i&lt;nums.size();++i)&#123;            if(used[nums[i]+100]&#x3D;&#x3D;1) continue;&#x2F;&#x2F;去重            used[nums[i]+100]&#x3D;1;            if(temp.size()&gt;0&amp;&amp;nums[i]&lt;temp.back()) continue;            temp.push_back(nums[i]);            if(temp.size()&gt;&#x3D;2) ans.push_back(temp);            backtrace(nums,i+1);            temp.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;        backtrace(nums,0);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总体来看，都可以使用这种方法进行去重，但这种去重方法是最耗费空间的，每次遍历都需要申请一个数组来记录状态。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>151. 反转字符串中的单词</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-151-middle/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-151-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h1><p>First：先找出每个单词再拼一起。写到后面发现可以从尾部遍历，那么就不需要额外空间了。</p><hr><p><strong>方法1</strong>：<strong>顺序遍历+双指针</strong></p><p>从首部开始，使用两个指针来找到单词的首尾从而找到每个单词，使用一个容器存储这些单词，再将每个单词拼在一起即可</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string reverseWords(string s) &#123;        vector&lt;string&gt; words;        int left&#x3D;0,right&#x3D;0;        while(left&lt;s.length()&amp;&amp;right&lt;s.length())&#123;            while(left&lt;s.length()&amp;&amp;s[left]&#x3D;&#x3D;&#39; &#39;)&#123;                ++left;            &#125;            right&#x3D;left;            while(right&lt;s.length()&amp;&amp;s[right]!&#x3D;&#39; &#39;)&#123;                ++right;            &#125;            if(left&gt;&#x3D;s.length()||right&gt;&#x3D;s.length()+1||left&gt;&#x3D;right) break;            words.push_back(s.substr(left,right-left));            left&#x3D;right;        &#125;        string ans;        for(int i&#x3D;words.size()-1;i&gt;&#x3D;0;--i)&#123;            ans+&#x3D;words[i];            if(i!&#x3D;0) ans+&#x3D;&#39; &#39;;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>逆序遍历+双指针</strong></p><p>从尾部开始，使用两个指针来找到单词的首尾，再将每个单词拼在一起即可</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string reverseWords(string s) &#123;        int left&#x3D;s.length()-1,right&#x3D;s.length()-1;        string ans;        while(left&gt;&#x3D;0&amp;&amp;right&gt;&#x3D;0)&#123;            while(right&gt;&#x3D;0&amp;&amp;s[right]&#x3D;&#x3D;&#39; &#39;)&#123;                --right;            &#125;            left&#x3D;right;            while(left&gt;&#x3D;0&amp;&amp;s[left]!&#x3D;&#39; &#39;)&#123;                --left;            &#125;            if(left&gt;&#x3D;right) break;            ans+&#x3D;s.substr(left+1,right-left);            ans+&#x3D;&#39; &#39;;            right&#x3D;left;        &#125;        ans.pop_back();        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>原地更改</strong></p><p>直接将原来的字符串先反转，然后再将每个单词反转回来，去掉首位空格即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28. 找出字符串中第一个匹配项的下标</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-28-middle/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-28-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h1><p>First：使用KMP算法查找</p><hr><p><strong>方法1</strong>：<strong>KMP算法</strong></p><p>使用暴力算法做了许多不必要的对比，而KMP算法减少对比的方法就是使用前缀表来记录下一次应该从子串的哪个位置开始对比。</p><blockquote><p>前缀表：记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀</p><ul><li>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</li><li>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/mujiubai/piclib@main/picgo/image-20220921183734095.png" alt="image-20220921183734095"></p><p>在上图匹配过程中，原串匹配到a时匹配失败，此时可以发现没必要从子串的开始处重新比对，而只需要将子串指针移动到e，而原串指针不变继续比对即可。</p><p>如何找移动位置？</p><ul><li>其实就是找原串现已经匹配成功的字符串后缀（以匹配失败的a前一个字符b的后缀）和匹配串的前缀（以串首a构成的前缀）最多有多少相同字符</li><li>而字符串是在a和f匹配失败，那么说明前面部分是一样的，也就是说通过匹配串上就能找到移动位置</li></ul><p>找最大相同前缀后缀方法：先使用指针j指向前缀末尾，指针i指向后缀末尾（初始时比对两个字符，因此i初始化为1，j初始化为0）。比对i和j指向数是否相同，若相同，则next[i]&#x3D;j，表明i位置相同后缀后缀最大值为j，i和j都加1再比较下一个位置；如果不相同，j就需要往前退直到找到相同值（退到第一个值则表明最大相同前缀后缀值为0），next[j]记录着之前的子串的相同前后缀的长度。</p><p>因此，KMP算法就是先计算next数组，然后匹配时，如果遇见不匹配字符，则看前一个字符的next值。</p><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int strStr(string haystack, string needle) &#123;        &#x2F;&#x2F;计算next数组        vector&lt;int&gt; next(needle.size(),0);        for(int i&#x3D;1,j&#x3D;0;i&lt;needle.size();++i)&#123;            while(j&gt;0&amp;&amp;needle[j]!&#x3D;needle[i])&#123;&#x2F;&#x2F;不能是j&gt;&#x3D;0，否则面对没有公共节点的前缀和后缀会一直循环                j&#x3D;next[j-1];            &#125;            if(needle[j]&#x3D;&#x3D;needle[i]) ++j;            next[i]&#x3D;j;        &#125;        &#x2F;&#x2F;匹配        for(int i&#x3D;0,j&#x3D;0;i&lt;haystack.size();++i)&#123;            while(j&gt;0&amp;&amp;haystack[i]!&#x3D;needle[j])&#123;                j&#x3D;next[j-1];&#x2F;&#x2F;看前一个字符得next值是因为当前字符已经匹配失败，用前一个字符才能找到多少个不用不配字符            &#125;            if(haystack[i]&#x3D;&#x3D;needle[j])&#123;                ++j;            &#125;            if(j&#x3D;&#x3D;needle.size())&#123;                return i-needle.size()+1;            &#125;        &#125;        return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>Sunday算法</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O()</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-字符串 </tag>
            
            <tag> Alg-KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>344. 反转字符串</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-344-simple/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-344-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h1><p>First：直接交换即可</p><hr><p><strong>方法1</strong>：<strong>双指针</strong></p><p>双指针指向前部和尾部，再交换即可</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        int n&#x3D;s.size();        for(int i&#x3D;0,j&#x3D;n-1;i&lt;j;++i,--j)&#123;            swap(s[i],s[j]);        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>459. 重复的子字符串</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-459-simple/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-459-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h1><p>First：不知道开始咋想的，想通过判断是否2个子串重复和3个子串重复来判断是否重复。看了下答案，通过移位来判断是没想到。</p><hr><p><strong>方法1</strong>：<strong>KMP</strong></p><p>如果字符串 <code>S</code> 包含一个重复的子字符串，那么这意味着您可以多次 “移位” 字符串，并使其与原始字符串匹配。</p><p>但每次移动字符串太麻烦，创建一个新的字符串为两个原字符串相加，每次移动的结果在新字符串中都有，因此直接找原字符串是否在新字符串中出现即可。但注意的是，需要将新字符串的首字符和尾字符串删除或不比对。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool kmp(string &amp;s1,string &amp;s2)&#123;        vector&lt;int&gt; next(s2.size(),0);        for(int i&#x3D;1,j&#x3D;0;i&lt;s2.size();++i)&#123;            while(j&gt;0&amp;&amp;s2[i]!&#x3D;s2[j]) j&#x3D;next[j-1];            if(s2[i]&#x3D;&#x3D;s2[j]) ++j;            next[i]&#x3D;j;        &#125;        for(int i&#x3D;1,j&#x3D;0;i&lt;s1.size()-1;++i)&#123;&#x2F;&#x2F;不比对首字符和尾字符            while(j&gt;0&amp;&amp;s1[i]!&#x3D;s2[j]) j&#x3D;next[j-1];            if(s1[i]&#x3D;&#x3D;s2[j]) ++j;            if(j&#x3D;&#x3D;s2.size()) return true;        &#125;        return false;    &#125;    bool repeatedSubstringPattern(string s) &#123;        string s1&#x3D;s+s;        return kmp(s1,s);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>优化的KMP</strong></p><p>还没看，但打败率要高很多</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-字符串 </tag>
            
            <tag> Alg-KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>541. 反转字符串 II</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-541-simple/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-541-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h1><p>First：直接交换</p><hr><p><strong>方法1</strong>：<strong>模拟</strong></p><p>每次跳过k个数，将其反转即可，只是处理下末尾数不够2k个情况</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        int n&#x3D;s.length();        for(int i&#x3D;0;i*k&lt;n;++i)&#123;            if(i%2&#x3D;&#x3D;1) continue;            int end&#x3D;(i+1)*k-1&lt;n?(i+1)*k-1:n-1;            for(int j&#x3D;i*k,k&#x3D;end;j&lt;k;++j,--k)&#123;                swap(s[j],s[k]);            &#125;        &#125;        return s;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>792. 匹配子序列的单词数</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-792-%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0-middle/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/leetcode-792-%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="792-匹配子序列的单词数"><a href="#792-匹配子序列的单词数" class="headerlink" title="792. 匹配子序列的单词数"></a><a href="https://leetcode.cn/problems/number-of-matching-subsequences/description/">792. 匹配子序列的单词数</a></h1><p>First：用双指针和哈希map虽然过了，但效率不够高。看了解析使用了方法二，虽然时间复杂度低了，但最后打败比例差不多。</p><hr><p><strong>方法1</strong>：<strong>双指针+哈希map</strong></p><p>对于words中的每个字符串，使用双指针方法来判断是否是子串。但这复杂度比较高，当words中存在许多重复的就过不了，因此使用一个unordered_map来过滤。</p><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int match(const string &amp;s1,const string &amp;s2)&#123;        if(s2.size()&gt;s1.size()) return 0;        int i&#x3D;0,j&#x3D;0;        while(i&lt;s1.size()&amp;&amp;j&lt;s2.size())&#123;            if(s1[i]&#x3D;&#x3D;s2[j])&#123;                ++i;                ++j;            &#125;else&#123;                ++i;            &#125;        &#125;        return j&#x3D;&#x3D;s2.size()?1:0;    &#125;    int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) &#123;        int ans&#x3D;0;        unordered_map&lt;string,int&gt; map;        for(int i&#x3D;0;i&lt;words.size();++i)&#123;            map[words[i]]++;        &#125;        for(auto &amp;it:map)&#123;            int t&#x3D;match(s,it.first);            ans+&#x3D;t*it.second;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>二分查找+哈希map</strong></p><p>同样先使用unordered_map过滤相同元素。</p><p>使用传统双指针来匹配是否为子序列速度比较慢，其找下一个匹配元素是逐个找的，可使用二分查找加快。</p><p>使用一个二维pos数据来记录字符出现位置，pos[i]记录s中’a’+i字符出现的所有位置。当进行匹配时，通过二分不断找到word[i]的每个字符出现位置（注意，找到第一个字符位置后，只会在这个位置之后找第二个字符的位置）。</p><ul><li>时间复杂度：O(logn*words数量 * word字符数)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    vector&lt;vector&lt;int&gt;&gt; pos;public:    int match(const string &amp;s1,const string &amp;s2)&#123;        if(s2.size()&gt;s1.size()) return 0;        int p&#x3D;-1;        for(int i&#x3D;0;i&lt;s2.size();++i)&#123;            auto &amp;t&#x3D;pos[s2[i]-&#39;a&#39;];            auto idx&#x3D;upper_bound(t.begin(),t.end(),p);            if(idx&#x3D;&#x3D;t.end())&#123;                return 0;            &#125;            p&#x3D;*idx;        &#125;        return 1;    &#125;    int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) &#123;        int ans&#x3D;0;        pos&#x3D;vector&lt;vector&lt;int&gt;&gt;(26);        for(int i&#x3D;0;i&lt;s.size();++i)&#123;            pos[s[i]-&#39;a&#39;].push_back(i);        &#125;        unordered_map&lt;string,int&gt; map;        for(int i&#x3D;0;i&lt;words.size();++i)&#123;            map[words[i]]++;        &#125;        for(auto &amp;it:map)&#123;            int t&#x3D;match(s,it.first);            ans+&#x3D;t*it.second;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 05. 替换空格</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%89%91%E6%8C%87-05-simple/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%89%91%E6%8C%87-05-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h1><p>First：先数空格，然后替换。但看到答案发现可以直接在原来数组上进行替换，只是要倒序遍历，空间效率更高。</p><hr><p><strong>方法1</strong>：<strong>遍历</strong></p><p>先数空格数量，再申请一个string，依次遍历替换即可</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string replaceSpace(string s) &#123;        int num&#x3D;0;        for(auto c:s)&#123;            if(c&#x3D;&#x3D;&#39; &#39;) ++num;        &#125;        string ans(s.length()+num*2,&#39; &#39;);        for(int i&#x3D;0,j&#x3D;0;i&lt;s.length();++i)&#123;            if(s[i]!&#x3D;&#39; &#39;)&#123;                ans[j++]&#x3D;s[i];            &#125;else&#123;                ans[j++]&#x3D;&#39;%&#39;;                ans[j++]&#x3D;&#39;2&#39;;                ans[j++]&#x3D;&#39;0&#39;;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法1</strong>：<strong>原地替换</strong></p><p>先数空格数量，将原数组进行扩容，然后从尾部进行遍历替换</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 58 - II. 左旋转字符串</title>
      <link href="/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%89%91%E6%8C%87-58-simple/"/>
      <url>/2023/02/15/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%89%91%E6%8C%87-58-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h1><p>First：就直接遍历即可，但没想到可以用取余来简化操作，使用反转三次效率更高</p><hr><p><strong>方法1</strong>：<strong>遍历</strong></p><p>依次遍历字符串即可，但是可以用取余操作来简化代码，不用写两个循环</p><p>或直接用substr函数</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    string reverseLeftWords(string s, int n) &#123;        int len&#x3D;s.length();        string ans;        ans.reserve(len);                for(int i&#x3D;n;i&lt;len+n;++i)&#123;            ans+&#x3D;s[i%len];        &#125;        return ans;        &#x2F;&#x2F;return s.substr(n,s.size()-n)+s.substr(0,n);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>原地反转</strong></p><p>以n未界限将字符串分为两部分，前半部分和后半部分都反转，然后整体再反转得到结果</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li><li><pre><code class="c++">class Solution &#123;public:    string reverseLeftWords(string s, int n) &#123;        reverse(s.begin(),s.begin()+n);        reverse(s.begin()+n,s.end());        reverse(s.begin(),s.end());        return s;    &#125;&#125;;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1004. 最大连续1的个数 III</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0III-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0III-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/">1004. 最大连续1的个数 III</a></h1><p>FIrst：比较顺利，使用双指针法即可</p><hr><p><strong>方法1</strong>：<strong>双指针</strong></p><p>使用两个指针left和right分别指向区间的左右，依次遍历数组，如果当前值为1则将right+1；如果为0，则判断当前区间中已有的0个数是否超过限制，如果未超过限制，则直接将right+1，否则需要移动左边界使得整体区间中少一个0，然后将right+1。记录区间的最大长度即为结果。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int longestOnes(vector&lt;int&gt;&amp; nums, int k) &#123;        int left&#x3D;0,right&#x3D;0,kn&#x3D;0;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(nums[i]&#x3D;&#x3D;1) ++right;            else &#123;                ++right;                if(kn&lt;k) ++kn;                                     else&#123;                    while(nums[left]!&#x3D;0) ++left;                    ++left;                &#125;                            &#125;            ans&#x3D;max(ans,right-left);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>162. 寻找峰值</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a href="https://leetcode.cn/problems/find-peak-element/description/">162. 寻找峰值</a></h1><p>FIrst：没做出来，这二分比较巧妙</p><hr><p><strong>方法1</strong>：<strong>二分法</strong></p><p>由于 <code>nums[-1] = nums[n] = -∞</code>，那么<strong>只要数组中存在一个元素比相邻元素大，那么沿着它一定可以找到一个峰值</strong>（比如nums[a]&lt;nums[a+1]，如果nums[a+2]小于nums[a+1]，则nums[a+1]为峰值，如果大于则继续比较a+2，即使一直递增但由于最末尾是一个负无穷，则也会存在一个峰值）</p><p>因此，设置两个指针left和right，计算中间值m，如果nums[m]&gt;nums[m+1]，则right&#x3D;m；否则left&#x3D;m+1；</p><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;        int left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;right)&#123;            int mid&#x3D;left+(right-left)&#x2F;2;            if(nums[mid+1]&gt;nums[mid]) left&#x3D;mid+1;            else right&#x3D;mid;        &#125;        return left;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>209. 长度最小的子数组</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-209-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-209-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h1><p>First：第一次见到这题想的还是用双重for循环或动态规划来做，但复杂度都超过O(n)</p><hr><p><strong>方法1</strong>：<strong>滑动窗口</strong> </p><p>使用一个窗口来表示选择了哪些数，循环遍历过程中，每次向滑动窗口中添加一个数，如果窗口总和小于target，则继续遍历。否则，则从窗口左边开始减少数，一直减少到窗口总和不小于target，再将此时窗口大小和返回值比较。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;                int sum&#x3D;0,ans&#x3D;INT_MAX,window&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            sum+&#x3D;nums[i];            ++window;            if(sum&lt;target) continue;            for(int j&#x3D;i-window+1;j&lt;&#x3D;i;++j)&#123;                if(sum-nums[j]&lt;target) break;                sum-&#x3D;nums[j];                window--;            &#125;            if(window&lt;ans) ans&#x3D;window;        &#125;        return ans&#x3D;&#x3D;INT_MAX?0:ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
            <tag> Alg-滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27. 移除元素</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-27-simple/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-27-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h1><p>First：看见这题直觉想的是使用双指针来做，但是我想到的是使用前后指针，即左边找到一个需要去除的，再从右边找到一个无需去除的，将右边找到的数填充的左边即可，这种方法会导致一些特俗用例通不过，如只有一个值。最后，看了解析发现这种思路需要一些技巧，见方法2.</p><hr><p><strong>方法1</strong>：<strong>快慢指针</strong></p><p>使用双指针来做，即快指针和慢指针，快指针依次遍历每个元素，同时在遍历时将每个元素复制到正确位置，因此需要一个慢指针代表元素正确位置。正确位置也就是移除元素后的位置，因此，找到快指针遍历时如果是需要移除的元素，则慢指针位置不变，否则慢指针+1.、</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        if(nums.empty())return 0;        int fast&#x3D;0,low&#x3D;0;        for(;fast&lt;nums.size();++fast)&#123;            if(nums[fast]!&#x3D;val)&#123;                nums[low]&#x3D;nums[fast];                ++low;            &#125;        &#125;        return low;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>左右双指针</strong></p><p>使用左右指针来做，左指针遍历查看是否是需要去除的元素，如果是则复制右指针的值，技巧见代码</p><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int left &#x3D; 0, right &#x3D; nums.size();        while (left &lt; right) &#123;            if (nums[left] &#x3D;&#x3D; val) &#123;                nums[left] &#x3D; nums[right - 1];                right--;            &#125; else &#123;                left++;            &#125;        &#125;        return left;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>287. 寻找重复数</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/description/">287. 寻找重复数</a></h1><p>FIrst：这映射思想值得学习</p><hr><p><strong>方法1</strong>：<strong>双指针+回环</strong></p><p>假设数组中是每个节点，可以为每个节点连接一个箭头指向下一个节点，连接规则即若节点值为k，则指向nums[k]。</p><p>由以上连接规则可知，由于数组中存在重复值，则一定会有两个箭头指向同一个节点，因此存在回环，就可以将此问题转换为检测回环起点问题。</p><p>使用快慢指针，快指针每次前进两步，慢指针每次前进一步，由于存在回环，则必相遇。和回环起点问题一样，将慢指针指向初始位置0处，然后快慢指针每次都只走一步，当指向节点值相同时即为答案（回环起始点必有两个箭头指向它）</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int slow&#x3D;0,fast&#x3D;0;        do&#123;            slow&#x3D;nums[slow];            fast&#x3D;nums[nums[fast]];        &#125;while(slow!&#x3D;fast);        slow&#x3D;0;        do&#123;            slow&#x3D;nums[slow];            fast&#x3D;nums[fast];        &#125;while(slow!&#x3D;fast);        return slow;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>二分查找</strong></p><p>假设任取一个值k，如果数组中小于等于此值的数量大于k，则说明存在重复数。使用二分查找不断缩小空间。</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int n&#x3D;nums.size();        int l&#x3D;0,r&#x3D;n-1,ans;        while(l&lt;&#x3D;r)&#123;            int mid&#x3D;(l+r)&#x2F;2;            int cnt&#x3D;0;            for(int i&#x3D;0;i&lt;n;++i)&#123;                cnt+&#x3D;nums[i]&lt;&#x3D;mid;            &#125;            if(cnt&lt;&#x3D;mid)&#123;                l&#x3D;mid+1;            &#125;else&#123;                r&#x3D;mid-1;                ans&#x3D;mid;            &#125;        &#125;        &#x2F;&#x2F;还可以建立一种隐射，找环的位置来做，还没这样做过，不过想不出为啥这样建隐射        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
            <tag> Alg-二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>414. 第三大的数</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-414-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0-simple/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-414-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a><a href="https://leetcode.cn/problems/third-maximum-number/description/">414. 第三大的数</a></h1><p>First：忘记set自带排序了，但最后实测两种方法打败比例差不多</p><hr><p><strong>方法1</strong>：<strong>排序</strong></p><p>先排序，然后找到是否有第三大的数，如果没有则返回第一个数。</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int thirdMax(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(),nums.end(),greater&lt;int&gt;());        int n&#x3D;0,t&#x3D;nums[0]-1;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(t!&#x3D;nums[i])&#123;                t&#x3D;nums[i];                ++n;                if(n&#x3D;&#x3D;3) return t;            &#125;        &#125;        return nums[0];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>有序集合</strong></p><p>不断将数插入set中，set会自动排序，当set容量大于3时就弹出第一个元素，使得set容量始终保持为3。</p><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int thirdMax(vector&lt;int&gt;&amp; nums) &#123;        set&lt;int&gt; s;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            s.insert(nums[i]);            if(s.size()&gt;3)&#123;                s.erase(s.begin());            &#125;        &#125;        return s.size()&#x3D;&#x3D;3?*s.begin():*s.rbegin();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：<strong>使用三个数存储</strong></p><p>使用三个数来存储第一大、第二大、第三大，一次遍历即可</p><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-排序 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>581. 最短无序连续子数组</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/">581. 最短无序连续子数组</a></h1><p>FIrst：O(n)的方法没写出来， 虽然以前做过</p><hr><p><strong>方法1</strong>：<strong>线性遍历</strong></p><p>将给定的数组 nums\textit{nums}nums 表示为三段子数组拼接的形式，分别记作 numsA、numsB、numsC，重排numsB即可有序。</p><p>numsA中的每个数一定都小于等于numB的最小值，那么从后向前遍历，记录当前最小值，如果nums[i]&gt;minn，则left&#x3D;i，找到最小的left值作为左边界。</p><p>同理，numsC中的每个数一定都大于等于numsB的最大值，那么从前向后遍历，记录最大值，如果nums[i]&gt;maxn，则right&#x3D;i,找到最大的right作为右边界。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123;        int maxn&#x3D;INT_MIN,right&#x3D;-1;        int minn&#x3D;INT_MAX,left&#x3D;-1;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(maxn&gt;nums[i]) right&#x3D;i;            else maxn&#x3D;nums[i];        &#125;        for(int i&#x3D;nums.size()-1;i&gt;&#x3D;0;--i)&#123;            if(minn&lt;nums[i]) left&#x3D;i;            else minn&#x3D;nums[i];        &#125;        return right&#x3D;&#x3D;-1?0:right-left+1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>排序</strong></p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>59. 螺旋矩阵 II</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-59-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-59-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h1><p>FIrst：就按顺时针模拟就可。</p><hr><p><strong>方法1</strong>：<strong>按层模拟</strong></p><p>将矩阵看成若干层，每个按顺时针旋转模拟填入一层，但注意不要在每个边处理相同的个数，否则遇见n&#x3D;1时需要单独处理。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;        if(n&lt;&#x3D;0) return &#123;&#123;&#125;&#125;;        vector&lt;vector&lt;int&gt;&gt; ans(n,vector(n,0));        int hl&#x3D;0,hr&#x3D;n-1;        int vt&#x3D;0,vb&#x3D;n-1;        int num&#x3D;1;        while(num&lt;&#x3D;n*n)&#123;            for(int i&#x3D;hl;i&lt;&#x3D;hr;++i)&#123;                ans[vt][i]&#x3D;num;                ++num;            &#125;            for(int i&#x3D;vt+1;i&lt;&#x3D;vb;++i)&#123;                ans[i][hr]&#x3D;num;                ++num;            &#125;            for(int i&#x3D;hr-1;i&gt;&#x3D;hl;--i)&#123;                ans[vb][i]&#x3D;num;                ++num;            &#125;            for(int i&#x3D;vb-1;i&gt;vt;--i)&#123;                ans[i][hl]&#x3D;num;                ++num;            &#125;            ++hl;            --hr;            ++vt;            --vb;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>模拟</strong></p><p>模拟矩阵的生成。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
            <tag> Alg-模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>665. 非递减数列</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-665-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-665-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a><a href="https://leetcode.cn/problems/non-decreasing-array/description/">665. 非递减数列</a></h1><p>First：失败了好几次。。。真面向测试编程</p><hr><p><strong>方法1</strong>：<strong>遍历</strong> </p><p>很明显，可以通过统计不满足非递减的个数来判断，但是当面对如[3,4,2,3]这种有两段有序但交接处不满足要求的数组时，则还需要判断前后数字是否满足要求，即判断nums[i-1]&lt;nums[i+1]&amp;&amp;nums[i]&lt;nums[i+2]是否成立（这是因为如果前后两段都满足要求的话只需要比较前段最大值和后段最小值即可，毕竟如果段中不满足要求时就不会有有序的两段），否则返回FALSE。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size()-1;++i)&#123;            if(nums[i]&gt;nums[i+1])&#123;                &#x2F;&#x2F;判断前后两段是有序的情况，这种情况下只需要判断nums[i-1]和nums[i+2]即可                if((i&gt;0&amp;&amp;nums[i-1]&gt;nums[i+1])&amp;&amp;(i&lt;nums.size()-2&amp;&amp;nums[i]&gt;nums[i+2])) return false;                ++ans;                if(ans&gt;1) return false;            &#125;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>更改数字</strong> </p><p>当找到不满足要求的数字时，如果nums[i+1]&lt;nums[i-1]时（这是为了保证前面有一段都小于nums[i+1]，如果只有一个数小于nums[i+1]，则没必要改，因为可以通过改nums[i]来解决，避免改nums[i+1]导致后面不满足要），将nums[i+1]&#x3D;nums[i]，然后继续遍历，如果不满足要求的数字大于1，则返回false。</p><blockquote><p>不设nums[i]&#x3D;nums[i+1]的原因是 此时虽然保证了此处有序，但前面的数不一定小于等于nums[i+1]，而设nums[i+1]&#x3D;nums[i]的话，nums[i+1]以前的数一定满足要求，而数组还会往后遍历查看不满足要求的数字个数</p></blockquote><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size()-1;++i)&#123;            if(nums[i]&gt;nums[i+1])&#123;                ++ans;                if(ans&gt;1) return false;                if(i&gt;0&amp;&amp;nums[i+1]&lt;nums[i-1]) nums[i+1]&#x3D;nums[i];            &#125;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>724. 寻找数组的中心下标</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87-simple/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724. 寻找数组的中心下标"></a><a href="https://leetcode.cn/problems/find-pivot-index/description/">724. 寻找数组的中心下标</a></h1><p>FIrst：傻了，从两边遍历，但遇见负数或正数就需要单独处理，麻烦且还不一定对</p><hr><p><strong>方法1</strong>：<strong>前缀和</strong></p><p>先求得数组总和total，然后从左开始遍历，如果左边以左的数相加和lsum&#x3D;&#x3D;total-lsum-nums[i]，则说明找到答案。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int pivotIndex(vector&lt;int&gt;&amp; nums) &#123;        int total&#x3D;0,lsum&#x3D;0;        for(auto a:nums) total+&#x3D;a;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(lsum&#x3D;&#x3D;total-nums[i]-lsum) return i;            lsum+&#x3D;nums[i];        &#125;        return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75. 颜色分类</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-middle/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/description/">75. 颜色分类</a></h1><p>FIrst：记得以前考研时做过，这次没有一遍遍历做出来</p><hr><p><strong>方法1</strong>：<strong>双指针</strong></p><p>采用双指针分别遍历两次，第一次先将0调换到数组前部分，第二次再将1调换到数组中部。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;right)&#123;            while(nums[left]&#x3D;&#x3D;0&amp;&amp;left&lt;right) ++left;            while(nums[right]!&#x3D;0&amp;&amp;left&lt;right) --right;            if(left&lt;right)&#123;                int t&#x3D;nums[left];                nums[left]&#x3D;nums[right];                nums[right]&#x3D;t;            &#125;        &#125;        left&#x3D;0,right&#x3D;nums.size()-1;        while(left&lt;nums.size()&amp;&amp;nums[left]&#x3D;&#x3D;0) ++left;        while(left&lt;right)&#123;            while(nums[left]&#x3D;&#x3D;1&amp;&amp;left&lt;right) ++left;            while(nums[right]&#x3D;&#x3D;2&amp;&amp;left&lt;right) --right;            if(left&lt;right)&#123;                int t&#x3D;nums[left];                nums[left]&#x3D;nums[right];                nums[right]&#x3D;t;            &#125;                    &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>三指针</strong></p><p>一次遍历。先使用两个指针p1 p2分别指向已排好的0和1尾部，使用一个指针从头到尾进行遍历，如果nums[i]&#x3D;1，则将其与nums[p2]进行交换，并p2+1；当nums[i]&#x3D;0时，此时将其与nums[p1]进行交换，但如果已经有1排好序，即p2&gt;p1，此时将会把1交换到nums[i]，因此还需要将nums[i]和nums[p2]交换，最后p1和p2都加1.</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        int p1&#x3D;0,p2&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(nums[i]&#x3D;&#x3D;0)&#123;                swap(nums[i],nums[p1]);                                                if(p1&lt;p2)&#123;                    swap(nums[i],nums[p2]);                                    &#125;                      ++p2;                ++p1;                      &#125;else if(nums[i]&#x3D;&#x3D;1)&#123;                swap(nums[i],nums[p2]);                ++p2;            &#125;        &#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>775. 全局倒置与局部倒置</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-775-%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-775-%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="775-全局倒置与局部倒置"><a href="#775-全局倒置与局部倒置" class="headerlink" title="775. 全局倒置与局部倒置"></a><a href="https://leetcode.cn/problems/global-and-local-inversions/description/">775. 全局倒置与局部倒置</a></h1><p>FIrst：开始打算分别计算两个值来比较，尝试了下错了，后来想到只要找到错误就可以判断了</p><hr><p><strong>方法1</strong>：<strong>维护最大值</strong></p><p>由定义得知全局倒置数量一定大于等于局部倒置数量，而只有当一个数nums[i]在大于i+1后还有比nums[i]小的数，此时全局倒置数量才会大于局部倒置数量。</p><p>对nums进行遍历，当遍历到i时，使用一个maxNum记录0到i-2的最大值，此时如果maxNum大于nums[i]，则说明全局倒置数量一定比局部多，返回false即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool isIdealPermutation(vector&lt;int&gt;&amp; nums) &#123;        int maxNum&#x3D;-1;        for(int i&#x3D;1;i&lt;nums.size();++i)&#123;            if(maxNum&gt;nums[i]) return false;            maxNum&#x3D;max(maxNum,nums[i-1]);        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>977. 有序数组的平方</title>
      <link href="/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-977-simple/"/>
      <url>/2023/02/15/leetcode/%E6%95%B0%E7%BB%84/leetcode-977-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h1><p>FIrst：原数组有序，因此只需要处理正负数平凡带来的影响即可。见到这题的第一想法便是方法1。</p><hr><p><strong>方法1</strong>：<strong>分界值+双指针</strong></p><p>先找到正负数的分界位置，从分界处开始向左右两边遍历，依次选择最小的即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;        int n&#x3D;nums.size();        if(n&#x3D;&#x3D;0) return &#123;&#125;;        vector&lt;int&gt; ans;        ans.reserve(n);        int pos&#x3D;0;        for(;pos&lt;n&amp;&amp;nums[pos]&lt;0;++pos)&#123;&#125;        int positive&#x3D;pos,negative&#x3D;pos-1;        int ansSize&#x3D;0;        while(positive&lt;n&amp;&amp;negative&gt;&#x3D;0)&#123;            int t1&#x3D;nums[positive]*nums[positive];            int t2&#x3D;nums[negative]*nums[negative];            if(t1&lt;t2)&#123;                ans.push_back(t1);                ++positive;            &#125;else&#123;                ans.push_back(t2);                                --negative;            &#125;            ++ansSize;        &#125;        while(positive&lt;n)&#123;            ans.push_back(nums[positive]*nums[positive++]);        &#125;        while(negative&gt;&#x3D;0)&#123;            ans.push_back(nums[negative]*nums[negative--]);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>双指针</strong></p><p>方法1还需要去寻找分界位置，需要一次遍历消耗。由于本题没说要排除重复值之类，因此结果大小是固定的。可以直接选择从原数组两头进行比较，选择最大值插入到结果数组中，从尾向头插入即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>155. 最小栈</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88-middle/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/description/">155. 最小栈</a></h1><p>First：没想到咋做，看了答案才知道直接存储每次的最小值。。。不过有个解法是存储差值很有意思。</p><hr><p><strong>方法1</strong>：<strong>双栈</strong></p><p>使用两个栈，栈s存储元素，一个栈ms存最小值。当push一个元素时，ms的栈顶元素与压入栈元素比较得到最小值。当取最小值时，则返回ms的栈顶元素。</p><ul><li>时间复杂度：O(1) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MinStack &#123;    stack&lt;int&gt; s;    stack&lt;int&gt; ms;public:    MinStack() &#123;    &#125;        void push(int val) &#123;        s.push(val);        if(!ms.empty())&#123;            ms.push(min(ms.top(),s.top()));        &#125;else&#123;            ms.push(s.top());        &#125;    &#125;        void pop() &#123;        s.pop();        ms.pop();    &#125;        int top() &#123;        return s.top();    &#125;        int getMin() &#123;        return ms.top();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法2</strong>：<strong>栈中存差值</strong></p><p>此方法只需常量级空间存储最小值。</p><p>成员包括一个栈s和一个最小值minValue，当push元素val时，dif&#x3D;val-minValue，将dif压入栈，当dif小于0时，说明minValue&#x3D;val。当pop时，如果s.top()&lt;0，弹出栈顶元素即可并将minValue&#x3D;minValue-dif，否则弹出栈顶元素即可。</p><p>注意栈中存的元素应为Long，否则相减值会越界。</p><ul><li>时间复杂度：O(1) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MinStack &#123;    stack&lt;long&gt; s;    int minValue;public:    MinStack() &#123;    &#125;        void push(int val) &#123;        if(s.empty())&#123;            s.push(0);            minValue&#x3D;val;        &#125;else&#123;            long dif&#x3D;(long)val-minValue;            if(dif&lt;0) minValue&#x3D;val;            s.push(dif);        &#125;    &#125;        void pop() &#123;        if(s.top()&lt;0)&#123;            minValue-&#x3D;s.top();                    &#125;        s.pop();    &#125;        int top() &#123;        return s.top()&lt;0?minValue:minValue+s.top();    &#125;        int getMin() &#123;        return minValue;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>239. 滑动窗口最大值</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-difficult/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值</a></h1><p>First：傻了，没想到使用单调队列来找最大数</p><hr><p><strong>方法1</strong>：<strong>单调队列</strong></p><p>关键在于如何滑动窗口中快速找到最大值</p><p>使用一个deque来维持从大到小的单调队列，队首元素为最大值。</p><p>每当滑动窗口向右移动，将新添加的值与队尾元素不断比较，若大于队尾元素则将队尾元素弹出（相等不弹出），否则压入队尾；将要删除的值与队首元素比较，如果相等则说明当前最大值被删除了，此时将队首元素弹出。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; ans;        deque&lt;int&gt; que;        for(int i&#x3D;0;i&lt;k;++i)&#123;            while(!que.empty()&amp;&amp;que.back()&lt;nums[i])&#123;                que.pop_back();            &#125;            que.push_back(nums[i]);        &#125;        ans.push_back(que.front());        for(int i&#x3D;k;i&lt;nums.size();++i)&#123;            while(!que.empty()&amp;&amp;que.back()&lt;nums[i])&#123;                que.pop_back();            &#125;            que.push_back(nums[i]);            if(nums[i-k]&#x3D;&#x3D;que.front())&#123;                que.pop_front();            &#125;            ans.push_back(que.front());        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>347. 前 K 个高频元素</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-middle/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">347. 前 K 个高频元素</a></h1><p>First：使用的两次比较来做，没想到用优先级队列</p><hr><p><strong>方法1</strong>：<strong>排序</strong></p><p>先使用unordered_map统计每个数的频率，再对频率进行排序，最后取前K个值。</p><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(pair&lt;int,int&gt;&amp; a,pair&lt;int,int&gt;&amp; b)&#123;        return a.second&gt;b.second;    &#125;    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; ans;        unordered_map&lt;int,int&gt; map;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            map[nums[i]]++;        &#125;        vector&lt;pair&lt;int,int&gt;&gt; freq;        for(auto &amp;it:map)&#123;            freq.push_back(pair&lt;int,int&gt;(it.first,it.second));        &#125;        sort(freq.begin(),freq.end(),compare);        for(int i&#x3D;0;i&lt;k;++i)&#123;            ans.push_back(freq[i].first);        &#125;                return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法2</strong>：<strong>优先级队列</strong></p><p>和方法一一样，先使用map统计每个数的频率，使用一个priority_queue来维持一个小顶堆，将小顶堆的节点数维持在K个，最后返回小顶堆中的元素即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-排序 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>636. 函数的独占时间</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-636-%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4-middle/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/leetcode-636-%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="636-函数的独占时间"><a href="#636-函数的独占时间" class="headerlink" title="636. 函数的独占时间"></a><a href="https://leetcode.cn/problems/exclusive-time-of-functions/description/">636. 函数的独占时间</a></h1><p>First：比较难处理的是遇到先end后start且中间有空格的情况，这就会导致必须使用栈来存储信息。目前方法效率较低</p><hr><p><strong>方法1</strong>：<strong>栈</strong></p><p>每次取相邻两组数据进行分析，如果第一组数据是start则将其压入栈中，然后分析第二组数据。可分为两种情况：</p><ul><li><p>第二组数据是start时：</p><ul><li>当第一组数据是start时，这段消耗时间属于第一组数据</li><li>当第一组数据是end时，此时这段消耗时间并不属于第一组，需要用栈来找到所属任务</li></ul></li><li><p>第二组数据是end时，先弹出栈顶元素，再分为以下情况：</p><ul><li>当第一组数据是start时，消耗时间属于第一组任务</li><li>当第一组数据是end时，消耗时间属于第二组任务</li></ul><p>注意这四张情况计算消耗时间会有所不同，</p></li><li><p>时间复杂度：O(n) </p></li><li><p>空间复杂度：O(n)</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:        vector&lt;string&gt; getLog(string &amp;log)&#123;        int k1&#x3D;0,k2&#x3D;log.size();        while(log[k1]!&#x3D;&#39;:&#39;)++k1;        while(log[k2]!&#x3D;&#39;:&#39;)--k2;        return &#123;log.substr(0,k1),log.substr(k1+1,k2-k1-1),log.substr(k2+1,log.size()-k2-1)&#125;;    &#125;    vector&lt;int&gt; exclusiveTime(int n, vector&lt;string&gt;&amp; logs) &#123;        vector&lt;int&gt; ans(n,0);        stack&lt;int&gt; st;        for(int i&#x3D;1;i&lt;logs.size();++i)&#123;            vector&lt;string&gt; log&#x3D;getLog(logs[i-1]);            int idx1&#x3D;atoi(log[0].c_str());            int num1&#x3D;atoi(log[2].c_str());            string flag1&#x3D;log[1];            log&#x3D;getLog(logs[i]);            int idx2&#x3D;atoi(log[0].c_str());            int num2&#x3D;atoi(log[2].c_str());            string flag2&#x3D;log[1];            if(flag1&#x3D;&#x3D;&quot;start&quot;) st.push(idx1);            if(flag2&#x3D;&#x3D;&quot;start&quot;) &#123;                if(flag1&#x3D;&#x3D;&quot;start&quot;) ans[idx1]+&#x3D;(num2-num1);                else if(num2-num1-1&gt;0) ans[st.top()]+&#x3D;(num2-num1-1);            &#125;            else &#123;                st.pop();                if(flag1&#x3D;&#x3D;&quot;start&quot;) ans[idx1]+&#x3D;(num2-num1+1);                 else ans[idx2]+&#x3D;(num2-num1);             &#125;           &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45. 跳跃游戏 II</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-1005-K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C-simple/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-1005-K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h1><p>First：折腾了半天，细节一直没搞好，总想着用最高效率，但这样又会太抠细节</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>局部最优：将每个负数变为正数</p><p>全局最优：尽量将所有负数都变为正数</p><p>先对数组进行排序，将所有负数变为正数，如果负数数量为大于等于k，则只将最小的K个负数变为正数，如果负数数量小于k，此时将所有负数变为正数，然后再进行一次排序。如果（k-负数数量）%2&#x3D;&#x3D;1，则表示必须翻转一次数，此时选排序后的最小值进行翻转可使得整体最大。最后，将数组相加即可。</p><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123;        sort(nums.begin(),nums.end());        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(nums[i]&lt;0&amp;&amp;k&gt;0)&#123;                nums[i]&#x3D;-nums[i];                --k;            &#125;        &#125;        sort(nums.begin(),nums.end());        if(k%2&#x3D;&#x3D;1)&#123;            nums[0]&#x3D;-nums[0];        &#125;        int sum&#x3D;0;        for(auto a:nums) sum+&#x3D;a;                return sum;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1029. 两地调度</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-1029-%E4%B8%A4%E5%9C%B0%E8%B0%83%E5%BA%A6-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-1029-%E4%B8%A4%E5%9C%B0%E8%B0%83%E5%BA%A6-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="1029-两地调度"><a href="#1029-两地调度" class="headerlink" title="1029. 两地调度"></a><a href="https://leetcode.cn/problems/two-city-scheduling/description/">1029. 两地调度</a></h1><p>First：快20天没刷题了，没做出来，想的是确定一个维度在来做，看了解析发现思想是真简洁</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>先将所有都派往A公司，然后从其中选出N个人改变行程前往B公司，那么应该选priceB-priceA最小的N个人才能使得总费用最少。</p><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int twoCitySchedCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123;        int n&#x3D;costs.size()&#x2F;2;        int res&#x3D;0;        for(int i&#x3D;0;i&lt;costs.size();++i)&#123;            res+&#x3D;costs[i][0];        &#125;        sort(costs.begin(), costs.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;            return (a[1]-a[0])&lt;(b[1]-b[0]);        &#125;);        for(int i&#x3D;0;i&lt;n;++i)&#123;            res+&#x3D;costs[i][1]-costs[i][0];        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>122. 买卖股票的最佳时机 II</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><p>First：使用的动态规划</p><p>Second：使用贪心，但思想和代码随想录中的题解有出入</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        &#x2F;&#x2F;动态规划         int dp1&#x3D;-prices[0],dp2&#x3D;0;         for(int i&#x3D;1;i&lt;prices.size();++i)&#123;             int t&#x3D;dp1;             dp1&#x3D;max(dp1,dp2-prices[i]);             dp2&#x3D;max(dp2,t+prices[i]);                     &#125;         return max(dp1,dp2);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>贪心</strong></p><p>局部最优：股票能赚钱只有在价格上升阶段，那么找出每个上升阶段，以上升阶段尾部值减去上升阶段首部值即为局部最大利润</p><p>全局最优：所有局部最优加起来即可</p><blockquote><p>代码随想录题解：</p><p>局部最优：找到每天相比前一天能赚钱的那些天（可以看成将大的上升阶段分成了小的上升阶段）</p><p>全局最优：将能赚钱的那些天利润加起来</p></blockquote><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        &#x2F;&#x2F;贪心        int ans&#x3D;0;        int sp&#x3D;prices[0];        for(int i&#x3D;1;i&lt;prices.size();++i)&#123;            if(prices[i]&lt;prices[i-1])&#123;                ans+&#x3D;prices[i-1]-sp;                sp&#x3D;prices[i];            &#125;        &#125;        ans+&#x3D;prices[prices.size()-1]-sp;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>134. 加油站</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h1><p>First：不知道为啥想到了找最大子串和</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>对于每个加油站，都可以计算出当前加油站能加油量与到下一个加油站的消耗的差值remain，由题中可知，只会存在唯一解，那么remain子串中最大值就一定是能保证开一圈的，这代表开了这些加油站后剩余油量最大，如果最大子串都不能开一圈，那么其他子串也不行。这问题也就转化为找最大子串。</p><p>局部最优：</p><p>全局最优：</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;        &#x2F;&#x2F; vector&lt;int&gt; remain(gas.size(),0);        &#x2F;&#x2F; int reSum;        &#x2F;&#x2F; for(int i&#x3D;0;i&lt;cost.size();++i)&#123;        &#x2F;&#x2F;     remain[i]&#x3D;gas[i]-cost[i];        &#x2F;&#x2F;     reSum+&#x3D;remain[i];        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; if(reSum&lt;0) return -1;        &#x2F;&#x2F; int start&#x3D;0, maxSum&#x3D;0;        &#x2F;&#x2F; for(int i&#x3D;0;i&lt;remain.size();++i)&#123;        &#x2F;&#x2F;     if(maxSum&lt;0)&#123;        &#x2F;&#x2F;         start&#x3D;i;        &#x2F;&#x2F;         maxSum&#x3D;remain[i];        &#x2F;&#x2F;     &#125;else&#123;        &#x2F;&#x2F;         maxSum+&#x3D;remain[i];        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; return start;        &#x2F;&#x2F;简化        int remainSum&#x3D;0,maxStart&#x3D;0,maxSum&#x3D;0;&#x2F;&#x2F;maxstart:子串起始点，maxsum：子串和        for(int i&#x3D;0;i&lt;gas.size();++i)&#123;            int remain&#x3D;gas[i]-cost[i];            remainSum+&#x3D;remain;            if(maxSum&lt;0)&#123;                maxSum&#x3D;remain;                maxStart&#x3D;i;            &#125;else&#123;                maxSum+&#x3D;remain;            &#125;        &#125;        return remainSum&lt;0?-1:maxStart;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>135. 分发糖果</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h1><p>First：两个月前做过，但还是没做出来。。。</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>由于相邻两个孩子评分更高的孩子会获得更多糖果，那么如果一起考虑左右孩子的情况会很复杂。将左右孩子分成两次进行考虑，每个只考虑左边或右边的孩子造成的影响，然后取最大的糖果数即可。</p><p>局部最优：</p><p>全局最优：</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int candy(vector&lt;int&gt;&amp; ratings) &#123;        vector&lt;int&gt; left(ratings.size(),1),right(ratings.size(),1);        for(int i&#x3D;1;i&lt;ratings.size();++i)&#123;            if(ratings[i]&gt;ratings[i-1])&#123;                left[i]&#x3D;left[i-1]+1;            &#125;        &#125;        for(int i&#x3D;ratings.size()-2;i&gt;&#x3D;0;--i)&#123;            if(ratings[i]&gt;ratings[i+1])&#123;                right[i]&#x3D;right[i+1]+1;            &#125;        &#125;        int sum&#x3D;0;        for(int i&#x3D;0;i&lt;left.size();++i)&#123;            sum+&#x3D;max(left[i],right[i]);        &#125;        return sum;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>376. 摆动序列</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h1><p>First：这道题我动荡了好久，上次写到写到都不想写了，始终觉得解析有点难理解，整的都有点心魔了，随想录得答案虽然能过，但始终觉得不舒服，最后写出了自己得特殊情况处理方法。</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p><img src="C:\Users\MyPC\AppData\Roaming\Typora\typora-user-images\image-20221029160040935.png" alt="image-20221029160040935"></p><p>如图，整个序列可以画成这种曲线，而其中那些没有交替的段可以将其删除，即为最大摆动序列</p><p>这道题特殊情况很难处理，比如[0,0,0] [3,3,3,2,5]。主要分为两个情况：找到第一个波动段和对第一个波动段的处理。一个是只能两端对比，那么波动第一段就很难处理；另一个是前面部分都是相同值，使得第一段不是第一个波动段。</p><p>特殊情况处理方法：对于第一个波动段处理，则在前面添加一段为波动段的相反值。而要找到第一个波动段，则要去除数组起始的重复值，则先找到第一个不重复的位置，也就找到第一个波动段所在。</p><blockquote><p>代码随想录处理方法：</p><p>处理方法就是默认最右边有一个摆动点（将count&#x3D;1)，假设第一个点左边还有一个相同值得点，即第一段dif1初始值设为0，当(dif1&gt;&#x3D;0&amp;&amp;dif2&lt;0)||(dif1&lt;&#x3D;0&amp;&amp;dif2&gt;0)时，第一段（最左边的点）也就能被计算了。</p></blockquote><p>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个摆动点。</p><p>全局最优：整个序列有最多的局部峰值，从而达到最长摆动序列。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;贪心class Solution &#123;public:    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;        &#x2F;&#x2F;代码随想录        &#x2F;&#x2F; if(nums.size()&lt;&#x3D;1) return 1;        &#x2F;&#x2F; int count&#x3D;1,dif1&#x3D;0;        &#x2F;&#x2F; for(int i&#x3D;1;i&lt;nums.size();++i)&#123;        &#x2F;&#x2F;     int dif2&#x3D;nums[i]-nums[i-1];        &#x2F;&#x2F;     if((dif1&gt;&#x3D;0&amp;&amp;dif2&lt;0)||(dif1&lt;&#x3D;0&amp;&amp;dif2&gt;0))&#123;        &#x2F;&#x2F;         ++count;        &#x2F;&#x2F;         dif1&#x3D;dif2;   &#x2F;&#x2F;不能放在if外 否则类似[3,5,5,6]会出错        &#x2F;&#x2F;     &#125;                             &#x2F;&#x2F; &#125;        &#x2F;&#x2F; return count;        &#x2F;&#x2F;自己写得        if(nums.size()&lt;&#x3D;1) return nums.size();        int index&#x3D;0;        for(;index&lt;nums.size()-1&amp;&amp;nums[index]&#x3D;&#x3D;nums[index+1];++index)&#123;&#125; &#x2F;&#x2F;去除前面重复值，重复值情况影响找交替段        if(index&#x3D;&#x3D;nums.size()-1) return 1;&#x2F;&#x2F;如果index到数组末尾了，说明整个数组全部是重复得，也就只有一个波动段        int count&#x3D;1,pre&#x3D;nums[index]-nums[index+1];&#x2F;&#x2F;将pre设置与第一段相反得值，使得第一段更好处理        for(int i&#x3D;index+1;i&lt;nums.size();++i)&#123;            int cur&#x3D;nums[i]-nums[i-1];            if(cur*pre&lt;0)&#123;                ++count;                pre&#x3D;cur;            &#125;        &#125;        return count;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>分成了两个序列来计算</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>406. 根据身高重建队列</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h1><p>First：以前做过，今天脑袋昏昏沉沉，知道了应该先排序，但后面没做出来</p><blockquote><p><strong>当有多个维度的数据时，需要先确定一个维度，再来做另一个维度，一起考虑的话会很繁琐</strong></p></blockquote><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。<strong>如果两个维度一起考虑一定会顾此失彼</strong>。</p><p>先对身高从大到小进行排序，当身高相同时，k较小的排在前面。当排序完成后，依次遍历people[i]，people[i] [1]代表people[i] 应该插入的位置（因为此时people[i]前面的数一定比它大，插入到第k个位置就代表前面有k个比它大的），不断插入得到最终结果。</p><p>（由于是从大到小排序，且从大到小插入的，无需考虑后面插入对前面造成的影响，因为后面的数一定比前面的小，即使插入到前面去了，也不会对k造成影响）</p><p>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性</p><p>全局最优：最后都做完插入操作，整个队列满足题目队列属性</p><ul><li>时间复杂度：O(n^2)  </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)&#123;        return a[0]&gt;b[0]||(a[0]&#x3D;&#x3D;b[0]&amp;&amp;a[1]&lt;b[1]);    &#125;    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;        sort(people.begin(),people.end(),compare);&#x2F;&#x2F;先确定一个维度上的顺序 先确定高度        for(int i&#x3D;0;i&lt;people.size();++i)&#123;&#x2F;&#x2F;必须从头到尾插            vector&lt;int&gt; t&#x3D;people[i];            int index&#x3D;t[1];            &#x2F;&#x2F; if(people[index]&#x3D;&#x3D;t) continue;            for(int j&#x3D;i;j&gt;index;--j)&#123;                people[j]&#x3D;people[j-1];            &#125;            people[index]&#x3D;t;        &#125;                return people;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>435. 无重叠区间</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h1><p>First：没做出来，不知道咋处理一个区间覆盖多个区间，但被覆盖的这些区间并不交叉这种特俗情况。</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>可以使用以左边界排序或右边界排序，但遍历方向不一样。</p><p>以右边界进行排序（右边界一样时左边界小的在前），从左到右进行遍历，当找到与上一个区间不交叉时num+1，找到所有不交叉的区间数num，使用总区间数减去num即为结果。</p><p>上述方法当遇见那种特俗情况时，由于是按右边界进行排序且从左到右进行遍历，其内部的区间一定排在其前面，一定会先处理其内部区间。（此题也可按左边界排序，从右到左依次选左边界最大的值）</p><p>也可使用452题，将区间边界判定改一下</p><p>局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。</p><p>全局最优：选取最多的非交叉区间。</p><ul><li>时间复杂度：O(nlogn) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(const vector&lt;int&gt; &amp;a,const vector&lt;int&gt; &amp;b)&#123;        return a[1]&lt;b[1]||(a[1]&#x3D;&#x3D;b[1]&amp;&amp;a[0]&gt;b[0]);    &#125;    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        sort(intervals.begin(),intervals.end(),compare);        cout&lt;&lt;endl;        int ans&#x3D;1,end&#x3D;intervals[0][1];&#x2F;&#x2F;end记录当前区间右边界        for(int i&#x3D;1;i&lt;intervals.size();++i)&#123;            vector&lt;int&gt; &amp;p&#x3D;intervals[i];            if(p[0]&gt;&#x3D;end)&#123;                ++ans;                end&#x3D;p[1];            &#125;        &#125;        return intervals.size()-ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45. 跳跃游戏 II</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h1><p>First：没做出来。</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>局部最优：找到走每一步所能到的最远距离</p><p>全局最优：当第一次当前步数的最远距离覆盖末尾时，即为最小步数</p><p>走一步会有一个距离覆盖，走2步同样有一个距离覆盖，求出每一步的距离覆盖，当第一次覆盖末尾时，即为最小步数。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()&#x3D;&#x3D;1) return 0;        int count&#x3D;0,cur_dis&#x3D;0,next_dis&#x3D;nums[0];        for(int i&#x3D;0;i&lt;nums.size();)&#123;                        while(i&lt;&#x3D;cur_dis)&#123;                next_dis&#x3D;max(next_dis,i+nums[i]);                if(next_dis&gt;&#x3D;nums.size()-1) return count+1;                ++i;            &#125;            cur_dis&#x3D;next_dis;            ++count;        &#125;        return 0;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>452. 用最少数量的箭引爆气球</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h1><p>First：ac了</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>当气球出现重叠时，就使用一只箭，注意一个重叠区域必须所有气球都有重叠。使用start和end记录当前区域，如果下一个区域和当前区域有交叉，则将当前区域区间更新为交叉区域，否则用箭数量加1。</p><p>局部最优：当气球出现重叠，一起射，所用弓箭最少。</p><p>全局最优：把所有气球射爆所用弓箭最少。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(const vector&lt;int&gt; &amp;a,const vector&lt;int&gt; &amp;b)&#123;        return a[0]&lt;b[0];    &#125;    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        sort(points.begin(),points.end(),compare);        int ans&#x3D;0,start&#x3D;-1,end&#x3D;-1;        for(int i&#x3D;0;i&lt;points.size();++i)&#123;            vector&lt;int&gt; &amp;p&#x3D;points[i];            if(p[0]&lt;start||p[0]&gt;end)&#123;                ++ans;                start&#x3D;p[0];                end&#x3D;p[1];            &#125;else&#123;                start&#x3D;max(start,p[0]);&#x2F;&#x2F;更新为重叠的区间，这样就避免三个以上气球区间其实不重叠                end&#x3D;min(end,p[1]);            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>455. 分发饼干</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h1><p>First：做久了动态规划，一下转到贪心还是不适合，遗憾，此题没做出来，总感觉有层膜没被捅破</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>先对两个数组进行从小到大排序，每个饼干都找到小于饼干值的最小孩子，然后剔除此孩子，继续遍历下一个饼干</p><p>局部最优：每个饼干分给能满足其胃口的孩子中胃口最小的那个孩子</p><p>全局最优：每个饼干都分给合适的孩子，所有饼干所分给的孩子就最多</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;        sort(g.begin(),g.end());        sort(s.begin(),s.end());        int start&#x3D;0;        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;s.size();++i)&#123;              if(start&gt;&#x3D;g.size()) break;            if(s[i]&lt;g[start])&#123;                continue;            &#125;else&#123;                ++ans;                ++start;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53. 最大子数组和</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h1><p>First：没做出来，定义不好dp含义，用两重循环超时了</p><p>Second：才做几天，刷贪心算法系列题又遇见了，不过没用贪心做出来，对这题理解得不够透彻</p><blockquote><p>动态规划五部法：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></blockquote><hr><p><strong>方法1</strong>：<strong>动态规划</strong></p><p>使用一维dp数组来记录状态，dp[i] 表示以nums[i-1]结尾的最大连续子数组的和，那么找到最大的dp即为结果。</p><p>要求以nums[i-1]结尾的最大和，那么对于nums[i-2]结尾的最大和dp[i-1]，如果dp[i-1]&gt;0，那么加上dp[i-1]才能使得dp[i]更大，否则就不应该加上dp[i-1]，而是从num[i-1]重新作为连续子数组的头和尾。因此，dp[i]&#x3D;max(dp[i-1]+nums[i-1],nums[i-1])。</p><p>皆初始化为0。</p><p>从小到大遍历即可。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n) 可优化为1</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int n&#x3D;nums.size();        vector&lt;int&gt; dp(n+1,0);        int ans&#x3D;INT_MIN;        for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;            dp[i]&#x3D;max(nums[i-1]+dp[i-1],nums[i-1]);            ans&#x3D;max(ans,dp[i]);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>贪心</strong></p><p>遍历整个数组，当遍历到任意位置k时，若现有连续子数组和为负时，nums[k]加上前面的连续子数组结果会更小，此时应该舍弃前面数组，而以nums[k]作为新子数组的起始。</p><p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p><p>全局最优：选取最大“连续和”</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int ans&#x3D;INT_MIN;        int count&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            count+&#x3D;nums[i];            ans&#x3D;max(ans,count);            if(count&lt;0) count&#x3D;0;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：<strong>分治法</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(logn)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55. 跳跃游戏</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h1><p>First：没使用贪心最初来，没想到可以用最大范围覆盖来考虑，其实用动态规划来理解贪心解析会更简单。</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>局部最优：找到每个位置所能到的最远位置</p><p>全局最优：找到每个局部最优值中的最大值，以此最大值来判断是否能达到数组末尾。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int s&#x3D;0;        int max_region&#x3D;0;        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;            if(i&gt;max_region) return false;            max_region&#x3D;max(max_region,i+nums[i]);        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>以动态规划方法来理解上面的贪心算法</p><p>以一维数组dp来记录状态，dp[i]表示通过nums前i个数组能到达的最远位置</p><p>只有当nums前i-1个数能到第i个数时，nums[i]才有用dp[i]&#x3D;max(dp[i-1],i+nums[i])，否则dp[i]&#x3D;dp[i-1];</p><p>初始化为0</p><p>由转移公式知，dp[i]由dp[i-1]决定，因此从小到大遍历</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. 合并区间</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/description/">56. 合并区间</a></h1><p>First：和763题一样合并所有区间</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>先对数组进行排序，依次遍历，如果当前区间与前一个区间有交叉则将其合并，否则则将上一个区间加入结果中。</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(const vector&lt;int&gt; &amp;a,const vector&lt;int&gt; &amp;b)&#123;        return a[0]&lt;b[0];    &#125;    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        vector&lt;vector&lt;int&gt;&gt; ans;        sort(intervals.begin(),intervals.end(),compare);        int start&#x3D;intervals[0][0],end&#x3D;intervals[0][1];        for(int i&#x3D;1;i&lt;intervals.size();++i)&#123;            if(intervals[i][0]&gt;end)&#123;                ans.push_back(&#123;start,end&#125;);                start&#x3D;intervals[i][0];                end&#x3D;intervals[i][1];            &#125;else&#123;                end&#x3D;max(end,intervals[i][1]);            &#125;        &#125;        ans.push_back(&#123;start,end&#125;);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>714. 买卖股票的最佳时机含手续费</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费</a></h1><p>First：动态规划还挺还做，用贪心是没想出来，看了解析之后发现这技巧很nice</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>在做收获利润操作的时候其实有三种情况：</p><ul><li>情况一：收获利润的这一天并不是收获利润区间里的最后一天（不是真正的卖出，相当于持有股票），所以后面要继续收获利润。</li><li>情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。</li><li>情况三：不作操作，保持原有状态（买入，卖出，不买不卖）</li></ul><p>局部最优：</p><p>全局最优：</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;        &#x2F;&#x2F;贪心        int ans&#x3D;0;        int minPrice&#x3D;prices[0];        for(int i&#x3D;1;i&lt;prices.size();++i)&#123;            if(prices[i]&lt;minPrice) minPrice&#x3D;prices[i];&#x2F;&#x2F;情况二，情况三代码可以不用写出来            if(prices[i]&gt;minPrice+fee)&#123;                ans+&#x3D;prices[i]-minPrice-fee;                minPrice&#x3D;prices[i]-fee;&#x2F;&#x2F;这一步极为关键，情况一            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>分为两种状态：持有股票和不持有股票</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;        &#x2F;&#x2F;动态规划 空间还可以优化为o(1)        &#x2F;&#x2F; vector&lt;vector&lt;int&gt;&gt; dp(prices.size(),vector&lt;int&gt;(2,0));        &#x2F;&#x2F; dp[0][0]&#x3D;-prices[0];        &#x2F;&#x2F; for(int i&#x3D;1;i&lt;prices.size();++i)&#123;        &#x2F;&#x2F;     dp[i][0]&#x3D;max(dp[i-1][1]-prices[i],dp[i-1][0]);        &#x2F;&#x2F;     dp[i][1]&#x3D;max(dp[i-1][0]+prices[i]-fee,dp[i-1][1]);        &#x2F;&#x2F;     cout&lt;&lt;dp[i][0]&lt;&lt;&quot; &quot;&lt;&lt;dp[i][1]&lt;&lt;endl;        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; return max(dp[prices.size()-1][0],dp[prices.size()-1][1]);        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>738. 单调递增的数字</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738. 单调递增的数字"></a><a href="https://leetcode.cn/problems/monotone-increasing-digits/description/">738. 单调递增的数字</a></h1><p>First：昨天没做出来，尝试了从后向前遍历但无法解决100这种情况，也尝试了从前向后遍历。其实没观察到只要一个数字变了后面的数字都要变为9这个特点</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>可以观察到一个特点：一个数字变小之后，其后面的数字会都变为9，只有这样才能变到最大。但不能从前向后遍历找到第一个非单调递增的数字，比如332这种情况，因为当遇到strNum[i-1]&gt;strNum[i]时，会将strNum[i-1]-1，这样便会导致strNum[i-2]&gt;strNum[i-1]。</p><p>因此，需要从后向前遍历，当strNum[i-1]&gt;strNum[i]时，将strNum[i-1]-1，flag标记为i，遍历完成后将flag以后的数字都变为9即可。</p><p>局部最优：</p><p>全局最优：</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int monotoneIncreasingDigits(int n) &#123;        string strNum&#x3D;to_string(n);        int size&#x3D;strNum.size();        int flag&#x3D;size;        for(int i&#x3D;size-1;i&gt;0;--i)&#123;            if(strNum[i-1]&gt;strNum[i])&#123;                flag&#x3D;i;                strNum[i-1]--;            &#125;        &#125;        for(int i&#x3D;flag;i&lt;size;++i)&#123;            strNum[i]&#x3D;&#39;9&#39;;        &#125;        return stoi(strNum);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>763. 划分字母区间</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-middle/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/description/">763. 划分字母区间</a></h1><p>First：转换下成求不相交区间个数</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>先求每一个字母出现的区间，只要相交的区间合并成一个（合并后取区间最大），最后计算剩余区间个数。</p><p>局部最优：</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    static bool compare(const vector&lt;int&gt; &amp;a,const vector&lt;int&gt; &amp;b)&#123;        return a[0]&lt;b[0];    &#125;    vector&lt;int&gt; partitionLabels(string s) &#123;        vector&lt;vector&lt;int&gt;&gt; letter(26,vector&lt;int&gt;(2,-2));        for(int i&#x3D;0;i&lt;s.size();++i)&#123;            int index&#x3D;s[i]-&#39;a&#39;;            if(letter[index][0]&lt;0) letter[index][0]&#x3D;i;            letter[index][1]&#x3D;max(letter[index][1],i);        &#125;        sort(letter.begin(),letter.end(),compare);        vector&lt;int&gt; ans;        int count&#x3D;0, start&#x3D;-1,end&#x3D;-1;        for(int i&#x3D;0;i&lt;letter.size();++i)&#123;            if(letter[i][0]&gt;end)&#123;                ans.push_back(end-start+1);                start&#x3D;letter[i][0];                end&#x3D;letter[i][1];            &#125;else if(letter[i][0]&gt;start)&#123;                ++count;                start&#x3D;min(start,letter[i][0]);                end&#x3D;max(end,letter[i][1]);            &#125;        &#125;        ans.push_back(end-start+1);        ans.erase(ans.begin());        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>860. 柠檬水找零</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6-simple/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a><a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h1><p>First：看着复杂，但逻辑固定</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>只会存在三种收款情况：收到5元、10元和20元，收到5元不用找零，收到10元只能找5元，而收到20元就有两种情况，一个是找3张5元，一个是找1张5元和1张10元，但是应该优先找10元，因为10元能由5元凑成。</p><p>局部最优：遇到账单20，优先消耗美元10，完成本次找零。</p><p>全局最优：完成全部账单的找零</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;        int remain5&#x3D;0,remain10&#x3D;0,remain20&#x3D;1;        for(int i&#x3D;0;i&lt;bills.size();++i)&#123;            int left&#x3D;bills[i]-5;            if(left&#x3D;&#x3D;0)&#123;                remain5+&#x3D;1;            &#125;else if(left&#x3D;&#x3D;5)&#123;                if(remain5&lt;&#x3D;0) return false;                remain5-&#x3D;1;                remain10+&#x3D;1;            &#125;else&#123;                if(remain10&gt;&#x3D;1&amp;&amp;remain5&gt;&#x3D;1)&#123;&#x2F;&#x2F;优先找10元                    remain5-&#x3D;1;                    remain10-&#x3D;1;                &#125;else if(remain5&gt;&#x3D;3)&#123;                    remain5-&#x3D;3;                &#125;else&#123;                    return false;                &#125;                remain20+&#x3D;1;            &#125;        &#125;        return true;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>968. 监控二叉树</title>
      <link href="/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91-difficult/"/>
      <url>/2023/02/15/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/leetcode-968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91-difficult/</url>
      
        <content type="html"><![CDATA[<h1 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a><a href="https://leetcode.cn/problems/binary-tree-cameras/description/">968. 监控二叉树</a></h1><p>First：贪心没做出来，现在连二叉树的动态规划也搞忘了</p><hr><p><strong>方法1</strong>：<strong>贪心</strong></p><p>假设每个节点有三种状态： 0（无覆盖），1（有覆盖），2（有摄像头）</p><p>从底部向上考虑，可以使得总摄像头数量最少，因为低层节点数一定大于等于当前上层节点数，而一个摄像头可以覆盖的低层节点更多。因此，采用后序遍历。</p><p>因此对于每个节点可以从左右子节点推导出状态，可分为三种：</p><ul><li>左右子节点都已覆盖，此时当前节点状态应该为无覆盖</li><li>左右子节点至少有一个未覆盖，此时节点状态为有摄像头</li><li>左右子节点至少一个有摄像头（由于先考虑第二种情况，此类情况就无需特殊考虑存在一个节点未被覆盖），此时节点状态为有覆盖</li></ul><p>但还存在两个问题：根节点和空节点</p><ul><li>根节点：由于上述方法只判断了根节点状态，如果根节点未覆盖状态时，并没有进行处理，因此还需最后对根节点判断是否未覆盖状态</li><li>空节点：空节点应该被设置未已覆盖状态，如果设置为未覆盖则会导致叶节点设置为有摄像头</li></ul><p>局部最优：让叶子节点的父节点安摄像头，所用摄像头最少</p><p>全局最优：全部摄像头数量所用最少！</p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    int ans;public:    &#x2F;&#x2F;0:无覆盖  1：有覆盖  2：有摄像头    int postOrder(TreeNode* root)&#123;        if(root&#x3D;&#x3D;nullptr) return 1;        int left&#x3D;postOrder(root-&gt;left);        int right&#x3D;postOrder(root-&gt;right);        if(left&#x3D;&#x3D;1&amp;&amp;right&#x3D;&#x3D;1) return 0;        else if(left&#x3D;&#x3D;0||right&#x3D;&#x3D;0) &#123;            ++ans;            return 2;        &#125;else if(left&#x3D;&#x3D;2||right&#x3D;&#x3D;2)&#123;            return 1;        &#125;        return 0;    &#125;    int minCameraCover(TreeNode* root) &#123;        int t&#x3D;postOrder(root);        if(t&#x3D;&#x3D;0) ++ans;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>动态规划</strong></p><p>同样是由底向上遍历，即后序遍历。每个几点可分为三种状态：</p><ul><li>（1）当前节点安装相机时，已当前节点为根的树都被覆盖所需相机数</li><li>（2）当前节点不安装相机但被覆盖时，已当前节点为根的树都被覆盖所需相机数</li><li>（3）当前节点不安装相机不被覆盖时，已当前节点为根的树都被覆盖所需相机数</li></ul><p>状态更新：</p><ul><li><p>dp[0]找左右最小值相加后再+1即可。dp[0]&#x3D;min(left[0],min(left[1],left[2]))+min(right[0],min(right[1],right[2]))+1;</p></li><li><p>dp[1]必须左右节点其中至少一个安装相机dp[1]&#x3D;min(left[0]+min(right[0],right[1]),right[0]+min(left[0],left[1]));</p></li><li><p>dp[2]必须左右节点都是被覆盖但未安装相机</p><p>dp[2]&#x3D;left[1]+right[1];</p></li></ul><p><strong>空节点初始化值还存在问题，还没AC</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;    int ans;public:    &#x2F;&#x2F;动态规划    &#x2F;&#x2F;每个节点分为三种状态：    &#x2F;&#x2F;（1）当前节点安装相机时，已当前节点为根的树都被覆盖所需相机数    &#x2F;&#x2F;（2）当前节点不安装相机但被覆盖时，已当前节点为根的树都被覆盖所需相机数    &#x2F;&#x2F;（3）当前节点不安装相机不被覆盖时，已当前节点为根的树都被覆盖所需相机数    vector&lt;int&gt; postOrder(TreeNode* root)&#123;        if(root&#x3D;&#x3D;nullptr) return&#123;0,0,INT_MAX&#x2F;2&#125;;&#x2F;&#x2F;初始化还存在问题，现在还没ac        vector&lt;int&gt; left &#x3D; postOrder(root-&gt;left);        vector&lt;int&gt; right &#x3D;postOrder(root-&gt;right);        vector&lt;int&gt; dp(3,0);        dp[0]&#x3D;min(left[0],min(left[1],left[2]))+min(right[0],min(right[1],right[2]))+1;        dp[1]&#x3D;min(left[0]+min(right[0],right[1]),right[0]+min(left[0],left[1]));        dp[2]&#x3D;left[1]+right[1];        cout&lt;&lt;dp[0]&lt;&lt;&quot; &quot;&lt;&lt;dp[1]&lt;&lt;&quot; &quot;&lt;&lt;dp[2]&lt;&lt;endl;        return dp;    &#125;    int minCameraCover(TreeNode* root) &#123;        vector&lt;int&gt; ans&#x3D;postOrder(root);        return max(ans[0],ans[1]);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-贪心 </tag>
            
            <tag> Alg-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>142. 环形链表 II</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-142-middle/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-142-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><p>First：以前做过，但这次卡住了，以为要算出距离来，但求了半天都算不出，还是理解不到位啊</p><hr><p><strong>方法1</strong>：<strong>双指针</strong></p><p>先使用快慢指针判断是否有环，即快指针每次走两步，慢指针每次走一步</p><p>当有环，即快慢指针相遇时，假设头节点到环起始处距离为a，环起始处到相遇节点距离为b，环长度为c</p><p>那么，快指针移动距离为：f&#x3D;a+b+nc</p><p>慢指针移动距离为：s&#x3D;a+b（一定会在第一次遍历环的时候遇见）</p><p>又知 f&#x3D;2s</p><p>可推出：a&#x3D;nc-b</p><p>由上可知，环起始处到相遇节点距离为b，那么如果从相遇节点再移动nc-b个位置，且同时从链表头节点开始也移动a个位置，那么再次相遇处即使环起始节点了。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        if(head&#x3D;&#x3D;nullptr||head-&gt;next&#x3D;&#x3D;nullptr) return nullptr;&#x2F;&#x2F;其他答案没这样处理开始时两个指针都在相同位置的情况，要更简便        ListNode *fast&#x3D;head-&gt;next-&gt;next,*slow&#x3D;head-&gt;next;        while(fast!&#x3D;nullptr&amp;&amp;fast-&gt;next!&#x3D;nullptr&amp;&amp;fast!&#x3D;slow)&#123;            fast&#x3D;fast-&gt;next-&gt;next;            slow&#x3D;slow-&gt;next;        &#125;        if(fast&#x3D;&#x3D;nullptr||fast-&gt;next&#x3D;&#x3D;nullptr) return nullptr;        fast&#x3D;head;        while(fast!&#x3D;slow)&#123;            fast&#x3D;fast-&gt;next;            slow&#x3D;slow-&gt;next;        &#125;        return fast;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>哈希表</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160. 相交链表</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-160-simple/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-160-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h1><p>First：先想到的是使用长度差来计算，但看了解析后一种很简约的思想，写起来代码也很简单，虽然两者效率是差不多的。</p><hr><p><strong>方法1</strong>：<strong>双指针+距离差</strong></p><p>分别遍历链表AB的长度，求出链表长度差n，然后使长的指针先走n个节点，然后同时向后移动节点找出公共节点即可。</p><ul><li>时间复杂度：O(a+b)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        if(headA&#x3D;&#x3D;nullptr||headB&#x3D;&#x3D;nullptr) return nullptr;        ListNode *pa&#x3D;headA,*pb&#x3D;headB;        int la&#x3D;0,lb&#x3D;0;        while(pa!&#x3D;nullptr)&#123;            ++la;            pa&#x3D;pa-&gt;next;        &#125;        while(pb!&#x3D;nullptr)&#123;            ++lb;            pb&#x3D;pb-&gt;next;        &#125;        if(la&gt;&#x3D;lb)&#123;            pa&#x3D;headB;            pb&#x3D;headA;        &#125;else&#123;            pa&#x3D;headA;            pb&#x3D;headB;        &#125;        int dis&#x3D;abs(la-lb);        while(dis&gt;0)&#123;            pb&#x3D;pb-&gt;next;            --dis;        &#125;        while(pa!&#x3D;pb)&#123;            pa&#x3D;pa-&gt;next;            pb&#x3D;pb-&gt;next;        &#125;        return pa;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>双指针</strong></p><p>假设表头A到公共节点距离为a，表头B到公共节点距离为b，公共节点到链表尾部距离为c</p><p>那么。如果让表头A走到表尾，再从链表B开始走，走到公共节点的总距离为a+b+c</p><p>同理，表头B走到表尾，再从链表A开始走，走到公共节点的总距离也同样是a+b+c</p><p>因此，按如上走法，相遇点则是公共节点（即使没有公共节点也会在nullptr相遇）</p><ul><li>时间复杂度：O(a+b)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode *A&#x3D;headA,*B&#x3D;headB;        while(A!&#x3D;B)&#123;            A&#x3D;A!&#x3D;nullptr?A-&gt;next:headB;            B&#x3D;B!&#x3D;nullptr?B-&gt;next:headA;        &#125;        return A;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19. 删除链表的倒数第 N 个结点</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-19-middle/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-19-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h1><p>First：看错题了，以为是顺数第n个节点。找两个指针间隔n个结点移动到末尾即可。</p><hr><p><strong>方法1</strong>：<strong>双指针</strong></p><p>使用一个表头节点来避免头节点的单独处理。使用两个指针p、q，p先移动n个节点，此时p和q指针再一起移动，直到p指针移动到末尾位置，q指针指向的下一个节点即为需要删除的节点。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        if(head&#x3D;&#x3D;nullptr||head-&gt;next&#x3D;&#x3D;nullptr) return head;&#x2F;&#x2F;加不加这个判断都可通过        ListNode *H&#x3D;new ListNode(0,head);        ListNode *p&#x3D;H,*q&#x3D;nullptr,*v&#x3D;nullptr;        while(p-&gt;next!&#x3D;nullptr&amp;&amp;p-&gt;next-&gt;next!&#x3D;nullptr)&#123;            v&#x3D;p;            p&#x3D;p-&gt;next;            q&#x3D;p-&gt;next;            ListNode *t&#x3D;q-&gt;next;            p-&gt;next&#x3D;q-&gt;next;            q-&gt;next&#x3D;p;            v-&gt;next&#x3D;q;        &#125;        return H-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>计算链表长度</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><hr><p><strong>方法3</strong>：<strong>栈</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203. 移除链表元素</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-203-simple/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-203-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h1><p>First：就很简单的移除元素即可，不过注意下需要移除的元素和不需要移除的处理细节上会有差别</p><hr><p><strong>方法1</strong>：<strong>迭代</strong></p><p>依次遍历每个元素判断是否需要移除即可，可以使用一个链表头来避免处理空表情况。需注意当遇见需要移除的元素时，移除后指针别跳到下一个元素，还是应该处理当前元素。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        if(head&#x3D;&#x3D;nullptr) return head;        ListNode *t&#x3D;new ListNode(0,head);        ListNode *h&#x3D;t,*p&#x3D;t-&gt;next;        while(h-&gt;next!&#x3D;nullptr)&#123;            p&#x3D;p-&gt;next;            if(h-&gt;next-&gt;val&#x3D;&#x3D;val)&#123;                              delete h-&gt;next;                h-&gt;next&#x3D;p;            &#125;else&#123;                h&#x3D;h-&gt;next;            &#125;        &#125;        return t-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>迭代</strong></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. 反转链表</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-206-simple/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-206-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h1><p>First：设置三个指针指向前中后三个位置</p><hr><p><strong>方法1</strong>：<strong>原地反转</strong></p><p>设置三个指针p、q、last指向三个连续位置，每次将q-&gt;next指向p，再将三个指针依次向后移一个位置即可，注意此链表也是有头节点的。除此外还需排除head为空和只有一个节点情况存在。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if(head&#x3D;&#x3D;nullptr||head-&gt;next&#x3D;&#x3D;nullptr) return head;        ListNode *p&#x3D;head,*q&#x3D;head-&gt;next,*last&#x3D;q;        head-&gt;next&#x3D;nullptr;        while(q!&#x3D;nullptr)&#123;            last&#x3D;q-&gt;next;            q-&gt;next&#x3D;p;            p&#x3D;q;            q&#x3D;last;        &#125;        return p;    &#125;&#125;;&#x2F;&#x2F;官方代码有点技巧，参考下class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* prev &#x3D; nullptr;        ListNode* curr &#x3D; head;        while (curr) &#123;            ListNode* next &#x3D; curr-&gt;next;            curr-&gt;next &#x3D; prev;            prev &#x3D; curr;            curr &#x3D; next;        &#125;        return prev;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>递归</strong></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24. 两两交换链表中的节点</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-24-middle/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-24-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h1><p>First：依次遍历交换节点</p><hr><p><strong>方法1</strong>：<strong>非递归</strong></p><p>使用一个表头节点来避免头节点的单独处理，使用三个指针分别指向需要交换的两个节点和这两个节点之前那个节点即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    ListNode* swapPairs(ListNode* head) &#123;        if(head&#x3D;&#x3D;nullptr||head-&gt;next&#x3D;&#x3D;nullptr) return head;&#x2F;&#x2F;加不加这个判断都可通过        ListNode *H&#x3D;new ListNode(0,head);        ListNode *p&#x3D;H,*q&#x3D;nullptr,*v&#x3D;nullptr;        while(p-&gt;next!&#x3D;nullptr&amp;&amp;p-&gt;next-&gt;next!&#x3D;nullptr)&#123;            v&#x3D;p;            p&#x3D;p-&gt;next;            q&#x3D;p-&gt;next;            ListNode *t&#x3D;q-&gt;next;            p-&gt;next&#x3D;q-&gt;next;            q-&gt;next&#x3D;p;            v-&gt;next&#x3D;q;        &#125;        return H-&gt;next;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>非递归</strong></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>707. 设计链表</title>
      <link href="/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-707-middle/"/>
      <url>/2023/02/15/leetcode/%E9%93%BE%E8%A1%A8/leetcode-707-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></h1><p>First：常规编写链表即可</p><hr><p><strong>方法1</strong>：<strong>单链表</strong></p><p>就普通的设计链表，注意下题目里是有一个空节点作为链表头。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyLinkedList &#123;    int val;    class MyLinkedList *next;public:    MyLinkedList():val(0),next(nullptr) &#123;    &#125;    MyLinkedList(int val):val(val),next(nullptr) &#123;    &#125;    int get(int index) &#123;        if(index&lt;0) return -1;        MyLinkedList *h&#x3D;this;        while(index&gt;&#x3D;0)&#123;            h&#x3D;h-&gt;next;            index--;            if(h&#x3D;&#x3D;nullptr) return -1;        &#125;        return h-&gt;val;    &#125;        void addAtHead(int val) &#123;        MyLinkedList *t&#x3D;new MyLinkedList(val);        t-&gt;next&#x3D;this-&gt;next;        this-&gt;next&#x3D;t;    &#125;        void addAtTail(int val) &#123;        MyLinkedList *t&#x3D;new MyLinkedList(val);        MyLinkedList *h&#x3D;this;        while(h-&gt;next!&#x3D;nullptr)&#123;            h&#x3D;h-&gt;next;        &#125;        h-&gt;next&#x3D;t;    &#125;        void addAtIndex(int index, int val) &#123;        if(index&lt;&#x3D;0)&#123;            addAtHead(val);            return;        &#125;        MyLinkedList *pos&#x3D;this;        while(index&gt;0&amp;&amp;pos!&#x3D;nullptr)&#123;            pos&#x3D;pos-&gt;next;            index--;        &#125;        if(pos&#x3D;&#x3D;nullptr) return;        MyLinkedList *t&#x3D;new MyLinkedList(val);        t-&gt;next&#x3D;pos-&gt;next;        pos-&gt;next&#x3D;t;    &#125;        void deleteAtIndex(int index) &#123;        if(index&lt;0) return;        MyLinkedList *p&#x3D;this,*q&#x3D;p-&gt;next;        while(index&gt;0&amp;&amp;q!&#x3D;nullptr)&#123;            p&#x3D;p-&gt;next;            q&#x3D;q-&gt;next;            index--;        &#125;        if(q&#x3D;&#x3D;nullptr) return;        p-&gt;next&#x3D;q-&gt;next;        delete q;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>双链表</strong></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. 接雨水</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-diffcult/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-diffcult/</url>
      
        <content type="html"><![CDATA[<h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h1><p>First：以前做过，还是没做出来，不知道为啥想到的是只找左右两边第一个大于的值，受了单调栈影响（这种方法其实能做出来，但没解决重复算得那部分）。。。但又没用单调栈做出来。</p><p>Second：想用找左右第一个大于的柱高度，但会多很多重复计算。最后还是使用的单调栈和按列求做出来。</p><hr><p><strong>方法1</strong>：<strong>按列求</strong></p><p>对于每一列，其能接到的最大雨水值为左边最大高度和右边最大高度中最小值减去当前高度，将所有列能接到的雨水加起来即可。</p><p>先遍历得到每个值得左边最大值，然后遍历每个值得右边最大高度时，求能接到得雨水。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int ans&#x3D;0;        vector&lt;int&gt; lmax(height.size(),-1),rmax(height.size(),-1);        int maxHeight&#x3D;height[height.size()-1];        for(int i&#x3D;height.size()-2;i&gt;&#x3D;0;--i)&#123;            rmax[i]&#x3D;maxHeight;            maxHeight&#x3D;max(maxHeight,height[i]);        &#125;        maxHeight&#x3D;height[0];        for(int i&#x3D;1;i&lt;height.size();++i)&#123;            int dif&#x3D;min(maxHeight,rmax[i])-height[i];                ans+&#x3D;dif&gt;0?dif:0;            maxHeight&#x3D;max(maxHeight,height[i]);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>单调栈</strong></p><p>单调栈其原理是使用按行求。使用单调栈方法来做，对于每个值与栈顶元素进行比较，如果大于栈顶元素，而单调栈又是递减的，因此此处也就存在一个凹槽，以当前值和栈顶第二个元素为界，求出宽度和高度。不断重复直到当前值小于栈顶元素。</p><p>这里需要注意的是当前值和栈顶元素相同时改怎么处理，不进行判断而使用单调栈方法来做的话，由于栈顶和当前值相等，两者相减求得的高度就变为0了。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> mst<span class="token punctuation">;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>mst<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>height<span class="token punctuation">[</span>mst<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> cur<span class="token operator">=</span>mst<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                mst<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>mst<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                ans<span class="token operator">+=</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>mst<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span>mst<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            mst<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：<strong>双指针</strong></p><p>是在按列求方法上运用了一些技巧</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>456. 132 模式</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-456-132%E6%A8%A1%E5%BC%8F-middle/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-456-132%E6%A8%A1%E5%BC%8F-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="456-132-模式"><a href="#456-132-模式" class="headerlink" title="456. 132 模式"></a><a href="https://leetcode.cn/problems/132-pattern/description/">456. 132 模式</a></h1><blockquote><p>什么时候用单调栈呢？</p><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p><p><strong>同理，如果要找一个大于（或小于）且最接近的数，也使用单调栈</strong></p></blockquote><p>First：22-11-15，这题使用单调栈来做是真的nice</p><hr><p><strong>方法1</strong>：<strong>单调栈</strong></p><p>参考<a href="https://leetcode.cn/problems/132-pattern/solutions/676970/xiang-xin-ke-xue-xi-lie-xiang-jie-wei-he-95gt/">解析</a></p><p>枚举i最简单，因为j&lt;k但nums[k]&lt;nums[j]，使得顺序乱了导致需要找中间值，逻辑会麻烦很多。</p><p>而枚举i时，只需要在i之后找到一段递减阶段jk，此时如果nums[i]&lt;nums[k]就满足132要求。因此对于每个nums[j]，需要找到一个比其小且最接近的数，此时既构成了递减序列且nums[k]和nums[j]也最接近，也就需要使用单调栈来找数。</p><p>从后向前遍历，维持一个递减的单调栈，当遍历到nums[i]时，如果nums[i]&lt;k，则返回true，否则将nums[i]与栈顶元素不断比较维持一个递减单调栈，且k设为最先弹出元素值。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;        vector&lt;int&gt; ans(temperatures.size(),0);        stack&lt;int&gt; s;        s.push(0);        for(int i&#x3D;1;i&lt;temperatures.size();++i)&#123;            while(!s.empty()&amp;&amp;temperatures[s.top()]&lt;temperatures[i])&#123;                ans[s.top()]&#x3D;i-s.top();                s.pop();            &#125;           s.push(i);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>496. 下一个更大元素 I</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I-simple/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I-simple/</url>
      
        <content type="html"><![CDATA[<h1 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h1><blockquote><p>什么时候用单调栈呢？</p><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p></blockquote><p>First：相比793，这题明显要复杂点，但难度还比那低。。</p><hr><p><strong>方法1</strong>：<strong>哈希表+单调栈</strong></p><p>使用哈希表来存储nums1中的所有数字，以便查找。遍历nums2中的每个值，对于nums[i]找到第一个大于其值的元素（使用单调栈），再使用哈希表查询其中是否存在nums[i]。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;int&gt; ans(nums1.size(),-1);        unordered_map&lt;int,int&gt; map;        stack&lt;int&gt; s;        for(int i&#x3D;0;i&lt;nums1.size();++i) map[nums1[i]]&#x3D;i;        s.push(0);        for(int j&#x3D;1;j&lt;nums2.size();++j)&#123;            while(!s.empty()&amp;&amp;nums2[s.top()]&lt;nums2[j])&#123;                if(map.find(nums2[s.top()])!&#x3D;map.end())&#123;                    ans[map[nums2[s.top()]]]&#x3D;nums2[j];                &#125;                s.pop();            &#125;            s.push(j);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-哈希表 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>739. 每日温度</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-middle/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h1><blockquote><p>什么时候用单调栈呢？</p><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p></blockquote><p>First：22-10-14，</p><hr><p><strong>方法1</strong>：<strong>单调栈</strong></p><p>使用栈来记录暂时还没有在右边找到大于其值的元素位置，依次遍历数组，对于每一个数temperatures[j]，都将其与栈顶元素temperatures[k]进行比较，如果大于栈顶元素，ans[k]&#x3D;j，不断重复直到栈顶元素小于temperatures[j]。自然，栈里面存的元素也就是依次较小的（栈底到栈顶减小），也叫做单调栈。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;        vector&lt;int&gt; ans(temperatures.size(),0);        stack&lt;int&gt; s;        s.push(0);        for(int i&#x3D;1;i&lt;temperatures.size();++i)&#123;            while(!s.empty()&amp;&amp;temperatures[s.top()]&lt;temperatures[i])&#123;                ans[s.top()]&#x3D;i-s.top();                s.pop();            &#125;           s.push(i);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>503. 下一个更大元素 II</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-503%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II-middle/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-503%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II-middle/</url>
      
        <content type="html"><![CDATA[<h1 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h1><blockquote><p>什么时候用单调栈呢？</p><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p></blockquote><p>First：循环数组，也就是要找其前面的数，多便利一次即可。</p><hr><p><strong>方法1</strong>：<strong>单调栈</strong></p><p>由于是循环数组，要找到其右边更大的数，那么也就需要在左边的数中去寻找，最简单的方法就是将nums复制一遍，使用单调栈遍历即可，可使用一点技巧不用拼接复制nums。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; ans(nums.size(),-1);        stack&lt;int&gt; s;        s.push(0);        for(int i&#x3D;0;i&lt;2*nums.size();++i)&#123;            int pos&#x3D;i%nums.size();            while(!s.empty()&amp;&amp;nums[s.top()]&lt;nums[pos])&#123;                ans[s.top()]&#x3D;nums[pos];                s.pop();            &#125;            s.push(pos);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>84. 柱状图中最大的矩形</title>
      <link href="/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-diffcult/"/>
      <url>/2023/02/15/leetcode/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/leetcode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-diffcult/</url>
      
        <content type="html"><![CDATA[<h1 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h1><p>First：没发现是要找左右两边第一个小于的柱子</p><hr><p><strong>方法1</strong>：<strong>单调栈</strong></p><p>可以通过遍历每一个柱子，以当前柱子为基础向左右两边扩散，其左右两边的柱子高度不能小于当前柱子高度，这样就保证了矩形面积由于扩散肯定是增大的。会存在一种情况就是虽然左右两边柱子虽然小于当前柱子，但将其纳入勾勒出来的矩形比不纳入大，然而这种情况可以由较小柱子左右扩散得到。</p><p>而要找左右两边第一个小的柱子，就可以使用单调栈来进行查找。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;        int ans&#x3D;heights[0];        stack&lt;int&gt; lmaxs,rmaxs;        vector&lt;int&gt; lnum(heights.size(),-1),rnum(heights.size(),heights.size());        lmaxs.push(heights.size()-1);        for(int i&#x3D;heights.size()-2;i&gt;&#x3D;0;--i)&#123;            while(!lmaxs.empty()&amp;&amp;heights[lmaxs.top()]&gt;heights[i])&#123;                lnum[lmaxs.top()]&#x3D;i;                lmaxs.pop();            &#125;            lmaxs.push(i);        &#125;        rmaxs.push(0);        for(int i&#x3D;1;i&lt;heights.size();++i)&#123;            while(!rmaxs.empty()&amp;&amp;heights[rmaxs.top()]&gt;heights[i])&#123;                rnum[rmaxs.top()]&#x3D;i;                                rmaxs.pop();            &#125;            rmaxs.push(i);        &#125;        for(int i&#x3D;0;i&lt;heights.size();++i)&#123;            ans&#x3D;max(ans,(rnum[i]-lnum[i]-1)*heights[i]);        &#125;                return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法2</strong>：<strong>单调栈+常数优化</strong></p><p>从方法1知是要找左右两边第一个小的值，而如果单调栈是递增的，那么栈顶元素的下一个元素就自然小于栈顶，那么左边界也就找到了，而右边界可以从单调栈的遍历中得到，因此也就只需要一次单调栈遍历。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;public:    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;        int ans&#x3D;heights[0];        stack&lt;int&gt; s;        heights.insert(heights.begin(),0);        heights.push_back(0);&#x2F;&#x2F;在头尾分别插入0使得对任意柱子都会存在左右边界（高为0的柱子不需要考虑）        s.push(0);        for(int i&#x3D;1;i&lt;heights.size();++i)&#123;            while(!s.empty()&amp;&amp;heights[s.top()]&gt;heights[i])&#123;                int index&#x3D;s.top();                s.pop();                ans&#x3D;max(ans,(i-s.top()-1)*heights[index]);            &#125;            s.push(i);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>方法3</strong>：<strong>双指针</strong></p><p>是在按列求方法上运用了一些技巧</p><ul><li>时间复杂度：O(n^2^)</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alg-单调栈 </tag>
            
            <tag> Alg-双指针 </tag>
            
            <tag> Alg-栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
